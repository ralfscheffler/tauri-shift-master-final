/**
@license
DayPilot Pro for JavaScript 2023.2.5592
Copyright (c) 2005 - 2023 Annpoint s.r.o.
https://www.daypilot.org/
Use of this software is subject to license terms.
*/
/* Copyright 2005 - 2023 Annpoint, s.r.o.
 Use of this software is subject to license terms.
 https://www.daypilot.org/
 */

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.$ !== 'undefined') {
        return;
    }

    DayPilot.$ = function(id) {
        return document.getElementById(id);
    };

    DayPilot.isKhtml = (navigator && navigator.userAgent && navigator.userAgent.indexOf("KHTML") !== -1);
    DayPilot.isIE = (navigator && navigator.userAgent && (navigator.userAgent.indexOf("MSIE") !== -1 || navigator.userAgent.indexOf("Trident") !== -1));
    DayPilot.isIEQuirks = DayPilot.isIE && (document.compatMode && document.compatMode === "BackCompat");

    DayPilot.browser = {};
    DayPilot.browser.ff = (navigator && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1);
    DayPilot.browser.chrome = (navigator && navigator.userAgent && navigator.userAgent.indexOf("Chrome") !== -1);
    DayPilot.browser.ie = DayPilot.isIE;
    DayPilot.browser.edge = (navigator && navigator.userAgent && navigator.userAgent.indexOf("Edge") !== -1);
    DayPilot.browser.webkit = (navigator && navigator.userAgent && navigator.userAgent.indexOf("WebKit") !== -1);
    DayPilot.browser.hover = !window.matchMedia("(any-hover: none)").matches;

    DayPilot.browser.passiveEvents = false;
    (function() {
        try {
            window.addEventListener("test", null, Object.defineProperty({}, 'passive', { "get": function() { DayPilot.browser.passiveEvents = true; } }));
        } catch (e) {}
    })();

    DayPilot.libs = {};
    DayPilot.libs.angularjs = typeof angularjs === "object";

    DayPilot.touch = {};
    DayPilot.touch.start = window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart";
    DayPilot.touch.move = window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove";
    DayPilot.touch.end = window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend";

    DayPilot.mo2 = function(target, ev) {

        // IE
        if (typeof (ev.offsetX) !== 'undefined') {

            var coords = {x: ev.offsetX + 1, y: ev.offsetY + 1};

            if (!target) {
                return coords;
            }

            var current = ev.srcElement;
            while (current && current !== target) {
                if (current.tagName !== 'SPAN') { // hack for DayPilotMonth/IE, hour info on the right side of an event
                    coords.x += current.offsetLeft;
                    if (current.offsetTop > 0) {  // hack for http://forums.daypilot.org/Topic.aspx/879/move_event_bug
                        coords.y += current.offsetTop - current.scrollTop;
                    }
                }

                current = current.offsetParent;
            }

            if (current) {
                return coords;
            }
            return null;
        }

        // FF
        if (typeof (ev.layerX) !== 'undefined') {

            var coords = {x: ev.layerX, y: ev.layerY, src: ev.target};

            if (!target) {
                return coords;
            }
            var current = ev.target;

            // find the positioned offsetParent, the layerX reference
            while (current && current.style.position !== 'absolute' && current.style.position !== 'relative') {
                current = current.parentNode;
                if (DayPilot.isKhtml) { // hack for KHTML (Safari and Google Chrome), used in DPC/event moving
                    coords.y += current.scrollTop;
                }
            }

            while (current && current !== target) {
                coords.x += current.offsetLeft;
                coords.y += current.offsetTop - current.scrollTop;
                current = current.offsetParent;
            }
            if (current) {
                return coords;
            }

            return null;
        }

        return null;
    };

    // mouse offset relative to the specified target
    DayPilot.mo3 = function(target, ev) {
        var coords;
        var page = DayPilot.page(ev);
        if (page) {
            if (target) {
                var abs = DayPilot.abs(target);
                if (!abs) {
                    throw new Error("no abs");
                    return null;
                }
                coords = {x: page.x - abs.x, y: page.y - abs.y};
            }
            else {
                coords = {x: page.x, y: page.y};
            }
        }
        else {
            coords = DayPilot.mo2(target, ev);
            if (!coords) {
                // throw new Error("no coords");
                return null;
            }
        }

        coords.shift = ev.shiftKey;
        coords.meta = ev.metaKey;
        coords.ctrl = ev.ctrlKey;
        coords.alt = ev.altKey;

        return coords;
    };

    // mouse coords
    DayPilot.mc = function(ev) {
        if (ev.touches) {
            var evt = ev.touches[0];
            return {
                x: evt.pageX,
                y: evt.pageY
            };
        }
        if (ev.pageX || ev.pageY) {
            return {x: ev.pageX, y: ev.pageY};
        }
        return {
            x: ev.clientX + document.documentElement.scrollLeft,
            y: ev.clientY + document.documentElement.scrollTop
        };
    };

    DayPilot.Stats = {};
    DayPilot.Stats.eventObjects = 0;
    DayPilot.Stats.dateObjects = 0;
    DayPilot.Stats.cacheHitsCtor = 0;
    DayPilot.Stats.cacheHitsParsing = 0;
    DayPilot.Stats.cacheHitsTicks = 0;

    DayPilot.list = function(array, enforceCopy) {

        if (array && array.isDayPilotList && !enforceCopy) {  // no need to copy unless requested explicitly
            return array;
        }

        var isArray = DayPilot.isArray(array) || Object.prototype.toString.call(array) === "[object NodeList]";
        var isItem = !isArray && !DayPilot.Util.isNullOrUndefined(array);

        //var list = new Array(isArray ? array.length : (isItem ? 1 : 0));
        var list = [];
        list.isDayPilotList = true;

        list.clone = function() {
            var result = DayPilot.list();
            list.forEach(function(item) {
                result.push(item);
            });
            return result;
        };

        list.each = function(f) {
            if (!f) {
                return;
            }
            if (list.forEach) {
                list.forEach(f);
                return;
            }
            for (var i = 0; i < this.length; i++) {
                f(list[i], i, list);
            }
        };

        // creates a copy, adds properties
        list.addProps = function(fields) {
            var result = list.clone();
            if (fields) {
                for (var name in fields) {
                    result[name] = fields[name];
                }
            }
            return result;
        };

        list.last = function() {
            if (list.length === 0) {
                return null;
            }
            return list[list.length - 1];
        };

        list.first = function() {
            if (list.length === 0) {
                return null;
            }
            return list[0];
        };

        // creates a copy with old items plus new item
        list.add = function(item) {
            var result = list.clone();
            result.push(item);
            return result;
        };

        // override, returns DayPilot.list()
        list.map = function(f) {
            if (typeof f !== "function") {
                throw "DayPilot.list().map(f): Function expected";
            }
            var result = DayPilot.list();
            list.forEach(function(item, i, array) {
                result.push(f(item, i, array));
            });

            return result;
        };

        list.filter = function(f) {
            var result = DayPilot.list();
            if (typeof f !== "function") {
                throw "DayPilot.list().filter(f): Function expected";
            }
            list.forEach(function(item, i, a) {
                if (f(item, i, a)) {
                    result.push(item);
                }
            });
            return result;
        };

        // override, returns DayPilot.list()
        list.concat = function(another) {
            if (!another) {
                return list;
            }
            var result = list.clone();
            for (var i = 0; i < another.length; i++) {
                result.push(another[i]);
            }
            return result;
        };

        if (!list.find) {
            list.find = function(f) {
                if (typeof f !== "function") {
                    throw "DayPilot.list().find(f): Function expected";
                }
                for (var i = 0; i < this.length; i++) {
                    if (f(list[i])) {
                        return list[i];
                    }
                }
                return undefined;
            };
        }

        if (!list.findIndex) {
            list.findIndex = function(f) {
                if (typeof f !== "function") {
                    throw "DayPilot.list().findIndex(f): Function expected";
                }
                for (var i = 0; i < this.length; i++) {
                    if (f(list[i])) {
                        return i;
                    }
                }
                return -1;
            };
        }
        // reuse if available
        if (!list.some) {
            list.some = function(f) {
                if (typeof f !== "function") {
                    throw "DayPilot.list().some(f): Function expected";
                }
                for (var i = 0; i < this.length; i++) {
                    if (f(list[i])) {
                        return true;
                    }
                }
                return false;
            };
        }

        // reuse if available
        if (!list.reduce) {
            list.reduce = function(f, initial) {
                if (typeof f !== "function") {
                    throw "DayPilot.list().reduce(f): Function expected";
                }
                var result;
                var start = 0;
                if (typeof initial !== 'undefined') {
                    result = initial;
                }
                else {
                    start = 1;
                    if (list.length === 0) {
                        throw "DayPilot.list().reduce(f): No initial value and empty list";
                    }
                    result = list[0];
                }
                for (var i = start; i < this.length; i++) {
                    result = f(result, list[i], i, this);
                }
                return result;
            };
        }

        list.isEmpty = function() {
            return list.length === 0;
        };


        if (isArray) {
            for (var i = 0; i < array.length; i++) {
                //list.push(array[i]);
                list[i] = array[i];
            }
        }
        else if (isItem) {
            list[0] = array;
        }

        return list;
    };

    DayPilot.list.for = function(count, initializer) {
        var result = DayPilot.list();
        for (var i = 0; i < count; i++) {
            if (typeof initializer === "function") {
                result.push(initializer(i));
            }
            else {
                result.push(i);
            }
        }
        return result;
    };

    DayPilot.line = function (x1, y1, x2, y2, props) {
        props = props || {};

        var source = { "x": x1, "y": y1 };
        var target = { "x": x2, "y": y2, "deg": DayPilot.deg(x1, y1, x2, y2)};

        var switched = false;
        if (y1 < y2){
            var pom = y1;
            y1 = y2;
            y2 = pom;
            pom = x1;
            x1 = x2;
            x2 = pom;

            switched = true;
        }

        var deg = DayPilot.deg(x1, y1, x2, y2);

        var from = {"x": x1, "y": y1};
        var to = {"x": x2, "y": y2};

        var x = (function() {
            var a = Math.abs(x1-x2);
            var b = Math.abs(y1-y2);
            var sx = (x1+x2)/2 ;
            var sy = (y1+y2)/2 ;
            var w = Math.sqrt(a*a + b*b ) ;
            return sx - w/2;
        })();

        var y = (function() {
            return (y1+y2)/2 ;
        })();

        // var toLeft = !switched && deg < 90 || switched && deg > 90;

        var width = DayPilot.distance(from, to);

        var div = document.createElement("div");
        div.setAttribute('style','width:'+width+'px;height:0px;-moz-transform:rotate('+deg+'deg);-webkit-transform:rotate('+deg+'deg);-ms-transform:rotate('+deg+'deg);transform:rotate('+deg+'deg);position:absolute;top:'+y+'px;left:'+x+'px;');
        if (props.cssClass) {
            div.className = props.cssClass;
        }

        var wrapper = document.createElement("div");
        // wrapper.innerHTML = deg + " " + switched + " " + toLeft;
        wrapper.appendChild(div);

        var symbol = "circle";
        var arrow = !!props.arrow;

        if (arrow && symbol === "arrow") {
            var arrowWidth = 6;
            var top = target.y - arrowWidth*0;
            var left = target.x - arrowWidth*0;
            // if (toLeft) {
            //     left -= arrowWidth;
            // }
            //if (target.x < source.x) { left -= width; }
            var deg = deg;
            if (target.y > source.y) { deg -= 180; }
            var a = document.createElement("div");

            a.style.borderWidth = arrowWidth + "px";
            a.style.borderStyle = "solid";
            a.style.position = "absolute";
            a.style.left = left + "px";
            a.style.top = top + "px";
            a.style.transform = "rotate(" + deg + "deg)";
            if (props.cssClass) {
                a.className = props.cssClass + "_arrow";
            }
            else {
                a.style.borderColor = "transparent black transparent transparent";
            }
            wrapper.appendChild(a);
        }
        else if (arrow && symbol === "circle") {
            var diameter = 10;
            var top = target.y - diameter/2;
            var left = target.x - diameter/2;
            var deg = deg;
            if (target.y > source.y) { deg -= 180; }
            var a = document.createElement("div");
            a.style.borderColor = "black";
            a.style.width = diameter + "px";
            a.style.height = diameter + "px";
            a.style.borderRadius = diameter + "px";
            // a.style.borderWidth = "1px";
            // a.style.borderStyle = "solid";
            //
            a.style.position = "absolute";
            a.style.left = left + "px";
            a.style.top = top + "px";
            if (props.cssClass) {
                a.className = props.cssClass + "_circle";
            }
            else {
                a.style.backgroundColor = "black";
            }
            // a.style.transform = "rotate(" + deg + "deg)";
            wrapper.appendChild(a);
        }

        return wrapper;

    };

    DayPilot.deg = function(x1, y1, x2, y2) {
        var a = Math.abs(x1-x2);
        var b = Math.abs(y1-y2);
        var c;
        var sx = (x1+x2)/2 ;
        var sy = (y1+y2)/2 ;
        var width = Math.sqrt(a*a + b*b ) ;
        var x = sx - width/2;
        var y = sy;

        a = width / 2;

        c = Math.abs(sx-x);

        b = Math.sqrt(Math.abs(x1-x)*Math.abs(x1-x)+Math.abs(y1-y)*Math.abs(y1-y) );

        var cosb = (b*b - a*a - c*c) / (2*a*c);
        var rad = Math.acos(cosb);
        var deg = (rad*180)/Math.PI;

        return deg;
    };

    DayPilot.complete = function(f) {
        if (document.readyState === "complete") {
            f();
            return;
        }
        if (!DayPilot.complete.list) {
            DayPilot.complete.list = [];
            DayPilot.re(document, "readystatechange", function() {
                if (document.readyState === "complete") {
                    for (var i = 0; i < DayPilot.complete.list.length; i++) {
                        var d = DayPilot.complete.list[i];
                        d();
                    }
                    DayPilot.complete.list = [];
                }
            });
        }
        DayPilot.complete.list.push(f);
    };

    // returns pageX, pageY (calculated from clientX if pageX is not available)
    DayPilot.page = function(ev) {
        // required for chrome/android
        var target = ev.changedTouches && ev.changedTouches[0] ? ev.changedTouches[0] : ev;

        // hack, in IE 11 pageX returns value inconsistent with other browsers (margin on html)
        if (typeof target.pageX !== 'undefined' && !DayPilot.browser.ie) {
            return {x: target.pageX, y: target.pageY};
        }
        if (typeof ev.clientX !== 'undefined' && document.body && document.documentElement) {
            return {
                x: ev.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
                y: ev.clientY + document.body.scrollTop + document.documentElement.scrollTop
            };
        }
        // shouldn't happen
        return null;
    };


    // position of the element, relative to the reference object
    DayPilot.rel = function(element, ref) {
        var elPos = DayPilot.abs(element);
        var refPos = DayPilot.abs(ref);

        return {
            "x": elPos.x - refPos.x,
            "y": elPos.y - refPos.y,
            "w": element.offsetWidth,
            "h": element.offsetHeight
        };
    };

    // absolute element position on page
    DayPilot.abs = function(element, visible) {
        if (!element) {
            return null;
        }

        // make it usable in a shadow dom
/*
        if (!document.body.contains(element)) {
            return null;
        }
*/

        if (element.getBoundingClientRect) {
            var r = DayPilot.absBoundingClientBased(element);

            if (visible) {
                // use diff, absOffsetBased is not as accurate
                var full = DayPilot.absOffsetBased(element, false);
                var visible = DayPilot.absOffsetBased(element, true);

                r.x += visible.x - full.x;
                r.y += visible.y - full.y;
                r.w = visible.w;
                r.h = visible.h;
            }

            return r;
        }
        else {
            return DayPilot.absOffsetBased(element, visible);
        }

    };

    DayPilot.absBoundingClientBased = function(element) {
        var elemRect = element.getBoundingClientRect();

        return {
            // x: elemRect.left + window.scrollX,   // IE11 doesn't support this
            x: elemRect.left + window.pageXOffset,
            // y: elemRect.top + window.scrollY,   // IE11 doesn't support this
            y: elemRect.top + window.pageYOffset,
            w: element.clientWidth,
            h: element.clientHeight,
            toString: function() {
                return "x:" + this.x + " y:" + this.y + " w:" + this.w + " h:" + this.h;
            }
        };
/*
        // didn't work for body with margin
        var bodyRect = document.body.getBoundingClientRect();

        return {
            x: elemRect.left - bodyRect.left,
            y: elemRect.top - bodyRect.top,
            w: element.clientWidth,
            h: element.clientHeight,
            toString: function() {
                return "x:" + this.x + " y:" + this.y + " w:" + this.w + " h:" + this.h;
            }
        };
*/

    };

    DayPilot.isArray = function(o) {
        return Object.prototype.toString.call(o) === '[object Array]';
    };

    // old implementation of absolute position
    // problems with adjacent float and margin-left in IE7
    // still the best way to calculate the visible part of the element
    DayPilot.absOffsetBased = function(element, visible) {
        var r = {
            x: element.offsetLeft,
            y: element.offsetTop,
            w: element.clientWidth,
            h: element.clientHeight,
            toString: function() {
                return "x:" + this.x + " y:" + this.y + " w:" + this.w + " h:" + this.h;
            }
        };

        while (DayPilot.op(element)) {
            element = DayPilot.op(element);

            r.x -= element.scrollLeft;
            r.y -= element.scrollTop;

            if (visible) {  // calculates the visible part
                if (r.x < 0) {
                    r.w += r.x; // decrease width
                    r.x = 0;
                }

                if (r.y < 0) {
                    r.h += r.y; // decrease height
                    r.y = 0;
                }

                if (element.scrollLeft > 0 && r.x + r.w > element.clientWidth) {
                    r.w -= r.x + r.w - element.clientWidth;
                }

                if (element.scrollTop && r.y + r.h > element.clientHeight) {
                    r.h -= r.y + r.h - element.clientHeight;
                }
            }

            r.x += element.offsetLeft;
            r.y += element.offsetTop;

        }

        var pageOffset = DayPilot.pageOffset();
        r.x += pageOffset.x;
        r.y += pageOffset.y;

        return r;
    };

    // window dimensions
    DayPilot.wd = function() {
        var ieQuirks = DayPilot.isIEQuirks;

        // don't show the bubble outside of the visible window
        var windowHeight = document.documentElement.clientHeight;
        // fixing http://forums.daypilot.org/Topic.aspx/519/issue_with_bubble_in_ie
        if (ieQuirks) {
            windowHeight = document.body.clientHeight;
        }

        var windowWidth = document.documentElement.clientWidth;
        // fixing http://forums.daypilot.org/Topic.aspx/519/issue_with_bubble_in_ie
        if (ieQuirks) {
            windowWidth = document.body.clientWidth;
        }

        var scrollTop = (document.documentElement && document.documentElement.scrollTop) || document.body.scrollTop;
        var scrollLeft = (document.documentElement && document.documentElement.scrollLeft) || document.body.scrollLeft;

        var result = {};
        result.width = windowWidth;
        result.height = windowHeight;
        result.scrollTop = scrollTop;
        result.scrollLeft = scrollLeft;

        return result;
    };

    // offsetParent, safe access to prevent "Unspecified Error" in IE
    DayPilot.op = function(element) {
        try {
            return element.offsetParent;
        }
        catch (e) {
            return document.body;
        }
    };

    // distance of two points, works with x and y
    DayPilot.distance = function(point1, point2) {
        return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    };

    // document element
    DayPilot.doc = function() {
        var de = document.documentElement;
        return (de && de.clientHeight) ? de : document.body;
    };

    DayPilot.pageOffset = function() {
        if (typeof window.pageXOffset !== 'undefined') {
            return {x: window.pageXOffset, y: window.pageYOffset};
        }
        //return { x: 0, y: 0};
        var d = DayPilot.doc();
        return {x: d.scrollLeft, y: d.scrollTop};
    };

    // all children
    DayPilot.ac = function(e, children) {
        if (!children) {
            var children = [];
        }
        for (var i = 0; e.children && i < e.children.length; i++) {
            children.push(e.children[i]);
            DayPilot.ac(e.children[i], children);
        }

        return children;
    };

    DayPilot.indexOf = function(array, object, equalsFunction) {
        if (!array || !array.length) {
            return -1;
        }
        for (var i = 0; i < array.length; i++) {
            if (equalsFunction) {
                if (equalsFunction(array[i], object)) {
                    return i;
                }
            }
            else if (array[i] === object) {
                return i;
            }
        }
        return -1;
    };

    DayPilot.contains = function(array, object) {

        if (arguments.length !== 2) {
            throw new DayPilot.Exception("DayPilot.contains() requires two arguments.");
        }

        if (!array) {
            return false;
        }

        if (array === object && !DayPilot.isArray(array)) {
            return true;
        }
        return DayPilot.indexOf(array, object) !== -1;
    };

    // remove from array
    DayPilot.rfa = function(array, object) {
        var i = DayPilot.indexOf(array, object);
        if (i === -1) {
            return;
        }
        array.splice(i, 1);
    };

    DayPilot.sheet = function(document) {
        document = document || window.document;

        var style = document.createElement("style");
        style.setAttribute("type", "text/css");
        if (!style.styleSheet) {   // ie
            style.appendChild(document.createTextNode(""));
        }

        var h = document.head || document.getElementsByTagName('head')[0];
        h.appendChild(style);

        var oldStyle = !! style.styleSheet; // old ie

        var sheet = {};
        sheet.rules = [];
        sheet.commit = function() {
            try {
                if (oldStyle) {
                    style.styleSheet.cssText = this.rules.join("\n");
                }
            }
            catch (e) {
                //alert("Error registering the built-in stylesheet (IE stylesheet limit reached). Stylesheet count: " + document.styleSheets.length);
            }
        };

        sheet.add = function(selector, rules, index) {
            if (oldStyle) {
                this.rules.push(selector + "{" + rules + "\u007d");
                return;
            }
            if(style.sheet.insertRule) {  // normal browsers, ie9+
                if (typeof index === "undefined") {
                    index = style.sheet.cssRules.length;
                }
                style.sheet.insertRule(selector + "{" + rules + "\u007d", index);
            }
            else if (style.sheet.addRule) {
                style.sheet.addRule(selector, rules, index);
            }
            else {
                throw "No CSS registration method found";
            }
            return sheet;
        };
        sheet.print = function() {
            var rules = style.sheet.cssRules;
            var all = [];

            for (var i = 0; i < rules.length; i++) {
                all.push(rules[i].cssText);
            }
            return all.join("\n");
        };

        return sheet;
    };

    DayPilot.Args = function(wrap) {
        var args = this;

        this.isArgs = true;
        this.preventDefault = function() {
            if (wrap) {
                wrap.preventDefault();
            }
            args.preventDefault.value = true;
        };

        /*
        this.getWrappedArgs = function() {
            return wrap;
        };
        */
    };

    DayPilot.Debug = function(calendar) {
        var debug = this;

        this.printToBrowserConsole = false;
        this.enabled = false;
        this.messages = [];
        this.target = null;
        this._div = null;
        this.clear = function() {
            this.messages = [];
            if (debug._div) {
                debug._div.innerHTML = '';
            }
        };

        this.hide = function() {
            DayPilot.de(debug._div);
            debug._div = null;
        };

        this.show = function() {
            if (debug._div) {
                debug.hide();
            }

            var ref = calendar.nav.top;

            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "0px";
            div.style.bottom = "0px";
            div.style.left = "0px";
            div.style.right = "0px";
            div.style.backgroundColor = "black";
            div.style.color = "#ccc";
            div.style.overflow = "auto";
            div.style.webkitUserSelect = 'auto';
            div.style.MozUserSelect = 'all';
            div.onclick = function() {
                debug.hide();
            };

            for(var i = 0; i < this.messages.length; i++) {
                var msg = debug.messages[i];

                var line = msg._toElement();
                div.appendChild(line);
            }

            this._div = div;
            ref.appendChild(div);
        };

        this.log = function() {
            if (!debug.target) {
                return;
            }
            var array = [];
            for(var i = 0; i < arguments.length; i++) {
                var item = arguments[i];
                array.push(item);
            }
            var str = array.join(" ");
            debug.target.style.whiteSpace = "pre";
            debug.target.innerText += str + "\n";
        };

        this.message = function(text, level) {  // levels: info, warning, error
            if (!this.enabled) {
                return;
            }
            var msg = {};
            msg.time = new DayPilot.Date();
            msg.level = level || "debug";
            msg.text = DayPilot.Util.escapeHtml(text);
            msg._toElement = function() {
                var line = document.createElement("div");
                line.innerHTML =  msg.time + " (" + msg.level + "): " + msg.text;
                switch (msg.level) {
                    case "error":
                        line.style.color = "red";
                        break;
                    case "warning":
                        line.style.color = "orange";
                        break;
                    case "info":
                        line.style.color = "white";
                        break;
                    case "debug":
                        break;
                }
                return line;
            };

            this.messages.push(msg);

            if (this.printToBrowserConsole && typeof console !== 'undefined') {
                console.log(msg);
            }
        };
    };

    // register event
    DayPilot.re = function(el, ev, func) {
        if (!func) {
            return;
        }
        if (!el) {
            return;
        }
        el.addEventListener(ev, func, false);
        /*
        if (el.addEventListener) {  // standard, IE9+
            el.addEventListener(ev, func, false);
        } else if (el.attachEvent) {
            var f = function(ev) {
                func.call(el, ev);
            };
            el.attachEvent("on" + ev, f);
        }*/
    };

    DayPilot.rePassive = function(el, ev, func) {
        if (!func) {
            return;
        }
        if (!el) {
            return;
        }
        el.addEventListener(ev, func, {"passive": true});
    };

    DayPilot.reNonPassive = function(el, ev, func) {
        if (!func) {
            return;
        }
        if (!el) {
            return;
        }
        el.addEventListener(ev, func, {"passive": false});
    };


    // unregister event
    DayPilot.ue = function(el, ev, func) {
        el.removeEventListener(ev, func, false);
        /*if (el.removeEventListener) {
            el.removeEventListener(ev, func, false);
        } else if (el.detachEvent) {
            el.detachEvent("on" + ev, func);
        }*/
    };
    // trim
/*
    DayPilot.tr = function(stringToTrim) {
        if (!stringToTrim)
            return '';
        if (typeof stringToTrim === "string") {
            return stringToTrim.replace(/^\s+|\s+$/g, "");
        }
        return stringToTrim;
    };
*/
    // date sortable (DateTime.ToString("s"))
    DayPilot.ds = function(d) {
        return DayPilot.Date.toStringSortable(d);
    };
    // get style
    DayPilot.gs = function(el, styleProp) {
        return window.getComputedStyle(el, null).getPropertyValue(styleProp) || "";
/*
        var x = el;
        if (x.currentStyle)
            var y = x.currentStyle[styleProp];
        else if (window.getComputedStyle)
            var y = document.defaultView.getComputedStyle(x, null).getPropertyValue(styleProp);
        if (typeof (y) === 'undefined')
            y = '';
        return y;
*/
    };

    DayPilot.StyleReader = function(element) {

        this.get = function(property) {
            if (!element) {
                return null;
            }
            return DayPilot.gs(element, property);
        };

        this.getPx = function(property) {
            var val = this.get(property);
            if (!val) {
                return undefined;
            }
            if (val.indexOf("px") === -1) {
                return undefined;
            }
            else {
                return parseInt(val, 10);
            }
        };

        this.getFont = function() {
            var weight = this.get("font-weight");
            var style = this.get("font-style") === "italic" ? "italic" : "";
            return {
                "family": this.get("font-family"),
                "size": this.get("font-size"),
                "style": style + " " + weight,
                "asString": function() { return DayPilot.Util.fontString(this); }
            };
        };

        this.getBackColor = function(defaultValue) {
            if (typeof defaultValue === "undefined") {
                defaultValue = "white";
            }
            var backColor = this.get("background-color");
            return DayPilot.Util.isTransparentColor(backColor) ? defaultValue : backColor;
        };

    };

    // html encode
    DayPilot.he = function(str) {
        var result = str.replace(/&/g, "&amp;");
        result = result.replace(/</g, "&lt;");
        result = result.replace(/>/g, "&gt;");
        result = result.replace(/"/g, "&quot;");
        return result;
    };

    DayPilot.he2 = function(str) {
        var text = document.createTextNode(str);
        var div = document.createElement("div");
        div.appendChild(text);
        return div.innerHTML;
    };

    // make unselectable
    DayPilot.us = function(element) {
        if (element) {
            element.setAttribute("unselectable", "on");
            element.style.userSelect = 'none';
            element.style.MozUserSelect = 'none';
            element.style.KhtmlUserSelect = 'none';
            element.style.webkitUserSelect = 'none';
            for (var i = 0; i < element.childNodes.length; i++) {
                if (element.childNodes[i].nodeType === 1) {
                    DayPilot.us(element.childNodes[i]);
                }
            }
        }
    };

    // purge
    // thanks to http://javascript.crockford.com/memory/leak.html
    DayPilot.pu = function(d) {
        //var removed = [];
        //var start = new Date();
        var a = d.attributes, i, l, n;
        if (a) {
            l = a.length;
            for (i = 0; i < l; i += 1) {
                if (!a[i]) {
                    continue;
                }
                n = a[i].name;
                if (typeof d[n] === 'function') {
                    //DayPilot.log.push(d.tagName + "." + n);
                    //removed.push(n);
                    d[n] = null;
                }
            }
        }
        a = d.childNodes;
        if (a) {
            l = a.length;
            for (i = 0; i < l; i += 1) {
                var children = DayPilot.pu(d.childNodes[i]);
                //removed = removed.concat(children);
            }
        }
        //return removed;
    };

    // purge children
    DayPilot.puc = function(d) {
        var a = d.childNodes, i, l;
        if (a) {
            var l = a.length;
            for (i = 0; i < l; i += 1) {
                DayPilot.pu(d.childNodes[i]);
            }
        }
    };

    // delete element
    DayPilot.de = function(e) {
        if (!e) {
            return;
        }
        if (DayPilot.isArray(e)) {
            for (var i = 0; i < e.length; i++) {
                DayPilot.de(e[i]);
            }
            return;
        }

        // use e.remove() in the future
        if (e.parentNode && e.parentNode.contains(e)) {
            e.parentNode.removeChild(e);
        }
    };

    DayPilot.fade = function(element, step, end) {
        if (!element) {
            return;
        }

        clearTimeout(element.messageTimeout);

        var delay = 50;
        var visible = element.style.display !== 'none';
        var fadeIn = step > 0;
        var fadeOut = step < 0;

        if (step === 0) {
            return;
        }

        if (fadeIn) {
            element.status = "in";
        }
        else if (fadeOut) {
            element.status = "out";
        }

        if (fadeIn && !visible) {
            element.target = parseFloat(element.style.opacity);
            element.opacity = 0; // current, for IE
            element.style.opacity = 0;
            // element.style.filter = "alpha(opacity=0)";
            element.style.display = '';
        }
        else if (fadeOut && !element.target) {
            element.target = element.style.opacity;
        }
        else {
            //var current = parseFloat(element.style.opacity);
            var current = element.opacity;
            var updated = Math.floor(10 * (current + step)) / 10;
            if (fadeIn && updated > element.target) {
                updated = element.target;
            }
            if (fadeOut && updated < 0) {
                updated = 0;
            }
            var ie = updated * 100;
            element.opacity = updated;
            element.style.opacity = updated;
            // element.style.filter = "alpha(opacity=" + ie + ")";
        }
        if ((fadeIn && (element.opacity >= element.target || element.opacity >= 1)) || (fadeOut && element.opacity <= 0)) {
            element.target = null;
            if (fadeOut) {
                element.style.opacity = element.target;
                element.opacity = element.target;
                // var filter = element.target ? "alpha(opacity=" + (element.target * 100) + ")" : null;
                // element.style.filter = filter;
                element.style.display = 'none';
            }
            if (end && typeof end === 'function') {
                element.status = null;
                end();
            }
        }
        else {
            element.messageTimeout = setTimeout(function() {
                DayPilot.fade(element, step, end);
            }, delay);
        }
    };


    // vertical scrollbar width
    DayPilot.sw = function(element) {
        if (!element) {
            return 0;
        }
        return element.offsetWidth - element.clientWidth;
    };

    DayPilot.swa = function() {
        var div = document.createElement("div");
        div.style.position = "absolute";
        div.style.top = "-2000px";
        div.style.left = "-2000px";
        div.style.width = '200px';
        div.style.height = '100px';
        div.style.overflow = 'auto';

        var inner = document.createElement("div");
        inner.style.width = '300px';
        inner.style.height = '300px';
        div.appendChild(inner);

        document.body.appendChild(div);
        var sw = DayPilot.sw(div);
        document.body.removeChild(div);

        return sw;
    };

    // horizontal scrollbar height
    DayPilot.sh = function(element) {
        if (!element) {
            return 0;
        }
        return element.offsetHeight - element.clientHeight;
    };

    DayPilot.guid = function() {
        var S4 = function() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return ("" + S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
    };

    // unique array members
    DayPilot.ua = function(array) {

        if (!DayPilot.isArray(array)) {
            throw new DayPilot.Exception("DayPilot.ua() - array required");
        }

        var copy = [];
        array.forEach(function(item) {
            if (DayPilot.contains(copy, item)) {
                return;
            }
            copy.push(item);
        });
        return copy;
    };

    // angular module
    DayPilot.am = function() {
        if (typeof angular === "undefined") {
            return null;
        }
        if (!DayPilot.am.cached) {
            DayPilot.am.cached = angular.module("daypilot", []);
        }
        return DayPilot.am.cached;
    };

    (function () {
        DayPilot.pop = wave;

        function wave(div, options) {
            var target = {
                w: div.offsetWidth,
                h: div.offsetHeight,
                x: parseInt(div.style.left),
                y: parseInt(div.style.top)
            };
            target.height = div.style.height;
            target.width = div.style.width;
            target.top = div.style.top;
            target.left = div.style.left;
            target.toString = function () { return "w: " + this.w + " h:" + this.h; };

            var config = {};
            config.finished = null;
            config.vertical = 'center';
            config.horizontal = 'center';

            if (options) {
                for (var name in options) {
                    config[name] = options[name];
                }
            }

            div.style.visibility = 'hidden';
            div.style.display = '';

            var animation = options.animation || "fast";

            var plan = createPlan(animation);

            plan.div = div;
            plan.i = 0;
            plan.target = target;
            plan.config = config;

            doStep(plan);
        }

        function createPlan(type) {

            var jump = function() {
                var plan = [];
                plan.time = 10;
                var last;

                var step = 0.08;
                last = 0.1;

                for (var i = last; i < 1.2; i += step) {
                    plan.push(i);
                    last = i;
                }

                step = 0.03;

                for (var i = last; i > 0.8; i -= step) {
                    plan.push(i);
                    last = i;
                }

                for (var i = last; i <= 1; i += step) {
                    plan.push(i);
                    last = i;
                }

                return plan;
            };

            var slow = function() {
                var plan = [];
                plan.time = 10;
                var last;

                var step = 0.04;
                last = 0.1;

                for (var i = last; i <= 1; i += step) {
                    plan.push(i);
                    last = i;
                }
                return plan;
            };

            var fast = function() {
                var plan = [];
                plan.time = 10;
                var last;

                var step = 0.08;
                last = 0.1;

                for (var i = last; i <= 1; i += step) {
                    plan.push(i);
                    last = i;
                }
                return plan;
            };

            var types = {
                "fast": fast,
                "slow": slow,
                "jump": jump
            };

            if (!types[type]) {
                type = "fast";
            }

            return types[type]();
        }

        function doStep(plan) {
            var div = plan.div;

            var pct = plan[plan.i];

            var height = pct * plan.target.h;
            var top;
            switch (plan.config.vertical) {
                case "center":
                    top = plan.target.y - (height - plan.target.h) / 2;
                    break;
                case "top":
                    top = plan.target.y;
                    break;
                case "bottom":
                    top = plan.target.y - (height - plan.target.h);
                    break;
                default:
                    throw "Unexpected 'vertical' value.";
            }

            var width = pct * plan.target.w;
            var left;

            switch (plan.config.horizontal) {
                case "left":
                    left = plan.target.x;
                    break;
                case "center":
                    left = plan.target.x - (width - plan.target.w) / 2;
                    break;
                case "right":
                    left = plan.target.x - (width - plan.target.w);
                    break;
                default:
                    throw "Unexpected 'horizontal' value.";
            }

            // TODO add scrollLeft
            /*
            var wd = DayPilot.wd();
            var bottom = (wd.height + wd.scrollTop) - (top + height);
            if (bottom < 0) {
                top += bottom;
            }

            var right = (wd.width) - (left + width);
            if (right < 0) {
                left += right;
            }
             */

            div.style.height = height + "px";
            div.style.top = top + "px";

            div.style.width = width + "px";
            div.style.left = left + "px";

            //div.style.display = '';
            div.style.visibility = 'visible';

            plan.i++;

            if (plan.i < plan.length - 1) {
                setTimeout((function (plan) {
                    return function () {
                        doStep(plan);
                    };
                })(plan), plan.time);
            }
            else {
                // set the original dimensions
                div.style.width = plan.target.width;
                div.style.height = plan.target.height;
                // and position
                div.style.top = plan.target.top;
                div.style.left = plan.target.left;

                // callback
                if (typeof plan.config.finished === 'function') {
                    plan.config.finished();
                }
            }
        }


    })();

    DayPilot.Util = {};

    // object - DOM element or array of DOM elements
    DayPilot.Util.addClass = function(object, name) {
        if (!name) {
            return;
        }
        if (!object) {
            return;
        }
        if (DayPilot.isArray(object)) {
            for (var i = 0; i < object.length; i++) {
                DayPilot.Util.addClass(object[i], name);
            }
            return;
        }
        if (!object.className) {
            object.className = name;
            return;
        }
        var already = new RegExp("(^|\\s)" + name + "($|\\s)");
        if (!already.test(object.className)) {
            object.className = object.className + ' ' + name;
        }
    };

    DayPilot.Util.normalizeColor = function (input) {
        if (input.indexOf("rgb") === 0) {
            return rgbToHex(input);
        }
        return input;

        function rgbToHex(a){
            a = a.replace(/[^\d,]/g,"").split(",");
            return "#"+((1<<24)+(+a[0]<<16)+(+a[1]<<8)+ (+a[2])).toString(16).slice(1);
        }
    };

    DayPilot.Util.addClassToString = function(str, name) {
        if (!str) {
            return name;
        }
        var already = new RegExp("(^|\\s)" + name + "($|\\s)");
        if (!already.test(str)) {
            return str + ' ' + name;
        }
        else {
            return str;
        }
    };

    DayPilot.Util.removeClassFromString = function(str, name) {
        if (!str) {
            return "";
        }
        var already = new RegExp("(^|\\s)" + name + "($|\\s)");
        return str.replace(already, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');  // trim spaces
    };

    DayPilot.Util.removeClass = function(object, name) {
        if (!object) {
            return;
        }
        if (DayPilot.isArray(object)) {
            for (var i = 0; i < object.length; i++) {
                DayPilot.Util.removeClass(object[i], name);
            }
            return;
        }
        if (!object.className) {
            return;
        }
        var already = new RegExp("(^|\\s)" + name + "($|\\s)");
        object.className = object.className.replace(already, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');  // trim spaces
    };

    DayPilot.Util.props = function(o) {
        var t = [];
        for (var a in o) {
            t.push(a);
            t.push(o[a]);
        }
        return t.join("-");
    };


    DayPilot.Util.propArray = function(props, name, defaultValue) {
        return DayPilot.list(props).map(function(item) {
            return item[name] ? item[name] : defaultValue;
        });

        /*
        var result = [];
        if (!props || !props.length) {
            return result;
        }

        for (var i = 0; i < props.length; i++) {
            result.push(props[i][name]);
        }
        return result;
        */
    };

    DayPilot.Util.updatePropsFromArray = function(props, name, array) {
        for (var i = 0; i < array.length; i++) {
            props[i][name] = array[i];
        }
    };

    DayPilot.Util.copyProps = function(source, target, props) {
        if (!target) {
            target = {};
        }
        if (!source) {
            return target;
        }
        if (typeof props === 'undefined') {
            for (var name in source) {
                if (source.hasOwnProperty(name) && typeof source[name] !== 'undefined') {
                    target[name] = source[name];
                }
            }
        }
        else {
            for (var i = 0; i < props.length; i++) {
                var name = props[i];
                if (typeof source[name] !== 'undefined') {
                    target[name] = source[name];
                }
            }
        }
        return target;
    };

    DayPilot.Util.ownPropsAsArray = function(object) {
        var result = [];

        if (!object) {
            return result;
        }

        for (var name in object) {
            if (object.hasOwnProperty(name)) {
                var item = {};
                item.key = name;
                item.val = object[name];
                result.push(item);
            }
        }

        return result;
    };

    DayPilot.Util.firstPropValue = function(object) {
        for (var name in object) {
            return object[name];
        }
    };

    DayPilot.Util.isOnlyProperty = function(obj, propertyName) {
        if (!obj) {
            return false;
        }
        for (var name in obj) {
            if (obj.hasOwnProperty(name)) {
                if (name !== propertyName) {
                    return false;
                }
            }
        }
        return true;
    };

    DayPilot.Util.createArrayCopy = function(source, itemProps) {
        if (!DayPilot.isArray(source)) {
            return [];
        }
        var list = [];
        for (var i = 0; i < source.length; i++) {
            var item = {};
            DayPilot.Util.copyProps(source[i], item, itemProps);
            list.push(item);
        }
        return list;
    };

    DayPilot.Util.atLeast = function(a, b) {
        return Math.max(a, b);
    };

    DayPilot.Util.atMost = function(a, b) {
        return Math.min(a, b);
    };

    DayPilot.Util.avg = function(a, b) {
        return (a + b) / 2;
    };

    DayPilot.Util.div = function(parent, left, top, width, height) {
        var div = document.createElement("div");
        if (left || top || width || height) {
            if (width < 0) {
                left += width;
                width *= -1;
            }
            if (height < 0) {
                top += height;
                height *= -1;
            }
            div.style.position = "absolute";
            if (typeof left === "number") {
                div.style.left = left + "px";
            }
            else if (typeof left === "string") {
                div.style.left = left;
            }
            if (typeof top === "number") {
                div.style.top = top + "px";
            }
            else if (typeof top === "string") {
                div.style.top = top;
            }
            if (typeof width === "number") {
                div.style.width = width + "px";
            }
            else if (typeof width === "string") {
                div.style.width = width;
            }
            if (typeof height === "number") {
                div.style.height = height + "px";
            }
            else if (typeof height === "string") {
                div.style.height = height;
            }
        }
        if (parent) {
            parent.appendChild(div);
        }
        return div;
    };

    DayPilot.Util.overlaps = function(start1, end1, start2, end2) {
        return !(end1 <= start2 || start1 >= end2);
    };

    DayPilot.Util.isMouseEvent = function(ev) {
        if (!navigator.msPointerEnabled) {
            return false;
        }
        if (!ev.pointerType) {
            return false;
        }
        if (ev.pointerType === "mouse") {  // Windows 8.1
            return true;
        }
        if (ev.pointerType === 4) {  // Windows 7 - 8
            return true;
        }
        return false;
    };

    DayPilot.Util.mouseButton = function(ev) {
        var result = {};

        switch (ev.button) {
            case 0:
                result.left = true;
                break;
            case 1:
                result.middle = true;
                break;
            case 2:
                result.right = true;
                break;
        }

        return result;
    };

    DayPilot.Util.membersPlain = function(obj) {
        var members = DayPilot.Util.members(obj, 2);

        var transformArray = function(array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                var name = item.name;
                if (item.obsolete) {
                    name += " (obsolete)";
                }
                if (item.noCssOnly) {
                    name += " (!cssOnly)";
                }
                if (item.aspnet) {
                    name += " (ASP.NET)";
                }
                if (item.mvc) {
                    name += "(MVC)";
                }
                array[i] = name;
            }
        };

        transformArray(members.events);
        transformArray(members.methods);
        transformArray(members.properties);

        return members;
    };

    DayPilot.Util.shouldApply = function (name) {
        if (!name) {
            return false;
        }
        var lower = name.toLowerCase();
        if (lower.indexOf("before") >= 0) {
            return false;
        }
        if (lower.indexOf("after") >= 0) {
            return false;
        }
        if (lower === "onrowfilter") {
            return false;
        }
        if (lower === "oneventfilter") {
            return false;
        }
        return true;
    };

    DayPilot.Util.safeApply = function(scope, f) {
        var phase = scope["$root"]["$$phase"];
        if (phase === "$apply" || phase === "$digest") {
            scope["$eval"](f);

        } else {
            scope["$apply"](f);
        }
    };

    DayPilot.Util.members = function(obj, maxLevel) {
        var events = DayPilot.list();
        var methods = DayPilot.list();
        var properties = DayPilot.list();

        var obsolete = (obj && obj.members) ? obj.members.obsolete : [];
        var noCssOnly = (obj && obj.members) ? obj.members.noCssOnly : [];
        var ignore = (obj && obj.members) ? obj.members.ignore : [];
        var ignoreFilter = (obj && obj.members && obj.members.ignoreFilter) ? obj.members.ignoreFilter : function() { return false; };

        for (var name in obj) {
            //var start = name.substring(0, 1);
            if (name.indexOf("$") === 0) {
                continue;
            }
            if (name.indexOf("_") === 0) {
                continue;
            }
            if (name.indexOf("number") === 0) {
                continue;
            }
            if (name.indexOf("is") === 0) {
                continue;
            }
            if (name === "v") {
                continue;
            }
            if (DayPilot.contains(ignore, name)) {
                continue;
            }
            if (ignoreFilter(name)) {
                continue;
            }
            if (name.indexOf("on") === 0) {
                events.push(name);
                continue;
            }
            if (typeof obj[name] === 'function') {
                methods.push(name);
                continue;
            }
            if (typeof obj[name] === 'object') {
                var o = obj[name];
                if (maxLevel === 0) {
                    properties.push(name);
                    continue;
                }
                if (o && o.nodeType > 0) {
                    properties.push(name);
                    continue;
                }
                if (o instanceof DayPilot.Bubble) {
                    properties.push(name);
                    continue;
                }
                if (o instanceof DayPilot.Date) {
                    properties.push(name);
                    continue;
                }
                if (o instanceof DayPilot.Menu) {
                    properties.push(name);
                    continue;
                }
                if (o instanceof DayPilot.Scheduler) {
                    properties.push(name);
                    continue;
                }
                if (DayPilot.isArray(o)) {
                    properties.push(name);
                    continue;
                }
                if (o === null) {
                    properties.push(name);
                }
                var ml = null;
                if (typeof maxLevel === "number") {
                    ml = maxLevel - 1;
                }
                var members = DayPilot.Util.members(o, ml);
                for (var i = 0; i < members.events.length; i++) {
                    events.push(name + "." + members.events[i].name);
                }
                for (var i = 0; i < members.methods.length; i++) {
                    methods.push(name + "." + members.methods[i].name);
                }
                for (var i = 0; i < members.properties.length; i++) {
                    properties.push(name + "." + members.properties[i].name);
                }
                continue;
            }
            properties.push(name);
        }

        events.sort();
        methods.sort();
        properties.sort();

        var transformArray = function(array) {
            for (var i = 0; i < array.length; i++) {
                var name = array[i];
                var item = {};
                item.name = name;
                array[i] = item;
                if (DayPilot.contains(obsolete, name)) {
                    item.obsolete = true;
                }
                if (DayPilot.contains(noCssOnly, name)) {
                    item.noCssOnly = true;
                }
                if (name.indexOf("CallBack") !== -1) {
                    item.aspnet = true;
                    item.mvc = true;
                }
                if (name.indexOf("PostBack") !== -1) {
                    item.aspnet = true;
                }
                if (name.indexOf("Notify") !== -1) {
                    item.aspnet = true;
                    item.mvc = true;
                }

            }
        };
        transformArray(events);
        transformArray(methods);
        transformArray(properties);

        return {
            "events": events,
            "methods": methods,
            "properties": properties
        };
    };

    DayPilot.Util.replaceCharAt = function(str, index, character) {
        return str.substr(0, index) + character + str.substr(index + character.length);
    };

    DayPilot.Util.evalVariable = function(str, allowed) {
        allowed = allowed || ['object']; //  'function'

        if (str === null || typeof str === 'undefined') {
            return null;
        }

        if (DayPilot.indexOf(allowed, typeof str) !== -1) {
            return str;
        }
        if (typeof str !== "string") {
            throw "Unable to resolve a variable name (not a string).";
        }
        if (!/^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str)) {
            throw "Invalid variable name: " + str;
        }
        return eval(str);
    };

    DayPilot.Util.evalFunction = function(str) {
        if (str === null) {
            return null;
        }
        if (typeof str === "function") {
            return str;
        }
        if (typeof str !== "string") {
            throw "Unable to resolve a function (not a string).";
        }
        if (!/^\(?function/.test(str)) {
            throw "Invalid function string";
        }
        return eval("(" + str + ")");
    };

    DayPilot.Util.isNullOrUndefined = function(val) {
        return val === null || typeof val === "undefined";
    };

    DayPilot.Util.log = function(message) {
        window.console && window.console.log && window.console.log(message);
    };

    DayPilot.Util.workerFrom = function(f) {
        var text = f.toString();
        var body = text.slice(text.indexOf("{") + 1, text.lastIndexOf("}"));
        var blob = new Blob([body]);
        //var blob = new Blob(['('+f.toString() + ')()'], {type: 'text/javascript'});
        var blobURL = window.URL.createObjectURL(blob);
        return new Worker(blobURL);
    };

    DayPilot.Util.dataUriToBlob = function(dataUri) {
        if (typeof dataUri !== "string") {
            throw "DayPilot.Util.dataUriToBlob(): dataURI string expected";
        }
        var split = dataUri.split(",");
        var header = split[0];
        var body = split[1];
        var isBase64 = header.indexOf("base64") !== -1;
        var decode = isBase64 ? atob : decodeURI;  // atob requires IE10+, unsecape is deprecated
        var mime = header.split(":")[1].split(";")[0];

        var raw = decode(body);
        var array = new window.Uint8Array(raw.length);

        for (var i = 0; i < raw.length; i++) {
            array[i] = raw.charCodeAt(i);
        }

        return new Blob([array], {"type": mime});
    };

    DayPilot.Util.downloadDataUri = function(dataUri, name) {
        var blob = DayPilot.Util.dataUriToBlob(dataUri);
        DayPilot.Util.downloadBlob(blob, name);
    };

    DayPilot.Util.downloadBlob = function(blob, name) {
        var name = name || "download";

        if (window.navigator.msSaveBlob) {
            window.navigator.msSaveBlob(blob, name);
        }
        else {
            var url = window.URL.createObjectURL(blob);     // required instead of data uri for big objects ( > 2097100 characters)

            var link = document.createElement("a");
            link.download = name;
            link.href = url;
            link.style.display = "none";
            document.body.appendChild(link);  // required by ff
            link.click();
            setTimeout(function() {
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
            });
        }
    };

    DayPilot.Util.monitor = function(obj, name, inject) {
        //var id = "f" + DayPilot.guid();
        //obj[id] = obj[name];
        var original = obj[name];

        obj[name] = function() {
            inject.apply(obj, arguments);
            original.apply(obj, arguments);
        };
    };

    DayPilot.Util.isTransparentColor = function(color) {
        if (color === "transparent") {
            return true;
        }
        if (color === "rgba(0, 0, 0, 0)") {
            return true;
        }
        return false;
    };

    DayPilot.Util.stripTags = function(html) {
        if (DayPilot.Util.isNullOrUndefined(html)) {
            return html;
        }
        if (typeof html === "string") {
            return html.replace(/<(?:.|\n)*?>/gm, '');
        }
        throw new DayPilot.Exception("Unable to strip tags from a non-string");
    };

    DayPilot.Util.escapeHtml = function(html) {
        var div = document.createElement("div");
        div.innerText = html;
        return div.innerHTML;
    };

    DayPilot.Util.escapeTextHtml = function(text, html) {
        if (!DayPilot.Util.isNullOrUndefined(html)) {
            return html;
        }
        if (DayPilot.Util.isNullOrUndefined(text)) {
            return "";
        }
        return DayPilot.Util.escapeHtml(text);
    };

    DayPilot.Util.isSameEvent = function(data1, data2) {
        if (!data1 || !data2) {
            return false;
        }

        data1 = data1 instanceof DayPilot.Event ? data1.data : data1;
        data2 = data2 instanceof DayPilot.Event ? data2.data : data2;

        if (data1 === data2) {
            return true;
        }

        if (!DayPilot.Util.isNullOrUndefined(data1.id) && data1.id === data2.id) {
            return true;
        }

        // recurring event occurrences in server-based versions
        if (DayPilot.Util.isNullOrUndefined(data1.id) && !DayPilot.Util.isNullOrUndefined(data1.recurrentMasterId)) {
            return data1.recurrentMasterId === data2.recurrentMasterId && new DayPilot.Date(data1.start) === new DayPilot.Date(data2.start);
        }

        return false;
    };

    DayPilot.Util.isReactComponent = function(obj) {
        return obj && obj.$$typeof === (typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103);
    };

    DayPilot.Util.fontString = function(font) {
        var str = font.style + " " + font.size + " " + font.family;
        return str.trim();
    };

    DayPilot.Util.fontHeight = function(font) {
        var fs = DayPilot.Util.fontString(font);
        if (typeof DayPilot.Util.fontHeight.cache[fs] !== "number") {
            var div = document.createElement('div');
            div.style.position = "fixed";
            div.style.left = "-2000px;";
            div.style.top = "-2000px";
            div.style.padding = "0px";
            div.style.font = fs;
            div.innerText = "X";
            document.body.appendChild(div);
            DayPilot.Util.fontHeight.cache[fs] = new DayPilot.StyleReader(div).getPx("height");
            document.body.removeChild(div);
        }
        return DayPilot.Util.fontHeight.cache[fs];
    };

    DayPilot.Util.fontHeight.cache = {};

    DayPilot.Areas = {};

    /**
     * Attach active areas to a target div.
     * Works with "Visible", "TouchVisible" and "Hover" visibility
     */
    DayPilot.Areas.attach = function (div, e, options) {
        var options = options || {};
        var areas = options.areas;
        var allowed = options.allowed || function() { return true; };
        var offsetX = options.offsetX || 0;

        // permanently visible active areas
        areas = areasExtract(e, areas);

        if (!areas) {
            return;
        }

        if (!DayPilot.isArray(areas)) {
            return;
        }

        if (areas.length === 0) {
            return;
        }

        DayPilot.re(div, "mousemove", function(ev) {
            if (!div.active && !div.areasDisabled && allowed()) {
                DayPilot.Areas.showAreas(div, e, ev, areas, { "offsetX": offsetX, "eventDiv": options.eventDiv});
            }
        });
        DayPilot.re(div, "mouseleave", function(ev) {
            DayPilot.Areas.hideAreas(div, ev);
        });

        DayPilot.list(areas).forEach(function(area) {
/*
            var v = area.visibility || area.v || "Visible";
            if (v !== "Visible") {
                return;
            }
*/
            if (!DayPilot.Areas.isVisible(area)) {
                return;
            }
            var a = DayPilot.Areas.createArea(div, e, area, { "offsetX": offsetX, "eventDiv": options.eventDiv});
            div.appendChild(a);
        });
    };

    DayPilot.Areas.disable = function(div) {
        div.areasDisabled = true;
        DayPilot.list(div.childNodes).filter(function(item) { return item.isActiveArea && !item.area.start; }).forEach(function(item) {
            item._originalDisplay = item.style.display;
            item.style.display = "none";
        });
    };

    DayPilot.Areas.enable = function(div) {
        div.areasDisabled = false;
        DayPilot.list(div.childNodes).filter(function(item) { return item.isActiveArea && !item.area.start; }).forEach(function(item) {
            if (item._originalDisplay) {
                item.style.display = item._originalDisplay;
            }
            else {
                item.style.display = "";
            }
        });
    };

    DayPilot.Areas.remove = function(div) {
        var divs = DayPilot.list(div.childNodes).filter(function(item) { return item.isActiveArea; });

        DayPilot.de(divs);
    };

    DayPilot.Areas.isVisible = function(area) {
        var v = area.visibility || area.v || "Visible";
        if (v === "Visible") {
            return true;
        }
        if (v === "TouchVisible") {
            if (!DayPilot.browser.hover) {
                return true;
            }
        }
        return false;
    };

    DayPilot.Areas.copy = function(areas) {
        if (!DayPilot.isArray(areas)) {
            return [];
        }

        return areas.map(function(area) {
            return DayPilot.Util.copyProps(area, {});
        });
    };

    // only scheduler
    DayPilot.Areas.resolvePosition = function(areas, scheduler, left, width) {
        var copy = DayPilot.Areas.copy(areas);
        var calendar = scheduler;
        copy.forEach(function(area) {
            if (area.start) {
                area.left = calendar.getPixels(new DayPilot.Date(area.start)).left - left;
            }
            if (typeof area.offsetX === "number") {
                area.left += area.offsetX;
            }
            if (area.end) {
                // area.width = calendar.getPixels(new DayPilot.Date(area.end)).left - area.left - left;
                area.right = left + width - calendar.getPixels(new DayPilot.Date(area.end)).left;
            }

        });
        return copy;
    };

    /**
     * Extracts areas array from the source object, giving priority to a standalone areas object.
     * @param e
     * @param areas
     */
    var areasExtract = function(e, areas) {
        if (!DayPilot.isArray(areas)) {
            areas = e.areas;
            if (!areas) {
                if (e.cache) {
                    areas = e.cache.areas;
                }
                else if (e.data) {
                    areas = e.data.areas;
                }
            }
        }
        return areas;
    };


    DayPilot.Areas.showAreas = function(div, e, ev, areas, options) {
        if (DayPilot.Global.resizing) {
            return;
        }

        if (DayPilot.Global.moving) {
            return;
        }

        if (DayPilot.Global.selecting) {
            return;
        }

        if (div.active) {
            return;
        }

        if (!DayPilot.browser.hover) {
            return;
        }

        if (DayPilot.Areas.all && DayPilot.Areas.all.length > 0) {
            for (var i = 0; i < DayPilot.Areas.all.length; i++) {
                var d = DayPilot.Areas.all[i];
                if (d !== div) {
                    DayPilot.Areas.hideAreas(d, ev);
                }
            }
        }

        div.active = {};

        //var areas;
        if (!DayPilot.isArray(areas)) {
            areas = e.areas;
            if (!areas) {
                if (e.cache) {
                    areas = e.cache.areas;
                }
                else if (e.data) {
                    areas = e.data.areas;
                }
            }
        }

        /*
        if (!areas && e.cache && e.cache.areas) {
            areas = e.cache.areas;
        }

        if (!areas && e.data && e.data.areas) {
            areas = e.data.areas;
        }
        */

        if (!areas || areas.length === 0) {
            return;
        }

        if (div.areas && div.areas.length > 0) {
            return;
        }
        //if (typeof div.areas == 'undefined') {
        div.areas = [];
        //}


        for (var i = 0; i < areas.length; i++) {
            var area = areas[i];

            /*var v = area.visibility || area.v || "Visible";
            if (v !== 'Hover') {
                continue;
            }
*/
            if (DayPilot.Areas.isVisible(area)) {
                continue;
            }

            var a = DayPilot.Areas.createArea(div, e, area, options);

            div.areas.push(a);
            div.appendChild(a);

            DayPilot.Areas.all.push(div);
        }
        div.active.children = DayPilot.ac(div);
    };

    /**
     *
     * @param div Target div element
     * @param e Source data object
     * @param area Area definition
     * @returns {Element}
     */
    DayPilot.Areas.createArea = function(div, e, area, options) {

        /*
        actions:
        - Default (equals not specified)
        - None (cancels bubble to parent)
        - JavaScript (legacy)
        - ContextMenu
        - HoverMenu
        - Bubble (hover on desktop, tap on touch devices)
        - ResizeStart
        - ResizeEnd
        - Move
         */

        var options = options || {};
        var offsetX = options.offsetX || 0;
        var ediv = options.eventDiv || div;

        var a = document.createElement("div");
        a.isActiveArea = true;
        a.area = area;
        a.setAttribute("unselectable", "on");
        var w = area.w || area.width;
        var h = area.h || area.height;
        var css = area.cssClass || area.css || area.className;
        if (typeof area.style !== "undefined") {
            a.setAttribute("style", area.style);
        }
        a.style.position = "absolute";

        a.style.width = resolvePosVal(w);
        a.style.height = resolvePosVal(h);
        a.style.right = resolvePosVal(area.right);
        a.style.top = resolvePosVal(area.top);
        a.style.left = resolvePosVal(area.left);
        a.style.bottom = resolvePosVal(area.bottom);

        if (typeof area.html !== 'undefined' || typeof area.text !== "undefined") {
            // a.innerHTML = area.html || area.text;
            a.innerHTML = DayPilot.Util.escapeTextHtml(area.text, area.html);
        }
        else if (area.icon) {
            var iel = document.createElement("i");
            iel.className = area.icon;
            a.appendChild(iel);
        }
        else if (area.image) {
            var img = document.createElement("img");
            img.src = area.image;
            a.appendChild(img);
        }
        else if (area.symbol) {
            var ns = "http://www.w3.org/2000/svg";
            var svg = document.createElementNS(ns,"svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            var use = document.createElementNS(ns,"use");
            use.setAttribute("href", area.symbol);
            svg.appendChild(use);
            a.appendChild(svg);
        }

        if (css) {
            a.className = css;
        }
        if (area.toolTip) {
            a.setAttribute("title", area.toolTip);
        }
        if (area.backColor) {
            a.style.background = area.backColor;
        }
        if (area.background) {  // alias
            a.style.background = area.background;
        }
        if (area.fontColor) {
            a.style.color = area.fontColor;
        }
        if (area.padding) {
            a.style.padding = area.padding + "px";
            a.style.boxSizing = "border-box";
        }
        if (area.verticalAlignment) {
            a.style.display = "flex";
            switch (area.verticalAlignment) {
                case "center":
                    a.style.alignItems = "center";
                    break;
                case "top":
                    a.style.alignItems = "flex-start";
                    break;
                case "bottom":
                    a.style.alignItems = "flex-end";
                    break;
            }
        }
        if (area.horizontalAlignment) {
            a.style.display = "flex";
            switch (area.horizontalAlignment) {
                case "right":
                    a.style.justifyContent = "flex-end";
                    break;
                case "left":
                    a.style.justifyContent = "flex-start";
                    break;
                case "center":
                    a.style.justifyContent = "center";
                    break;
            }
        }

        if (area.action === "ResizeEnd" || area.action === "ResizeStart" || area.action === "Move") {
            if (e.calendar.isCalendar) {
                switch (area.action) {
                    case "ResizeEnd":
                        area.cursor = "s-resize";
                        area.dpBorder = "bottom";
                        break;
                    case "ResizeStart":
                        area.cursor = "n-resize";
                        area.dpBorder = "top";
                        break;
                    case "Move":
                        area.cursor = "move";
                        break;
                }
            }
            if (e.calendar.isScheduler || e.calendar.isMonth) {
                switch (area.action) {
                    case "ResizeEnd":
                        area.cursor = "e-resize";
                        area.dpBorder = "right";
                        break;
                    case "ResizeStart":
                        area.cursor = "w-resize";
                        area.dpBorder = "left";
                        break;
                    case "Move":
                        area.cursor = "move";
                        break;
                }
            }
            a.onmousemove = (function(div, e, area) {
                return function(ev) {

                    if (e.calendar.internal && e.calendar.internal.dragInProgress && e.calendar.internal.dragInProgress()) {  // resizing in progress
                        return;
                    }
                    ev.cancelBubble = true;

                    div.style.cursor = area.cursor;
                    if (area.dpBorder) {
                        div.dpBorder = area.dpBorder;
                    }
                };
            })(ediv, e, area);
            a.onmouseout = (function(div, e, area) {
                return function(ev) {
                    div.style.cursor = '';
                };
            })(ediv, e, area);
        }
        if ((area.action === "ResizeEnd" || area.action === "ResizeStart") && e.isEvent) {
            if (e.calendar.internal.touch) {
                var touchstart = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        var touch = e.calendar.internal.touch;
                        var t = ev.touches ? ev.touches[0] : ev;
                        var coords = {x: t.pageX, y: t.pageY };
                        // immediately
                        e.calendar.coords = touch.relativeCoords(ev);
                        touch.preventEventTap = true;
                        if (e.calendar.isScheduler) {
                            touch.startResizing(div, area.action === "ResizeEnd" ? "right" : "left");
                        }
                        else if (e.calendar.isCalendar) {
                            touch.startResizing(div, area.action === "ResizeEnd" ? "bottom" : "top", coords);
                        }

                    };
                })(ediv, e, area);
                DayPilot.rePassive(a, DayPilot.touch.start, touchstart);
                // a.addEventListener(DayPilot.touch.start, touchstart, {"passive": true});
            }
        }
        if (area.action === "ContextMenu" && e.isEvent) {
            if (e.calendar.internal.touch) {
                var touchstart = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        ev.preventDefault();

                        showContextMenu(div, e, area, ev);
                        var touch = e.calendar.internal.touch;
                        touch.preventEventTap = true;
                    };
                })(ediv, e, area);
                var touchend = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        ev.preventDefault();
                    };
                })(ediv, e, area);
                DayPilot.reNonPassive(a, DayPilot.touch.start, touchstart);
                DayPilot.reNonPassive(a, DayPilot.touch.end, touchend);
            }
        }
        if (area.action === "Bubble" && e.isEvent) {
            if (e.calendar.internal.touch) {
                var touchstart = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        ev.preventDefault();

                        var args = doOnClick(area, e, ev);
                        if (args.preventDefault.value) {
                            return;
                        }
                        showBubble(e, area, ev);
                        var touch = e.calendar.internal.touch;
                        touch.preventEventTap = true;

                        if (typeof area.onClicked === "function") {
                            area.onClicked(args);
                        }
                    };
                })(ediv, e, area);
                var touchend = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        ev.preventDefault();
                    };
                })(ediv, e, area);
                DayPilot.reNonPassive(a, DayPilot.touch.start, touchstart);
                DayPilot.reNonPassive(a, DayPilot.touch.end, touchend);
            }
        }
        if (area.action === "Move" && e.isEvent) {
            if (e.calendar.internal.touch) {
                var touchstart = (function(div, e, area) {
                    return function(ev) {
                        ev.cancelBubble = true;
                        var touch = e.calendar.internal.touch;
                        var t = ev.touches ? ev.touches[0] : ev;
                        var coords = {x: t.pageX, y: t.pageY };
                        // immediately
                        e.calendar.coords = touch.relativeCoords(ev);

                        // DayPilot.Global.movingAreaData = area.data;
                        if (DayPilot.Global && DayPilot.Global.touch) {
                            DayPilot.Global.touch.active = true;
                        }

                        touch.preventEventTap = true;
                        touch.startMoving(div, coords);
                    };
                })(ediv, e, area);
                DayPilot.rePassive(a, DayPilot.touch.start, touchstart);
                // a.addEventListener(DayPilot.touch.start, touchstart, {"passive": true});
            }
        }
        if (area.action === "Move" && e.isRow) {
            if (e.calendar.internal.touch) {
                // TODO
            }
            /*
            a.onmousedown = (function(div, e, area) {
                return function(ev) {
                    rowmoving.row = row;
                    rowtools.createOverlay(row);
                };
            })(div, e, area);
            */
        }
        if (area.action === "Bubble" && e.isEvent) {
            a.onmousemove = (function(div, e, area) {
                return function(ev) {
                    if (area.bubble) {
                        area.bubble.showEvent(e, true);
                    }
                    else if (e.calendar.bubble) {
                        e.calendar.bubble.showEvent(e, true);
                    }
                };
            })(div, e, area);
            a.onmouseout = (function(div, e, area) {
                return function(ev) {
                    if (typeof DayPilot.Bubble !== "undefined") {
                        //DayPilot.Bubble.hideActive();
                        if (area.bubble) {
                            area.bubble.hideOnMouseOut();
                        }
                        else if (e.calendar.bubble) {
                            e.calendar.bubble.hideOnMouseOut();
                        }
                    }

                };
            })(div, e, area);
        }
        else if (area.action === "Bubble" && e.isRow) {
            a.onmousemove = (function(div, e, area) {
                return function(ev) {
                    if (area.bubble) {
                        area.bubble.showResource(e, true);
                    }
                    else if (e.calendar.resourceBubble) {
                        e.calendar.resourceBubble.showResource(e, true);
                    }
                };
            })(div, e, area);
            a.onmouseout = (function(div, e, area) {
                return function(ev) {
                    if (typeof DayPilot.Bubble !== "undefined") {
                        //DayPilot.Bubble.hideActive();
                        if (area.bubble) {
                            area.bubble.hideOnMouseOut();
                        }
                        else if (e.calendar.resourceBubble) {
                            e.calendar.resourceBubble.hideOnMouseOut();
                        }
                    }

                };
            })(div, e, area);
        }
        else if (area.action === "Bubble" && typeof DayPilot.Bubble !== "undefined" && area.bubble instanceof DayPilot.Bubble) {
            a.onmousemove = (function(div, e, area) {
                return function(ev) {
                    area.bubble.showHtml(null, null);
                };
            })(div, e, area);
            a.onmouseout = (function(div, e, area) {
                return function(ev) {
                    if (typeof DayPilot.Bubble !== "undefined") {
                        if (area.bubble) {
                            area.bubble.hideOnMouseOut();
                        }
                    }

                };
            })(div, e, area);
        }
        if (area.action === "HoverMenu") {
            a.onmousemove = (function(div, e, area) {
                return function(ev) {
                    var m = area.menu;
                    if (typeof m === 'string') {
                        m = DayPilot.Util.evalVariable(m);
                    }
                    if (m && m.show) {
                        if (!m.visible) {
                            m.show(e);
                        }
                        else if (m.source && typeof m.source.id !== 'undefined' && m.source.id !== e.id) {
                            m.show(e);
                        }
                        m.cancelHideTimeout();
                    }
                };
            })(div, e, area);
            a.onmouseout = (function(div, e, area) {
                return function(ev) {
                    var m = area.menu;
                    if (typeof m === 'string') {
                        m = DayPilot.Util.evalVariable(m);
                    }
                    if (!m) {
                        return;
                    }
                    if (m.hideOnMouseOver) {
                        m.delayedHide();
                    }
                };
            })(div, e, area);
        }
        if (area.action === "JavaScript") {
            var touchstart = (function(div, e, area) {
                return function(ev) {
                    if (DayPilot.Util.isMouseEvent(ev)) {
                        return;
                    }

                    //alert("touchstart");
                    ev.cancelBubble = true;
                    ev.preventDefault();

                    //showBubble(e, area, ev);
                    var touch = e.calendar.internal.touch;
                    if (DayPilot.Global && DayPilot.Global.touch) {
                        DayPilot.Global.touch.start = true;
                    }


                };
            })(ediv, e, area);
            var touchend = (function(div, e, area) {
                return function(ev) {
                    if (DayPilot.Util.isMouseEvent(ev)) {
                        return;
                    }

                    ev.cancelBubble = true;
                    ev.preventDefault();

                    var touch = e.calendar.internal.touch;
                    if (DayPilot.Global && DayPilot.Global.touch) {
                        DayPilot.Global.touch.start = false;
                    }

                    var f = area.js;
                    if (typeof f === 'string') {
                        f = DayPilot.Util.evalFunction(area.js);
                    }
                    if (typeof f === 'function') {
                        var target = area.target || e;
                        f.call(this, target);
                    }

                };
            })(ediv, e, area);
            DayPilot.reNonPassive(a, DayPilot.touch.start, touchstart);
            DayPilot.reNonPassive(a, DayPilot.touch.end, touchend);
        }

        if (area.action === "None") {
            var touchstart = (function(div, e, area) {
                return function(ev) {
                    var args = doOnClick(area, e, ev);

                    if (typeof area.onClicked === "function") {
                        area.onClicked(args);
                    }

                    ev.preventDefault();
                    ev.stopPropagation();
                };
            })(ediv, e, area);
            DayPilot.reNonPassive(a, DayPilot.touch.start, touchstart);
        }


        // independent onClick on touch devices
/*
        DayPilot.re(a, DayPilot.touch.start, function(ev) {
            DayPilot.Areas._touchstart = true;
        });
        DayPilot.re(a, DayPilot.touch.move, function(ev) {
            if (DayPilot.Areas._touchstart) {
                DayPilot.Areas._touchmove = true;
            }
        });
        DayPilot.re(a, DayPilot.touch.end, function(ev) {
            var moved = DayPilot.Areas._touchmove;
            DayPilot.Areas._touchstart = false;
            DayPilot.Areas._touchend = false;
            if (moved) {
                return;
            }
            ev.preventDefault(); // cancel click
            DayPilot.Modal.alert('touch/click');
        });
*/

        // prevent event moving
        a.onmousedown = (function(div, e, area) {
            return function(ev) {
                if (typeof area.onmousedown === 'function') { // obsolete, remove
                    area.onmousedown(ev);
                }

                if (typeof area.mousedown === 'function') { // internal
                    var args = {};
                    args.area = area;
                    args.div = div;
                    args.originalEvent = ev;
                    args.source = e;
                    area.mousedown(args);
                }

                if (area.action === "Move" && e.isRow) {
                    var row = e.$.row;
                    var startMoving = e.calendar.internal.rowStartMoving;

                    startMoving(row);
                }

                // cancel any bubble
                if (typeof DayPilot.Bubble !== "undefined") {
                    DayPilot.Bubble.hideActive();
                }

                if (area.action === "Move") {
                    DayPilot.Global.movingAreaData = area.data;
                }

                if (area.action === "Move" && e.isEvent) {
                    if (e.calendar.internal && e.calendar.internal.startMoving) {
                        e.calendar.internal.startMoving(div, ev);
                    }
                }

                var cancel = true;

                if (cancel) {
                    if (area.action === "Move" || area.action === "ResizeEnd" || area.action === "ResizeStart" || !area.action || area.action === "Default") {
                        return;
                    }
                    ev.preventDefault(); // prevents text selection on dragging
                    ev.cancelBubble = true;
                }
            };
        })(div, e, area);
        a.onclick = (function(div, e, area) {
            return function(ev) {

                /*
                if (!area.action) {  // do not cancel bubble
                    return;
                }
                */

/*                var args = {};
                args.area = area;
                args.source = e;
                args.originalEvent = ev;
                args.preventDefault = function() {
                    args.preventDefault.value = true;
                };

                if (typeof area.onClick === "function") {
                    area.onClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }*/

                var args = doOnClick(area, e, ev);

                if (args.preventDefault.value) {
                    return;
                }

                switch (area.action) {
                    case "JavaScript":
                        var f = area.js;
                        if (typeof f === 'string') {
                            f = DayPilot.Util.evalFunction(area.js);
                        }
                        if (typeof f === 'function') {
                            var target = area.target || e;
                            f.call(this, target);
                        }
                        ev.cancelBubble = true;
                        break;
                    case "ContextMenu":
                        showContextMenu(div, e, area, ev);
                        ev.cancelBubble = true;
                        break;
                    case "CallBack":
                        alert("callback not implemented yet, id: " + area.id);
                        ev.cancelBubble = true;
                        break;
                    case "None":
                        ev.cancelBubble = true;
                        break;
                }

                if (typeof area.onClicked === "function") {
                    area.onClicked(args);
                }
            };
        })(div, e, area);

        if (typeof area.onMouseEnter === "function") {
            a.addEventListener("mouseenter", (function(div, e, area) {
                return function(ev) {
                    var args = {};
                    args.area = area;
                    args.source = e;
                    args.originalEvent = ev;
                    area.onMouseEnter(args);
                };
            })(div, e, area));
        }
        if (typeof area.onMouseLeave === "function") {
            a.addEventListener("mouseleave", (function(div, e, area) {
                return function(ev) {
                    var args = {};
                    args.area = area;
                    args.source = e;
                    args.originalEvent = ev;
                    area.onMouseLeave(args);
                };
            })(div, e, area));
        }

        function doOnClick(area, source, originalEvent) {
            var args = {};
            args.area = area;
            args.source = source;
            args.originalEvent = originalEvent;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            if (typeof area.onClick === "function") {
                area.onClick(args);
            }
            return args;
        }

        function showBubble(e, area, ev) {
            if (DayPilot.Bubble) {
                DayPilot.Bubble.touchPosition(ev);
            }

            if (e.calendar.bubble) {
                e.calendar.bubble.showEvent(e, true);
            }
        }

        function showContextMenu(div, e, area, ev) {
            if (DayPilot.Menu) {
                DayPilot.Menu.touchPosition(ev);
            }

            var m = area.contextMenu || area.menu;
            if (!(m instanceof DayPilot.Menu)) {
                if (typeof m === 'string') {
                    m = DayPilot.Util.evalVariable(m);
                }
                else if (e.isEvent && e.client.contextMenu()) {
                    m = e.client.contextMenu();
                }
                else if (e.isEvent && e.calendar.contextMenu) {
                    m = DayPilot.Util.evalVariable(e.calendar.contextMenu);
                }
                else if (e.isRow && e.calendar.contextMenuResource) {
                    m = DayPilot.Util.evalVariable(e.calendar.contextMenuResource);
                }
            }
            if (m && m.show) {
                var initiator = { "type": "area", "div": div, "e": e, "area": area, "a": a};
                m.show(e, { "initiator": initiator});
            }
        }

        function resolvePosVal(val) {
            if (typeof val === "string" && isNaN(val)) {
                return val;
            }
            else if (typeof val !== "undefined") {
                return val + "px";
            }
            return undefined;
        }

        return a;
    };

    DayPilot.Areas.all = [];

    DayPilot.Areas.hideAreas = function(div, ev) {
        if (!div) {
            return;
        }

        if (!div || !div.active) {
            return;
        }

        var active = div.active;
        var areas = div.areas;

        if (active && active.children) {
            if (ev) {
                var target = ev.toElement || ev.relatedTarget;
                if (~DayPilot.indexOf(active.children, target)) {
                    return;
                }
            }
        }

        if (!areas || areas.length === 0) {
            div.active = null;
            return;
        }

        DayPilot.de(areas);
        /*
        for (var i = 0; i < areas.length; i++) {
            var a = areas[i];
            div.removeChild(a);
        }*/

        div.active = null;
        div.areas = [];

        DayPilot.rfa(DayPilot.Areas.all, div);

        active.children = null;
    };

    DayPilot.Areas.hideAll = function(ev) {
        if (!DayPilot.Areas.all || DayPilot.Areas.all.length === 0) {
            return;
        }
        for (var i = 0; i < DayPilot.Areas.all.length; i++) {
            DayPilot.Areas.hideAreas(DayPilot.Areas.all[i], ev);
        }

    };

    DayPilot.Action = function(calendar, name, params, data) {
        var action = this;
        this.calendar = calendar;
        this.isAction = true;
        this.action = name;
        this.params = params;
        this.data = data;

        this.notify = function() {
            action.calendar.internal.invokeEvent("Immediate", this.action, this.params, this.data);
        };

        this.auto = function() {
            action.calendar.internal.invokeEvent("Notify", this.action, this.params, this.data);
        };

        this.queue = function() {
            action.calendar.queue.add(this);
        };

        this.toJSON = function() {
            var json = {};
            json.name = this.action;
            json.params = this.params;
            json.data = this.data;

            return json;
        };

    };

    DayPilot.Selection = function(start, end, resource, root) {
        this.menuType = 'selection';  // for menu
        this.start = new DayPilot.Date(start);
        this.end = new DayPilot.Date(end);
        this.resource = resource;
        this.root = root;
        this.calendar = root;

        this.toJSON = function(key) {
            var json = {};
            json.start = this.start;
            json.end = this.end;
            json.resource = this.resource;

            return json;
        };
    };

    DayPilot.Link = function(data, calendar) {
        this.isLink = true;
        this.data = data;
        this.calendar = calendar;

        this.to = function() {
            return this.data.to;
        };

        this.from = function() {
            return this.data.from;
        };

        this.type = function() {
            return this.data.type;
        };

        this.id = function() {
            return this.data.id;
        };

        this.toJSON = function() {
            var json = {};
            json.from = this.data.from;
            json.to = this.data.to;
            json.id = this.data.id;
            json.type = this.data.type;
            return json;
        };
    };

/*
    DayPilot.Args = function() {
        this.isArgs = true;
        this.preventDefault = function () {
            this.preventDefault.value = true;
        };
    };
*/

    DayPilot.Event = function(data, calendar, part) {
        var e = this;
        this.calendar = calendar;
        this.data = data ? data : {};
        this.part = part ? part : {};

        // backwards compatibility, still accepts id in "value"
        if (typeof this.data.id === 'undefined') {
            this.data.id = this.data.value;
        }

        var copy = {};
        var synced = ["id", "text", "start", "end", "resource"];

        this.isEvent = true;

        DayPilot.Stats.eventObjects += 1;

        // internal
        this.temp = function() {
            if (copy.dirty) {
                return copy;
            }
            for (var i = 0; i < synced.length; i++) {
                copy[synced[i]] = e.data[synced[i]];
            }
            copy.dirty = true;
            return copy;

        };

        // internal
        // copies data object
        // used when the original state of the data is needed (notified EventMove etc.)
        this.copy = function() {
            var result = {};
            DayPilot.Util.copyProps(e.data, result);
            return result;
            /*
            for (var i = 0; i < synced.length; i++) {
                result[synced[i]] = e.data[synced[i]];
            }
            return result;
            */
        };

        this.commit = function() {
            if (!copy.dirty) {
                return;
            }

            for (var i = 0; i < synced.length; i++) {
                e.data[synced[i]] = copy[synced[i]];
            }

            // gantt back-sync during moving and resizing
            if (typeof e.data.commitCallback === "function") {
                e.data.commitCallback();
            }

            copy.dirty = false;
        };

        this.dirty = function() {
            return copy.dirty;
        };

        this.id = function(val) {
            if (typeof val === 'undefined') {
                return e.data.id;
            }
            else {
                this.temp().id = val;
            }
        };
        // obsolete, use id() instead
        this.value = function(val) {
            if (typeof val === 'undefined') {
                return e.id();
            }
            else {
                e.id(val);
            }
        };

        this.text = function(val) {
            if (typeof val === 'undefined') {
                return e.data.text;
            }
            else {
                this.temp().text = val;

                // update the HTML automatically with escaped value
                var escapedHtml = DayPilot.Util.escapeHtml(val);
                this.client.innerHTML(escapedHtml);
            }
        };
        this.start = function(val) {
            if (typeof val === 'undefined') {
                return new DayPilot.Date(e.data.start);
            }
            else {
                this.temp().start = new DayPilot.Date(val);
            }
        };
        this.end = function(val) {
            if (typeof val === 'undefined') {
                if (calendar && calendar.internal.adjustEndNormalize) {
                    return calendar.internal.adjustEndNormalize(new DayPilot.Date(e.data.end));
                }
                return new DayPilot.Date(e.data.end);
            }
            else {
                this.temp().end = new DayPilot.Date(val);
            }
        };
        this.duration = function() {
            return new DayPilot.Duration(this.start(), this.end());
        };
        this.rawend = function(val) {
            if (typeof val === 'undefined') {
                if (calendar && calendar.internal.adjustEndIn) {
                    return calendar.internal.adjustEndIn(new DayPilot.Date(e.data.end));
                }
                return new DayPilot.Date(e.data.end);
            }
            else {
                throw new DayPilot.Exception("DayPilot.Event.rawend() is readonly");
            }
        };
        this.partStart = function() {
            return new DayPilot.Date(this.part.start);
        };
        this.partEnd = function() {
            return new DayPilot.Date(this.part.end);
        };
        this.row = function() {
            return this.resource();
        };

        this.allday = function() {
            if (typeof val === 'undefined') {
                return e.data.allday;
            }
            else {
                this.temp().allday = val;
            }
        };

        // backwards compatibility, 7.3
        this.isAllDay = this.allday;

        this.resource = function(val) {
            if (typeof val === 'undefined') {
                return e.data.resource;
            }
            else { // it's a resource id
                this.temp().resource = val;
            }
        };

        this.recurrent = function() {
            return e.data.recurrent;
        };
        this.recurrentMasterId = function() {
            return e.data.recurrentMasterId;
        };
        this.useBox = function() {
            return this.part.box;
        };
        this.staticBubbleHTML = function() {
            return this.bubbleHtml();
        };
        this.bubbleHtml = function() {
            if (e.cache) {
                return e.cache.bubbleHtml || e.data.bubbleHtml;
            }
            return e.data.bubbleHtml;
        };
        this.tag = function(field) {
            if (e.data.tags) {
                return e.data.tags[field];
            }
            else {
                var values = e.data.tag;
                if (!values) {
                    return null;
                }
                if (typeof field === 'undefined') {
                    return e.data.tag;
                }
                var fields = e.calendar.tagFields;
                var index = -1;
                for (var i = 0; i < fields.length; i++) {
                    if (field === fields[i])
                        index = i;
                }
                if (index === -1) {
                    throw "Field name not found.";
                }
                return values[index];
            }
        };

        this.client = {};
        this.client.innerHTML = function(val) {
            if (typeof val === 'undefined') {
                var data = e.cache || e.data;
                var xssTextHtml = e.calendar && e.calendar.internal && e.calendar.internal.xssTextHtml;
                if (xssTextHtml) {
                    return xssTextHtml(data.text, data.html);
                }
                return DayPilot.Util.escapeTextHtml(data.text, data.html);
                /*
                if (e.cache && typeof e.cache.html !== "undefined") {
                    return e.cache.html;
                }
                if (typeof e.data.html !== "undefined") {
                    return e.data.html;
                }
                return e.data.text;*/
            }
            else {
                e.data.html = val;
                if (e.cache) {
                    e.cache.html = val;
                }
            }
        };

        this.client.html = this.client.innerHTML;

        this.client.header = function(val) {
            if (typeof val === 'undefined') {
                return e.data.header;
            }
            else {
                e.data.header = val;
            }
        };

        this.client.cssClass = function(val) {
            if (typeof val === 'undefined') {
                return e.data.cssClass;
            }
            else {
                e.data.cssClass = val;
            }
        };
        this.client.toolTip = function(val) {
            if (typeof val === 'undefined') {
                var tooltip = null;
                if (e.cache && typeof e.cache.toolTip !== "undefined") {
                    tooltip = e.cache.toolTip;
                }
                else {
                    tooltip = typeof e.data.toolTip !== 'undefined' ? e.data.toolTip : e.data.text;
                }
                // don't HTML-escape
                return tooltip;
            }
            else {
                e.data.toolTip = val;
            }
        };

        // toberemoved
        this.client.backColor = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.backColor !== "undefined") {
                    return e.cache.backColor;
                }
                return typeof e.data.backColor !== "undefined" ? e.data.backColor : e.calendar.eventBackColor;
            }
            else {
                e.data.backColor = val;
            }
        };

        this.client.borderColor = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.borderColor !== "undefined") {
                    return e.cache.borderColor;
                }
                return typeof e.data.borderColor !== "undefined" ? e.data.borderColor : e.calendar.eventBorderColor;
            }
            else {
                e.data.borderColor = val;
            }
        };

        // toberemoved
        this.client.barColor = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.barColor !== "undefined") {
                    return e.cache.barColor;
                }
                return typeof e.data.barColor !== "undefined" ? e.data.barColor : e.calendar.durationBarColor;
            }
            else {
                e.data.barColor = val;
            }
        };

        this.client.barVisible = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.barHidden !== "undefined") {
                    return !e.cache.barHidden;
                }
                return e.calendar.durationBarVisible && !e.data.barHidden;
            }
            else {
                e.data.barHidden = !val;
            }
        };

        this.client.contextMenu = function(val) {
            if (typeof val === 'undefined') {
                if (e.oContextMenu) {
                    return e.oContextMenu;
                }
                var cm = e.cache ? e.cache.contextMenu : e.data.contextMenu;
                return (cm) ? DayPilot.Util.evalVariable(cm) : null;  // might want to return the default context menu in the future
            }
            else {
                e.oContextMenu = val;
            }
        };

        this.client.moveEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.moveDisabled !== "undefined") {
                    return !e.cache.moveDisabled;
                }
                return e.calendar.eventMoveHandling !== 'Disabled' && !e.data.moveDisabled;
            }
            else {
                e.data.moveDisabled = !val;
            }
        };

        this.client.resizeEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.data.type === "Milestone") {
                    return false;
                }
                if (e.cache && typeof e.cache.resizeDisabled !== "undefined") {
                    return !e.cache.resizeDisabled;
                }
                return e.calendar.eventResizeHandling !== 'Disabled' && !e.data.resizeDisabled;
            }
            else {
                e.data.resizeDisabled = !val;
            }
        };

        this.client.rightClickEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.rightClickDisabled !== "undefined") {
                    return !e.cache.rightClickDisabled;
                }
                return e.calendar.eventRightClickHandling !== 'Disabled' && !e.data.rightClickDisabled;
            }
            else {
                e.data.rightClickDisabled = !val;
            }
        };

        this.client.clickEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.clickDisabled !== "undefined") {
                    return !e.cache.clickDisabled;
                }
                return e.calendar.eventClickHandling !== 'Disabled' && !e.data.clickDisabled;
            }
            else {
                e.data.clickDisabled = !val;
            }
        };

        this.client.deleteEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.deleteDisabled !== "undefined") {
                    return !e.cache.deleteDisabled;
                }
                return e.calendar.eventDeleteHandling !== 'Disabled' && !e.data.deleteDisabled;
            }
            else {
                e.data.deleteDisabled = !val;
            }
        };

        this.client.doubleClickEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.doubleClickDisabled !== "undefined") {
                    return !e.cache.doubleClickDisabled;
                }
                return e.calendar.eventDoubleClickHandling !== 'Disabled' && !e.data.doubleClickDisabled;
            }
            else {
                e.data.doubleClickDisabled = !val;
            }
        };

        this.client.deleteClickEnabled = function(val) {
            if (typeof val === 'undefined') {
                if (e.cache && typeof e.cache.deleteDisabled !== "undefined") {
                    return !e.cache.deleteDisabled;
                }
                return e.calendar.eventDeleteHandling !== 'Disabled' && !e.data.deleteDisabled;
            }
            else {
                e.data.deleteDisabled = !val;
            }
        };

        this.toJSON = function(key) {
            var json = {};
            json.value = this.id(); // still sending it with the old name
            json.id = this.id();
            json.text = this.text();
            json.start = this.start().toJSON();
            json.end = this.end().toJSON();
            json.resource = this.resource();
            json.isAllDay = false;
            json.recurrentMasterId = this.recurrentMasterId();
            json.join = this.data.join;
            json.tag = {};

            if (e.data.tags) {
                for (var name in e.data.tags) {
                    if (e.data.tags.hasOwnProperty(name)) {
                        json.tag[name] = "" + e.data.tags[name];
                    }
                }
            }
            else {
                if (e.calendar && e.calendar.tagFields) {
                    var fields = e.calendar.tagFields;
                    for (var i = 0; i < fields.length; i++) {
                        json.tag[fields[i]] = this.tag(fields[i]);
                    }
                }
            }

            return json;
        };
    };

    /**
     * A simple wrapper around task data.
     * @param data
     * @constructor
     */
    DayPilot.Task = function(data, calendar) {
        if (!data) {
            throw "Trying to initialize DayPilot.Task with null data parameter";
        }

        var e = this;

        var event = null; // reference to DayPilot.Event received from the Scheduler

        if (data instanceof DayPilot.Event) {
            event = data;
            this.data = data.data.task;
        }
        else if (data instanceof DayPilot.Task) {
            return data; // don't create a new object
        }
        else if (data.isTaskWrapper) {
            this.data = data.data;
        }
        else {
            this.data = data;
        }

        var copy = {};
        var synced = ["id", "text", "start", "end", "complete", "type"];

        this.isTask = true;
        this.calendar = calendar;

        // internal
        this.temp = function() {
            if (copy.dirty) {
                return copy;
            }
            for (var i = 0; i < synced.length; i++) {
                copy[synced[i]] = e.data[synced[i]];
            }
            copy.dirty = true;
            return copy;

        };

        // internal
        // copies data object
        // used when the original state of the data is needed (notified EventMove etc.)
        this.copy = function() {
            var result = {};
            DayPilot.Util.copyProps(e.data, result);
            return result;
        };

        this.commit = function() {
            if (!copy.dirty) {
                return;
            }

            for (var i = 0; i < synced.length; i++) {
                e.data[synced[i]] = copy[synced[i]];
            }

            copy.dirty = false;
        };

        this.dirty = function() {
            return copy.dirty;
        };

        this.id = function(val) {
            if (typeof val === 'undefined') {
                return e.data.id;
            }
            else {
                this.temp().id = val;
            }
        };
        this.text = function(val) {
            if (typeof val === 'undefined') {
                return e.data.text;
            }
            else {
                this.temp().text = val;

                // update the HTML automatically
                var escapedHtml = DayPilot.Util.escapeHtml(val);
                this.client.innerHTML(escapedHtml);
            }
        };
        this.start = function(val) {
            if (typeof val === 'undefined') {
                return new DayPilot.Date(e.data.start);
            }
            else {
                this.temp().start = new DayPilot.Date(val);
            }
        };
        this.duration = function() {
            return new DayPilot.Duration(this.start(), this.end());
        };
        this.end = function(val) {
            if (typeof val === 'undefined') {
                if (calendar && calendar.eventEndSpec === "Date") {
                    return new DayPilot.Date(e.data.end).getDatePart().addDays(1);
                }
                return new DayPilot.Date(e.data.end);
            }
            else {
                this.temp().end = new DayPilot.Date(val);
            }
        };
        this.type = function(val) {
            if (typeof val === 'undefined') {
                if (event) {
                    return event.data.type || "Task";
                }
                return e.data.type;
            }
            else {
                this.temp().type = val;
            }
        };
        this.complete = function(val) {
            if (typeof val === 'undefined') {
                if (!e.data.complete) {
                    return 0;
                }
                return e.data.complete;
            }
            else {
                this.temp().complete = val;
            }
        };
        this.children = function() {
            var list = [];
            list.add = function(data) {
                var task = new DayPilot.Task(data);
                if (!this.data.children) {
                    this.data.children = [];
                }
                this.children.push(task.data);
            };
            for(var i = 0; this.data.children && i < this.data.children.length; i++) {
                list.push(new DayPilot.Task(this.data.children[i], calendar));
            }

            return list;
        };

        this.toJSON = function(key) {
            var json = {};
            json.id = this.id();
            json.text = this.text();
            json.start = this.start().toJSON();
            json.end = this.end().toJSON();
            json.type = this.type();
            json.tags = {};

            DayPilot.Util.copyProps(this.data.tags, json.tags);

            return json;
        };

        this.row = {};
        var row = this.row;

        row.expanded = function(val) {
            if (typeof val === 'undefined') {
                if (!e.data.row) {
                    return true;
                }
                return !e.data.row.collapsed;
            }
            else {
                if (!e.data.row) {
                    e.data.row = {};
                }
                if (!!e.data.row.collapsed  !== !val) {
                    calendar.internal.rowObjectForTaskData(e.data).toggle();
                }
                e.data.row.collapsed = !val;

                /*
                if (calendar) {
                    calendar.update();
                }
                */
            }
        };

        row.expand = function() {
            row.expanded(true);
        };

        row.collapse = function() {
            row.expanded(false);
        };

        row.toggle = function() {
            row.expanded(!row.expanded());
        };

    };

    /* XMLHttpRequest */

    DayPilot.request = function(url, callback, postData, errorCallback) {
        var req = DayPilot.createXmlHttp();
        if (!req) {
            return;
        }

        req.open("POST", url, true);
        req.setRequestHeader('Content-type', 'text/plain');
        req.onreadystatechange = function() {
            if (req.readyState !== 4)
                return;
            if (req.status !== 200 && req.status !== 304) {
                if (errorCallback) {
                    errorCallback(req);
                }
                else {
                    if (window.console) { console.log('HTTP error ' + req.status); }
                }
                return;
            }
            callback(req);
        };
        if (req.readyState === 4) {
            return;
        }
        if (typeof postData === 'object') {
            postData = JSON.stringify(postData);
        }
        req.send(postData);
    };

    DayPilot.ajax = function(params) {
        if (!params) {
            throw new DayPilot.Exception("Parameter object required.");
        }

        if (typeof params.url !== "string") {
            throw new DayPilot.Exception("The parameter object must have 'url' property.")
        }

        var req = DayPilot.createXmlHttp();
        if (!req) {
            throw new DayPilot.Exception("Unable to create XMLHttpRequest object");
        }

        var dataIsObject = typeof params.data === "object";

        var data = params.data;
        var method = params.method || (params.data ? "POST" : "GET");
        var success = params.success || function() {};
        var error = params.error || function() {};
        var url = params.url;
        var contentType = params.contentType || (dataIsObject ? "application/json" : "text/plain");
        var headers = params.headers || {};

        req.open(method, url, true);
        req.setRequestHeader('Content-type', contentType);

        // overriding the content-type is allowed
        DayPilot.Util.ownPropsAsArray(headers).forEach(function(item) {
            req.setRequestHeader(item.key, item.val);
        });

        req.onreadystatechange = function() {
            if (req.readyState !== 4) {
                return;
            }
            if (req.status !== 200 && req.status !== 201 && req.status !== 204 && req.status !== 304) {
                if (error) {
                    var args = {};
                    args.request = req;
                    error(args);
                }
                else {
                    if (window.console) { console.log('HTTP error ' + req.status); }
                }
                return;
            }
            var args = {};
            args.request = req;
            if (req.responseText) {
                args.data = JSON.parse(req.responseText);
            }
            success(args);
        };
        if (req.readyState === 4) {
            return;
        }
        if (dataIsObject) {
            data = JSON.stringify(data);
        }
        req.send(data);
    };

    DayPilot.createXmlHttp = function() {
        return new XMLHttpRequest();
    };

    DayPilot.Http = {};

    DayPilot.Http.ajax = function(params) {
        DayPilot.ajax(params);
    };


    /*
    allowed params:
    - headers
    - contentType
     */
    DayPilot.Http.get = function(url, params) {
        params = params || {};
        return new Promise(function(resolve, reject) {
            var aparams = {};
            aparams.url = url;
            aparams.method = "GET";
            aparams.success = function(args) {
                resolve(args);
            };
            aparams.error = function(args) {
                reject(args);
            };
            aparams.contentType = params.contentType;
            aparams.headers = params.headers;

            DayPilot.ajax(aparams);
        });
    };

    DayPilot.Http.post = function(url, data, params) {
        params = params || {};
        return new Promise(function(resolve, reject) {
            var aparams = {};
            aparams.url = url;
            aparams.method = "POST";
            aparams.data = data;
            aparams.success = function(args) {
                resolve(args);
            };
            aparams.error = function(args) {
                reject(args);
            };
            aparams.contentType = params.contentType;
            aparams.headers = params.headers;

            DayPilot.ajax(aparams);
        });
    };

    DayPilot.Http.put = function(url, data, params) {
        params = params || {};
        return new Promise(function(resolve, reject) {
            var aparams = {};
            aparams.url = url;
            aparams.method = "PUT";
            aparams.data = data;
            aparams.success = function(args) {
                resolve(args);
            };
            aparams.error = function(args) {
                reject(args);
            };
            aparams.contentType = params.contentType;
            aparams.headers = params.headers;

            DayPilot.ajax(aparams);
        });
    };

    DayPilot.Http.delete = function(url, params) {
        params = params || {};
        return new Promise(function(resolve, reject) {
            var aparams = {};
            aparams.url = url;
            aparams.method = "DELETE";
            aparams.success = function(args) {
                resolve(args);
            };
            aparams.error = function(args) {
                reject(args);
            };
            aparams.contentType = params.contentType;
            aparams.headers = params.headers;

            DayPilot.ajax(aparams);
        });
    };

    DayPilot.Http.patch = function(url, data, params) {
        params = params || {};
        return new Promise(function(resolve, reject) {
            var aparams = {};
            aparams.url = url;
            aparams.method = "PATCH";
            aparams.data = data;
            aparams.success = function(args) {
                resolve(args);
            };
            aparams.error = function(args) {
                reject(args);
            };
            aparams.contentType = params.contentType;
            aparams.headers = params.headers;

            DayPilot.ajax(aparams);
        });
    };



    DayPilot.Duration = function(ticks) {
        var d = this;

        var day = 1000*60*60*24.0;
        var hour = 1000*60*60.0;
        var minute = 1000*60.0;
        var second = 1000.0;

        if (arguments.length === 2) {
            var start = arguments[0];
            var end = arguments[1];

            if (!(start instanceof DayPilot.Date) && (typeof start !== "string")) {
                throw "DayPilot.Duration(): Invalid start argument, DayPilot.Date expected";
            }
            if (!(end instanceof DayPilot.Date) && (typeof end !== "string")) {
                throw "DayPilot.Duration(): Invalid end argument, DayPilot.Date expected";
            }
            if (typeof start === "string") {
                start = new DayPilot.Date(start);
            }
            if (typeof end === "string") {
                end = new DayPilot.Date(end);
            }
            ticks = end.getTime() - start.getTime();
        }

        this.ticks = ticks || 0;

        // caching, allows direct comparison
        if (DayPilot.Date.Cache.DurationCtor["" + ticks]) {
            return DayPilot.Date.Cache.DurationCtor["" + ticks];
        }
        DayPilot.Date.Cache.DurationCtor["" + ticks] = this;

        this.toString = function(pattern) {
            if (!pattern) {
                return d.days() + "." + d.hours() + ":" + d.minutes() + ":" + d.seconds() + "." + d.milliseconds();
            }

            var minutes = d.minutes();
            minutes = (minutes < 10 ? "0" : "") + minutes;

            // dumb replacement
            var result = pattern;
            result = result.replace("mm", minutes);
            result = result.replace("m", d.minutes());
            result = result.replace("H", d.hours());
            result = result.replace("h", d.hours());
            result = result.replace("d", d.days());
            result = result.replace("s", d.seconds());
            return result;
        };

        this.totalHours = function() {
            return d.ticks / hour;
        };

        this.totalDays = function() {
            return d.ticks / day;
        };

        this.totalMinutes = function() {
            return d.ticks / minute;
        };

        this.totalSeconds = function() {
            return d.ticks / second;
        };

        this.totalMilliseconds = function() {
            return d.ticks;
        };

        this.days = function() {
            return Math.floor(d.totalDays());
        };

        this.hours = function() {
            var hourPartTicks = d.ticks - d.days()*day;
            return Math.floor(hourPartTicks/hour);
        };

        this.minutes = function() {
            var minutePartTicks = d.ticks - Math.floor(d.totalHours()) * hour;
            return Math.floor(minutePartTicks/minute);
        };

        this.seconds = function() {
            var secondPartTicks = d.ticks - Math.floor(d.totalMinutes()) * minute;
            return Math.floor(secondPartTicks/second);
        };

        this.milliseconds = function() {
            return d.ticks % second;
        };

        this.add = function(duration) {
            return new DayPilot.Duration(d.ticks + duration.ticks);
        }

    };

    DayPilot.Duration.ofWeeks = function(i) {
        return new DayPilot.Duration(i * 1000*60*60*24*7);
    };

    DayPilot.Duration.ofDays = function(i) {
        return new DayPilot.Duration(i * 1000*60*60*24);
    };

    DayPilot.Duration.ofHours = function(i) {
        return new DayPilot.Duration(i * 1000*60*60);
    };

    DayPilot.Duration.ofMinutes = function(i) {
        return new DayPilot.Duration(i * 1000*60);
    };

    DayPilot.Duration.ofSeconds = function(i) {
        return new DayPilot.Duration(i * 1000);
    };

    // legacy, to be removed
    DayPilot.Duration.weeks = function(i) {
        return DayPilot.Duration.ofWeeks(i);
    };

    DayPilot.Duration.days = function(i) {
        return DayPilot.Duration.ofDays(i);
    };

    DayPilot.Duration.hours = function(i) {
        return DayPilot.Duration.ofHours(i);
    };

    DayPilot.Duration.minutes = function(i) {
        return DayPilot.Duration.ofMinutes(i);
    };

    DayPilot.Duration.seconds = function(i) {
        return DayPilot.Duration.ofSeconds(i);
    };


    // alias to DayPilot.Duration
    // disabled, doesn't work with caching
    DayPilot.TimeSpan = function() {

        throw "Please use DayPilot.Duration class instead of DayPilot.TimeSpan.";
        // DayPilot.Duration.apply(this, arguments);
    };
    try {
        DayPilot.TimeSpan.prototype = Object.create(DayPilot.Duration.prototype);  // make instanceof work
    }
    catch (e) {}  // doesn't work in IE8

    // DayPilot.TimeSpan.prototype.constructor = DayPilot.TimeSpan;  // not necessary, it's an alias, not an inherited class

    /* Date utils */

    // DayPilot.Date class
    /* Constructor signatures:

     -- new DayPilot.Date(date, isLocal)
     date - JavaScript Date object
     isLocal - true if the local time should be taken from date, otherwise GMT base is used

     -- new DayPilot.Date() - returns now, using local date

     -- new DayPilot.Date(string)
     string - date in ISO 8601 format, e.g. 2009-01-01T00:00:00

     */
    DayPilot.Date = function(date, readLocal) {

        if (date instanceof DayPilot.Date) { // it's already a DayPilot.Date object, return it (no copy)
            return date;
        }

        var ticks;

        if (DayPilot.Util.isNullOrUndefined(date)) {  // date not set, use NOW
            ticks = DayPilot.DateUtil.fromLocal().getTime();
            date = ticks;
        }

        var cache = DayPilot.Date.Cache.Ctor;
        if (cache[date]) {
            DayPilot.Stats.cacheHitsCtor += 1;
            return cache[date];
        }

        var isString = false;

        if (typeof date === "string") {
            try {
                ticks = DayPilot.DateUtil.fromStringSortable(date, readLocal).getTime();
            }
            catch (e) {
                throw new DayPilot.Exception("DayPilot.Date - Unable to parse ISO8601 date/time string: " + date);
            }

            isString = true;
        }
        else if (typeof date === "number") {
            if (isNaN(date)) {
                throw "Cannot create DayPilot.Date from NaN";
            }
            ticks = date;
        }
        else if (date instanceof Date) {
            if (readLocal) {
                ticks = DayPilot.DateUtil.fromLocal(date).getTime();
            }
            else {
                ticks = date.getTime();
            }
        }
        else {
            throw "Unrecognized parameter: use Date, number or string in ISO 8601 format";
        }

        var value = ticksToSortable(ticks); // normalized value

        if (cache[value]) {
            return cache[value];
        }

        cache[value] = this;
        cache[ticks] = this;
        if (isString && value !== date  && DayPilot.DateUtil.hasTzSpec(date)) {  // don't cache strings with TZ spec
            cache[date] = this;
        }

        if (Object.defineProperty/* && !DayPilot.browser.ielt9*/) {
            Object.defineProperty(this, "ticks", {
                get: function() { return ticks; }
            });
            Object.defineProperty(this, "value", {
                "value": value,
                "writable": false,
                "enumerable": true
            });
        }
        else {
            this.ticks = ticks;
            this.value = value;
        }

        if (DayPilot.Date.Config.legacyShowD) {
            this.d = new Date(ticks);
        }

        DayPilot.Stats.dateObjects += 1;
    };

    DayPilot.Date.Config = {};
    DayPilot.Date.Config.legacyShowD = false;

    DayPilot.Date.Cache = {};
    DayPilot.Date.Cache.Parsing = {};
    DayPilot.Date.Cache.Ctor = {};
    DayPilot.Date.Cache.Ticks = {};
    DayPilot.Date.Cache.DurationCtor = {};

    DayPilot.Date.Cache.clear = function() {
        DayPilot.Date.Cache.Parsing = {};
        DayPilot.Date.Cache.Ctor = {};
        DayPilot.Date.Cache.Ticks = {};
        DayPilot.Date.Cache.DurationCtor = {};
    };


    DayPilot.Date.prototype.addDays = function(days) {
        if (!days) {
            return this;
        }
        return new DayPilot.Date(this.ticks + days * 24 * 60 * 60 * 1000);
    };

    DayPilot.Date.prototype.addHours = function(hours) {
        if (!hours) {
            return this;
        }
        return this.addTime(hours * 60 * 60 * 1000);
    };

    DayPilot.Date.prototype.addMilliseconds = function(millis) {
        if (!millis) {
            return this;
        }
        return this.addTime(millis);
    };

    DayPilot.Date.prototype.addMinutes = function(minutes) {
        if (!minutes) {
            return this;
        }
        return this.addTime(minutes * 60 * 1000);
    };

    DayPilot.Date.prototype.addMonths = function(months) {
        if (!months) {
            return this;
        }

        var date = new Date(this.ticks);

        var y = date.getUTCFullYear();
        var m = date.getUTCMonth() + 1;

        if (months > 0) {
            while (months >= 12) {
                months -= 12;
                y++;
            }
            if (months > 12 - m) {
                y++;
                m = months - (12 - m);
            }
            else {
                m += months;
            }
        }
        else {
            while (months <= -12) {
                months += 12;
                y--;
            }
            if (m + months <= 0) {  //
                y--;
                m = 12 + m + months;
            }
            else {
                m = m + months;
            }
        }

        var d = new Date(date.getTime());
        d.setUTCDate(1);
        d.setUTCFullYear(y);
        d.setUTCMonth(m - 1);

        //var max = DayPilot.Date.daysInMonth(y, m);
        var max = new DayPilot.Date(d).daysInMonth();
        d.setUTCDate(Math.min(max, date.getUTCDate()));

        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.addSeconds = function(seconds) {
        if (!seconds) {
            return this;
        }
        return this.addTime(seconds * 1000);
    };

    DayPilot.Date.prototype.addTime = function(ticks) {
        if (!ticks) {
            return this;
        }
        if (ticks instanceof DayPilot.Duration) {
            ticks = ticks.ticks;
        }
        return new DayPilot.Date(this.ticks + ticks);
    };

    DayPilot.Date.prototype.addYears = function(years) {
        var original = new Date(this.ticks);
        var d = new Date(this.ticks);
        var y = this.getYear() + years;
        var m = this.getMonth();

        d.setUTCDate(1);
        d.setUTCFullYear(y);
        d.setUTCMonth(m);

        //var max = DayPilot.Date.daysInMonth(y, m + 1);
        var max = new DayPilot.Date(d).daysInMonth();
        d.setUTCDate(Math.min(max, original.getUTCDate()));

        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.dayOfWeek = function() {
        return new Date(this.ticks).getUTCDay();
    };

    DayPilot.Date.prototype.dayOfWeekISO = function() {
        return new Date(this.ticks).getUTCDay() || 7;
    };

    DayPilot.Date.prototype.getDayOfWeek = function() {
        return new Date(this.ticks).getUTCDay();
    };

    DayPilot.Date.prototype.getDayOfYear = function() {
        var first = this.firstDayOfYear();
        return DayPilot.DateUtil.daysDiff(first, this) + 1;
    };

    DayPilot.Date.prototype.daysInMonth = function() {
        var date = new Date(this.ticks);
        var month = date.getUTCMonth() + 1;
        var year = date.getUTCFullYear();


        var m = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        if (month !== 2)
            return m[month - 1];
        if (year % 4 !== 0)
            return m[1];
        if (year % 100 === 0 && year % 400 !== 0)
            return m[1];
        return m[1] + 1;

    };

    DayPilot.Date.prototype.daysInYear = function() {
        var year = this.getYear();
        if (year % 4 !== 0) {
            return 365;
        }
        if (year % 100 === 0 && year % 400 !== 0) {
            return 365;
        }
        return 366;
    };

    DayPilot.Date.prototype.dayOfYear = function() {
        return Math.ceil((this.getDatePart().getTime() - this.firstDayOfYear().getTime()) / 86400000) + 1;
    };

    // not required, direct comparison can be used
    DayPilot.Date.prototype.equals = function(another) {
        if (another === null) {
            return false;
        }
        if (another instanceof DayPilot.Date) {
            return this === another;
        }
        else {
            throw "The parameter must be a DayPilot.Date object (DayPilot.Date.equals())";
        }
    };

    DayPilot.Date.prototype.firstDayOfMonth = function() {
        //var utc = DayPilot.Date.firstDayOfMonth(this.getYear(), this.getMonth() + 1);
        //return new DayPilot.Date(utc);

        var d = new Date();
        d.setUTCFullYear(this.getYear(), this.getMonth(), 1);
        d.setUTCHours(0);
        d.setUTCMinutes(0);
        d.setUTCSeconds(0);
        d.setUTCMilliseconds(0);
        return new DayPilot.Date(d);

    };

    DayPilot.Date.prototype.firstDayOfYear = function() {
        var year = this.getYear();
        var d = new Date();
        d.setUTCFullYear(year, 0, 1);
        d.setUTCHours(0);
        d.setUTCMinutes(0);
        d.setUTCSeconds(0);
        d.setUTCMilliseconds(0);
        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.firstDayOfWeek = function(weekStarts) {
        var d = this;
        if (weekStarts instanceof DayPilot.Locale) {
            weekStarts = weekStarts.weekStarts;
        }
        else if (typeof weekStarts === "string" && DayPilot.Locale.find(weekStarts)) {
            var locale = DayPilot.Locale.find(weekStarts);
            weekStarts = locale.weekStarts;
        }
        else {
            weekStarts = weekStarts || 0;
        }

        var day = d.dayOfWeek();
        while (day !== weekStarts) {
            d = d.addDays(-1);
            day = d.dayOfWeek();
        }
        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.getDay = function() {
        return new Date(this.ticks).getUTCDate();
    };

    DayPilot.Date.prototype.getDatePart = function() {
        var d = new Date(this.ticks);
        d.setUTCHours(0);
        d.setUTCMinutes(0);
        d.setUTCSeconds(0);
        d.setUTCMilliseconds(0);
        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.getYear = function() {
        return new Date(this.ticks).getUTCFullYear();
    };

    DayPilot.Date.prototype.getHours = function() {
        return new Date(this.ticks).getUTCHours();
    };

    DayPilot.Date.prototype.getMilliseconds = function() {
        return new Date(this.ticks).getUTCMilliseconds();
    };

    DayPilot.Date.prototype.getMinutes = function() {
        return new Date(this.ticks).getUTCMinutes();
    };

    DayPilot.Date.prototype.getMonth = function() {
        return new Date(this.ticks).getUTCMonth();
    };

    DayPilot.Date.prototype.getSeconds = function() {
        return new Date(this.ticks).getUTCSeconds();
    };

    DayPilot.Date.prototype.getTotalTicks = function() {
        return this.getTime();
    };

    // undocumented
    DayPilot.Date.prototype.getTime = function() {
        return this.ticks;
    };

    DayPilot.Date.prototype.getTimePart = function() {
        var datePart = this.getDatePart();
        return DayPilot.DateUtil.diff(this, datePart);
    };

    DayPilot.Date.prototype.lastDayOfMonth = function() {
        //var utc = DayPilot.Date.lastDayOfMonth(this.getYear(), this.getMonth() + 1);
        //return new DayPilot.Date(utc);
        var d = new Date(this.firstDayOfMonth().getTime());
        var length = this.daysInMonth();
        d.setUTCDate(length);
        return new DayPilot.Date(d);
    };

    DayPilot.Date.prototype.weekNumber = function() {
        var first = this.firstDayOfYear();
        var days = (this.getTime() - first.getTime()) / 86400000;
        return Math.ceil((days + first.dayOfWeek() + 1) / 7);
    };

    // ISO 8601
    DayPilot.Date.prototype.weekNumberISO = function() {
        var thursdayFlag = false;
        var dayOfYear = this.dayOfYear();

        var startWeekDayOfYear = this.firstDayOfYear().dayOfWeek();
        var endWeekDayOfYear = this.firstDayOfYear().addYears(1).addDays(-1).dayOfWeek();
        //int startWeekDayOfYear = new DateTime(date.getYear(), 1, 1).getDayOfWeekOrdinal();
        //int endWeekDayOfYear = new DateTime(date.getYear(), 12, 31).getDayOfWeekOrdinal();

        if (startWeekDayOfYear === 0) {
            startWeekDayOfYear = 7;
        }
        if (endWeekDayOfYear === 0) {
            endWeekDayOfYear = 7;
        }

        var daysInFirstWeek = 8 - (startWeekDayOfYear);

        if (startWeekDayOfYear === 4 || endWeekDayOfYear === 4) {
            thursdayFlag = true;
        }

        var fullWeeks = Math.ceil((dayOfYear - (daysInFirstWeek)) / 7.0);

        var weekNumber = fullWeeks;

        if (daysInFirstWeek >= 4) {
            weekNumber = weekNumber + 1;
        }

        if (weekNumber > 52 && !thursdayFlag) {
            weekNumber = 1;
        }

        if (weekNumber === 0) {
            weekNumber = this.firstDayOfYear().addDays(-1).weekNumberISO(); //weekNrISO8601(new DateTime(date.getYear() - 1, 12, 31));
        }

        return weekNumber;

    };

    DayPilot.Date.prototype.toDateLocal = function() {
        var date = new Date(this.ticks);

        var d = new Date();
        d.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        d.setHours(date.getUTCHours());
        d.setMinutes(date.getUTCMinutes());
        d.setSeconds(date.getUTCSeconds());
        d.setMilliseconds(date.getUTCMilliseconds());
        return d;

    };

    DayPilot.Date.prototype.toDate = function() {
        return new Date(this.ticks);
    };

    DayPilot.Date.prototype.toJSON = function() {
        return this.value;
    };

    // formatting and languages needed here
    DayPilot.Date.prototype.toString = function(pattern, locale) {
        if (!pattern) {
            return this.toStringSortable();
        }
        return new Pattern(pattern, locale).print(this);
    };

    DayPilot.Date.prototype.toStringSortable = function() {
        return ticksToSortable(this.ticks);
    };

    function ticksToSortable(ticks) {

        var cache = DayPilot.Date.Cache.Ticks;
        if (cache[ticks]) {
            DayPilot.Stats.cacheHitsTicks += 1;
            return cache[ticks];
        }

        var d = new Date(ticks);

        var millisecond;
        var ms = d.getUTCMilliseconds();

        if (ms === 0) {
            millisecond = "";
        }
        else if (ms < 10) {
            millisecond = ".00" + ms;
        }
        else if (ms < 100) {
            millisecond = ".0" + ms;
        }
        else {
            millisecond = "." + ms
        }

        var second = d.getUTCSeconds();
        if (second < 10)
            second = "0" + second;
        var minute = d.getUTCMinutes();
        if (minute < 10)
            minute = "0" + minute;
        var hour = d.getUTCHours();
        if (hour < 10)
            hour = "0" + hour;
        var day = d.getUTCDate();
        if (day < 10)
            day = "0" + day;
        var month = d.getUTCMonth() + 1;
        if (month < 10)
            month = "0" + month;
        var year = d.getUTCFullYear();

        if (year <= 0) {
            throw "The minimum year supported is 1.";
        }
        if (year < 10) {
            year = "000" + year;
        }
        else if (year < 100) {
            year = "00" + year;
        }
        else if (year < 1000) {
            year = "0" + year;
        }

        var result = year + "-" + month + "-" + day + 'T' + hour + ":" + minute + ":" + second + millisecond;
        cache[ticks] = result;
        return result;
    }

    /* static functions, return DayPilot.Date object */

    // returns null if parsing was not successful
    DayPilot.Date.parse = function(str, pattern, locale) {
        var p = new Pattern(pattern, locale);
        return p.parse(str);
    };

    var todayCount = 0;

    DayPilot.Date.today = function() {
        //return new DayPilot.Date().getDatePart();
        return new DayPilot.Date(DayPilot.DateUtil.localToday(), true);
    };

    DayPilot.Date.now = function() {
        return new DayPilot.Date();
    };

    DayPilot.Date.fromYearMonthDay = function(year, month, day) {
        month = month || 1;
        day = day || 1;

        var d = new Date(0);
        d.setUTCFullYear(year);
        d.setUTCMonth(month - 1);
        d.setUTCDate(day);
        return new DayPilot.Date(d);
    };

    DayPilot.DateUtil = {};

    /* internal functions, all operate with GMT base of the date object
     (except of DayPilot.DateUtil.fromLocal()) */

    DayPilot.DateUtil.fromStringSortable = function(string, readLocal) {
        /*
        Supported formats:
        2015-01-01
        2015-01-01T00:00:00
        2015-01-01T00:00:00.000
        2015-01-01T00:00:00Z
        2015-01-01T00:00:00.000Z
        2015-01-01T00:00:00+01:00
        2015-01-01T00:00:00.000+01:00

         */

        var err = function() {
            return new DayPilot.Exception("Invalid string format (use '2010-12-31' or '2010-12-31T23:50:00'): '" + string + "'");
        };

        if (!string) {
            throw new DayPilot.Exception("Can't create DayPilot.Date from an empty string");
        }

        var len = string.length;
        var date = len === 10;
        var datetime = len === 19;
        var long = len > 19;

        if (!date && !datetime && !long) {
            throw err();
        }

        if (DayPilot.Date.Cache.Parsing[string] && !readLocal) {
            DayPilot.Stats.cacheHitsParsing += 1;
            return DayPilot.Date.Cache.Parsing[string];
        }

        var year = string.substring(0, 4);
        if (isNaN(year)) {
            throw err();
        }
        var month = string.substring(5, 7);
        if (isNaN(month)) {
            throw err();
        }
        var day = string.substring(8, 10);
        if (isNaN(day)) {
            throw err();
        }

        var d = new Date(0);
        d.setUTCFullYear(year, month - 1, day);

        if (date) {
            /*
            d.setUTCHours(0);
            d.setUTCMinutes(0);
            d.setUTCSeconds(0);
            d.setUTCMilliseconds(0);
            */
            //result = d;
            DayPilot.Date.Cache.Parsing[string] = d;
            return d;
        }

        var hours = string.substring(11, 13);
        if (isNaN(hours)) {
            throw err();
        }

        var minutes = string.substring(14, 16);
        if (isNaN(minutes)) {
            throw err();
        }

        var seconds = string.substring(17, 19);
        if (isNaN(seconds)) {
            throw err();
        }


        d.setUTCHours(hours);
        d.setUTCMinutes(minutes);
        d.setUTCSeconds(seconds);
        //d.setUTCMilliseconds(0);
        //result = d;

        if (datetime) {
            DayPilot.Date.Cache.Parsing[string] = d;
            return d;
        }

        var tzdir = string[19];

        var tzoffset = 0;

        if (tzdir === ".") {
            var ms = parseInt(string.substring(20, 23)); /// .000
            if (isNaN(ms)) {
                throw err();
            }

            d.setUTCMilliseconds(ms);
            tzoffset = DayPilot.DateUtil.getTzOffsetMinutes(string.substring(23));
        }
        else {
            tzoffset = DayPilot.DateUtil.getTzOffsetMinutes(string.substring(19));
        }

        var dd = new DayPilot.Date(d);
        if (!readLocal) {
            dd = dd.addMinutes(-tzoffset);
        }

        d = dd.toDate(); // get UTC base

        DayPilot.Date.Cache.Parsing[string] = d;
        return d;
    };

    DayPilot.DateUtil.getTzOffsetMinutes = function(string) {
        if (DayPilot.Util.isNullOrUndefined(string) || string === "") {
            return 0;
        }
        if (string === "Z") {
            return 0;
        }

        var tzdir = string[0];

        var tzhours = parseInt(string.substring(1, 3));
        var tzminutes = parseInt(string.substring(4));
        var tzoffset = tzhours * 60 + tzminutes;

        if (tzdir === "-") {
            return -tzoffset;
        }
        else if (tzdir === "+") {
            return tzoffset;
        }
        else {
            throw "Invalid timezone spec: " + string;
        }
    };

    DayPilot.DateUtil.hasTzSpec = function(string) {
        if (string.indexOf("+")) {
            return true;
        }
        if (string.indexOf("-")) {
            return true;
        }
        return false;
    };


    // rename candidate: diffDays
    DayPilot.DateUtil.daysDiff = function(first, second) {
        (first && second) || (function() { throw "two parameters required"; })();

        first = new DayPilot.Date(first);
        second = new DayPilot.Date(second);

        if (first.getTime() > second.getTime()) {
            return null;
        }

        var i = 0;
        var fDay = first.getDatePart();
        var sDay = second.getDatePart();

        while (fDay < sDay) {
            fDay = fDay.addDays(1);
            i++;
        }

        return i;
    };

    DayPilot.DateUtil.daysSpan = function(first, second) {
        (first && second) || (function() { throw "two parameters required"; })();

        first = new DayPilot.Date(first);
        second = new DayPilot.Date(second);

        if (first === second) {
            return 0;
        }

        var diff = DayPilot.DateUtil.daysDiff(first, second);

        if (second == second.getDatePart()) {
            diff--;
        }

        return diff;
    };

    DayPilot.DateUtil.diff = function(first, second) { // = first - second
        if (!(first && second && first.getTime && second.getTime)) {
            throw "Both compared objects must be Date objects (DayPilot.Date.diff).";
        }

        return first.getTime() - second.getTime();
    };

    // returns Date object
    DayPilot.DateUtil.fromLocal = function(localDate) {
        if (!localDate) {
            localDate = new Date();
        }

        var d = new Date();
        d.setUTCFullYear(localDate.getFullYear(), localDate.getMonth(), localDate.getDate());
        d.setUTCHours(localDate.getHours());
        d.setUTCMinutes(localDate.getMinutes());
        d.setUTCSeconds(localDate.getSeconds());
        d.setUTCMilliseconds(localDate.getMilliseconds());
        return d;
    };

    DayPilot.DateUtil.localToday = function() {
        var d = new Date();
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        return d;
    };

    // rename candidate: toHourString
    DayPilot.DateUtil.hours = function(date, use12) {

        var minute = date.getUTCMinutes();
        if (minute < 10)
            minute = "0" + minute;


        var hour = date.getUTCHours();
        //if (hour < 10) hour = "0" + hour;

        if (use12) {
            var am = hour < 12;
            var hour = hour % 12;
            if (hour === 0) {
                hour = 12;
            }
            var suffix = am ? "AM" : "PM";
            return hour + ':' + minute + ' ' + suffix;
        }
        else {
            return hour + ':' + minute;
        }
    };

    DayPilot.DateUtil.max = function(first, second) {
        if (first.getTime() > second.getTime()) {
            return first;
        }
        else {
            return second;
        }
    };

    DayPilot.DateUtil.min = function(first, second) {
        if (first.getTime() < second.getTime()) {
            return first;
        }
        else {
            return second;
        }
    };

    var Pattern = function(pattern, locale) {
        if (typeof locale === "string") {
            locale = DayPilot.Locale.find(locale);
        }
        var locale = locale || DayPilot.Locale.US;
        var all = [
            {"seq": "yyyy", "expr": "[0-9]{4,4\u007d", "str": function(d) {
                    return d.getYear();
                }},
            {"seq": "yy", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                return d.getYear() % 100;
            }, "transform" : function(input) {
                    return parseInt(input) + 2000;
                }},
            {"seq": "mm", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var r = d.getMinutes();
                return r < 10 ? "0" + r : r;
            }},
            {"seq": "m", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                    var r = d.getMinutes();
                    return r;
                }},
            {"seq": "HH", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var r = d.getHours();
                return r < 10 ? "0" + r : r;
            }},
            {"seq": "H", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                    var r = d.getHours();
                    return r;
                }},
            {"seq": "hh", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var hour = d.getHours();
                var hour = hour % 12;
                if (hour === 0) {
                    hour = 12;
                }
                var r = hour;
                return r < 10 ? "0" + r : r;
            }},
            {"seq": "h", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                    var hour = d.getHours();
                    var hour = hour % 12;
                    if (hour === 0) {
                        hour = 12;
                    }
                    return hour;
                }},
            {"seq": "ss", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var r = d.getSeconds();
                return r < 10 ? "0" + r : r;
                }},
            {"seq": "s", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                    var r = d.getSeconds();
                    return r;
                }},
            {"seq": "MMMM", "expr": "[^\\s0-9]*", "str": function(d) {
                var r = locale.monthNames[d.getMonth()];
                return r;
            }, "transform" : function(input) {
                var index = DayPilot.indexOf(locale.monthNames, input, equalsIgnoreCase);
                if (index < 0) {
                    return null;
                }
                return index + 1;
            }},
            {"seq": "MMM", "expr": "[^\\s0-9]*", "str": function(d) {  // \u0073 = 's'
                var r = locale.monthNamesShort[d.getMonth()];
                return r;
            }, "transform" : function(input) {
                var index = DayPilot.indexOf(locale.monthNamesShort, input, equalsIgnoreCase);
                if (index < 0) {
                    return null;
                }
                return index + 1;
            }},
            {"seq": "MM", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var r = d.getMonth() + 1;
                return r < 10 ? "0" + r : r;
            }},
            {"seq": "M", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                var r = d.getMonth() + 1;
                return r;
            }},
            {"seq": "dddd", "expr": "[^\\s0-9]*", "str": function(d) {
                var r = locale.dayNames[d.getDayOfWeek()];
                return r;
            }},
            {"seq": "ddd", "expr": "[^\\s0-9]*", "str": function(d) {
                var r = locale.dayNamesShort[d.getDayOfWeek()];
                return r;
            }},
            {"seq": "dd", "expr": "[0-9]{2,2\u007d", "str": function(d) {
                var r = d.getDay();
                return r < 10 ? "0" + r : r;
            }},
            {"seq": "%d", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                var r = d.getDay();
                return r;
            }},
            {"seq": "d", "expr": "[0-9]{1,2\u007d", "str": function(d) {
                var r = d.getDay();
                return r;
            }},
            {"seq": "tt", "expr": "(AM|PM|am|pm)", "str": function(d) {
                var hour = d.getHours();
                var am = hour < 12;
                return am ? "AM" : "PM";
            }, "transform" : function(input) {
                return input.toUpperCase();
            }},
        ];

        var escapeRegex = function(text) {
            return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        };

        this.init = function() {
            this.year = this.findSequence("yyyy") || this.findSequence("yy");
            this.month = this.findSequence("MMMM") || this.findSequence("MMM") || this.findSequence("MM") || this.findSequence("M");
            this.day = this.findSequence("dd") || this.findSequence("d");

            this.hours = this.findSequence("HH") || this.findSequence("H");
            this.minutes = this.findSequence("mm") || this.findSequence("m");
            this.seconds = this.findSequence("ss") || this.findSequence("s");

            this.ampm = this.findSequence("tt");
            this.hours12 = this.findSequence("hh") || this.findSequence("h");

            /*if (this.hours && this.ampm) {
                throw new DayPilot.Exception("'HH' and 'H' specifiers cannot be used in combination with 'tt'. Use 12-hour clock specifiers: 'hh' or 'h'.");
            }*/
        };

        this.findSequence = function(seq) {

            function defaultTransform(value) {
                return parseInt(value);
            }

            var index = pattern.indexOf(seq);
            if (index === -1) {
                return null;
            }
            return {
                "findValue": function(input) {
                    var prepared = escapeRegex(pattern);
                    var transform = null;
                    for (var i = 0; i < all.length; i++) {
                        var len = all[i].length;
                        var pick = (seq === all[i].seq);
                        //var expr = "";
                        var expr = all[i].expr;
                        if (pick) {
                            expr = "(" + expr + ")";
                            transform = all[i].transform;
                        }
                        prepared = prepared.replace(all[i].seq, expr);
                    }

                    prepared = "^" + prepared + "$";

                    try {
                        var r = new RegExp(prepared);
                        var array = r.exec(input);
                        if (!array) {
                            return null;
                        }
                        transform = transform || defaultTransform;  // parseInt is the default transform/parse function
                        return transform(array[1]);
                    }
                    catch (e) {
                        throw "unable to create regex from: " + prepared;
                    }
                }
            };
        };

        this.print = function(date) {
            // always recompiles the pattern

            var find = function(t) {
                for (var i = 0; i < all.length; i++) {
                    if (all[i] && all[i].seq === t) {
                        return all[i];
                    }
                }
                return null;
            };

            var eos = pattern.length <= 0;
            var pos = 0;
            var components = [];

            while (!eos) {
                var rem = pattern.substring(pos);
                var matches = /%?(.)\1*/.exec(rem);  // matches a sequence of identical characters, with an optional '%' preceding char
                if (matches && matches.length > 0) {
                    var match = matches[0];
                    var q = find(match);
                    if (q) {
                        components.push(q);
                    }
                    else {
                        components.push(match);
                    }
                    pos += match.length;
                    eos = pattern.length <= pos;
                }
                else {
                    eos = true;
                }
            }

            // resolve placeholders
            for (var i = 0; i < components.length; i++) {
                var c = components[i];
                if (typeof c !== 'string') {
                    components[i] = c.str(date);
                }
            }

            return components.join("");
        };



        this.parse = function(input) {

            var year = this.year.findValue(input);
            if (!year) {
                return null; // unparseable
            }

            var month = this.month.findValue(input);
            if (DayPilot.Util.isNullOrUndefined(month)) {
                return null;
            }
            if (month > 12 || month < 1) {
                return null;
            }
            var day = this.day.findValue(input);

            var daysInMonth = DayPilot.Date.fromYearMonthDay(year, month).daysInMonth();
            if (day < 1 || day > daysInMonth) {
                return null;
            }

            var hours = this.hours ? this.hours.findValue(input) : 0;
            var minutes = this.minutes ? this.minutes.findValue(input) : 0;
            var seconds = this.seconds ? this.seconds.findValue(input) : 0;

            var ampm = this.ampm ? this.ampm.findValue(input): null;

            if (this.ampm && this.hours12) {

                var hours12 = this.hours12.findValue(input);

                if (hours12 < 1 || hours12 > 12) {
                    return null;
                }

                if (ampm === "PM") {
                    if (hours12 === 12) {
                        hours = 12;
                    }
                    else {
                        hours = hours12 + 12;
                    }
                }
                else {
                    if (hours12 === 12) {
                        hours = 0;
                    }
                    else {
                        hours = hours12;
                    }
                }

            }

            if (hours < 0 || hours > 23) {
                return null;
            }

            if (minutes < 0 || minutes > 59) {
                return null;
            }

            if (seconds < 0 || seconds > 59) {
                return null;
            }

            var d = new Date();
            d.setUTCFullYear(year, month - 1, day);
            d.setUTCHours(hours);
            d.setUTCMinutes(minutes);
            d.setUTCSeconds(seconds);
            d.setUTCMilliseconds(0);

            return new DayPilot.Date(d);
        };

        this.init();

    };

    function equalsIgnoreCase(str1, str2) {
        if (DayPilot.Util.isNullOrUndefined(str1)) {
            return false;
        }
        if (DayPilot.Util.isNullOrUndefined(str2)) {
            return false;
        }
        return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
    }


    DayPilot.ColorUtil = {};

    function toHex(dec) {
        dec = Math.min(dec, 255);
        dec = Math.max(dec, 0);
        var str = dec.toString(16);
        return (dec < 16) ? "0" + str : str;
    }

    DayPilot.ColorUtil.hexToRgb = function(hex) {
        if (!/^#[0-9a-f]{6}$/i.test(hex)) {
            throw new DayPilot.Exception("Invalid color, only full hex color string accepted, eg. '#ffaaff'.");
        }
        hex = hex.replace("#", "");
        return {
            r: parseInt(hex.substring(0, 2), 16),
            g: parseInt(hex.substring(2, 4), 16),
            b: parseInt(hex.substring(4, 6), 16),
        };
    };

    DayPilot.ColorUtil.rgbToHex = function(rgb) {
        return "#" + toHex(rgb.r) + toHex(rgb.g) + toHex(rgb.b);
    };

    // pt in 255 base
    DayPilot.ColorUtil.adjustLuminance = function(rgb, pt) {
        return {
            r: rgb.r + pt,
            g: rgb.g + pt,
            b: rgb.b + pt
        };
    };

    DayPilot.ColorUtil.darker = function(hexColor, steps) {
        var src = DayPilot.ColorUtil.hexToRgb(hexColor);
        if (typeof steps !== "number") {
            steps = 1;
        }
        var step = 17; // (0xbb - 0xaa = 17)
        var pt = Math.round(steps * step);
        var target = DayPilot.ColorUtil.adjustLuminance(src, -pt);
        return DayPilot.ColorUtil.rgbToHex(target);
    };


    DayPilot.ColorUtil.lighter = function(hexColor, steps) {
        if (typeof steps !== "number") {
            steps = 1;
        }
        return DayPilot.ColorUtil.darker(hexColor, -steps);
    };


    DayPilot.ColorUtil.pl = function(hexColor) {
        var rgb = DayPilot.ColorUtil.hexToRgb(hexColor);
        var r = rgb.r / 255;
        var g = rgb.g / 255;
        var b = rgb.b / 255;
        var pl = Math.sqrt(0.299*r*r + 0.587*g*g + 0.114*b*b);
        return pl;
    };

    DayPilot.ColorUtil.contrasting = function(hexColor, light, dark) {
        var pl = DayPilot.ColorUtil.pl(hexColor);
        light = light || "#ffffff";
        dark = dark || "#000000";
        return pl > 0.5 ? dark : light;
    };

    DayPilot.Canvas = function(width, height, format, scale, jpegQuality) {
        var scale = scale || 1;

        var canvas = document.createElement("canvas");
        canvas.width = width*scale;
        canvas.height = height*scale;

        var ctx = canvas.getContext("2d");
        ctx.scale(scale, scale);

        this.defaultFileName = "image.png";

        if (format === "image/jpeg") {
            this.defaultFileName = "image.jpg";
            jpegQuality = jpegQuality || 0.92;
        }

        this.groupStart = function(data) {};
        this.groupEnd = function() {};

        this.fillRect = function(rect, color) {
            ctx.save();

            ctx.strokeStyle = "rgb(0,0,0,0)";
            ctx.fillStyle = color;
            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
            //ctx.fill();

            ctx.restore();
        };

        this.rect = function(rect, color) {
            ctx.save();

            ctx.strokeStyle = color;
            ctx.beginPath();  // clear the previous path
            ctx.rect(rect.x +.5, rect.y +.5, rect.w - 1, rect.h - 1);
            ctx.stroke();

            ctx.restore();
        };

        this.diamond = function(rect, color) {
            ctx.save();

            ctx.strokeStyle = "rgb(0,0,0,0)";
            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(rect.x + rect.w/2, rect.y + 0.5);
            ctx.lineTo(rect.x + rect.w - 0.5, rect.y + rect.h/2);
            ctx.lineTo(rect.x + rect.w/2, rect.y + rect.h - 0.5);
            ctx.lineTo(rect.x + 0.5, rect.y + rect.h/2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        this.triangle = function(rect, color, rotate) {

            rotate = rotate || 0;

            // normalize
            while (rotate < 0) {
                rotate += 360;
            }

            while (rotate >= 360) {
                rotate -= 360;
            }

            ctx.save();

            ctx.strokeStyle = "rgb(0,0,0,0)";
            ctx.fillStyle = color;

            ctx.beginPath();

            switch (rotate) {

                case 0:  // right
                    ctx.moveTo(rect.x + rect.w/3, rect.y + 0.5);
                    ctx.lineTo(rect.x + rect.w + 0.5, rect.y + rect.h/2);
                    ctx.lineTo(rect.x + rect.w/3, rect.y + rect.h - 0.5);
                    break;
                case 90:  // down
                    ctx.moveTo(rect.x - 0.5, rect.y + rect.h/3);
                    ctx.lineTo(rect.x + rect.w + 0.5, rect.y + rect.h/3);
                    ctx.lineTo(rect.x + rect.w/2, rect.y + rect.h + 0.5);
                    break;
                case 180: // left
                    ctx.moveTo(rect.x + 2*rect.w/3, rect.y + 0.5);
                    ctx.lineTo(rect.x + 2*rect.w/3, rect.y + rect.h);
                    ctx.lineTo(rect.x, rect.y + rect.h/2);
                    break;
                case 270: // up
                    ctx.moveTo(rect.x + rect.w/2, rect.y + rect.w/2 + 0.5);
                    ctx.lineTo(rect.x + rect.w - 0.5, rect.y + 2*rect.h/3);
                    ctx.lineTo(rect.x, rect.y + 2*rect.h/3);
                    break;
                default:
                    throw new DayPilot.Exception("Unsupported rotation angle");
            }

            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        this.upperLeftCorner = function(rect, color) {
            ctx.save();

            ctx.strokeStyle = "rgb(0,0,0,0)";
            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(rect.x, rect.y);
            ctx.lineTo(rect.x + rect.w, rect.y);
            ctx.lineTo(rect.x, rect.y + rect.h);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        this.upperRightCorner = function(rect, color) {
            ctx.save();

            ctx.strokeStyle = "rgb(0,0,0,0)";
            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(rect.x, rect.y);
            ctx.lineTo(rect.x + rect.w, rect.y);
            ctx.lineTo(rect.x + rect.w, rect.y + rect.h);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        this.textWidth = function(text, font) {
            ctx.save();
            ctx.font = font.style + " " + font.size + " " + font.family;
            var w = ctx.measureText(text).width + 1;
            ctx.restore();

            return w;
        };

        this.text = function(rect, text, font, color, halign, padding, valign) {

            if (!text) {
                return;
            }
            if (typeof text === "number") {
                text = "" + text;
            }
            if (typeof text !== "string") {
                throw "String expected, supplied: " + typeof text;
            }

            halign = halign || "left";
            padding = padding || 0;
            color = color || "#000";
            valign = valign || "top";

            ctx.save();

            // var fontHeight = parseInt(font.size);
            var fontHeight = DayPilot.Util.fontHeight(font);

            // TODO firefox textBaseline bug; guess value that works for small font sizes; try to calculate it using 1.1 em
            var topOffset = DayPilot.browser.ff ? 3 : 0;
            topOffset += fontHeight * 0.2;
            topOffset += DayPilot.browser.chrome ? 1 : 0;
            topOffset += DayPilot.browser.ie ? 1 : 0;

            ctx.beginPath();
            ctx.rect(rect.x +.5 + padding, rect.y +.5 + padding, rect.w - 1 - padding, rect.h - 1 - padding);
            ctx.clip();

            ctx.fillStyle = color;
            ctx.font = font.style + " " + font.size + " " + font.family;
            ctx.textBaseline = "top";
            ctx.textAlign = halign;

            var x = rect.x;
            switch (halign) {
                case "left":
                    x += padding;
                    break;
                case "center":
                    x += rect.w/2;
                    break;
                case "right":
                    x += rect.w - padding;
                    break;
            }

            var lineHeight = fontHeight * 1.2;
            var hardLines = text.split("\n");

            var lines = [];
            DayPilot.list(hardLines).forEach(function(text) {
                var autoLines = getLines(ctx, text, rect.w);
                DayPilot.list(autoLines).forEach(function(al) {
                    lines.push(al);
                });
            });

            var lastSpace = lineHeight - fontHeight;
            var textHeight = lineHeight * lines.length - lastSpace;
            var availableHeight = rect.h - 2*padding;

            var top = rect.y + padding;
            switch (valign) {
                case "top":
                    top += topOffset;
                    break;
                case "center":
                    top += (availableHeight - textHeight) / 2 + fontHeight*0.1;
                    break;
                case "bottom":
                    top += availableHeight - textHeight;
                    break;
            }

            // var top = rect.y + shift + padding + topOffset;
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                ctx.fillText(line, x, top);
                top += lineHeight;
            }

            ctx.restore();
        };

        function getLines(ctx, text, maxWidth) {
            var words = text.split(" ");
            var lines = [];
            var currentLine = words[0];

            for (var i = 1; i < words.length; i++) {
                var word = words[i];
                var width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }


        this.line = function(x1, y1, x2, y2, color) {
            ctx.save();

            ctx.lineWidth = 1;
            ctx.strokeStyle = color;

            ctx.beginPath();
            ctx.moveTo(x1 +.5, y1 +.5);
            ctx.lineTo(x2 +.5, y2 +.5);
            ctx.stroke();

            ctx.restore();
        };

        this.image = function(rect, img) {
            if (!img) {
                return;
            }

            var alwaysUseOnload = true;

            if (typeof img === "string") {
                var href = img;
                var img = document.createElement("img");

                if (href.indexOf("data:") !== 0 || alwaysUseOnload) {
                    img.onload = function() {
                        ctx.save();
                        ctx.drawImage(img, rect.x, rect.y);
                        ctx.restore();
                    };
                    img.src = href;
                    return;
                }
                img.src = href;
            }

            ctx.save();
            ctx.drawImage(img, rect.x, rect.y);
            ctx.restore();

        };

        this.symbol = function(rect, url, options) {
            var ns = "http://www.w3.org/2000/svg";
            var svg = document.createElementNS(ns, "svg");

            // var result = fetch(url).then(function(response) { return response.text(); });
            var This = this;

            options = options || {};
            var color = options.color;

            var loader = new SymbolLoader(url);
            var result = loader._result();
            result.then(function(symbol) {
                if (color) {
                    var style = document.createElementNS(ns, "style");
                    style.innerHTML = "svg { color: " + color + "; }";
                    svg.appendChild(style);
                }

                svg.setAttribute("viewBox", symbol.getAttribute("viewBox"));
                svg.setAttribute("width", rect.w);
                svg.setAttribute("height", rect.h);

                var g = document.createElementNS(ns, "g");
                g.innerHTML = symbol.innerHTML;

                svg.appendChild(g);

                var xml = new XMLSerializer().serializeToString(svg);
                var image64 = 'data:image/svg+xml;base64,' + btoa(xml);
                This.image(rect, image64);
            });

        };

        this.getWidth = function() {
            return canvas.width;
        };

        this.getHeight = function() {
            return canvas.height;
        };

        this.getElement = function() {
            return canvas;
        };

        this.getSource = function() {
            return "<img src='" + canvas.toDataURL(format, jpegQuality) + "' />";
        };

        this.getDataUri = function() {
            //return 'data:application/octet-stream,' + encodeURIComponent(this.getSource());
            return canvas.toDataURL(format, jpegQuality);
        };

        this.getDefaultFileName = function() {
            return this.defaultFileName;
        };

        this.getBlob = function() {
            if (canvas.msToBlob) {
                return canvas.msToBlob();
            }
            //return new Blob([this.getSource(format, jpegQuality)]);
            return DayPilot.Util.dataUriToBlob(this.getDataUri());
        };


    };

    DayPilot.Svg = function(width, height) {
        var ns = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(ns, "svg");
        var me = this;
        this._svg = svg;
        this.groups = [];

        if (svg.outerHTML) {  // other than ie
            svg.setAttribute("xmlns", ns);
            // svg.setAttributeNS(ns, "xlink", 'http://www.w3.org/1999/xlink');
        }

        svg.setAttribute("viewBox", "0 0 " + width + " " + height); // allows auto scaling

        var defs = document.createElementNS(ns, "defs");
        svg.appendChild(defs);
        me.defs = defs;

        _clipAll(width, height);

        function _clipAll(width, height) {
            var clip = document.createElementNS(ns, "clipPath");
            clip.id = "clip" + DayPilot.guid();
            var r = document.createElementNS(ns, "rect");
            r.setAttribute('x', 0);
            r.setAttribute('y', 0);
            r.setAttribute('width', width);
            r.setAttribute('height', height);
            clip.appendChild(r);
            me.defs.appendChild(clip);

            var g = document.createElementNS(ns, "g");
            g.setAttribute("clip-path", "url(#" + clip.id + ")");
            svg.appendChild(g);

            svg = g;
        }

        this.defaultFileName = "image.svg";

        this.groupStart = function(data) {
            var r = document.createElementNS(ns, "g");
            for (var name in data) {
                r.setAttribute("data-" + name, data[name]);
            }
            svg = r;

            if (this.group) {
                this.groups.push(this.group);
            }
            this.group = r;

        };

        this.groupEnd = function() {
            if (!this.group) {
                throw new DayPilot.Exception("SVG export = group not open");
            }
            var group = this.group;

            // get new parent
            this.group = this.groups.pop();
            svg = this.group;
            if (!svg) {
                svg = this._svg;
            }

            svg.appendChild(group);
        };

        this.fillRect = function(rect, color) {
            var r = document.createElementNS(ns, "rect");
            r.setAttribute('x', rect.x);
            r.setAttribute('y', rect.y);
            r.setAttribute('width', rect.w);
            r.setAttribute('height', rect.h);
            r.setAttribute('fill', color);
            svg.appendChild(r);
        };

        this.diamond = function(rect, color) {
            var r = document.createElementNS(ns, "path");

            var path = "";
            path += "M " + (rect.x + rect.w/2) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x + rect.w) + " " + (rect.y + rect.h/2);
            path += " ";
            path += "L " + (rect.x + rect.w/2) + " " + (rect.y + rect.h);
            path += " ";
            path += "L " + (rect.x) + " " + (rect.y + rect.h/2);
            path += " Z";
            r.setAttribute("d", path);
            r.setAttribute('fill', color);
            svg.appendChild(r);
        };

        this.triangle = function(rect, color, rotate) {

            // known rotations: 0, 90, 180, -90
            // translate x to y
            var r = document.createElementNS(ns, "path");

            var path = "";
            path += "M " + (rect.x + rect.w/3) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x + rect.w) + " " + (rect.y + rect.h/2);
            path += " ";
            path += "L " + (rect.x + rect.w/3) + " " + (rect.y + rect.h);
            path += " Z";
            r.setAttribute("d", path);
            r.setAttribute('fill', color);
            if (typeof rotate === "number") {
                r.setAttribute("transform", "rotate(" + rotate + "," + (rect.x + rect.w/2) + "," + (rect.y + rect.h/2) + ")");
            }
            svg.appendChild(r);
        };

        this.upperLeftCorner = function(rect, color) {
            var r = document.createElementNS(ns, "path");

            var path = "";
            path += "M " + (rect.x) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x + rect.w) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x) + " " + (rect.y + rect.h);
            path += " Z";
            r.setAttribute("d", path);
            r.setAttribute('fill', color);
            svg.appendChild(r);
        };

        this.upperRightCorner = function(rect, color) {
            var r = document.createElementNS(ns, "path");

            var path = "";
            path += "M " + (rect.x) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x + rect.w) + " " + (rect.y);
            path += " ";
            path += "L " + (rect.x + rect.w ) + " " + (rect.y + rect.h);
            path += " Z";
            r.setAttribute("d", path);
            r.setAttribute('fill', color);
            svg.appendChild(r);
        };

        this.rect = function(rect, color) {
            if (rect.w <= 0) {
                return;
            }
            if (rect.h <= 0) {
                return;
            }

            var r = document.createElementNS(ns, "rect");
            r.setAttribute('x', rect.x + 0.5);
            r.setAttribute('y', rect.y + 0.5);
            r.setAttribute('width', rect.w - 1);
            r.setAttribute('height', rect.h - 1);
            r.setAttribute('stroke', color);
            r.setAttribute("stroke-width", "1");
            r.setAttribute("fill", "transparent");
            svg.appendChild(r);
        };

        this.text = function(rect, text, font, color, halign, padding, valign) {

            if (!text) {
                return;
            }
            if (typeof text === "number") {
                text = "" + text;
            }
            if (typeof text !== "string") {
                throw "String expected, supplied: " + typeof text;
            }

            if (rect.w < 0) {
                return;
            }

            /*if (typeof text === "number") {
                text = "" + text;
            }
            if (typeof text !== "string") {
                throw "String expected";
            }*/

            halign = halign || "left";
            padding = padding || 0;
            valign = valign || "top";

            var fontStyle = font.style;
            if (fontStyle.indexOf("italic") !== -1) {
                fontStyle = "bold";
            }

            var fontWeight = font.style;
            if (font.style)

            var topOffset = 3;  // hardcoded

            var x = rect.x;
            var anchor = "start";
            switch (halign) {
                case "center":
                    x += rect.w/2;
                    anchor = "middle";
                    break;
                case "right":
                    x += rect.w;
                    anchor = "end";
                    break;
            }

            var clip = document.createElementNS(ns, "clipPath");
            clip.id = "clip" + DayPilot.guid();
            var r = document.createElementNS(ns, "rect");
            r.setAttribute('x', rect.x);
            r.setAttribute('y', rect.y);
            r.setAttribute('width', rect.w);
            r.setAttribute('height', rect.h);
            clip.appendChild(r);
            me.defs.appendChild(clip); // always global

            var fontHeight = DayPilot.Util.fontHeight(font);
            var lineHeight = fontHeight * 1.2;
            var lines = text.split("\n");

            var lastSpace = lineHeight - fontHeight;
            var textHeight = lineHeight * lines.length - lastSpace;
            var availableHeight = rect.h - 2*padding;

            var top = rect.y + padding;
            switch (valign) {
                case "top":
                    top += topOffset;
                    break;
                case "center":
                    top += (availableHeight - textHeight) / 2 + fontHeight*0.1;
                    break;
                case "bottom":
                    top += availableHeight - textHeight;
                    break;
            }


            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                printLine(line, x + padding, top);
                top += lineHeight;
            }

            function printLine(text, x, y) {
                var txt = document.createElementNS(ns, "text");
                txt.setAttribute("fill", color);
                txt.setAttribute("font-family", font.family);
                txt.setAttribute("font-size", font.size);
                txt.setAttribute("font-style", fontStyle);
                txt.setAttribute("font-weight", fontWeight);
                txt.setAttribute("x", x);
                txt.setAttribute("y", y);
                txt.setAttribute("dy", "0.8em");
                txt.setAttribute("text-anchor", anchor);
                txt.setAttribute("clip-path", "url(#" + clip.id + ")");
                var inner = document.createTextNode(text);
                txt.appendChild(inner);

                svg.appendChild(txt);
            }

        };

        this.line = function(x1, y1, x2, y2, color) {
            var line = document.createElementNS(ns, "line");
            line.setAttribute("x1", x1 + 0.5);
            line.setAttribute("y1", y1 + 0.5);
            line.setAttribute("x2", x2 + 0.5);
            line.setAttribute("y2", y2 + 0.5);
            line.setAttribute("stroke", color);
            svg.appendChild(line);

        };

        // careful, it's asynchronous
        this.image = function(rect, img) {

            var placeholder = document.createElementNS(ns, "g");
            svg.appendChild(placeholder);

            function doit(args) {
                var image = document.createElementNS(ns, "image");
                image.setAttribute("href", args.dataUri);
                image.setAttribute("x", rect.x);
                image.setAttribute("y", rect.y);
                image.setAttribute("width", rect.w);
                image.setAttribute("height", rect.h);
                placeholder.appendChild(image);
            }

            getDataUri(img, doit);
        };

        this.symbol = function(rect, url, options) {
            var ns = "http://www.w3.org/2000/svg";
            var svg2 = document.createElementNS(ns, "symbol");

            var This = this;

            options = options || {};
            var color = options.color;

            var loader = new SymbolLoader(url);
            var result = loader._result();
            result.then(function(symbol) {

                if (color) {
                    var style = document.createElementNS(ns, "style");
                    style.innerHTML = "svg { color: " + color + "; }";
                    svg2.appendChild(style);
                }

                var id = DayPilot.guid();
                svg2.setAttribute("viewBox", symbol.getAttribute("viewBox"));
                svg2.setAttribute("width", rect.w);
                svg2.setAttribute("height", rect.h);
                svg2.setAttribute("id", id);

                var g = document.createElementNS(ns, "g");
                g.innerHTML = symbol.innerHTML;

                svg2.appendChild(g);
                This._svg.appendChild(svg2);

                var use = document.createElementNS(ns, "use");
                use.setAttribute("href", "#" + id);
                use.setAttribute("x", rect.x);
                use.setAttribute("y", rect.y);
                svg.appendChild(use);

            });

        };

        function getDataUri(img, finished) {
            var href = null;
            if (!img) {  // no image specified
                return;
            }
            if (typeof img === "string") {
                if (img.indexOf("data:") === 0) {
                    var args = {};
                    args.dataUri = img;
                    finished(args);
                }
                href = img;
            }
            else {
                href = img.src;
            }
            var img = document.createElement("img");
            img.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = this.naturalWidth;
                canvas.height = this.naturalHeight;
                canvas.getContext("2d").drawImage(this, 0, 0);

                var args = {};
                args.dataUri = canvas.toDataURL('image/png');
                finished(args);
            };
            img.src = href;
        }

        this._widthCache = {};

        this.textWidth = function(text, font) {

            var key = "#" + text + "#" + JSON.stringify(font);
            var cached = this._widthCache[key];
            if (typeof cached === "number") {
                return cached;
            }

            var ns = "http://www.w3.org/2000/svg";
            var svg = document.createElementNS(ns, "svg");

            svg.style.position = "absolute";
            svg.style.left = "-10000px";
            svg.style.width = "100px";

            if (svg.outerHTML) {  // other than ie
                svg.setAttribute("xmlns", ns);
            }

            svg.setAttribute("viewBox", "0 0 100 100");

            var txt = document.createElementNS(ns, "text");
            // txt.setAttribute("fill", color);
            txt.setAttribute("font-family", font.family);
            txt.setAttribute("font-size", font.size);
            txt.setAttribute("font-style", font.style);
            txt.setAttribute("x", 0);
            txt.setAttribute("y", 0);
            txt.setAttribute("dy", "1em");
            var inner = document.createTextNode(text);
            txt.appendChild(inner);

            svg.appendChild(txt);
            document.body.appendChild(svg);

            var width = txt.getComputedTextLength();
            this._widthCache[key] = width;

            document.body.removeChild(svg);

            return width;
        };

        this.getWidth = function() {
            return width;
        };

        this.getHeight = function() {
            return height;
        };

        this.getElement = function() {
            return this._svg;
        };

        this.getSource = function() {
            if (this._svg.outerHTML) {
                return this._svg.outerHTML;
            }
            else {
                var div = document.createElement('div');
                var clone = this._svg.cloneNode(true);
                div.appendChild(clone);
                return div.innerHTML;
            }
        };

        this.getDataUri = function() {
            return 'data:application/octet-stream,' + encodeURIComponent(this.getSource());
        };

        this.getDefaultFileName = function() {
            return this.defaultFileName;
        };

        this.getBlob = function() {
            return new Blob([this.getSource()]);
        };

    };

    DayPilot.Excel = function() {
        var excel = this;

        var doc = null;
        var styles = null;
        var styleDefault = null;

        var ns = {};
        ns.xmlns = 'urn:schemas-microsoft-com:office:spreadsheet';
        ns.o = "urn:schemas-microsoft-com:office:office";
        ns.x = "urn:schemas-microsoft-com:office:excel";
        ns.ss = "urn:schemas-microsoft-com:office:spreadsheet";
        ns.html = "http://www.w3.org/TR/REC-html40";

        this.init = function() {
            doc = document.implementation.createDocument (ns.xmlns, 'Workbook', null);
            doc.documentElement.setAttribute("xmlns:o", ns.o);
            doc.documentElement.setAttribute("xmlns:x", ns.x);
            doc.documentElement.setAttribute("xmlns:ss", ns.ss);
            doc.documentElement.setAttribute("xmlns:html", ns.html);

            var excelWorkbook = doc.createElement("x:ExcelWorkbook");
            doc.documentElement.appendChild(excelWorkbook);

            styles = doc.createElement("ss:Styles");
            doc.documentElement.appendChild(styles);

            styleDefault = excel.styles.create();
            styleDefault.setId("Default");
            styleDefault.setName("Normal");

        };

        this.worksheets = [];
        this.worksheets.create = function(name) {
            var element = excel.el(ns.ss, "Worksheet");
            var ws = new Worksheet(element);
            ws.setName(name);
            this.push(ws);
            return ws;
        };

        this.styles = [];
        this.styles.create = function(options) {
            var style = doc.createElement("ss:Style");
            styles.appendChild(style);
            var s = new Style(style);
            this.push(s);
            return s;
        };

        this.styles.getDefault = function() {
            return styleDefault;
        };

        this.el = function(ns, element) {
            var e = doc.createElementNS(ns, element);
            doc.documentElement.appendChild(e);
            return e;
        };

        this.getSource = function() {
            var serializer = new XMLSerializer();
            var xmlString = serializer.serializeToString(doc);

            return "<?xml version=\"1.0\"?>" + xmlString;
        };

        this.getDataUri = function() {
            return 'data:application/vnd.ms-excel,' + encodeURIComponent(this.getSource());
        };

        this.getElement = function() {
            return doc;
        };

        this.getDefaultFileName = function() {
            return "spreadsheet.xls";
        };

        this.getBlob = function() {
            return new Blob([this.getSource()]);
        };

        var Worksheet = function(element) {

            var table = doc.createElement("Table");
            element.appendChild(table);

            var options = doc.createElement("x:WorksheetOptions");
            element.appendChild(options);

            this.rows = [];

            this.setName = function(name) {
                element.setAttribute("ss:Name", name);
            };

            this.cell = function(x, y) {
                // make sure it exists
                while (y >= this.rows.length) {
                    var row = doc.createElement("Row");
                    table.appendChild(row);
                    this.rows.push(new Row(row));
                }

                var r = this.rows[y];
                return r.cell(x);

            };

            this.enableGridlines = function(value) {

                var existing = DayPilot.list(options.childNodes).find(function(node) {
                    return node.tagName === "x:DoNotDisplayGridlines";
                });

                if (!existing && !value) {
                    var donot = doc.createElement("x:DoNotDisplayGridlines");
                    options.appendChild(donot);
                }

                if (existing && value) {
                    options.removeChild(existing);
                }
            };


            var Row = function(element) {

                this.cells = [];

                this.getElement = function() {
                    return element;
                };

                this.cell = function(x) {
                    while (x >= this.cells.length) {
                        var cell = doc.createElement("Cell");
                        element.appendChild(cell);
                        this.cells.push(new Cell(cell));
                    }

                    return this.cells[x];
                };

                var Cell = function(element) {
                    this.setText = function(text) {
                        var data = doc.createElement("Data");
                        data.setAttribute("ss:Type", "String");
                        var inner = doc.createTextNode(text);
                        data.appendChild(inner);
                        while (element.firstChild) {
                            element.removeChild(element.firstChild);
                        }
                        element.appendChild(data);
                        return this;
                    };

                    this.setColspan = function(i) {
                        //  ss:MergeAcross="1"
                        if (i > 1) {
                            element.setAttribute("ss:MergeAcross", i - 1);
                        }
                        else {
                            element.removeAttribute("ss:MergeAcross");
                        }

                        return this;
                    };

                    this.setRowspan = function(i) {
                        if (i > 1) {
                            element.setAttribute("ss:MergeDown", i - 1);
                        }
                        else {
                            element.removeAttribute("ss:MergeDown");
                        }

                        return this;
                    };

                    this.setStyle = function(style) {
                        if (!(style instanceof Style)) {
                            throw "Invalid argument, Style expected";
                        }
                        element.setAttribute("ss:StyleID", style.getId());
                        return this;
                    }
                };
            };
        };

        var Style = function(element) {

            var id = DayPilot.guid();
            element.setAttribute("ss:ID", id);

            var alignment = doc.createElement("ss:Alignment");
            element.appendChild(alignment);

            var interior = doc.createElement("ss:Interior");
            element.appendChild(interior);

            var borders = doc.createElement("ss:Borders");
            element.appendChild(borders);

            /***
             * Horizontal alignment
             * @param value "Automatic" | "Left" | "Center" | "Right"
             */
            this.setHorizontalAlignment = function(value) {
                alignment.setAttribute("ss:Horizontal", value);
            };

            /**
             * Vertical alignment
             * @param value "Automatic" | "Top" | "Bottom" | "Center"
             */
            this.setVerticalAlignment = function(value) {
                alignment.setAttribute("ss:Vertical", value);
            };

            this.setBackColor = function(value) {
                var normalized = DayPilot.Util.normalizeColor(value);
                interior.setAttribute("ss:Color", normalized);
                interior.setAttribute("ss:Pattern", "Solid");
            };

            this.setBorderColor = function(color) {

                this.clearBorders();

                var borderLeft = createBorder("Left", color);
                borders.appendChild(borderLeft);

                var borderRight = createBorder("Right", color);
                borders.appendChild(borderRight);

                var borderTop = createBorder("Top", color);
                borders.appendChild(borderTop);

                var borderBottom = createBorder("Bottom", color);
                borders.appendChild(borderBottom);

                function createBorder(position, color) {
                    var border = doc.createElement("ss:Border");
                    border.setAttribute("ss:Position", position);
                    border.setAttribute("ss:LineStyle", "Continuous");
                    border.setAttribute("ss:Color", DayPilot.Util.normalizeColor(color));
                    return border;
                }
            };

            this.clearBorders = function() {
                while(borders.firstChild) {
                    borders.removeChild(borders.firstChild);
                }
            };

            this.getId = function() {
                return id;
            };

            this.setId = function(value) {
                id = value;
                element.setAttribute("ss:ID", id);
            };

            this.setName = function(value) {
                element.setAttribute("ss:Name", value);
            };
        };

        this.init();

    };

    DayPilot.Export = function(board) {
        this.toElement = function() {
            return board.getElement();
        };

        this.dimensions = function() {
            return {
                "width": board.getWidth(),
                "height": board.getHeight()
            };
        };

        this.toHtml = function() {
            return board.getSource();
        };

        this.toDataUri = function() {
            return board.getDataUri();
        };

        this.toBlob = function() {
            return board.getBlob();
        };

        this.print = function(options) {
            options = options || {};
            options.orientation = options.orientation || "portrait";

            var iframe = document.createElement("iframe");
            iframe.setAttribute("width", 0);
            iframe.setAttribute("height", 0);
            iframe.setAttribute("frameborder", 0);
            iframe.setAttribute("src", "about:blank");

            //var ibody = doc.compatMode === 'BackCompat' ? doc.body : doc.documentElement;

            iframe.onload = function() {

                var doc = iframe.contentWindow.document;
                doc.body.appendChild(board.getElement());

                if (options.orientation === "landscape") {
                    var sheet = DayPilot.sheet(doc);
                    sheet.add("@page", "size: landscape;");
                    // sheet.add("body", "width: 276mm; height: 190mm; margin: 0; padding: 0; transform: rotate(270deg) translate(-276mm, 0); transform-origin: 0 0;");
                    sheet.commit();
                }

                var result = iframe.contentWindow.document.execCommand('print', false, null);

                if (!result) {
                    iframe.contentWindow.focus();
                    iframe.contentWindow.print();
                }

                setTimeout(function() {
                    document.body.removeChild(iframe);
                }, 10);

            };

            document.body.appendChild(iframe);

        };

        // ie only 10+
        this.download = function(name) {
            var name = name || board.getDefaultFileName();
            var blob = board.getBlob();
            DayPilot.Util.downloadBlob(blob, name);

        };
    };


    DayPilot.Exception = function(msg) {
        return new Error(msg);
    };

    DayPilot.Locale = function(id, config) {
        this.id = id;
        this.dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        this.dayNamesShort = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
        this.monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        this.monthNamesShort  = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        this.datePattern = "M/d/yyyy";
        this.timePattern = "H:mm";
        this.dateTimePattern = "M/d/yyyy H:mm";
        this.timeFormat = "Clock12Hours";
        this.weekStarts = 0; // Sunday

        if (config) {
            for (var name in config) {
                this[name] = config[name];
            }
        }
    };

    DayPilot.Locale.all = {};

    DayPilot.Locale.find = function(id) {
        if (!id) {
            return null;
        }
        var normalized = id.toLowerCase();
        if (normalized.length > 2) {
            normalized = DayPilot.Util.replaceCharAt(normalized, 2, '-');
        }
        return DayPilot.Locale.all[normalized];
    };

    DayPilot.Locale.register = function(locale) {
        DayPilot.Locale.all[locale.id] = locale;
    };

    DayPilot.Locale.register(new DayPilot.Locale('ca-es', {'dayNames':['diumenge','dilluns','dimarts','dimecres','dijous','divendres','dissabte'],'dayNamesShort':['dg','dl','dt','dc','dj','dv','ds'],'monthNames':['gener','febrer','març','abril','maig','juny','juliol','agost','setembre','octubre','novembre','desembre',''],'monthNamesShort':['gen.','febr.','març','abr.','maig','juny','jul.','ag.','set.','oct.','nov.','des.',''],'timePattern':'H:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('cs-cz', {'dayNames':['neděle','pondělí','úterý','středa','čtvrtek','pátek','sobota'],'dayNamesShort':['ne','po','út','st','čt','pá','so'],'monthNames':['leden','únor','březen','duben','květen','červen','červenec','srpen','září','říjen','listopad','prosinec',''],'monthNamesShort':['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII',''],'timePattern':'H:mm','datePattern':'d. M. yyyy','dateTimePattern':'d. M. yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('da-dk', {'dayNames':['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],'dayNamesShort':['sø','ma','ti','on','to','fr','lø'],'monthNames':['januar','februar','marts','april','maj','juni','juli','august','september','oktober','november','december',''],'monthNamesShort':['jan','feb','mar','apr','maj','jun','jul','aug','sep','okt','nov','dec',''],'timePattern':'HH:mm','datePattern':'dd-MM-yyyy','dateTimePattern':'dd-MM-yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('de-at', {'dayNames':['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],'dayNamesShort':['So','Mo','Di','Mi','Do','Fr','Sa'],'monthNames':['Jänner','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember',''],'monthNamesShort':['Jän','Feb','Mär','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('de-ch', {'dayNames':['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],'dayNamesShort':['So','Mo','Di','Mi','Do','Fr','Sa'],'monthNames':['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember',''],'monthNamesShort':['Jan','Feb','Mrz','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('de-de', {'dayNames':['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],'dayNamesShort':['So','Mo','Di','Mi','Do','Fr','Sa'],'monthNames':['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember',''],'monthNamesShort':['Jan','Feb','Mrz','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('de-lu', {'dayNames':['Sonntag','Montag','Dienstag','Mittwoch','Donnerstag','Freitag','Samstag'],'dayNamesShort':['So','Mo','Di','Mi','Do','Fr','Sa'],'monthNames':['Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember',''],'monthNamesShort':['Jan','Feb','Mrz','Apr','Mai','Jun','Jul','Aug','Sep','Okt','Nov','Dez',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('en-au', {'dayNames':['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],'dayNamesShort':['Su','Mo','Tu','We','Th','Fr','Sa'],'monthNames':['January','February','March','April','May','June','July','August','September','October','November','December',''],'monthNamesShort':['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec',''],'timePattern':'h:mm tt','datePattern':'d/MM/yyyy','dateTimePattern':'d/MM/yyyy h:mm tt','timeFormat':'Clock12Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('en-ca', {'dayNames':['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],'dayNamesShort':['Su','Mo','Tu','We','Th','Fr','Sa'],'monthNames':['January','February','March','April','May','June','July','August','September','October','November','December',''],'monthNamesShort':['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec',''],'timePattern':'h:mm tt','datePattern':'yyyy-MM-dd','dateTimePattern':'yyyy-MM-dd h:mm tt','timeFormat':'Clock12Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('en-gb', {'dayNames':['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],'dayNamesShort':['Su','Mo','Tu','We','Th','Fr','Sa'],'monthNames':['January','February','March','April','May','June','July','August','September','October','November','December',''],'monthNamesShort':['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('en-us', {'dayNames':['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],'dayNamesShort':['Su','Mo','Tu','We','Th','Fr','Sa'],'monthNames':['January','February','March','April','May','June','July','August','September','October','November','December',''],'monthNamesShort':['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec',''],'timePattern':'h:mm tt','datePattern':'M/d/yyyy','dateTimePattern':'M/d/yyyy h:mm tt','timeFormat':'Clock12Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('es-es', {'dayNames':['domingo','lunes','martes','miércoles','jueves','viernes','sábado'],'dayNamesShort':['D','L','M','X','J','V','S'],'monthNames':['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre',''],'monthNamesShort':['ene.','feb.','mar.','abr.','may.','jun.','jul.','ago.','sep.','oct.','nov.','dic.',''],'timePattern':'H:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('es-mx', {'dayNames':['domingo','lunes','martes','miércoles','jueves','viernes','sábado'],'dayNamesShort':['do.','lu.','ma.','mi.','ju.','vi.','sá.'],'monthNames':['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre',''],'monthNamesShort':['ene.','feb.','mar.','abr.','may.','jun.','jul.','ago.','sep.','oct.','nov.','dic.',''],'timePattern':'hh:mm tt','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy hh:mm tt','timeFormat':'Clock12Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('eu-es', {'dayNames':['igandea','astelehena','asteartea','asteazkena','osteguna','ostirala','larunbata'],'dayNamesShort':['ig','al','as','az','og','or','lr'],'monthNames':['urtarrila','otsaila','martxoa','apirila','maiatza','ekaina','uztaila','abuztua','iraila','urria','azaroa','abendua',''],'monthNamesShort':['urt.','ots.','mar.','api.','mai.','eka.','uzt.','abu.','ira.','urr.','aza.','abe.',''],'timePattern':'H:mm','datePattern':'yyyy/MM/dd','dateTimePattern':'yyyy/MM/dd H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('fi-fi', {'dayNames':['sunnuntai','maanantai','tiistai','keskiviikko','torstai','perjantai','lauantai'],'dayNamesShort':['su','ma','ti','ke','to','pe','la'],'monthNames':['tammikuu','helmikuu','maaliskuu','huhtikuu','toukokuu','kesäkuu','heinäkuu','elokuu','syyskuu','lokakuu','marraskuu','joulukuu',''],'monthNamesShort':['tammi','helmi','maalis','huhti','touko','kesä','heinä','elo','syys','loka','marras','joulu',''],'timePattern':'H:mm','datePattern':'d.M.yyyy','dateTimePattern':'d.M.yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('fr-be', {'dayNames':['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'],'dayNamesShort':['di','lu','ma','me','je','ve','sa'],'monthNames':['janvier','février','mars','avril','mai','juin','juillet','août','septembre','octobre','novembre','décembre',''],'monthNamesShort':['janv.','févr.','mars','avr.','mai','juin','juil.','août','sept.','oct.','nov.','déc.',''],'timePattern':'HH:mm','datePattern':'dd-MM-yy','dateTimePattern':'dd-MM-yy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('fr-ca', {'dayNames':['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'],'dayNamesShort':['di','lu','ma','me','je','ve','sa'],'monthNames':['janvier','février','mars','avril','mai','juin','juillet','août','septembre','octobre','novembre','décembre',''],'monthNamesShort':['janv.','févr.','mars','avr.','mai','juin','juil.','août','sept.','oct.','nov.','déc.',''],'timePattern':'HH:mm','datePattern':'yyyy-MM-dd','dateTimePattern':'yyyy-MM-dd HH:mm','timeFormat':'Clock24Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('fr-ch', {'dayNames':['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'],'dayNamesShort':['di','lu','ma','me','je','ve','sa'],'monthNames':['janvier','février','mars','avril','mai','juin','juillet','août','septembre','octobre','novembre','décembre',''],'monthNamesShort':['janv.','févr.','mars','avr.','mai','juin','juil.','août','sept.','oct.','nov.','déc.',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('fr-fr', {'dayNames':['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'],'dayNamesShort':['di','lu','ma','me','je','ve','sa'],'monthNames':['janvier','février','mars','avril','mai','juin','juillet','août','septembre','octobre','novembre','décembre',''],'monthNamesShort':['janv.','févr.','mars','avr.','mai','juin','juil.','août','sept.','oct.','nov.','déc.',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('fr-lu', {'dayNames':['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'],'dayNamesShort':['di','lu','ma','me','je','ve','sa'],'monthNames':['janvier','février','mars','avril','mai','juin','juillet','août','septembre','octobre','novembre','décembre',''],'monthNamesShort':['janv.','févr.','mars','avr.','mai','juin','juil.','août','sept.','oct.','nov.','déc.',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('gl-es', {'dayNames':['domingo','luns','martes','mércores','xoves','venres','sábado'],'dayNamesShort':['do','lu','ma','mé','xo','ve','sá'],'monthNames':['xaneiro','febreiro','marzo','abril','maio','xuño','xullo','agosto','setembro','outubro','novembro','decembro',''],'monthNamesShort':['xan','feb','mar','abr','maio','xuño','xul','ago','set','out','nov','dec',''],'timePattern':'H:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('it-it', {'dayNames':['domenica','lunedì','martedì','mercoledì','giovedì','venerdì','sabato'],'dayNamesShort':['do','lu','ma','me','gi','ve','sa'],'monthNames':['gennaio','febbraio','marzo','aprile','maggio','giugno','luglio','agosto','settembre','ottobre','novembre','dicembre',''],'monthNamesShort':['gen','feb','mar','apr','mag','giu','lug','ago','set','ott','nov','dic',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('it-ch', {'dayNames':['domenica','lunedì','martedì','mercoledì','giovedì','venerdì','sabato'],'dayNamesShort':['do','lu','ma','me','gi','ve','sa'],'monthNames':['gennaio','febbraio','marzo','aprile','maggio','giugno','luglio','agosto','settembre','ottobre','novembre','dicembre',''],'monthNamesShort':['gen','feb','mar','apr','mag','giu','lug','ago','set','ott','nov','dic',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('ja-jp', {'dayNames':['日曜日','月曜日','火曜日','水曜日','木曜日','金曜日','土曜日'],'dayNamesShort':['日','月','火','水','木','金','土'],'monthNames':['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月',''],'monthNamesShort':['1','2','3','4','5','6','7','8','9','10','11','12',''],'timePattern':'H:mm','datePattern':'yyyy/MM/dd','dateTimePattern':'yyyy/MM/dd H:mm','timeFormat':'Clock24Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('ko-kr', {'dayNames':['일요일','월요일','화요일','수요일','목요일','금요일','토요일'],'dayNamesShort':['일','월','화','수','목','금','토'],'monthNames':['1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월',''],'monthNamesShort':['1','2','3','4','5','6','7','8','9','10','11','12',''],'timePattern':'tt h:mm','datePattern':'yyyy-MM-dd','dateTimePattern':'yyyy-MM-dd tt h:mm','timeFormat':'Clock12Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('nb-no', {'dayNames':['søndag','mandag','tirsdag','onsdag','torsdag','fredag','lørdag'],'dayNamesShort':['sø','ma','ti','on','to','fr','lø'],'monthNames':['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember',''],'monthNamesShort':['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('nl-nl', {'dayNames':['zondag','maandag','dinsdag','woensdag','donderdag','vrijdag','zaterdag'],'dayNamesShort':['zo','ma','di','wo','do','vr','za'],'monthNames':['januari','februari','maart','april','mei','juni','juli','augustus','september','oktober','november','december',''],'monthNamesShort':['jan','feb','mrt','apr','mei','jun','jul','aug','sep','okt','nov','dec',''],'timePattern':'HH:mm','datePattern':'d-M-yyyy','dateTimePattern':'d-M-yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('nl-be', {'dayNames':['zondag','maandag','dinsdag','woensdag','donderdag','vrijdag','zaterdag'],'dayNamesShort':['zo','ma','di','wo','do','vr','za'],'monthNames':['januari','februari','maart','april','mei','juni','juli','augustus','september','oktober','november','december',''],'monthNamesShort':['jan','feb','mrt','apr','mei','jun','jul','aug','sep','okt','nov','dec',''],'timePattern':'H:mm','datePattern':'d/MM/yyyy','dateTimePattern':'d/MM/yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('nn-no', {'dayNames':['søndag','måndag','tysdag','onsdag','torsdag','fredag','laurdag'],'dayNamesShort':['sø','må','ty','on','to','fr','la'],'monthNames':['januar','februar','mars','april','mai','juni','juli','august','september','oktober','november','desember',''],'monthNamesShort':['jan','feb','mar','apr','mai','jun','jul','aug','sep','okt','nov','des',''],'timePattern':'HH:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('pt-br', {'dayNames':['domingo','segunda-feira','terça-feira','quarta-feira','quinta-feira','sexta-feira','sábado'],'dayNamesShort':['D','S','T','Q','Q','S','S'],'monthNames':['janeiro','fevereiro','março','abril','maio','junho','julho','agosto','setembro','outubro','novembro','dezembro',''],'monthNamesShort':['jan','fev','mar','abr','mai','jun','jul','ago','set','out','nov','dez',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('pl-pl', {'dayNames':['niedziela','poniedziałek','wtorek','środa','czwartek','piątek','sobota'],'dayNamesShort':['N','Pn','Wt','Śr','Cz','Pt','So'],'monthNames':['styczeń','luty','marzec','kwiecień','maj','czerwiec','lipiec','sierpień','wrzesień','październik','listopad','grudzień',''],'monthNamesShort':['sty','lut','mar','kwi','maj','cze','lip','sie','wrz','paź','lis','gru',''],'timePattern':'HH:mm','datePattern':'yyyy-MM-dd','dateTimePattern':'yyyy-MM-dd HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('pt-pt', {'dayNames':['domingo','segunda-feira','terça-feira','quarta-feira','quinta-feira','sexta-feira','sábado'],'dayNamesShort':['D','S','T','Q','Q','S','S'],'monthNames':['janeiro','fevereiro','março','abril','maio','junho','julho','agosto','setembro','outubro','novembro','dezembro',''],'monthNamesShort':['jan','fev','mar','abr','mai','jun','jul','ago','set','out','nov','dez',''],'timePattern':'HH:mm','datePattern':'dd/MM/yyyy','dateTimePattern':'dd/MM/yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':0}));
    DayPilot.Locale.register(new DayPilot.Locale('ro-ro', {'dayNames':['duminică','luni','marți','miercuri','joi','vineri','sâmbătă'],'dayNamesShort':['D','L','Ma','Mi','J','V','S'],'monthNames':['ianuarie','februarie','martie','aprilie','mai','iunie','iulie','august','septembrie','octombrie','noiembrie','decembrie',''],'monthNamesShort':['ian.','feb.','mar.','apr.','mai.','iun.','iul.','aug.','sep.','oct.','nov.','dec.',''],'timePattern':'H:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('ru-ru', {'dayNames':['воскресенье','понедельник','вторник','среда','четверг','пятница','суббота'],'dayNamesShort':['Вс','Пн','Вт','Ср','Чт','Пт','Сб'],'monthNames':['Январь','Февраль','Март','Апрель','Май','Июнь','Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь',''],'monthNamesShort':['янв','фев','мар','апр','май','июн','июл','авг','сен','окт','ноя','дек',''],'timePattern':'H:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('sk-sk', {'dayNames':['nedeľa','pondelok','utorok','streda','štvrtok','piatok','sobota'],'dayNamesShort':['ne','po','ut','st','št','pi','so'],'monthNames':['január','február','marec','apríl','máj','jún','júl','august','september','október','november','december',''],'monthNamesShort':['1','2','3','4','5','6','7','8','9','10','11','12',''],'timePattern':'H:mm','datePattern':'d.M.yyyy','dateTimePattern':'d.M.yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('sv-se', {'dayNames':['söndag','måndag','tisdag','onsdag','torsdag','fredag','lördag'],'dayNamesShort':['sö','må','ti','on','to','fr','lö'],'monthNames':['januari','februari','mars','april','maj','juni','juli','augusti','september','oktober','november','december',''],'monthNamesShort':['jan','feb','mar','apr','maj','jun','jul','aug','sep','okt','nov','dec',''],'timePattern':'HH:mm','datePattern':'yyyy-MM-dd','dateTimePattern':'yyyy-MM-dd HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('tr-tr', {'dayNames':['Pazar','Pazartesi','Salı','Çarşamba','Perşembe','Cuma','Cumartesi'],'dayNamesShort':['Pz','Pt','Sa','Ça','Pe','Cu','Ct'],'monthNames':['Ocak','Şubat','Mart','Nisan','Mayıs','Haziran','Temmuz','Ağustos','Eylül','Ekim','Kasım','Aralık',''],'monthNamesShort':['Oca','Şub','Mar','Nis','May','Haz','Tem','Ağu','Eyl','Eki','Kas','Ara',''],'timePattern':'HH:mm','datePattern':'d.M.yyyy','dateTimePattern':'d.M.yyyy HH:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('uk-ua', {'dayNames':['неділя','понеділок','вівторок','середа','четвер',"п'ятниця",'субота'],'dayNamesShort':['Нд','Пн','Вт','Ср','Чт','Пт','Сб'],'monthNames':['січень','лютий','березень','квітень','травень','червень','липень','серпень','вересень','жовтень','листопад','грудень',''],'monthNamesShort':['Січ','Лют','Бер','Кві','Тра','Чер','Лип','Сер','Вер','Жов','Лис','Гру',''],'timePattern':'H:mm','datePattern':'dd.MM.yyyy','dateTimePattern':'dd.MM.yyyy H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('zh-cn', {'dayNames':['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],'dayNamesShort':['日','一','二','三','四','五','六'],'monthNames':['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月',''],'monthNamesShort':['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月',''],'timePattern':'H:mm','datePattern':'yyyy/M/d','dateTimePattern':'yyyy/M/d H:mm','timeFormat':'Clock24Hours','weekStarts':1}));
    DayPilot.Locale.register(new DayPilot.Locale('zh-tw', {'dayNames':['星期日','星期一','星期二','星期三','星期四','星期五','星期六'],'dayNamesShort':['日','一','二','三','四','五','六'],'monthNames':['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月',''],'monthNamesShort':['一月','二月','三月','四月','五月','六月','七月','八月','九月','十月','十一月','十二月',''],'timePattern':'tt hh:mm','datePattern':'yyyy/M/d','dateTimePattern':'yyyy/M/d tt hh:mm','timeFormat':'Clock12Hours','weekStarts':0}));

    DayPilot.Locale.US = DayPilot.Locale.find("en-us");

    /**
     * Created on 2023-04-04.
     */

    DayPilot.Switcher = function(options) {

        var This = this;

        this._views = [];
        this._triggers = [];
        this._navigator = {};

        this.selectedClass = null;

        this._active = null;

        this._day = DayPilot.Date.today();

        this.onChange = null;
        this.onChanged = null;
        this.onSelect = null;

        this._navigator.updateMode = function (mode) {
            var control = This._navigator.control;
            if (!control) {
                return;
            }
            control.selectMode = mode;
            control.select(This._day);
        };

        this.addView = function (spec, options) {
            var element;
            if (typeof spec === 'string') {
                element = document.getElementById(spec);
                if (!element) {
                    throw "Element not found: " + spec;
                }
            }
            else {  // DayPilot object, DOM element
                element = spec;
            }

            var control = element;

            var view = {};
            view._isView = true;
            view._id = control.id;
            view.control = control;
            view._options = options || {};
            view._hide = function () {
                if (control.hide) {
                    control.hide();
                }
                else if (control.nav && control.nav.top) {
                    control.nav.top.style.display = 'none';
                }
                else {
                    control.style.display = 'none';
                }
            };
            view._sendNavigate = function(date) {
                var serverBased = (function() {
                    if (control.backendUrl) {  // ASP.NET MVC, Java
                        return true;
                    }
                    if (typeof WebForm_DoCallback === 'function' && control.uniqueID) {  // ASP.NET WebForms
                        return true;
                    }
                    return false;
                })();
                if (serverBased) {
                    if (control.commandCallBack) {
                        control.commandCallBack("navigate", { "day": date });
                    }
                }
                else {
                    control.startDate = date;
                    control.update();
                }
            };
            view._show = function () {
                This._hideViews();
                if (control.show) {
                    control.show();
                }
                else if (control.nav && control.nav.top) {
                    control.nav.top.style.display = '';
                }
                else {
                    control.style.display = '';
                }
            };
            view._selectMode = function () { // for navigator
                if (view._options.navigatorSelectMode) {
                    return view._options.navigatorSelectMode;
                }

                if (control.isCalendar) {
                    switch (control.viewType) {
                        case "Day":
                            return "day";
                        case "Week":
                            return "week";
                        case "WorkWeek":
                            return "week";
                        default:
                            return "day";
                    }
                }
                else if (control.isMonth) {
                    switch (control.viewType) {
                        case "Month":
                            return "month";
                        case "Weeks":
                            return "week";
                        default:
                            return "day";
                    }
                }
                return "day";
            };

            this._views.push(view);

            return view;
        };

        this.addTrigger = function (id, control) {
            var element;
            if (typeof id === 'string') {
                element = document.getElementById(id);
                if (!element) {
                    throw "Element not found: " + id;
                }
            }
            else {
                element = id;
            }

            var view = this._findViewByControl(control);
            if (!view) {
                view = this.addView(control);
            }

            var trigger = {};
            trigger._isTrigger = true;
            trigger._element = element;
            trigger._id = element.id;
            trigger._view = view;
            trigger._onClick = function (ev) {

                This.show(trigger);
                This._select(trigger);

                if (ev) {
                    ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
                }

            };

            DayPilot.re(element, 'click', trigger._onClick);

            this._triggers.push(trigger);

            return trigger;
        };

        // backwards compatibility
        this.addButton = this.addTrigger;

        this.select = function(id) {
            var trigger = this._findTriggerById(id);
            if (trigger) {
                trigger._onClick();
            }
            else if (this._triggers.length > 0) {
                this._triggers[0]._onClick();
            }
        };

        this._findTriggerById = function(id) {
            for (var i = 0; i < this._triggers.length; i++) {
                var trigger = this._triggers[i];
                if (trigger._id === id) {
                    return trigger;
                }
            }
            return null;
        };

        this._select = function(trigger) {
            if (!this.selectedClass) {
                return;
            }

            for (var i = 0; i < this._triggers.length; i++) {
                var s = this._triggers[i];
                DayPilot.Util.removeClass(s._element, this.selectedClass);
            }
            DayPilot.Util.addClass(trigger._element, this.selectedClass);
        };

        this.addNavigator = function (control) {
            //this.navigator = {};
            This._navigator.control = control;

            control.timeRangeSelectedHandling = "JavaScript";
            control.onTimeRangeSelected = function() {
                var start, end, day;
                if (control.api === 1) {
                    start = arguments[0];
                    end = arguments[1];
                    day = arguments[2];
                }
                else {
                    var args = arguments[0];
                    start = args.start;
                    end = args.end;
                    day = args.day;
                }
                This._day = day;

                navigate(start, end, day);

            };
        };

        this.show = function (el) {
            var view, trigger;
            if (el._isTrigger) {
                trigger = el;
                view = trigger._view;
            }
            else {
                view = el._isView ? el : this._findViewByControl(el);
                if (this._active === view) {
                    return;
                }
            }

            if (This.onSelect) {
                var args = {};
                args.source = trigger ? trigger._element : null;
                args.target = view.control;

                This.onSelect(args);
                // TODO add preventDefault
            }

            this._active = view;
            view._show();

            var mode = view._selectMode();
            This._navigator.updateMode(mode);

            //This.navigator.select(This.day);

            //This.active.sendNavigate(this.day);

            // this ensures first onChange call if single day = today is displayed
            var start = This._navigator.control.selectionStart;
            var end = This._navigator.control.selectionEnd.addDays(1);
            var day = This._navigator.control.selectionDay;
            navigate(start, end, day);
        };

        this._findViewByControl = function (control) {
            for (var i = 0; i < this._views.length; i++) {
                if (this._views[i].control === control) {
                    return this._views[i];
                }
            }
            return null;
        };

        this._hideViews = function () {
            //var controls = [dp_day, dp_week, dp_month];
            for (var i = 0; i < this._views.length; i++) {
                this._views[i]._hide();
            }
        };

        Object.defineProperty(this, "active", {
            get: function() {
                return This._active;
            }
        });

        this.events = {};

        this.events.load = function(url, success, error) {
            if (This._active && This._active.control) {
                This._active.control.events.load(url, success, error);
            }
            else {
                throw "DayPilot.Switcher.events.load(): Active view not found";
            }
        };

        this._previousArgs = null;

        this._init = function() {
            if (!options) {
                return;
            }

            for (var name in options) {
                if (name === "triggers") {
                    var triggers = options.triggers || [];
                    triggers.forEach(function(item) {
                        This.addTrigger(item.id, item.view);
                    });
                }
                else if (name === "navigator") {
                    This.addNavigator(options.navigator);
                }
                else {
                    This[name] = options[name];
                }
            }

        };

        this._init();

        function navigate(start, end, day) {
            var args = {};
            args.start = start;
            args.end = end;
            args.day = day;
            args.target = This._active.control;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            var previous = This._previousArgs;
            if (previous) {
                if (previous.start === args.start && previous.end === args.end && previous.day === args.day && previous.target === args.target) {
                    return;  // duplicate, no change
                }
            }

            This._previousArgs = args;

            if (typeof This.onChange === "function") {
                This.onChange(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            // backwards compatibility
            if (typeof This.onTimeRangeSelect === "function") {
                This.onTimeRangeSelect(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            This._active._sendNavigate(This._day);

            if (typeof This.onChanged === "function") {
                This.onChanged(args);
            }

            if (typeof This.onTimeRangeSelected === "function") {
                This.onTimeRangeSelected(args);
            }

        }

    };

    // register the default theme
    (function() {
        if (DayPilot.Global.defaultCss) {
            return;
        }

        var sheet = DayPilot.sheet();

        // bubble
        sheet.add(".bubble_default_main", "cursor: default; font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".bubble_default_main_inner", 'border-radius: 5px; padding: 4px;color: #666;background: #eeeeee; background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");border: 1px solid #ccc;-moz-border-radius: 5px;-webkit-border-radius: 5px;border-radius: 5px;-moz-box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);-webkit-box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);');
        sheet.add(".bubble_default_arrow_top", 'fill: #ffffff; stroke: #cccccc; stroke-width: 1;');
        sheet.add(".bubble_default_arrow_bottom", 'fill: #eeeeee; stroke: #cccccc; stroke-width: 2;');
        sheet.add(".bubble_default_arrow_left", 'fill: #ffffff; stroke: #cccccc; stroke-width: 1;');
        sheet.add(".bubble_default_arrow_right", 'fill: #ffffff; stroke: #cccccc; stroke-width: 1;');

        // calendar
        // sheet.add(".calendar_default_main", "border: 1px solid #999; font-family: Tahoma, Arial, Helvetica, sans-serif; font-size: 12px;");
        sheet.add(".calendar_default_main", "border: 1px solid #c0c0c0; font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".calendar_default_main *, .calendar_default_main *:before, .calendar_default_main *:after", "box-sizing: content-box;");  // bootstrap
        sheet.add(".calendar_default_rowheader_inner,.calendar_default_cornerright_inner,.calendar_default_corner_inner,.calendar_default_colheader_inner,.calendar_default_alldayheader_inner", "color: #333;background: #f3f3f3;");
        sheet.add(".calendar_default_colheader_back", "background: #f3f3f3; border-bottom: 1px solid red;");
        sheet.add(".calendar_default_colheader_back_inner", "position: absolute; inset: 0; border-bottom: 1px solid #c0c0c0;");
        sheet.add(".calendar_default_cornerright_inner", "position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px; border-bottom: 1px solid #c0c0c0;");
        sheet.add(".calendar_default_direction_rtl .calendar_default_cornerright_inner", "border-right: 1px solid #c0c0c0;");
        sheet.add(".calendar_default_rowheader_inner", "font-size: 16pt;text-align: right; position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0; padding: 3px;");
        sheet.add(".calendar_default_direction_rtl .calendar_default_rowheader_inner", "border-right: none;");
        sheet.add(".calendar_default_corner_inner", "position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;");
        sheet.add(".calendar_default_direction_rtl .calendar_default_corner_inner", "border-right: none;");
        sheet.add(".calendar_default_rowheader_minutes", "font-size:10px;vertical-align: super;padding-left: 2px;padding-right: 2px;");
        sheet.add(".calendar_default_colheader_inner", "position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0; display: flex; align-items: center; justify-content: center;");
        sheet.add(".calendar_default_cell_inner", "position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #ddd;border-bottom: 1px solid #ddd; background: #f9f9f9;");
        sheet.add(".calendar_default_cell_business .calendar_default_cell_inner", "background: #fff");
        sheet.add(".calendar_default_alldayheader_inner", "text-align: center;position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;");
        sheet.add(".calendar_default_message", "opacity: 0.9; padding: 10px; color: #ffffff;background: #ffa216;");
        sheet.add(".calendar_default_alldayevent_inner,.calendar_default_event_inner", 'color: #333; border: 1px solid #999;'); // border-top: 4px solid #1066a8;
        sheet.add(".calendar_default_event_bar", "top: 0px;bottom: 0px;left: 0px;width: 6px;background-color: #9dc8e8;");
        sheet.add(".calendar_default_event_bar_inner", "position: absolute;width: 6px;background-color: #1066a8;");
        sheet.add(".calendar_default_alldayevent_inner,.calendar_default_event_inner", 'background: #fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".calendar_default_selected .calendar_default_event_inner", "background: #ddd;");
        // sheet.add(".calendar_default_alldayevent_inner", "position: absolute;top: 2px;bottom: 2px;left: 2px;right: 2px;overflow:hidden;padding: 4px;margin-right: 1px; display: flex; align-items: center;");
        sheet.add(".calendar_default_alldayevent_inner", "position: absolute;top: 0px;bottom: 0px;left: 0px;right: 0px;overflow:hidden;padding: 4px;margin-right: 0px; display: flex; align-items: center;");
        sheet.add(".calendar_default_event_withheader .calendar_default_event_inner", "padding-top: 15px;");
        sheet.add(".calendar_default_event", "cursor: default;");
        sheet.add(".calendar_default_event_inner", "position: absolute;overflow: hidden;top: 0px;bottom: 0px;left: 0px;right: 0px;padding: 2px 2px 2px 8px;");
        sheet.add(".calendar_default_shadow_inner", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;background-color: #666666; opacity: 0.5;");
        sheet.add(".calendar_default_event_delete", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAI5JREFUKFNtkLERgCAMRbmzdK8s4gAUlhYOYEHJEJYOYOEwDmGBPxC4kOPfvePy84MGR0RJ2N1A8H3N6DATwSQ57m2ql8NBG+AEM7D+UW+wjdfUPgerYNgB5gOLRHqhcasg84C2QxPMtrUhSqQIhg7ypy9VM2EUZPI/4rQ7rGxqo9sadTegw+UdjeDLAKUfhbaQUVPIfJYAAAAASUVORK5CYII=) center center no-repeat; opacity: 0.6; cursor: pointer;");
        sheet.add(".calendar_default_event_delete:hover", "opacity: 1;-ms-filter: none;");
        sheet.add(".calendar_default_scroll_up", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAB3RJTUUH2wESDiYcrhwCiQAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAARnQU1BAACxjwv8YQUAAACcSURBVHjaY2AgF9wWsTW6yGMlhi7OhC7AyMDQzMnBXIpFHAFuCtuaMTP+P8nA8P/b1x//FfW/HHuF1UQmxv+NUP1c3OxMVVhNvCVi683E8H8LXOY/w9+fTH81tF8fv4NiIpBRj+YoZtZ/LDUoJmKYhsVUpv0MDiyMDP96sIYV0FS2/8z9ICaLlOhvS4b/jC//MzC8xBG0vJeF7GQBlK0xdiUzCtsAAAAASUVORK5CYII=);");
        sheet.add(".calendar_default_scroll_down", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAACqSURBVChTY7wpam3L9J+xmQEP+PGPKZZxP4MDi4zI78uMDIwa2NT+Z2DYovrmiC+TI8OBP/8ZmEqwGvif4e8vxr+FIDkmEKH25vBWBgbG0+iK/zEwLtF+ffwOXCGI8Y+BoRFFIdC030x/WmBiYBNhpgLdswNJ8RSYaSgmgk39z1gPUfj/29ef/9rwhQTDHRHbrbdEbLvRFcGthkkAra/9/uMvhkK8piNLAgCRpTnNn4AEmAAAAABJRU5ErkJggg==);");

        sheet.add(".calendar_default_now", "background-color: red;");
        sheet.add(".calendar_default_now:before", "content: ''; top: -5px; border-width: 5px; border-color: transparent transparent transparent red; border-style: solid; width: 0px; height:0px; position: absolute; -moz-transform: scale(.9999);");

        // 2017-09-12
        sheet.add(".calendar_default_shadow_forbidden .calendar_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".calendar_default_shadow_top", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".calendar_default_shadow_bottom", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');

        // 2018-03-12
        sheet.add(".calendar_default_crosshair_vertical, .calendar_default_crosshair_horizontal, .calendar_default_crosshair_left, .calendar_default_crosshair_top", "background-color: gray; opacity: 0.2;");
        sheet.add(".calendar_default_loading", "background-color: orange; color: white; padding: 2px;");

        // 2018-03-20
        sheet.add(".calendar_default_scroll", "background-color: #f3f3f3;");

        // 2023-01-10
        //sheet.add(".calendar_default_alldayevent_inner", "position: absolute;top: 0px;bottom: 0px;left: 0px;right: 0px;overflow:hidden;padding: 4px;margin-right: 0px; display: flex; align-items: center;");


        // 2019-05-28
        // vertical centering
        // sheet.add(".calendar_default_colheader_inner", "position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0; display: flex; align-items: center; justify-content: center;");
        // padding added
        // sheet.add(".calendar_default_rowheader_inner", "font-size: 16pt;text-align: right; position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0; padding: 3px;");

        // 2020-03-09 RTL

        // 2021-03-02
        sheet.add(".calendar_default_event_moving_source", "opacity: 0.5;");

        // 2022-06-24
        sheet.add(".calendar_default_colmove_handle", "background-repeat: no-repeat; background-position: center center; background-color: #ccc; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAKCAYAAACT+/8OAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAClJREFUGFdj+P//P4O9vX2Bg4NDP4gNFgBytgPxebgAMsYuQGMz/jMAAFsTZDPYJlDHAAAAAElFTkSuQmCC); cursor: move;");
        sheet.add(".calendar_default_colheader:hover .calendar_default_colheader_splitter", "background-color: #c0c0c0;");

        sheet.add(".calendar_default_colmove_source", "background-color: black; opacity: 0.5;");

        sheet.add(".calendar_default_colmove_position_before", "box-sizing: border-box; border-left: 2px solid #999999;");
        sheet.add(".calendar_default_colmove_position_before:before", "content: ''; border-width: 6px; border-color: transparent #999999 transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".calendar_default_colmove_position_after", "box-sizing: border-box; border-right: 2px solid #999999;");
        sheet.add(".calendar_default_colmove_position_after:before", "content: ''; border-width: 6px; border-color: transparent transparent transparent #999999; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".calendar_default_colmove_position_child", "box-sizing: border-box; border-bottom: 2px solid #999999;");
        sheet.add(".calendar_default_colmove_position_child:before", "content: ''; border-width: 6px; border-color: #999999 transparent transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        // sheet.add(".calendar_default_colmove_position_forbidden:before", "content: 'X'; color: red; position: absolute;");
        sheet.add(".calendar_default_colmove_position_forbidden", "border-top: 2px solid red;");

/*
        sheet.add(".calendar_default_colmove_position_forbidden", "background-color: red; height: 2px; margin-left: 10px;");
        sheet.add(".calendar_default_colmove_position_forbidden:before", "content: 'x'; color: red; position: absolute; top: -8px; left: -10px;");
*/

        sheet.add(".calendar_default_colheader .calendar_default_colheader_splitter:hover", "background-color: #999999;");


        // 2021-10-28, vertical centering of all-day events, padding increased
        // sheet.add(".calendar_default_alldayevent_inner", "position: absolute;top: 2px;bottom: 2px;left: 2px;right: 2px;overflow:hidden;padding: 4px;margin-right: 1px; display: flex; align-items: center;");

        // 2021-12-10: colheader_background
        // sheet.add(".calendar_default_colheader_back", "background: #f3f3f3; border-bottom: 1px solid red;");
        // sheet.add(".calendar_default_colheader_back_inner", "position: absolute; inset: 0; border-bottom: 1px solid #c0c0c0;");

        // 2022-05-19
        // sheet.add(".calendar_default_shadow_forbidden .calendar_default_shadow_inner", "background-color: #cc4125;");

        // menu
        sheet.add(".menu_default_main", "user-select:none; font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;font-size: 13px;border: 1px solid #dddddd;background-color: white;padding: 0px;cursor: default;background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAABCAIAAABG0om7AAAAKXRFWHRDcmVhdGlvbiBUaW1lAHBvIDEwIDUgMjAxMCAyMjozMzo1OSArMDEwMGzy7+IAAAAHdElNRQfaBQoUJAesj4VUAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAABVJREFUeNpj/P//PwO1weMnT2RlZAAYuwX/4oA3BgAAAABJRU5ErkJggg==);background-repeat: repeat-y;xborder-radius: 5px;-moz-box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);-webkit-box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);box-shadow:0px 2px 3px rgba(000,000,000,0.3),inset 0px 0px 2px rgba(255,255,255,0.8);");
        sheet.add(".menu_default_main, .menu_default_main *, .menu_default_main *:before, .menu_default_main *:after", "box-sizing: content-box;");
        sheet.add(".menu_default_title", "background-color: #f2f2f2;border-bottom: 1px solid gray;padding: 4px 4px 4px 37px;");
        sheet.add(".menu_default_main a", "padding: 2px 2px 2px 35px;color: black;text-decoration: none;cursor: default;");
        sheet.add(".menu_default_main.menu_default_withchildren a", "padding: 2px 35px 2px 35px;");
        sheet.add(".menu_default_main a img", "margin-left: 6px;margin-top: 2px;");
        sheet.add(".menu_default_item_text", "display: block;height: 20px;line-height: 20px; overflow:hidden;padding-left: 2px;padding-right: 20px; white-space: nowrap;");
        sheet.add(".menu_default_main a:hover", "background-color: #f3f3f3;");
        sheet.add(".menu_default_main div div", "border-top: 1px solid #dddddd;margin-top: 2px;margin-bottom: 2px;margin-left: 28px;");
        sheet.add(".menu_default_main a.menu_default_item_disabled", "color: #ccc");
        sheet.add(".menu_default_item_haschildren.menu_default_item_haschildren_active", 'background-color: #f3f3f3;');
        sheet.add(".menu_default_item_haschildren a:before", "content: ''; border-width: 5px; border-color: transparent transparent transparent #666; border-style: solid; width: 0px; height:0px; position: absolute; right: 5px; margin-top: 5px;");
        sheet.add(".menu_default_item_icon", "position: absolute; top:0px; left: 0px; padding: 2px 2px 2px 8px;");
        sheet.add(".menu_default_item a i", "height: 20px;line-height: 20px;");
        sheet.add(".menu_default_item .menu_default_item_symbol", "width: 18px; height: 18px; color: #999; margin-left: 6px;margin-top: 2px;");
        // sheet.add(".menu_default_item a svg", "width: 16px; height: 16px;");


        // menubar
        sheet.add(".menubar_default_main", "border-bottom: 1px solid #ccc; font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px; user-select:none;");
        sheet.add(".menubar_default_item", "display: inline-block;  padding: 6px 10px; cursor: default;");
        sheet.add(".menubar_default_item:hover", "background-color: #f2f2f2;");
        sheet.add(".menubar_default_item_active", "background-color: #f2f2f2;");

        // month
        sheet.add(".month_default_main", "border: 1px solid #c0c0c0;font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;color: #333;");
        sheet.add(".month_default_main *, .month_default_main *:before, .month_default_main *:after", "box-sizing: content-box;");
        sheet.add(".month_default_cell_inner", "border-right: 1px solid #ddd;border-bottom: 1px solid #ddd;position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;background-color: #f9f9f9;");
        sheet.add(".month_default_cell_business .month_default_cell_inner", "background-color: #fff;");
        sheet.add(".month_default_cell_header", "text-align: right; padding: 4px; box-sizing: border-box;");
        sheet.add(".month_default_header_inner", 'position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;cursor: default;color: #333;background: #f3f3f3; overflow:hidden; display: flex; align-items: center; justify-content: center;');
        sheet.add(".month_default_message", 'padding: 10px;opacity: 0.9; color: #ffffff;background: #ffa216;');
        sheet.add(".month_default_event_inner", 'position: absolute;top: 0px;bottom: 0px;left: 1px;right: 1px;overflow:hidden;padding: 2px;padding-left: 10px;color: #333;background: #fff;background: linear-gradient(to bottom, #ffffff 0%, #eeeeee);border: 1px solid #999;border-radius: 0px;display: flex; align-items: center;');
        sheet.add(".month_default_event_continueright .month_default_event_inner", "border-top-right-radius: 0px;border-bottom-right-radius: 0px;border-right-style: dotted;");
        sheet.add(".month_default_event_continueleft .month_default_event_inner", "border-top-left-radius: 0px;border-bottom-left-radius: 0px;border-left-style: dotted;");
        sheet.add(".month_default_event_bar", "top: 0px;bottom: 0px;left: 0px;width: 6px;");
        sheet.add(".month_default_event_bar_inner", "position: absolute;width: 6px;background-color: #1066a8;");
        sheet.add(".month_default_event_continueleft .month_default_event_bar", "display: none;");
        sheet.add(".month_default_selected .month_default_event_inner", "background: #ddd;");
        sheet.add(".month_default_shadow_inner", "background-color: #666666;opacity: 0.5;height: 100%;");
        sheet.add(".month_default_event_delete", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAI5JREFUKFNtkLERgCAMRbmzdK8s4gAUlhYOYEHJEJYOYOEwDmGBPxC4kOPfvePy84MGR0RJ2N1A8H3N6DATwSQ57m2ql8NBG+AEM7D+UW+wjdfUPgerYNgB5gOLRHqhcasg84C2QxPMtrUhSqQIhg7ypy9VM2EUZPI/4rQ7rGxqo9sadTegw+UdjeDLAKUfhbaQUVPIfJYAAAAASUVORK5CYII=) center center no-repeat; opacity: 0.6; cursor: pointer;");
        sheet.add(".month_default_event_delete:hover", "opacity: 1;-ms-filter: none;");
        sheet.add(".month_default_event_timeleft", "color: #ccc; font-size: 11px; display: flex; align-items: center;");
        sheet.add(".month_default_event_timeright", "color: #ccc; font-size: 11px; display: flex; align-items: center; justify-content: end;");

        // 2018-04-25
        sheet.add(".month_default_loading", "background-color: orange; color: white; padding: 2px;");

        // 2019-09-19
        // vertical centering
        //sheet.add(".month_default_header_inner", 'position: absolute;top: 0px;left: 0px;bottom: 0px;right: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;cursor: default;color: #333;background: #f3f3f3; overflow:hidden; display: flex; align-items: center; justify-content: center;');
        // sheet.add(".month_default_cell_header", "text-align: right;padding: 4px;");

        // 2019-12-10
        //sheet.add(".month_default_cell_header", "text-align: right; padding: 4px; box-sizing: border-box;");

        // 2020-07-27
        //sheet.add(".month_default_event_inner", 'position: absolute;top: 0px;bottom: 0px;left: 1px;right: 1px;overflow:hidden;padding: 2px;padding-left: 5px;font-size: 12px;color: #333;background: #fff;background: linear-gradient(to bottom, #ffffff 0%, #eeeeee);border: 1px solid #999;border-radius: 0px;display: flex; align-items: center;');

        // 2022-02-15
        // sheet.add(".month_default_event_bar", "top: 0px;bottom: 0px;left: 0px;width: 6px;");
        // sheet.add(".month_default_event_bar_inner", "position: absolute;width: 6px;background-color: #1066a8;");
        // sheet.add(".month_default_event_continueleft .month_default_event_bar", "display: none;");
        // nowrap
        // sheet.add(".month_default_event_inner", 'position: absolute;top: 0px;bottom: 0px;left: 1px;right: 1px;overflow:hidden;padding: 2px;padding-left: 10px;color: #333;background: #fff;background: linear-gradient(to bottom, #ffffff 0%, #eeeeee);border: 1px solid #999;border-radius: 0px;display: flex; align-items: center; white-space: nowrap;');
        // vertical alignment, font size
        // sheet.add(".month_default_event_timeleft", "color: #ccc; font-size: 11px; display: flex; align-items: center;");
        // sheet.add(".month_default_event_timeright", "color: #ccc; font-size: 11px; display: flex; align-items: center; justify-content: end;");

        // 2022-05-19
        // sheet.add(".month_default_shadow_forbidden .month_default_shadow_inner", "background-color: #a61c00;");
        sheet.add(".month_default_shadow_forbidden .month_default_shadow_inner", "background-color: #cc4125;");


        // navigator
        sheet.add(".navigator_default_main", "border-left: 1px solid #c0c0c0;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;background-color: white;color: #000000; box-sizing: content-box;");
        sheet.add(".navigator_default_main *, .navigator_default_main *:before, .navigator_default_main *:after", "box-sizing: content-box;");
        sheet.add(".navigator_default_month", "font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 12px;");
        sheet.add(".navigator_default_day", "color: black;");
        sheet.add(".navigator_default_weekend", "background-color: #f0f0f0;");
        sheet.add(".navigator_default_dayheader", "color: black;");
        sheet.add(".navigator_default_line", "border-bottom: 1px solid #c0c0c0;");
        sheet.add(".navigator_default_dayother", "color: gray;");
        sheet.add(".navigator_default_todaybox", "border: 1px solid red;");
        sheet.add(".navigator_default_title, .navigator_default_titleleft, .navigator_default_titleright", "border-top: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;color: #333;background: #f3f3f3;");
        sheet.add(".navigator_default_busy", "font-weight: bold;");
        sheet.add(".navigator_default_cell", "text-align: center;");
        sheet.add(".navigator_default_select .navigator_default_cell_box", "background-color: #FFE794; opacity: 0.5;");
        sheet.add(".navigator_default_title", "text-align: center;");
        sheet.add(".navigator_default_titleleft, .navigator_default_titleright", "text-align: center;");
        sheet.add(".navigator_default_dayheader", "text-align: center;");
        sheet.add(".navigator_default_weeknumber", "text-align: center; color: #999;");
        sheet.add(".navigator_default_cell_text", "cursor: pointer;");


        // scheduler

        sheet.add(".scheduler_default_main *, .scheduler_default_main *:before, .scheduler_default_main *:after", "box-sizing: content-box;");
        sheet.add(".scheduler_default_main", "box-sizing: content-box; border: 1px solid #c0c0c0;font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".scheduler_default_selected .scheduler_default_event_inner", "background: #ddd;");
        sheet.add(".scheduler_default_timeheader_scroll", "background: #f3f3f3;");
        sheet.add(".scheduler_default_message", "opacity: 0.9; padding: 10px; color: #ffffff; background: #ffa216;");
        sheet.add(".scheduler_default_timeheadergroup,.scheduler_default_timeheadercol", "color: #333;background: #f3f3f3;");
        sheet.add(".scheduler_default_rowheader,.scheduler_default_corner", "color: #333;background: #f3f3f3;");
        sheet.add(".scheduler_default_rowheader.scheduler_default_rowheader_selected", "background-color: #aaa; background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent); background-size: 20px 20px;");
        sheet.add(".scheduler_default_rowheader_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #e0e0e0;padding: 7px;display: flex; align-items: center;");
        sheet.add(".scheduler_default_timeheadergroup_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;display: flex; align-items: center; justify-content: center;");
        sheet.add(".scheduler_default_timeheadercol_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #c0c0c0;display: flex; align-items: center; justify-content: center;");
        sheet.add(".scheduler_default_timeheader_float", "display: flex; align-items: center; justify-content: center;");
        sheet.add(".scheduler_default_divider, .scheduler_default_splitter", "background-color: #c0c0c0;");
        sheet.add(".scheduler_default_divider_horizontal", "background-color: #c0c0c0;");
        sheet.add(".scheduler_default_matrix_vertical_line", "background-color: #eee;");
        sheet.add(".scheduler_default_matrix_vertical_break", "background-color: #999;");
        sheet.add(".scheduler_default_matrix_horizontal_line", "background-color: #eee;");
        sheet.add(".scheduler_default_resourcedivider", "background-color: #c0c0c0;");
        sheet.add(".scheduler_default_shadow_inner", "background-color: #666666;opacity: 0.5;height: 100%;");
        sheet.add(".scheduler_default_event", "font-size:13px;color:#333;");
        sheet.add(".scheduler_default_event_inner", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;padding:2px 2px 2px 2px;overflow:hidden;border:1px solid #ccc; display: flex; align-items: center;");
        sheet.add(".scheduler_default_event_bar", "top:0px;left:0px;right:0px;height:4px;background-color:#9dc8e8;");
        sheet.add(".scheduler_default_event_bar_inner", "position:absolute;height:4px;background-color:#1066a8;");
        sheet.add(".scheduler_default_event_inner", 'background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".scheduler_default_event_float", "display: flex; align-items: center;");
        sheet.add(".scheduler_default_event_float_inner", "padding:2px 2px 2px 8px; position: relative;"); // space for arrow
        sheet.add(".scheduler_default_event_float_inner:after", 'content:"";border-color: transparent #666 transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:5px;left:-4px;');
        sheet.add(".scheduler_default_event_focus", "outline: red 2px solid; z-index: 100; opacity: 0.5;");
        sheet.add(".scheduler_default_columnheader_inner", "font-weight: bold;");
        sheet.add(".scheduler_default_columnheader_splitter", "box-sizing: border-box; border-right: 1px solid #c0c0c0;");
        sheet.add(".scheduler_default_columnheader_splitter:hover", "background-color: #c0c0c0;");
        sheet.add(".scheduler_default_columnheader_cell_inner", "position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; padding: 2px; display: flex; align-items: center;");
        sheet.add(".scheduler_default_cell", "background-color: #f9f9f9;");
        sheet.add(".scheduler_default_cell.scheduler_default_cell_business", "background-color: #fff;");
        sheet.add(".scheduler_default_cell.scheduler_default_cell_business.scheduler_default_cell_selected,.scheduler_default_cell.scheduler_default_cell_selected", "background-color: #ccc; background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent); background-size: 20px 20px;");
        sheet.add(".scheduler_default_tree_image_no_children", "");
        // <svg xmlns='http://www.w3.org/2000/svg'><path d='M 1.5 0.5 L 6.5 5 L 1.5 9.5' style='fill:none;stroke:#999999;stroke-width:2;stroke-linejoin:round;stroke-linecap:butt' /></svg>
        sheet.add(".scheduler_default_tree_image_expand", "background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjxwYXRoIGQ9J00gMS41IDAuNSBMIDYuNSA1IEwgMS41IDkuNScgc3R5bGU9J2ZpbGw6bm9uZTtzdHJva2U6Izk5OTk5OTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWxpbmVjYXA6YnV0dCcgLz48L3N2Zz4=);");
        // <svg width='10' height='10' xmlns='http://www.w3.org/2000/svg'><path d='M 0.5 1.5 L 5 6.5 L 9.5 1.5' style='fill:none;stroke:#999999;stroke-width:2;stroke-linejoin:round;stroke-linecap:butt' /></svg>
        sheet.add(".scheduler_default_tree_image_collapse", "background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTSAwLjUgMS41IEwgNSA2LjUgTCA5LjUgMS41JyBzdHlsZT0nZmlsbDpub25lO3N0cm9rZTojOTk5OTk5O3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpidXR0JyAvPjwvc3ZnPg==);");
        // <svg width='12' height='12' xmlns='http://www.w3.org/2000/svg'><path d='M 0.5 0.5 L 11.5 11.5 M 0.5 11.5 L 11.5 0.5' style='fill:none;stroke:#464646;stroke-width:3;stroke-linejoin:round;stroke-linecap:butt' /></svg>
        sheet.add(".scheduler_default_event_delete", "background: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTInIGhlaWdodD0nMTInIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTSAwLjUgMC41IEwgMTEuNSAxMS41IE0gMC41IDExLjUgTCAxMS41IDAuNScgc3R5bGU9J2ZpbGw6bm9uZTtzdHJva2U6IzQ2NDY0NjtzdHJva2Utd2lkdGg6MztzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWxpbmVjYXA6YnV0dCcgLz48L3N2Zz4=) no-repeat center center; opacity: 0.6; cursor: pointer;");
        sheet.add(".scheduler_default_event_delete:hover", "opacity: 1;");
        sheet.add(".scheduler_default_rowmove_handle", "background-repeat: no-repeat; background-position: center center; background-color: #ccc; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAKCAYAAACT+/8OAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAClJREFUGFdj+P//P4O9vX2Bg4NDP4gNFgBytgPxebgAMsYuQGMz/jMAAFsTZDPYJlDHAAAAAElFTkSuQmCC); cursor: move;");
        sheet.add(".scheduler_default_rowmove_source", "background-color: black; opacity: 0.2;");
        sheet.add(".scheduler_default_rowmove_position_before, .scheduler_default_rowmove_position_after", "background-color: #999; height: 2px;");
        sheet.add(".scheduler_default_rowmove_position_child", "margin-left: 10px; background-color: #999; height: 2px;");
        sheet.add(".scheduler_default_rowmove_position_child:before", "content: '+'; color: #999; position: absolute; top: -8px; left: -10px;");
        sheet.add(".scheduler_default_rowmove_position_forbidden", "background-color: red; height: 2px; margin-left: 10px;");
        sheet.add(".scheduler_default_rowmove_position_forbidden:before", "content: 'x'; color: red; position: absolute; top: -8px; left: -10px;");
        sheet.add(".scheduler_default_link_horizontal", "border-bottom-style: solid; border-bottom-color: #cc0000");
        sheet.add(".scheduler_default_link_vertical", "border-right-style: solid; border-right-color: #cc0000");
        sheet.add(".scheduler_default_link_arrow_right:before", "content: ''; border-width: 6px; border-color: transparent transparent transparent #cc0000; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".scheduler_default_link_arrow_left:before", "content: ''; border-width: 6px; border-color: transparent #cc0000 transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".scheduler_default_link_arrow_down:before", "content: ''; border-width: 6px; border-color: #cc0000 transparent transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".scheduler_default_link_arrow_up:before", "content: ''; border-width: 6px; border-color: transparent transparent #cc0000 transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".scheduler_default_shadow_overlap .scheduler_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".scheduler_default_block", "background-color: #808080; opacity: 0.5;");
        sheet.add(".scheduler_default_main .scheduler_default_event_group", "box-sizing: border-box; font-size:13px; color:#666; padding:2px; overflow:hidden; border:1px solid #ccc; background-color: #fff; display: flex; align-items: center; white-space: nowrap;");
        sheet.add(".scheduler_default_main .scheduler_default_header_icon", "box-sizing: border-box; border: 1px solid #c0c0c0; background-color: #f5f5f5; color: #000;");
        sheet.add(".scheduler_default_header_icon:hover", "background-color: #ccc;");
        sheet.add(".scheduler_default_header_icon_hide:before", "content: '\\00AB';");
        sheet.add(".scheduler_default_header_icon_show:before", "content: '\\00BB';");
        sheet.add(".scheduler_default_row_new .scheduler_default_rowheader_inner", "padding-left: 10px; color: #666; cursor: text; background-position: 0px 50%; background-repeat: no-repeat; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABUSURBVChTY0ACslAaK2CC0iCQDMSlECYmQFYIAl1AjFUxukIQwKoYm0IQwFCMSyEIaEJpMMClcD4Qp0CYEIBNIUzRPzAPCtAVYlWEDgyAGIdTGBgAbqEJYyjqa3oAAAAASUVORK5CYII=);");
        sheet.add(".scheduler_default_row_new .scheduler_default_rowheader_inner:hover", "background: white; color: white;");
        sheet.add(".scheduler_default_rowheader textarea", "padding: 3px;");
        sheet.add(".scheduler_default_rowheader_scroll", "cursor: default; background: #f3f3f3;");
        sheet.add(".scheduler_default_shadow_forbidden .scheduler_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".scheduler_default_shadow_invalid .scheduler_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".scheduler_default_event_moving_source", "opacity: 0.5;");
        sheet.add(".scheduler_default_linkpoint", "background-color: white; border: 1px solid gray; border-radius: 5px;");
        sheet.add(".scheduler_default_linkpoint.scheduler_default_linkpoint_hover", "background-color: black;");
        sheet.add(".scheduler_default_event.scheduler_default_event_version .scheduler_default_event_inner", "overflow:hidden; background-color: #cfdde8;background-image: -webkit-gradient(linear, 0 100%, 100% 0,	color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".scheduler_default_crosshair_vertical, .scheduler_default_crosshair_horizontal, .scheduler_default_crosshair_left, .scheduler_default_crosshair_top", "background-color: gray; opacity: 0.2;");
        sheet.add(".scheduler_default_link_dot", "border-radius: 10px; background-color: #cc0000");
        sheet.add(".scheduler_default_task_milestone .scheduler_default_event_inner", "position:absolute;top:16%;left:16%;right:16%;bottom:16%; background: #38761d; border: 0px none; -webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);-ms-transform: rotate(45deg);-o-transform: rotate(45deg); transform: rotate(45deg); filter: none;");
        sheet.add(".scheduler_default_event_left", "white-space: nowrap; color: #666; cursor: default; display: flex; align-items: center;");
        sheet.add(".scheduler_default_event_right", "white-space: nowrap; color: #666; cursor: default; display: flex; align-items: center;");
        sheet.add(".scheduler_default_main:focus", "outline: none;");
        sheet.add(".scheduler_default_cell_focus", "outline: red 2px solid; outline-offset: -2px; z-index: 100; opacity: 0.5;");
        sheet.add(".scheduler_default_cell_focus.scheduler_default_cell_focus_top", "border-top: 4px solid red;");
        sheet.add(".scheduler_default_cell_focus.scheduler_default_cell_focus_bottom", "border-bottom: 4px solid red;");
        sheet.add(".scheduler_default_selectionrectangle", "background-color: #0000ff; border: 1px solid #000033; opacity: 0.4;");
        sheet.add(".scheduler_default_link_shadow", "border:1px solid black;");
        sheet.add(".scheduler_default_link_shadow_circle", "background-color:black;");
        sheet.add(".scheduler_default_event_move_left",  'box-sizing: border-box; padding: 2px; border: 1px solid #ccc; background: #fff; background: linear-gradient(to bottom, #ffffff 0%, #eeeeee); display: flex; align-items: center;');
        sheet.add(".scheduler_default_event_move_right", 'box-sizing: border-box; padding: 2px; border: 1px solid #ccc; background: #fff; background: linear-gradient(to bottom, #ffffff 0%, #eeeeee); display: flex; align-items: center;');
        sheet.add(".scheduler_default_link_hover", "box-shadow: 0px 0px 2px 2px rgba(255, 0, 0, 0.3)");
        sheet.add(".scheduler_default_sorticon", "opacity: 0.2;background-position: center center; background-repeat: no-repeat; cursor: pointer;");
        sheet.add(".scheduler_default_sorticon.scheduler_default_sorticon_asc", "background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBvbHlnb24gcG9pbnRzPSI1IDEuNSwgMTAgMTAsIDAgMTAiLz48L3N2Zz4=');");
        sheet.add(".scheduler_default_sorticon.scheduler_default_sorticon_desc", "background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAiIGhlaWdodD0iMTAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBvbHlnb24gcG9pbnRzPSI1IDguNSwgMCAwLCAxMCAwIi8+PC9zdmc+');");
        sheet.add(".scheduler_default_sorticon.scheduler_default_sorticon_active", "opacity: 1;");
        sheet.add(".scheduler_default_loading", "background-color: orange; color: white; padding: 2px;");

        // 2021-10-13: floating arrow vertical position fixed
        //sheet.add(".scheduler_default_event_float_inner:after", 'content:"";border-color: transparent #666 transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:5px;left:-4px;');
        // 2021-10-24: duration bar position
        //sheet.add(".scheduler_default_event_bar", "top:1px;left:1px;right:1px;height:4px;background-color:#9dc8e8;");
        // 2021-12-23
        // sheet.add(".scheduler_default_event_left", "white-space: nowrap; color: #666; cursor: default; display: flex; align-items: center;");
        // sheet.add(".scheduler_default_event_right", "white-space: nowrap; color: #666; cursor: default; display: flex; align-items: center;");

        // 2022-05-19
        // sheet.add(".scheduler_default_shadow_forbidden .scheduler_default_shadow_inner", "background-color: #cc4125;");
        // sheet.add(".scheduler_default_shadow_invalid .scheduler_default_shadow_inner", "background-color: #cc4125;");


        // gantt
        sheet.add(".gantt_default_selected .gantt_default_event_inner", "background: #ddd;");
        sheet.add(".gantt_default_main", "border: 1px solid #c0c0c0;font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".gantt_default_main *, .gantt_default_main *:before, .gantt_default_main *:after", "box-sizing: content-box;");
        sheet.add(".gantt_default_timeheader", "cursor: default;color: #666;");
        sheet.add(".gantt_default_message", "opacity: 0.9;padding: 10px; color: #ffffff;background: #ffa216;");
        sheet.add(".gantt_default_timeheadergroup,.gantt_default_timeheadercol", "color: #333;background: #f3f3f3;");
        sheet.add(".gantt_default_rowheader,.gantt_default_corner", "color: #333;background: #f3f3f3;");
        sheet.add(".gantt_default_rowheader.gantt_default_rowheader_selected", "background-color: #aaa;background-image: -webkit-gradient(linear, 0 100%, 100% 0,color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".gantt_default_rowheader_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #e0e0e0;padding: 7px;display: flex; align-items: center;");
        sheet.add(".gantt_default_timeheadergroup_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;display: flex; align-items: center; justify-content: center;");
        sheet.add(".gantt_default_timeheadercol_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #c0c0c0;display: flex; align-items: center; justify-content: center;");
        sheet.add(".gantt_default_timeheader_float", "display: flex; align-items: center; justify-content: center;");
        sheet.add(".gantt_default_divider, .gantt_default_splitter", "background-color: #c0c0c0;");
        sheet.add(".gantt_default_divider_horizontal", "background-color: #c0c0c0;");
        sheet.add(".gantt_default_matrix_vertical_line", "background-color: #eee;");
        sheet.add(".gantt_default_matrix_vertical_break", "background-color: #000;");
        sheet.add(".gantt_default_matrix_horizontal_line", "background-color: #eee;");
        sheet.add(".gantt_default_resourcedivider", "background-color: #c0c0c0;");
        sheet.add(".gantt_default_shadow_inner", "background-color: #666666;opacity: 0.5;height: 100%;");
        sheet.add(".gantt_default_event", "color:#666;");
        sheet.add(".gantt_default_event_inner", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;padding:2px 2px 2px 2px;overflow:hidden;border:1px solid #ccc; display: flex; align-items: center;");
        sheet.add(".gantt_default_event_bar", "top:0px;left:0px;right:0px;height:4px;background-color:#9dc8e8;");
        sheet.add(".gantt_default_event_bar_inner", "position:absolute;height:4px;background-color:#1066a8;");
        sheet.add(".gantt_default_event_inner", 'background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".gantt_default_event_float_inner", "padding:6px 2px 2px 8px;"); // space for arrow
        sheet.add(".gantt_default_event_float_inner:after", 'content:"";border-color: transparent #666 transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:8px;left:-4px;');
        sheet.add(".gantt_default_columnheader_inner", "font-weight: bold;");
        sheet.add(".gantt_default_columnheader_splitter", "background-color: #666;opacity: 0.5;");
        sheet.add(".gantt_default_columnheader_cell_inner", "position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; padding: 2px; display: flex; align-items: center;");
        sheet.add(".gantt_default_cell", "background-color: #f9f9f9;");
        sheet.add(".gantt_default_cell.gantt_default_cell_business", "background-color: #fff;");
        sheet.add(".gantt_default_cell.gantt_default_cell_business.gantt_default_cell_selected,.gantt_default_cell.gantt_default_cell_selected", "background-color: #ccc;background-image: -webkit-gradient(linear, 0 100%, 100% 0,	color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".gantt_default_tree_image_no_children", "");
        // <svg xmlns='http://www.w3.org/2000/svg'><path d='M 1.5 0.5 L 6.5 5 L 1.5 9.5' style='fill:none;stroke:#999999;stroke-width:2;stroke-linejoin:round;stroke-linecap:butt' /></svg>
        sheet.add(".gantt_default_tree_image_expand", "background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjxwYXRoIGQ9J00gMS41IDAuNSBMIDYuNSA1IEwgMS41IDkuNScgc3R5bGU9J2ZpbGw6bm9uZTtzdHJva2U6Izk5OTk5OTtzdHJva2Utd2lkdGg6MjtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWxpbmVjYXA6YnV0dCcgLz48L3N2Zz4=);");
        // <svg width='10' height='10' xmlns='http://www.w3.org/2000/svg'><path d='M 0.5 1.5 L 5 6.5 L 9.5 1.5' style='fill:none;stroke:#999999;stroke-width:2;stroke-linejoin:round;stroke-linecap:butt' /></svg>
        sheet.add(".gantt_default_tree_image_collapse", "background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTSAwLjUgMS41IEwgNSA2LjUgTCA5LjUgMS41JyBzdHlsZT0nZmlsbDpub25lO3N0cm9rZTojOTk5OTk5O3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpidXR0JyAvPjwvc3ZnPg==);");
        sheet.add(".gantt_default_event_move_left", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".gantt_default_event_move_right", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".gantt_default_event_delete", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAI5JREFUKFNtkLERgCAMRbmzdK8s4gAUlhYOYEHJEJYOYOEwDmGBPxC4kOPfvePy84MGR0RJ2N1A8H3N6DATwSQ57m2ql8NBG+AEM7D+UW+wjdfUPgerYNgB5gOLRHqhcasg84C2QxPMtrUhSqQIhg7ypy9VM2EUZPI/4rQ7rGxqo9sadTegw+UdjeDLAKUfhbaQUVPIfJYAAAAASUVORK5CYII=) center center no-repeat; opacity: 0.6; cursor: pointer;");
        sheet.add(".gantt_default_event_delete:hover", "opacity: 1;-ms-filter: none;");
        sheet.add(".gantt_default_rowmove_handle", "background-repeat: no-repeat; background-position: center center; background-color: #ccc; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAKCAYAAACT+/8OAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAClJREFUGFdj+P//P4O9vX2Bg4NDP4gNFgBytgPxebgAMsYuQGMz/jMAAFsTZDPYJlDHAAAAAElFTkSuQmCC); cursor: move;");
        sheet.add(".gantt_default_rowmove_source", "background-color: black; opacity: 0.2;");
        sheet.add(".gantt_default_rowmove_position_before, .gantt_default_rowmove_position_after", "background-color: #999; height: 2px;");
        sheet.add(".gantt_default_rowmove_position_child", "margin-left: 10px; background-color: #999; height: 2px;");
        sheet.add(".gantt_default_rowmove_position_child:before", "content: '+'; color: #999; position: absolute; top: -8px; left: -10px;");
        sheet.add(".gantt_default_rowmove_position_forbidden", "background-color: red; height: 2px; margin-left: 10px;");
        sheet.add(".gantt_default_rowmove_position_forbidden:before", "content: 'x'; color: red; position: absolute; top: -8px; left: -10px;");
        sheet.add(".gantt_default_task_group .gantt_default_event_inner", "position:absolute;top:5px;left:0px;right:0px;bottom:6px;overflow:hidden; background: #0b5394; filter: none; border: 0px none;");
        sheet.add(".gantt_default_task_group.gantt_default_event:before", "content:''; border-color: transparent transparent transparent #0b5394; border-style: solid; border-width: 6px; position: absolute; bottom: 0px;");
        sheet.add(".gantt_default_task_group.gantt_default_event:after", "content:''; border-color: transparent #0b5394 transparent transparent; border-style: solid; border-width: 6px; position: absolute; bottom: 0px; right: 0px;");
        sheet.add(".gantt_default_task_milestone .gantt_default_event_inner", "position:absolute;top:16%;left:16%;right:16%;bottom:16%; background: #38761d; border: 0px none; -webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);-ms-transform: rotate(45deg);-o-transform: rotate(45deg); transform: rotate(45deg); filter: none;");
        sheet.add(".gantt_default_browser_ie8 .gantt_default_task_milestone .gantt_default_event_inner", "-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(SizingMethod='auto expand', M11=0.7071067811865476, M12=-0.7071067811865475, M21=0.7071067811865475, M22=0.7071067811865476);\"");
        sheet.add(".gantt_default_event_left", "white-space: nowrap; color: #666; cursor: default;  display: flex; align-items: center;");
        sheet.add(".gantt_default_event_right", "white-space: nowrap; color: #666; cursor: default;  display: flex; align-items: center;");
        sheet.add(".gantt_default_link_horizontal", "border-bottom-style: solid; border-bottom-color: #cc0000;");
        sheet.add(".gantt_default_link_vertical", "border-right-style: solid; border-right-color: #cc0000;");
        sheet.add(".gantt_default_link_arrow_right:before", "content: ''; border-width: 6px; border-color: transparent transparent transparent #cc0000; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".gantt_default_link_arrow_left:before", "content: ''; border-width: 6px; border-color: transparent #cc0000 transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".gantt_default_link_arrow_down:before", "content: ''; border-width: 6px; border-color: #cc0000 transparent transparent transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".gantt_default_link_arrow_up:before", "content: ''; border-width: 6px; border-color: transparent transparent #cc0000 transparent; border-style: solid; width: 0px; height:0px; position: absolute;");
        sheet.add(".gantt_default_shadow_overlap .gantt_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".gantt_default_block", "background-color: gray; opacity: 0.5;");
        sheet.add(".gantt_default_link_hover", "box-shadow: 0px 0px 2px 2px rgba(255, 0, 0, 0.3)");
        sheet.add(".gantt_default_main .gantt_default_header_icon", "box-sizing: border-box; border: 1px solid #aaa; background-color: #f5f5f5; color: #000;");
        sheet.add(".gantt_default_header_icon:hover", "background-color: #ccc;");
        sheet.add(".gantt_default_header_icon_hide:before", "content: '\\00AB';");
        sheet.add(".gantt_default_header_icon_show:before", "content: '\\00BB';");
        sheet.add(".gantt_default_row_new .gantt_default_rowheader_inner", "cursor: text; background-position: 0 50%; background-repeat: no-repeat; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABUSURBVChTY0ACslAaK2CC0iCQDMSlECYmQFYIAl1AjFUxukIQwKoYm0IQwFCMSyEIaEJpMMClcD4Qp0CYEIBNIUzRPzAPCtAVYlWEDgyAGIdTGBgAbqEJYyjqa3oAAAAASUVORK5CYII=);");
        sheet.add(".gantt_default_row_new .gantt_default_rowheader_inner:hover", "background: white;");
        sheet.add(".gantt_default_rowheader textarea", "padding: 5px;");
        sheet.add(".gantt_default_rowheader_scroll", "cursor: default; background: #f3f3f3;");
        sheet.add(".gantt_default_shadow_forbidden .gantt_default_shadow_inner", "background-color: #cc4125;");
        sheet.add(".gantt_default_event_moving_source", "opacity: 0.5;");
        sheet.add(".gantt_default_event.gantt_default_event_version .gantt_default_event_inner", "background-color: #cfdde8;background-image: -webkit-gradient(linear, 0 100%, 100% 0,	color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".gantt_default_task_group.gantt_default_event_continueleft.gantt_default_event:before", "border:0;");
        sheet.add(".gantt_default_task_group.gantt_default_event_continueleft.gantt_default_event .gantt_default_event_inner:before", 'content:"";border-color: transparent #fff transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:2px;left:-4px;');
        sheet.add(".gantt_default_event_continueleft.gantt_default_event .gantt_default_event_inner", "padding-left: 8px;");
        sheet.add(".gantt_default_event_continueleft.gantt_default_event .gantt_default_event_inner:before", 'content:"";border-color: transparent #000 transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:7px;left:-4px;');
        sheet.add(".gantt_default_task_group.gantt_default_event_continueright.gantt_default_event:after", "border:0;");
        sheet.add(".gantt_default_task_group.gantt_default_event_continueright.gantt_default_event .gantt_default_event_inner:after", 'content:"";border-color: transparent transparent transparent #fff;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:2px;right:-2px;');
        sheet.add(".gantt_default_event_continueright.gantt_default_event .gantt_default_event_inner", "padding-right: 8px;");
        sheet.add(".gantt_default_event_continueright.gantt_default_event .gantt_default_event_inner:after", 'content:"";border-color: transparent transparent transparent #000;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:7px;right:-2px;');
        sheet.add(".gantt_default_linkpoint", "background-color: white; border: 1px solid gray; border-radius: 5px;");
        sheet.add(".gantt_default_linkpoint.gantt_default_linkpoint_hover", "background-color: black;");
        sheet.add(".gantt_default_crosshair_vertical, .gantt_default_crosshair_horizontal, .gantt_default_crosshair_left, .gantt_default_crosshair_top", "background-color: gray; opacity: 0.2; ");
        sheet.add(".gantt_default_selectionrectangle", "background-color: #0000ff; border: 1px solid #000033; opacity: 0.4;");
        sheet.add(".gantt_default_link_shadow", "border:1px solid black;");
        sheet.add(".gantt_default_link_shadow_circle", "background-color:black;");
        sheet.add(".gantt_default_link_hover", "box-shadow: 0px 0px 2px 2px rgba(255, 0, 0, 0.3)");


        // 2020-07-29
        // link color: red --> #cc0000
        // task group color: #1155cc --> #0b5394

        // 2022-05-10
        // sheet.add(".gantt_default_shadow_forbidden .gantt_default_shadow_inner", "background-color: #cc4125;");

        // 2022-07-09 padding removed:
        // sheet.add(".gantt_default_event_left", "white-space: nowrap; color: #666; cursor: default;  display: flex; align-items: center;");
        // sheet.add(".gantt_default_event_right", "white-space: nowrap; color: #666; cursor: default;  display: flex; align-items: center;");


        // kanban
        // scheduler
        sheet.add(".kanban_default_main *, .kanban_default_main *:before, .kanban_default_main *:after", "box-sizing: content-box;");
        sheet.add(".kanban_default_main", "box-sizing: content-box; border: 1px solid #c0c0c0;font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".kanban_default_selected .kanban_default_event_inner", "background: #ddd;");
        sheet.add(".kanban_default_timeheader", "cursor: default;color: #333;");
        sheet.add(".kanban_default_message", "opacity: 0.9;padding: 10px; color: #ffffff;background: #ffa216;");
        sheet.add(".kanban_default_colheadercell", "color: #333;background: #f3f3f3;");
        sheet.add(".kanban_default_rowheader,.kanban_default_corner", "color: #333;background: #f3f3f3;");
        sheet.add(".kanban_default_rowheader.kanban_default_rowheader_selected", "background-color: #aaa;background-image: -webkit-gradient(linear, 0 100%, 100% 0,color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".kanban_default_rowheader_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #f3f3f3;padding: 2px;");
        sheet.add(".kanban_default_colheadercell", "text-align: center;");
        sheet.add(".kanban_default_colheadercell_inner", "position: absolute;left: 0px;right: 0px;top: 0px;bottom: 0px;border-right: 1px solid #c0c0c0;");
        sheet.add(".kanban_default_divider, .kanban_default_splitter", "background-color: #c0c0c0;");
        sheet.add(".kanban_default_divider_horizontal", "background-color: #c0c0c0;");
        sheet.add(".kanban_default_matrix_vertical_line", "background-color: #eee;");
        sheet.add(".kanban_default_matrix_vertical_break", "background-color: #000;");
        sheet.add(".kanban_default_matrix_horizontal_line", "background-color: #eee;");
        sheet.add(".kanban_default_rowheaderdivider", "background-color: #c0c0c0;");
        sheet.add(".kanban_default_shadow_inner", "background-color: #666666;opacity: 0.5;height: 100%;");
        sheet.add(".kanban_default_card", "color:#333;");
        sheet.add(".kanban_default_card_inner", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;padding:5px 2px 2px 2px;overflow:hidden;border:1px solid #ccc;");
        //sheet.add(".kanban_default_event_bar", "top:0px;left:0px;right:0px;height:4px;background-color:#9dc8e8;");
        //sheet.add(".kanban_default_event_bar_inner", "position:absolute;height:4px;background-color:#1066a8;");
        sheet.add(".kanban_default_card_inner", 'background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        //sheet.add(".kanban_default_event_float_inner", "padding:6px 2px 2px 8px;"); // space for arrow
        //sheet.add(".kanban_default_event_float_inner:after", 'content:"";border-color: transparent #333 transparent transparent;border-style:solid;border-width:5px;width:0;height:0;position:absolute;top:8px;left:-4px;');
        //sheet.add(".kanban_default_columnheader_inner", "font-weight: bold;");
        //sheet.add(".kanban_default_columnheader_splitter", "background-color: #666;opacity: 0.5;filter: alpha(opacity=50);");
        //sheet.add(".kanban_default_columnheader_cell_inner", "padding: 2px;");
        sheet.add(".kanban_default_cell", "background-color: #fff;");
        sheet.add(".kanban_default_cell.kanban_default_cell_selected", "background-color: #ccc;background-image: -webkit-gradient(linear, 0 100%, 100% 0,	color-stop(.25, rgba(255, 255, 255, .2)), color-stop(.25, transparent),	color-stop(.5, transparent), color-stop(.5, rgba(255, 255, 255, .2)), color-stop(.75, rgba(255, 255, 255, .2)), color-stop(.75, transparent), to(transparent));background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -moz-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -ms-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: -o-linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);background-image: linear-gradient(45deg, rgba(255, 255, 255, .2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .2) 50%, rgba(255, 255, 255, .2) 75%, transparent 75%, transparent);-webkit-background-size: 20px 20px;-moz-background-size: 20px 20px;background-size: 20px 20px;");
        sheet.add(".kanban_default_tree_image_no_children", "background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAIAAABv85FHAAAAKXRFWHRDcmVhdGlvbiBUaW1lAHDhIDMwIEkgMjAwOSAwODo0NjozMSArMDEwMClDkt4AAAAHdElNRQfZAR4HLzEyzsCJAAAACXBIWXMAAA7CAAAOwgEVKEqAAAAABGdBTUEAALGPC/xhBQAAADBJREFUeNpjrK6s5uTl/P75OybJ0NLW8h8bAIozgeSxAaA4E1A7VjmgOL31MeLxHwCeXUT0WkFMKAAAAABJRU5ErkJggg==);");
        sheet.add(".kanban_default_tree_image_expand", "background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAIAAABv85FHAAAAKXRFWHRDcmVhdGlvbiBUaW1lAHDhIDMwIEkgMjAwOSAwODo0NjozMSArMDEwMClDkt4AAAAHdElNRQfZAR4HLyUoFBT0AAAACXBIWXMAAA7CAAAOwgEVKEqAAAAABGdBTUEAALGPC/xhBQAAAFJJREFUeNpjrK6s5uTl/P75OybJ0NLW8h8bAIozgeRhgJGREc4GijMBtTNgA0BxFog+uA4IA2gmUJwFog/IgUhAGBB9KPYhA3T74Jog+hjx+A8A1KRQ+AN5vcwAAAAASUVORK5CYII=);");
        sheet.add(".kanban_default_tree_image_collapse", "background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAIAAABv85FHAAAAKXRFWHRDcmVhdGlvbiBUaW1lAHDhIDMwIEkgMjAwOSAwODo0NjozMSArMDEwMClDkt4AAAAHdElNRQfZAR4HLxB+p9DXAAAACXBIWXMAAA7CAAAOwgEVKEqAAAAABGdBTUEAALGPC/xhBQAAAENJREFUeNpjrK6s5uTl/P75OybJ0NLW8h8bAIozgeSxAaA4E1A7VjmgOAtEHyMjI7IE0EygOAtEH5CDqY9c+xjx+A8ANndK9WaZlP4AAAAASUVORK5CYII=);");
        //sheet.add(".kanban_default_event_move_left", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        //sheet.add(".kanban_default_event_move_right", 'box-sizing: border-box; padding:2px;border:1px solid #ccc;background:#fff;background: -webkit-gradient(linear, left top, left bottom, from(#ffffff), to(#eeeeee));background: -webkit-linear-gradient(top, #ffffff 0%, #eeeeee);background: -moz-linear-gradient(top, #ffffff 0%, #eeeeee);background: -ms-linear-gradient(top, #ffffff 0%, #eeeeee);background: -o-linear-gradient(top, #ffffff 0%, #eeeeee);background: linear-gradient(top, #ffffff 0%, #eeeeee);filter: progid:DXImageTransform.Microsoft.Gradient(startColorStr="#ffffff", endColorStr="#eeeeee");');
        sheet.add(".kanban_default_card_delete", "background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALCAYAAACprHcmAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAI5JREFUKFNtkLERgCAMRbmzdK8s4gAUlhYOYEHJEJYOYOEwDmGBPxC4kOPfvePy84MGR0RJ2N1A8H3N6DATwSQ57m2ql8NBG+AEM7D+UW+wjdfUPgerYNgB5gOLRHqhcasg84C2QxPMtrUhSqQIhg7ypy9VM2EUZPI/4rQ7rGxqo9sadTegw+UdjeDLAKUfhbaQUVPIfJYAAAAASUVORK5CYII=) center center no-repeat; opacity: 0.6; cursor: pointer;");
        sheet.add(".kanban_default_card_delete:hover", "opacity: 1;-ms-filter: none;");

        sheet.add(".kanban_default_rowmove_source", "background-color: black; opacity: 0.2;");
        sheet.add(".kanban_default_rowmove_position_before, .kanban_default_rowmove_position_after", "background-color: #999; height: 2px;");
        //sheet.add(".kanban_default_rowmove_position_child", "margin-left: 10px; background-color: #999; height: 2px;");
        //sheet.add(".kanban_default_rowmove_position_child:before", "content: '+'; color: #999; position: absolute; top: -8px; left: -10px;");
        sheet.add(".kanban_default_rowmove_position_forbidden", "background-color: red; height: 2px; margin-left: 10px;");
        sheet.add(".kanban_default_rowmove_position_forbidden:before", "content: 'x'; color: red; position: absolute; top: -8px; left: -10px;");

        //sheet.add(".kanban_default_shadow_overlap .kanban_default_shadow_inner", "background-color: red;");
        sheet.add(".kanban_default_block", "background-color: gray; opacity: 0.5;");

        sheet.add(".kanban_default_main .kanban_default_header_icon", "box-sizing: border-box; border: 1px solid #aaa; background-color: #f5f5f5; color: #000;");
        sheet.add(".kanban_default_header_icon:hover", "background-color: #ccc;");
        sheet.add(".kanban_default_header_icon_hide:before", "content: '\\00AB';");
        sheet.add(".kanban_default_header_icon_show:before", "content: '\\00BB';");

        sheet.add(".kanban_default_row_new .kanban_default_rowheader_inner", "cursor: text; background-position: 0px 50%; background-repeat: no-repeat; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABUSURBVChTY0ACslAaK2CC0iCQDMSlECYmQFYIAl1AjFUxukIQwKoYm0IQwFCMSyEIaEJpMMClcD4Qp0CYEIBNIUzRPzAPCtAVYlWEDgyAGIdTGBgAbqEJYyjqa3oAAAAASUVORK5CYII=);");
        sheet.add(".kanban_default_row_new .kanban_default_rowheader_inner:hover", "background: white;");
        sheet.add(".kanban_default_rowheader textarea", "padding: 3px;");
        sheet.add(".kanban_default_rowheader_scroll", "cursor: default;");

        //sheet.add(".kanban_default_shadow_forbidden .kanban_default_shadow_inner", "background-color: red;");

        sheet.add(".kanban_default_card_moving_source", "opacity: 0.5;");

        // diff
        sheet.add(".kanban_default_card .kanban_default_card_inner", "padding: 5px 5px 5px 10px;");
        sheet.add(".kanban_default_cell", "background-color: #fff;");
        sheet.add(".kanban_default_rowmove_handle", "opacity: 0.5; background-repeat: no-repeat; background-position: center center; background-color: #ccc; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAKCAYAAACT+/8OAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAClJREFUGFdj+P//P4O9vX2Bg4NDP4gNFgBytgPxebgAMsYuQGMz/jMAAFsTZDPYJlDHAAAAAElFTkSuQmCC); cursor: move;");

        // add
        sheet.add(".kanban_default_card_header", "font-size: 120%; font-weight: bold;");
        sheet.add(".kanban_default_card_bar", "background-color: #cc0000; cursor:move;");
        sheet.add(".kanban_default_cell.kanban_default_collapsed", "background-color: #eee;");
        sheet.add(".kanban_default_swimlane_collapse", "cursor:pointer; border: 1px solid #ccc; text-align:center;");
        sheet.add(".kanban_default_swimlane_collapse:before", "content: '^';");
        sheet.add(".kanban_default_swimlane_expand", "cursor:pointer; border: 1px solid #ccc; text-align:center;");
        sheet.add(".kanban_default_swimlane_expand:before", "content: '>';");
        sheet.add(".kanban_default_columnmove_handle", "opacity: 0.5; background-repeat: no-repeat; background-position: center center; background-color: #ccc; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAKCAYAAACT+/8OAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAClJREFUGFdj+P//P4O9vX2Bg4NDP4gNFgBytgPxebgAMsYuQGMz/jMAAFsTZDPYJlDHAAAAAElFTkSuQmCC); cursor: move;");
        sheet.add(".kanban_default_columnmove_position", "background-color: #333;");

        // 2016-10-18
        sheet.add(".kanban_default_crosshair_vertical, .kanban_default_crosshair_horizontal, .kanban_default_crosshair_left, .kanban_default_crosshair_top", "background-color: gray; opacity: 0.2;");


        // queue
        sheet.add(".queue_default_main", "min-width: 100px; border: 1px solid #ccc; padding: 5px; min-height: 200px; overflow-y: auto; font-family: -apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif; font-size: 13px;");
        sheet.add(".queue_default_event_bar", "left: 0px; top: 0px; bottom: 0px; width: 5px; background-color: #1066a8;");
        sheet.add(".queue_default_event_inner", "position:absolute;top:0px;left:0px;right:0px;bottom:0px;padding:2px 2px 2px 10px;overflow:hidden;border:1px solid #ccc; display: flex; align-items: center;");
        sheet.add(".queue_default_event_inner", "background:#fff; background: linear-gradient(to bottom, #ffffff 0%, #eeeeee);");
        sheet.add(".queue_default_selected .queue_default_event_inner", "background: #ddd;");
        sheet.add(".queue_default_shadow", "background-color: #ccc;");

        sheet.commit();

        DayPilot.Global.defaultCss = true;
    })();


    var SymbolLoader = function(url) {

        var t = this;
        this._result = function() {
            var load = isDifferent();
            if (load) {
                return fetch(url)
                    .then(function(response) {
                        return response.text();
                    })
                    .then(function(text) {
                        var symbol = document.createElement("div");
                        symbol.innerHTML = text;
                        return new Promise(function(resolve, reject) {
                            resolve(symbol.querySelector(t._hash()));
                        });
                    });
            }
            else {
                return new Promise(function(resolve, reject) {
                   resolve(document.querySelector(t._hash()));
                });
            }
        }

        this._hash = function(){
            return new URL(url, location.href).hash;
        };

        function isDifferent() {
            var test = new URL(url, location.href);
            return test.origin + test.pathname !== location.origin + location.pathname;
        }

    };

    var Splitter = function(id) {
        var This = this;

        this.id = id;
        this.widths = [];
        this.titles = [];
        this.data = [];
        this.height = null;
        this.splitterWidth = 3;
        this.splitterWidthLast = null;
        this.css = {};
        this.css.title = null;
        this.css.titleInner = null;
        this.css.splitter = null;

        this.enabled = true;

        // internal
        this.blocks = [];
        this.drag = {};

        // callback
        this.updated = function() {};
        this.updating = function() {};
        this.started = function() {};

        var resolved = {};
        resolved.splitterWidth = function(isLast) {
            var width = (isLast && typeof This.splitterWidthLast === "number") ? This.splitterWidthLast : This.splitterWidth;
            return This.enabled ? width : 1;
        };

        this.init = function() {
            var div;

            if (!id) {
                throw "error: id not provided";
            }
            else if (typeof id === 'string') {
                div = document.getElementById(id);
            }
            else if (id.appendChild) {
                div = id;
            }
            else {
                throw "error: invalid object provided";
            }

            this.div = div;
            this.blocks = [];

            for (var i = 0; i < this.widths.length; i++) {
                var isLast = i === this.widths.length - 1;
                var splitterWidth = resolved.splitterWidth(isLast);

                var s = document.createElement("div");
                s.style.display = "inline-block";
                if (This.height !== null) {
                    s.style.height = This.height + "px";
                }
                else {
                    s.style.height = "100%";
                }
                s.style.width = (this.widths[i] - splitterWidth) + "px";
                s.style.overflow = 'hidden';
                // s.style.verticalAlign = "top";
                s.style.position = "relative";
                s.setAttribute("unselectable", "on");
                s.className = this.css.title;
                div.appendChild(s);

                var title = this.titles[i];
                var html = null;
                var areas = [];
                var cssClass = null;

                if (typeof title === "object") {
                    html = title.html;
                    areas = title.areas;
                    cssClass = title.cssClass;
                }

                if (cssClass) {
                    DayPilot.Util.addClass(s, cssClass);
                }

                var inner = document.createElement("div");
                inner.innerHTML = html;
                inner.setAttribute("unselectable", "on");
                inner.className = this.css.titleInner;
                s.appendChild(inner);

                DayPilot.Areas.attach(s, This.data[i], {"areas": areas});

                var handle = document.createElement("div");
                handle.style.display = "inline-block";

                if (This.height !== null) {
                    handle.style.height = This.height + "px";
                }
                else {
                    handle.style.height = "100%";
                }

                handle.style.width = splitterWidth + "px";
                handle.style.position = "relative";

                handle.appendChild(document.createElement("div"));

                if (This.enabled) {
                    handle.style.cursor = "col-resize";
                }

                handle.setAttribute("unselectable", "on");
                handle.className = this.css.splitter;

                var data = {};
                data.index = i;
                data.width = this.widths[i];

                handle.data = data;

                handle.onmousedown = function(ev) {
                    ev.preventDefault();
                    if (!This.enabled) {
                        return;
                    }

                    var page = DayPilot.page(ev);
                    if (!page) {
                        return;
                    }
                    This.drag.start = page;
                    This.drag.data = this.data;
                    This.div.style.cursor = "col-resize";

                    This.started();
                };

                div.appendChild(handle);

                var block = {};
                block.section = s;
                block.handle = handle;
                this.blocks.push(block);
            }

            this.registerGlobalHandlers();
        }; // Init

        // resets the initial value
        this.updateWidths = function() {
            for (var i = 0; i < this.blocks.length; i++) {
                var block = this.blocks[i];
                var width = this.widths[i];
                block.handle.data.width = width;

                this._updateWidth(i);
            }
        };

        this._updateWidth = function(i) {
            var block = this.blocks[i];
            var width = this.widths[i];
            var isLast = i === this.widths.length - 1;
            block.section.style.width = (width - resolved.splitterWidth(isLast)) + "px";
        };

        this.totalWidth = function() {
            var t = 0;
            for (var i = 0; i < this.widths.length; i++) {
                t += this.widths[i];
            }
            return t;
        };

        this.gMouseMove = function(ev) {

            if (!This.drag.start) {
                return;
            }

            var data = This.drag.data;

            var now = DayPilot.page(ev);
            if (!now) {
                return;
            }
            var delta = now.x - This.drag.start.x;
            var i = data.index;

            This.widths[i] = Math.max(5, data.width + delta);
            This._updateWidth(i);

            // callback
            var params = {};
            params.widths = this.widths;
            params.index = data.index;

            This.updating(params);
        };

        this.gMouseUp = function(ev) {
            if (!This.drag.start) {
                return;
            }
            This.drag.start = null;
            document.body.style.cursor = "";
            This.div.style.cursor = "";

            var data = This.drag.data;
            data.width = This.widths[data.index];

            // callback
            var params = {};
            params.widths = this.widths;
            params.index = data.index;

            This.updated(params);
        };

        this.dispose = function() {
            DayPilot.list(this.blocks).forEach(function(block) {
                block.handle.onmousedown = null;
                DayPilot.de(block.section);
                DayPilot.de(block.handle);
            });
            this.unregisterGlobalHandlers();
        };

        this.registerGlobalHandlers = function() {
            DayPilot.re(document, 'mousemove', this.gMouseMove);
            DayPilot.re(document, 'mouseup', this.gMouseUp);
        };

        this.unregisterGlobalHandlers = function() {
            DayPilot.ue(document, 'mousemove', this.gMouseMove);
            DayPilot.ue(document, 'mouseup', this.gMouseUp);
        };
    };

    DayPilot.Splitter = Splitter;

})(DayPilot);

(function() {

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})();
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Bubble !== 'undefined' && DayPilot.Bubble.def) {
        return;
    }

    var DayPilotBubble = {};

    DayPilotBubble.mouseMove = function(ev) {
        if (typeof(DayPilotBubble) === 'undefined') {
            return;
        }
        DayPilotBubble.mouse = DayPilotBubble.mousePosition(ev);

        var b = DayPilotBubble.active;
        if (b && b._state.showPosition) {
            var pos1 = b._state.showPosition;
            var pos2 = DayPilotBubble.mouse;
            if (pos1.clientX !== pos2.clientX || pos1.clientY !== pos2.clientY) {
                // b.delayedHide();
            }
        }
    };

    DayPilotBubble.touchPosition = function(ev) {
        if (!ev || !ev.touches) {
            return null;
        }
        var touch = ev.touches[0];
        var mouse = {};
        mouse.x = touch.pageX;
        mouse.y = touch.pageY;
        mouse.clientX = touch.clientX;
        mouse.clientY = touch.clientY;
        return mouse;

    };

    DayPilotBubble.mousePosition = function(e) {
        // var result = DayPilot.mo3(document.body, e);
        var result = DayPilot.mo3(null, e);
        if (e) {
            result.clientY = e.clientY;
            result.clientX = e.clientX;
        }
        return result;
    };

    DayPilot.Bubble = function(options) {
        this.v = '2023.2.5592';

        var bubble = this;
        var elements = {};

        // default property values
        this.hideAfter = 500;
        this.loadingText = "Loading...";
        this.animated = true;
        this.animation = "fast";
        this.position = "Above";
        this.hideOnClick = true;
        this.hideOnHover = false;
        this.showAfter = 500;
        this.showLoadingLabel = true;
        this.showArrow = true;
        this.zIndex = 10;
        this.theme = "bubble_default";

        this.onLoad = null;
        this.onBeforeDomAdd = null;
        this.onBeforeDomRemove = null;

        // hiding for angular
        this._state = function() {};

        this._arrowTopIndent = 10;
        this._arrowLeftIndent = 10;

        this.callBack = function(args) {
            if (this.aspnet()) {
                WebForm_DoCallback(this.uniqueID, JSON.stringify(args), this.updateView, this, this.callbackError, true);
            }
            else {
                if (args.calendar.internal.bubbleCallBack) {
                    args.calendar.internal.bubbleCallBack(args, this);
                }
                else {
                    args.calendar.bubbleCallBack(args, this);
                }
            }
        };

        this.callbackError = function (result, context) {
            alert(result);
        };

        this.updateView = function(result, context) {

            // context should equal to bubble
            if (bubble !== context) {
                throw "Callback object mismatch (internal error)";
            }
            if (!result) {
                bubble._removeDiv();
                // bubble.removeShadow();
                return;
            }

            var domArgs = null;
            var html = null;
            var element = null;
            if (typeof result === "string") {
                html = result;
            }
            else if (typeof result === "object") {
                domArgs = result;
                html = result.html;
                element = result.element;
            }

            DayPilotBubble.active = bubble;
            if (bubble) {
                var doUpdate = false;
                var delayedReact = false;
                if (elements.div) {
                    if (element) {
                        elements._inner.innerHTML = '';

                        var isReactComponent = DayPilot.Util.isReactComponent(element);
                        if (isReactComponent) {
                            var reactDom = bubble._ref.calendar && bubble._ref.calendar.internal.reactRefs().reactDOM;
                            if (!reactDom) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            bubble._react._render(element, elements._inner);
                            delayedReact = bubble._react._react18();
                        }
                        else {
                            elements._inner.appendChild(element);
                        }
                        doUpdate = true;
                    }
                    else if (html) {
                        elements._inner.innerHTML = html;
                        doUpdate = true;
                    }
                    elements.div.domArgs = domArgs;
                }
                if (doUpdate) {
                    if (delayedReact) {
                        setTimeout(function() {
                           bubble._adjustPosition();
                        });
                    }
                    else {
                        bubble._adjustPosition();
                    }
                }
            }
        };

        this.init = function() {
            // moved to global init code
            //DayPilot.re(document.body, 'mousemove', DayPilotBubble.mouseMove);
        };

        this.aspnet = function() {
            return (typeof WebForm_DoCallback !== 'undefined');
        };

        this.showEvent = function(e, now) {
            var a = new DayPilotBubble.CallBackArgs(e.calendar || e.root, 'Event', e, e.bubbleHtml ? e.bubbleHtml() : null);
            if (now) {
                this.show(a);
            }
            else {
                this.showOnMouseOver(a);
            }
        };

        this.showGroup = function(group) {
            this.showOnMouseOver(group);
        };

        this.showCell = function(cell, div) {
            DayPilotBubble.cancelShowing();
            var a = new DayPilotBubble.CallBackArgs(cell.calendar || cell.root, 'Cell', cell, cell.staticBubbleHTML ? cell.staticBubbleHTML() : null);
            a.div = div;
            this.showOnMouseOver(a);
        };

        this.showLink = function(link) {
            DayPilotBubble.cancelShowing();
            var a = new DayPilotBubble.CallBackArgs(link.calendar || link.root, 'Cell', link, link.data && link.data.bubbleHtml);
            this.showOnMouseOver(a);
        };

        this.showTime = function(time) {
            var a = new DayPilotBubble.CallBackArgs(time.calendar || time.root, 'Time', time, time.staticBubbleHTML ? time.staticBubbleHTML() : null);
            this.showOnMouseOver(a);
        };

        this.showResource = function(row, now) {
           /* var isRow = DayPilot.Row && row instanceof DayPilot.Row;
            var isColumn = DayPilot.Column && row instanceof DayPilot.Column;
            var rowOrCol = isRow || isColumn;

            if (!rowOrCol) {
                throw new DayPilot.Exception("DayPilot.Row or DayPilot.Column object expected");
            }*/

            var res = {};
            res.calendar = row.calendar;
            res.id = row.id;
            res.name = row.name;
            res.start = row.start;
            if (row.bubbleHtml) {
                res.bubbleHtml = function() {
                    return row.bubbleHtml;
                };
            }
            else if (row.data && row.data.bubbleHtml) {
                res.bubbleHtml = function() {
                    return row.data.bubbleHtml;
                };
            }
            res.toJSON = function() {
                var json = {};
                json.id = this.id;
                return json;
            };

            var a = new DayPilotBubble.CallBackArgs(res.calendar || res.root, 'Resource', res, res.bubbleHtml ? res.bubbleHtml() : null);
            a.div = row.div;

            if (now) {
                this.show(a);
            }
            else {
                this.showOnMouseOver(a);
            }
        };

        this.showHtml = function(html, div) {
            var a = new DayPilotBubble.CallBackArgs(null, 'Html', null, html);
            a.div = div;
            this.show(a);
        };

        this.hide = function() {
            if (DayPilotBubble.active === this) {
                DayPilot.Bubble.hide();
            }
        };

        // angular change detection
        this.toJSON = function() {
            return null;
        };

        this.show = function(callbackArgument) {

            if (!bubble._anythingToDisplay(callbackArgument)) {
                return;
            }

            var pop = this.animated;

            this._state.showPosition = DayPilotBubble.mouse;

            DayPilotBubble.showing = null;

            if (!DayPilotBubble.mouse) {
                // wait a bit
                setTimeout(function() {
                    bubble.show(callbackArgument);
                }, 100);
                return;
            }

            var mouse = DayPilotBubble.mouse;
            mouse.h = 0;
            mouse.w = 0;
            var ref = this.getDiv(callbackArgument);
            var pos = bubble._resolvedPosition();
            var posAbove = pos === "Above";
            var posRight = pos === "Right";
            var posRef = posAbove || posRight;
            if (posRef && ref) {
                var margin = 2;
                var abs = DayPilot.abs(ref, true);
                if (!abs) {
                    return;
                }

                mouse.x = abs.x;
                mouse.y = abs.y;
                mouse.h = abs.h + margin;
                mouse.w = abs.w;
            }

            this._state.mouse = mouse;

            var id;
            try {
                id = JSON.stringify(callbackArgument.object);
            }
            catch (e) {
                return; // unable to serialize, it's an invalid event (might have been cleared already)
            }

            if (DayPilotBubble.active === this && this._state.sourceId === id) { // don't show, it's already visible
                return;
            }
            if (typeof DayPilot.Menu !== 'undefined' && DayPilot.Menu.active) { // don't show the bubble if a menu is active
                return;
            }

            // hide whatever might be visible (we are going to show another one)
            DayPilotBubble.hideActive();

            DayPilotBubble.active = this;
            this._state.sourceId = id;

            var div = document.createElement("div");
            div.setAttribute("unselectable", "on");
            div.style.position = 'absolute';

            //if (!this.showLoadingLabel && !pop) {
            if (!this.showLoadingLabel) {
                div.style.display = 'none';
            }

            div.className = this._prefixCssClass("_main");

            div.style.top = '-3000px';
            div.style.left = '-3000px';
            div.style.zIndex = this.zIndex + 1;

            if (pop) {
                div.style.visibility = 'hidden';
            }

            if (this.hideOnClick) {
                div.onclick = function() {
                    DayPilotBubble.hideActive();
                };
            }

            div.onmousemove = function(e) {
                if (bubble.hideOnHover) {
                    DayPilotBubble.hideActive();
                }

                // prevent other bubbles from becoming active (may cause just hiding the current one if no html is specified)
                DayPilotBubble.cancelShowing();

                DayPilotBubble.cancelHiding();
                var e = e || window.event;
                e.cancelBubble = true;
            };
            div.oncontextmenu = function() { return false; };
            div.onmouseleave = function() { bubble.delayedHide(); };

            var arrowLeftIndent = this._arrowLeftIndent;
            var arrowTopIndent = this._arrowTopIndent;

            var ns = "http://www.w3.org/2000/svg";
            var arrowTop = document.createElementNS(ns,"svg");
            arrowTop.setAttribute("viewBox", "0 0 12 10");
            arrowTop.setAttribute("class", this._prefixCssClass("_arrow_top"));
            arrowTop.style.width = "12px";
            arrowTop.style.height = "10px";
            arrowTop.style.position = "absolute";
            arrowTop.style.top = "0px";
            arrowTop.style.left = arrowLeftIndent + "px";
            arrowTop.style.display = "none";
            arrowTop.innerHTML = '<polyline points="0 10 6 0 12 10"></polyline>';

            var arrowBottom = document.createElementNS(ns,"svg");
            arrowBottom.setAttribute("viewBox", "0 0 12 10");
            arrowBottom.setAttribute("class", this._prefixCssClass("_arrow_bottom"));
            arrowBottom.style.width = "12px";
            arrowBottom.style.height = "10px";
            arrowBottom.style.position = "absolute";
            arrowBottom.style.bottom = "0px";
            arrowBottom.style.left = arrowLeftIndent + "px";
            arrowBottom.style.display = "none";
            arrowBottom.innerHTML = '<polyline points="0 0 6 10 12 0"></polyline>';

            var arrowLeft = document.createElementNS(ns,"svg");
            arrowLeft.setAttribute("viewBox", "0 0 10 12");
            arrowLeft.setAttribute("class", this._prefixCssClass("_arrow_left"));
            arrowLeft.style.width = "10px";
            arrowLeft.style.height = "12px";
            arrowLeft.style.position = "absolute";
            arrowLeft.style.top = arrowTopIndent + "px";
            arrowLeft.style.left =  "0px";
            arrowLeft.style.display = "none";
            arrowLeft.innerHTML = '<polyline points="10 0 0 6 10 12"></polyline>';

            var arrowRight = document.createElementNS(ns,"svg");
            arrowRight.setAttribute("viewBox", "0 0 10 12");
            arrowRight.setAttribute("class", this._prefixCssClass("_arrow_right"));
            arrowRight.style.width = "10px";
            arrowRight.style.height = "12px";
            arrowRight.style.position = "absolute";
            arrowRight.style.top = arrowTopIndent + "px";
            arrowRight.style.right = "0px";
            arrowRight.style.display = "none";
            arrowRight.innerHTML = '<polyline points="0 0 10 6 0 12"></polyline>';

            var inner = document.createElement("div");
            div.appendChild(inner);
            div.appendChild(arrowTop);
            div.appendChild(arrowBottom);
            div.appendChild(arrowLeft);
            div.appendChild(arrowRight);

            inner.className = this._prefixCssClass("_main_inner");
            inner.innerHTML = this.loadingText;

            document.body.appendChild(div);

            elements.div = div;
            elements._inner = inner;
            elements._arrowTop = arrowTop;
            elements._arrowBottom = arrowBottom;
            elements._arrowLeft = arrowLeft;
            elements._arrowRight = arrowRight;

            // bubble._calendar = callbackArgument.calendar;

            bubble._ref = function() {};
            bubble._ref.calendar = callbackArgument.calendar;

            var args = {};
            args.source = callbackArgument.object;
            args.async = false;
            args.html = callbackArgument.staticHTML;
            args.loaded = function() {
                // make sure it's marked as async
                if (this.async) {
                    // bubble.updateView(args.html, bubble);
                    bubble._domAdd(args);
                }
            };

            if (this.showLoadingLabel && !pop) {
                this._adjustPosition();
                // this.addShadow();
            }

            if (callbackArgument.staticHTML  && typeof this.onLoad !== 'function') {
                // this.updateView(callbackArgument.staticHTML, this);
                bubble._domAdd(args);
            }
            else if (typeof this.onLoad === 'function') {
                this.onLoad(args);

                // not async, show now
                if (!args.async) {
                    // bubble.updateView(args.html, bubble);
                    bubble._domAdd(args);
                }
            }
            else if (typeof bubble.onDomAdd === "function" || typeof bubble.onBeforeDomAdd === "function") {
                bubble._domAdd(args);
            }
            else if (this._serverBased(callbackArgument)) {
                this.callBack(callbackArgument);
            }
        };

        this._anythingToDisplay = function(callbackArgument) {
            if (callbackArgument.staticHTML) {
                return true;
            }
            if (typeof this.onLoad === 'function') {
                return true;
            }
            if (typeof bubble.onDomAdd === "function" || typeof bubble.onBeforeDomAdd === "function") {
                return true;
            }
            if (this._serverBased(callbackArgument)) {
                return true;
            }
            return false;
        };

        this._domAdd = function(loadArgs) {
            var args = {};
            args.source = loadArgs.source;
            args.html = loadArgs.html;
            args.element = null;

            // legacy, to be removed
            if (typeof bubble.onDomAdd === "function") {
                bubble.onDomAdd(args);
            }

            if (typeof bubble.onBeforeDomAdd === "function") {
                bubble.onBeforeDomAdd(args);
            }

            bubble.updateView(args, bubble);

        };

        this.getDiv = function(callbackArgument) {
            if (callbackArgument.div) {
                return callbackArgument.div;
            }
            if (callbackArgument.type === 'Event' && callbackArgument.calendar && callbackArgument.calendar.internal.findEventDiv) {
                return callbackArgument.calendar.internal.findEventDiv(callbackArgument.object);
            }

        };

        this._prefixCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            if (prefix) {
                return prefix + part;
            }
            else {
                return "";
            }
        };


        this._resolvedPosition = function() {
            var pos = bubble.position;
            if (!pos) {
                return "Above";
            }
            if (pos.toLowerCase() === "eventtop") {
                return "Above";
            }
            if (pos.toLowerCase() === "above") {
                return "Above";
            }
            if (pos.toLowerCase() === "mouse") {
                return "Mouse";
            }
            if (pos.toLowerCase() === "right") {
                return "Right";
            }
            throw new DayPilot.Exception("Unrecognized DayPilot.Bubble.position value: " + pos);
        };

        this._adjustPosition = function() {

            var pop = this.animated;
            var mouse = this._state.mouse;

            var position = bubble._resolvedPosition();

            var windowPadding = 10; // used for both horizontal and vertical padding if the bubble
            var yArrowOffset = 0;

            if (!elements.div) {
                return;
            }

            if (!mouse) {  // don't adjust the position
                return;
            }

            // invalid coordinates
            if (!mouse.x || !mouse.y) {
                DayPilotBubble.hideActive();
                return;
            }

            var div = elements.div;
            var inner = elements._inner;

            div.style.display = '';

            var height = div.offsetHeight;
            if (this.showArrow) {
                height += 9;
            }
            var width = div.offsetWidth;
            if (this.showArrow) {
                width += 9;
            }

            div.style.display = 'none';

            var wd = DayPilot.wd();

            var windowWidth = wd.width;
            var windowHeight = wd.height;

            var verticalref = "bottom";
            var horizontalref = "left";

            if (position === 'Mouse') {
                var pixelsBelowCursor = 22;
                var pixelsAboveCursor = 10;

                var top = 0;
                if (mouse.clientY > windowHeight - height + windowPadding) {
                    var offsetY = mouse.clientY - (windowHeight - height) + windowPadding;
                    top = (mouse.y - height - pixelsAboveCursor);
                }
                else {
                    top = mouse.y + pixelsBelowCursor;
                }

                if (typeof top === 'number') {
                    div.style.top = Math.max(top, 0) + "px";
                }

                if (mouse.clientX > windowWidth - width + windowPadding) {
                    var offsetX = mouse.clientX - (windowWidth - width) + windowPadding;
                    div.style.left = (mouse.x - offsetX) + 'px';
                }
                else {
                    div.style.left = mouse.x + 'px';
                }
            }
            else if (position === 'Above') {
                var space = 2;

                // 1 try to show it above the event
                var top = mouse.y - height - space;
                var scrollTop = wd.scrollTop;

                // 2 doesn't fit there, try to show it below the event
                if (top < scrollTop) {
                    top = mouse.y + mouse.h;
                    verticalref = "top";
                }

                if (typeof top === 'number') {
                    div.style.top = Math.max(top, 0) + 'px';
                }

                var left = mouse.x;

                // does it have any effect here? gets updated later
                if (mouse.x + width + windowPadding > windowWidth) {
                    //var offsetX = this.mouse.x - (windowWidth - width) + windowPadding;
                    //left = this.mouse.x - offsetX;
                    left = windowWidth - width - windowPadding;
                    horizontalref = "right";
                }

                div.style.left = left + 'px';
            }
            else if (position === "Right") {

                // console.log("position = right");
                verticalref = "top";

                var top = mouse.y;
                var left = mouse.x + mouse.w;

                if (left + width + windowPadding > windowWidth) {
                    if (width < mouse.x) {
                        left = left - width - mouse.w;
                        horizontalref = "right";
                    }
                }

                var yOverflow = top + height + windowPadding - windowHeight;
                if (yOverflow > 0) {
                    top -= yOverflow;
                    yArrowOffset = yOverflow;
                    if (top < 0) {
                        yArrowOffset += top;
                        top = 0;
                    }
                }

                div.style.top = top + "px";
                div.style.left = left + "px";
            }

            div.style.display = '';

            if (this.showArrow) {
                if (position === "Above" || position === "Mouse") {
                    if (verticalref === "bottom") {
                        elements._arrowTop.style.display = "none";
                        elements._arrowBottom.style.display = "";
                        inner.style.marginTop = "0px";
                        inner.style.marginBottom = "9px";
                    }
                    else {
                        elements._arrowTop.style.display = "";
                        elements._arrowBottom.style.display = "none";
                        inner.style.marginTop = "9px";
                        inner.style.marginBottom = "0px";
                    }
                }
                else {
                    if (horizontalref === "left") {
                        elements._arrowRight.style.display = "none";
                        elements._arrowLeft.style.display = "";
                        elements._arrowLeft.style.top = (this._arrowTopIndent + yArrowOffset) + "px";
                        inner.style.marginRight = "0px";
                        inner.style.marginLeft = "9px";
                    }
                    else {
                        elements._arrowRight.style.display = "";
                        elements._arrowLeft.style.display = "none";
                        elements._arrowRight.style.top = (this._arrowTopIndent + yArrowOffset) + "px";
                        inner.style.marginRight = "9px";
                        inner.style.marginLeft = "0px";
                    }
                }
            }

            // debugger;

            if (pop) {
                div.style.display = '';

                var original = {};
                original.color = inner.style.color;
                original.overflow = div.style.overflow;

                inner.style.color = "transparent";
                div.style.overflow = 'hidden';

                // this.removeShadow();

                DayPilot.pop(div, {
                    "finished": function() {
                        inner.style.color = original.color;
                        div.style.overflow = original.overflow;
                        // bubble.addShadow();
                    },
                    // "vertical": "bottom",
                    "vertical": verticalref,
                    // "horizontal": "left",
                    "horizontal": horizontalref,
                    "animation" : bubble.animation
                });
            }

        };

        this.delayedHide = function() {
            // turned off, might not be desired
            // DayPilotBubble.cancelHiding();

            if (DayPilotBubble.showing === this) {
                DayPilotBubble.cancelShowing();
                // this.delayedHide();
                // return;
            }

            var active = DayPilotBubble.active;
            if (active === this) {
                DayPilotBubble.cancelHiding();
                if (active.hideAfter > 0) {
                    var hideAfter = active.hideAfter;
                    DayPilotBubble.timeoutHide = window.setTimeout(DayPilotBubble.hideActive, hideAfter);
                }
            }
        };

        this.showOnMouseOver = function (callbackArgument) {
            // DayPilotBubble.cancelTimeout();

            if (DayPilotBubble.active === this) {
                DayPilotBubble.cancelHiding();
            }

            var delayedShow = function(arg) {
                return function() {
                    bubble.show(arg);
                };
            };

            clearTimeout(DayPilotBubble.timeoutShow);
            DayPilotBubble.timeoutShow = window.setTimeout(delayedShow(callbackArgument), this.showAfter);

            DayPilotBubble.showing = this;
            //DayPilotBubble.timeout = window.setTimeout(this.clientObjectName + ".show('" + callbackArgument + "')", this.showAfter);
        };

        this.hideOnMouseOut = function() {
            this.delayedHide();
        };

        this._serverBased = function(args) {
            if (args.calendar.backendUrl) {  // ASP.NET MVC, Java
                return true;
            }
            if (typeof WebForm_DoCallback === 'function' && this.uniqueID) {  // ASP.NET WebForms
                return true;
            }
            return false;
        };

        this._removeDiv = function() {
            if (!elements.div) {
                return;
            }

            var domArgs = elements.div.domArgs;
            elements.div.domArgs = null;

            if (domArgs) {
                if (typeof bubble.onDomRemove === "function") {
                    bubble.onDomRemove(domArgs);
                }
                if (typeof bubble.onBeforeDomRemove === "function") {
                    bubble.onBeforeDomRemove(domArgs);
                }

                if (typeof bubble.onDomAdd === "function" || typeof bubble.onBeforeDomAdd === "function") {
                    var target = elements._inner;
                    if (target) {
                        var isReact = DayPilot.Util.isReactComponent(domArgs.element);
                        if (isReact) {
                            var reactDom = bubble._ref.calendar && bubble._ref.calendar.internal.reactRefs().reactDOM;
                            if (!reactDom) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            bubble._react._unmount(target);
                        }
                    }
                }
            }

            document.body.removeChild(elements.div);
            elements.div = null;
        };

        this._react = {};
        this._react._render = function(component, target) {
            var rd = bubble._ref.calendar && bubble._ref.calendar.internal.reactRefs().reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                if (!root) {
                    root = rd.createRoot(target);
                    target._root = root;
                }
                root.render(component);
            }
            else {
                rd.render(component, target);
            }

        };
        this._react._react18 = function() {
            var rd = bubble._ref.calendar && bubble._ref.calendar.internal.reactRefs().reactDOM;
            return rd && typeof rd.createRoot === "function";
        };
        this._react._unmount = function(target) {
            var rd = bubble._ref.calendar && bubble._ref.calendar.internal.reactRefs().reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                setTimeout(function() {
                    root.unmount();
                }, 0);
            }
            else {
                rd.unmountComponentAtNode(target);
            }
        };

        if (options) {
            for (var name in options) {
                this[name] = options[name];
            }
        }

        this.init();

    };

    DayPilot.Bubble.touchPosition = function(ev) {
        if (ev.touches) {
            DayPilotBubble.mouse = DayPilotBubble.touchPosition(ev);
        }
    };

    DayPilotBubble.cancelShowing = function() {
        DayPilotBubble.showing = null;
        if (DayPilotBubble.timeoutShow) {
            window.clearTimeout(DayPilotBubble.timeoutShow);
            DayPilotBubble.timeoutShow = null;

        }
    };

    DayPilotBubble.cancelHiding = function() {
        if (DayPilotBubble.timeoutHide) {
            window.clearTimeout(DayPilotBubble.timeoutHide);
        }
    };

    DayPilotBubble.hideActive = function() {
        DayPilotBubble.cancelHiding();

        // don't cancel showing here (it prevents showing bubble of another type right away)
        // DayPilotBubble.cancelShowing();
        var bubble = DayPilotBubble.active;
        if (bubble) {
            bubble._removeDiv();
            // bubble.removeShadow();
        }
        DayPilotBubble.active = null;
    };

    DayPilotBubble.CallBackArgs = function(calendar, type, object, staticHTML) {
        this.calendar = calendar;
        this.type = type;
        this.object = object;
        this.staticHTML = staticHTML;

        this.toJSON = function() {
            var json = {};
            json.uid = this.calendar.uniqueID;
            //json.v = this.calendar.v;
            json.type = this.type;
            json.object = object;
            //json.staticHTML = staticHTML;
            return json;
        };
    };

    // register global events
    DayPilot.re(document, 'mousemove', DayPilotBubble.mouseMove);

    // publish the API

    // (backwards compatibility)
    /*
    DayPilot.BubbleVisible.Bubble = DayPilotBubble.Bubble;
    DayPilot.BubbleVisible.hideActive = DayPilotBubble.hideActive;
    DayPilot.BubbleVisible.cancelTimeout = DayPilotBubble.cancelTimeout;
    */

    // current
    DayPilot.Bubble.hideActive = DayPilotBubble.hideActive;
    DayPilot.Bubble.cancelShowing = DayPilotBubble.cancelShowing;
    DayPilot.Bubble.hide = function(options) {
        options = options || {};

        // hide bubble only for the specified calendar source
        if (options.calendar) {
            var active = DayPilotBubble.active;
            if (active && active._ref.calendar === options.calendar) {
                DayPilot.Bubble.hide();
            }
        }
        else {
            DayPilotBubble.hideActive();
        }
    };
    DayPilot.Bubble.getActive = function() {
        return DayPilotBubble.active;
    };

    DayPilot.Bubble.def = {};

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded){
       Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Calendar !== 'undefined' && DayPilot.Calendar.def) {
        return;
    }

    var shadowZindex = 10;

    var createDiv = function() {
        return document.createElement("div");
    };

    var rePassive = DayPilot.rePassive;
    var reNonPassive = DayPilot.reNonPassive;
    var registerEvent = DayPilot.re;
    var addClass = DayPilot.Util.addClass;
    var removeClass = DayPilot.Util.removeClass;
    var isMouseEvent = DayPilot.Util.isMouseEvent;
    var copyProps = DayPilot.Util.copyProps;
    var isReactComp = DayPilot.Util.isReactComponent;
    var overlaps = DayPilot.Util.overlaps;
    var createList = DayPilot.list;
    var DpGlobal = DayPilot.Global;
    var deleteElement = DayPilot.de;

    DayPilot.Calendar = function(id, options) {
        this.v = '2023.2.5592';

        var isConstructor = false;
        if (this instanceof DayPilot.Calendar && !this.__constructor) {
            isConstructor = true;
            this.__constructor = true;
        }

        if (!isConstructor) {
            throw new DayPilot.Exception("DayPilot.Calendar() is a constructor and must be called as 'var c = new DayPilot.Calendar(id);'");
        }

        var calendar = this;

        // asp.net
        this.uniqueID = null;
        this.clientName = id;

        this.id = id;
        this.isCalendar = true;

        this.allDayEnd = "DateTime";
        this.allDayEventHeight = 30;
        this.allDayEventTextWrappingEnabled = false;
        this.allowEventOverlap = true;
        this.allowMultiSelect = true;
        this.api = 2;
        this.autoRefreshCommand = 'refresh';
        this.autoRefreshEnabled = false;
        this.autoRefreshInterval = 60;
        this.autoRefreshMaxCount = 20;
        this.autoScroll = "Drag";
        this.backendUrl = null;
        if (typeof DayPilot.Bubble === "function") {
            this.bubble = new DayPilot.Bubble();
            // this.cellBubble = new DayPilot.Bubble();
            // this.columnBubble = new DayPilot.Bubble();
        } else {
            this.bubble = null;
        }
        this.cellBubble = null;
        this.columnBubble = null;
        this.businessBeginsHour = 9;
        this.businessEndsHour = 18;
        this.cellHeight = 30;
        this.cellDuration = 30;
        this.clientState = {};
        this.columnMarginRight = 5;
        this.columnMoveSameLevelOnly = false;
        this.columnWidth = 200;
        this.columnWidthMin = 10;
        this.columnWidthSpec = "Auto";
        this.columnsLoadMethod = "GET";
        this.contextMenu = null;
        this.contextMenuSelection = null;
        this.cornerText = "";
        this.cornerHtml = null;
        this.crosshairType = "Header";
        this.cssClass = null;
        this.dayBeginsHour = 0;
        this.dayEndsHour = 24;
        this.days = 1;
        this.doubleClickTimeout = 300;
        this.durationBarVisible = true;
        this.dynamicEventRendering = "Disabled";
        this.dynamicEventRenderingMarginX = 0;
        this.dynamicEventRenderingMarginY = 0;
        this.eventArrangement = "Cascade";  // "Cascade" | "Full" | "SideBySide"
        this.eventsLoadMethod = "GET";
        this.headerHeight = 30;
        this.headerTextWrappingEnabled = false;
        this.headerHeightAutoFit = false;
        this.headerLevels = "Auto";
        this.height = 300;
        this.heightSpec = 'BusinessHours';
        this.hideFreeCells = false;
        this.hideUntilInit = true;
        this.headerDateFormat = null; // uses locale.dateFormat by default
        this.hourWidth = 60;
        this.initEventEnabled = false;
        this.initScrollPos = null;
        this.loadingLabelText = "Loading...";
        this.loadingLabelHtml = null;
        this.loadingLabelVisible = true;
        this.locale = "en-us";
        this.messageHideAfter = 5000;
        this.moveBy = "Full";
        this.notifyCommit = 'Immediate'; // or 'Queue'
        this.rtl = false;
        this.scrollDelayCells = 0;
        this.scrollDelayEvents = 10;
        this.scrollLabelsVisible = false;
        this.showToolTip = true;
        this.showAllDayEvents = false;
        this.showEventStartEnd = false;
        this.showHeader = true;
        this.showHours = true;
        this.showCurrentTime = true;
        this.showCurrentTimeMode = "Day";
        this.showCurrentTimeOffset = 0;
        this.startDate = DayPilot.Date.today();
        this.cssClassPrefix = "calendar_default";
        this.tapAndHoldTimeout = 300;
        this.theme = null;
        this.timeFormat = 'Auto';
        this.timeHeaderCellDuration = 60;
        this.timeRangeSelectingStartEndEnabled = false;
        this.timeRangeSelectingStartEndFormat = "Auto";
        this.eventMovingStartEndEnabled = false;
        this.eventMovingStartEndFormat = "Auto";
        this.eventResizingStartEndEnabled = false;
        this.eventResizingStartEndFormat = "Auto";

        this.useEventBoxes = 'Always';
        this.viewType = 'Days';
        this.visible = true;
        this.watchWidthChanges = true;
        this.weekStarts = "Auto";
        this.width = null;
        this.xssProtection = "Enabled"; // "Disabled"

        this.columnMoveHandling = "Disabled";
        this.columnResizeHandling = "Disabled";
        this.eventClickHandling = 'Enabled';
        this.eventDoubleClickHandling = 'Disabled';
        this.eventRightClickHandling = 'ContextMenu';
        this.eventDeleteHandling = 'Disabled';
        this.eventEditHandling = 'Update';
        this.eventHoverHandling = 'Bubble';
        this.eventResizeHandling = 'Update';
        this.eventMoveHandling = 'Update';
        this.eventSelectHandling = 'Update';
        this.eventTapAndHoldHandling = 'Move';
        this.headerClickHandling = 'Enabled';
        this.timeRangeTapAndHoldHandling = 'Select';
        this.timeRangeSelectedHandling = 'Enabled';
        this.timeRangeClickHandling = "Enabled";
        this.timeRangeDoubleClickHandling = "Disabled";
        this.timeRangeRightClickHandling = "ContextMenu";  // "ContextMenu", "Enabled", "Disabled"

        this.onAutoRefresh = null;
        this.onColumnFilter = null;
        this.onColumnResize = null;
        this.onColumnResized = null;
        this.onEventFilter = null;
        this.onEventClick = null;
        this.onEventClicked = null;
        this.onEventDelete = null;
        this.onEventDeleted = null;
        this.onEventEdit = null;
        this.onEventEdited = null;
        this.onEventMove = null;
        this.onEventMoved = null;
        this.onEventMoving = null;
        this.onEventResize = null;
        this.onEventResized = null;
        this.onEventResizing = null;
        this.onEventSelect = null;
        this.onEventSelected = null;
        this.onEventRightClick = null;
        this.onEventRightClicked = null;
        this.onEventDoubleClick = null;
        this.onEventDoubleClicked = null;
        this.onHeaderClick = null;
        this.onHeaderClicked = null;
        this.onTimeRangeClick = null;
        this.onTimeRangeClicked = null;
        this.onTimeRangeRightClick = null;
        this.onTimeRangeRightClicked = null;
        this.onTimeRangeDoubleClick = null;
        this.onTimeRangeDoubleClicked = null;
        this.onTimeRangeSelect = null;
        this.onTimeRangeSelected = null;
        this.onTimeRangeSelecting = null;

        this.onAfterRender = null;
        this.onAfterEventRender = null;
        this.onAfterCellRender = null;

        this.onBeforeEventRender = null;
        this.onBeforeEventExport = null;
        this.onBeforeEventDomAdd = null;
        this.onBeforeEventDomRemove = null;
        this.onBeforeCellRender = null;
        this.onBeforeCellExport = null;
        this.onBeforeCornerDomAdd = null;
        this.onBeforeCornerDomRemove = null;
        this.onBeforeCornerRender = null;
        this.onBeforeHeaderRender = null;
        this.onBeforeHeaderExport = null;
        this.onBeforeTimeHeaderRender = null;

        // transitional
        this._separateEventsTable = true;
        this._shadowZindex = shadowZindex;
        this._unifiedScrollable = true;
        this._divBasedGrid = true;
        this._fasterDispose = true;             // potentially leaking a bit but significantly faster in IE, phasing out

        // nav
        this._cache = {};
        this._cache.pixels = {};
        this._cache.events = [];
        this._cache.drawArea = null;
        this._cache._coldims = null;
        this.elements = {};
        this.elements.events = [];
        this.elements.separators = [];
        this.elements.selection = [];
        this.elements.cells = {};
        this.elements.crosshair = [];
        this.elements.timeHeaders = [];
        this.events = {};
        this.events.list = [];
        this.nav = {};

        // internal
        this._autoRefreshCount = 0;
        this._initialized = false;
        this._disposed = false;

        this.members = {};
        this.members.obsolete = [
            "Init",
            "cleanSelection",
            "cssClassPrefix",
            "clientName",
            "uniqueID"
        ];
        this.members.ignore = [
            "internal",
            "nav",
            "debug",
            "temp",
            "elements",
            "members",
            "onCallbackError"
        ];

        this._productCode = 'javasc';

        this._browser = {};

        this._browser.ie = (navigator && navigator.userAgent && navigator.userAgent.indexOf("MSIE") !== -1);  // IE
        this._browser.ff = (navigator && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1);

        this.clearSelection = function() {
            if (!this._selectedCells) {
                this._selectedCells = [];
                return;
            }
            DayPilotCalendar._topSelectedCell = null;
            DayPilotCalendar._bottomSelectedCell = null;
            DpGlobal.selecting = null;
            this._hideSelection();
            this._selectedCells = [];
        };

        this._hideSelection = function() {
            if (!this._selectedCells) {
                return;
            }

            deleteElement(calendar.elements.selection);
            calendar.elements.selection = [];
            calendar.nav.activeSelection = null;
        };

        this.cleanSelection = this.clearSelection;

        this._getDrawArea = function() {

            if (calendar._cache.drawArea) {
                return calendar._cache.drawArea;
            }

            var ref = calendar._scrollDiv();

            if (!ref) {
                return null;
            }

            var area = {};

            area.pixels = {};
            area.pixels.left = ref.scrollLeft;
            area.pixels.right = ref.scrollLeft + ref.clientWidth;
            area.pixels.top = ref.scrollTop;
            area.pixels.bottom = ref.scrollTop + ref.clientHeight;
            area.pixels.width = ref.scrollWidth;

            var marginX = calendar.dynamicEventRenderingMarginX;
            if (marginX) {
                area.pixels.left -= marginX;
                area.pixels.right += marginX;

                if (area.pixels.left < 0) {
                    area.pixels.left = 0;
                }
                if (area.pixels.right > area.pixels.width) {
                    area.pixels.right = area.pixels.width;
                }
            }

            var marginY = calendar.dynamicEventRenderingMarginY;
            if (marginY) {
                area.pixels.top -= marginY;
                area.pixels.bottom += marginY;

                var max = calendar._getInnerHeight();
                if (area.pixels.top < 0) {
                    area.pixels.top = 0;
                }
                if (area.pixels.bottom > max) {
                    area.pixels.bottom = max;
                }
            }

            var coldims = calendar._getColumnDimensions();

            var xStart = null;
            var xEnd = null;
            for (var x = 0; x < coldims.length; x++) {
                var col = coldims[x];
                var right = col.left + col.width;
                if (xStart === null && right > area.pixels.left) {
                    xStart = x;
                }
                if (xStart !== null && xEnd === null) {
                    if (right >= area.pixels.right || x === coldims.length - 1) {
                        xEnd = x;
                        break;
                    }
                }
            }

            var yStart = Math.floor(area.pixels.top / calendar.cellHeight);
            yStart = DayPilot.Util.atLeast(0, yStart);
            var yEnd = Math.ceil(area.pixels.bottom / calendar.cellHeight);
            yEnd = DayPilot.Util.atMost(calendar._rowCount() - 1, yEnd);

            area.xStart = xStart;
            area.xEnd = xEnd;
            area.yStart = yStart;
            area.yEnd = yEnd;

            calendar._cache.drawArea = area;

            return area;
        };

        this._getColX = function(x) {
            if (!calendar._cache._coldims) {
                calendar._cache._coldims = calendar._getColumnDimensions();
            }
            return calendar._cache._coldims[x];
        }

        this._clearCachedValues = function() {
            calendar._cache.drawArea = null;
            calendar._cache._coldims = null;
        };

        this._xssTextHtml = function(text, html) {

            if (calendar._resolved._xssProtectionEnabled()) {
                return DayPilot.Util.escapeTextHtml(text, html);
            }

            if (!DayPilot.Util.isNullOrUndefined(html)) {
                return html;
            }
            if (DayPilot.Util.isNullOrUndefined(text)) {
                return "";
            }
            return text;
        };

        this._postBack2 = function(action, data, parameters) {
            var envelope = {};
            envelope.action = action;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);
            __doPostBack(calendar.uniqueID, commandstring);
        };

        this._callBack2 = function(action, parameters, data, type) {

            if (!this._serverBased()) {
                calendar.debug.message("Callback invoked without the server-side backend specified. Callback canceled.", "warning");
                return;
            }

            if (typeof type === 'undefined') {
                type = "CallBack";
            }

            calendar._loadingStart();

            var envelope = {};

            envelope.action = action;
            envelope.type = type;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);
            if (this.backendUrl) {
                DayPilot.request(this.backendUrl, this._callBackResponse, commandstring, this._ajaxError);
            }
            else if (typeof WebForm_DoCallback === 'function') {
                //var clientName = calendar.id;
                WebForm_DoCallback(this.uniqueID, commandstring, this._updateView, this.clientName, this.onCallbackError, true);
            }
        };

        this._serverBased = function() {
            return (calendar._productCode !== "javasc" && calendar._productCode.indexOf("DCODE") === -1) || calendar.devsb;
        };


        this._isAspnetWebForms = function() {
            if (typeof WebForm_DoCallback === 'function' && this.uniqueID) {
                return true;
            }
            return false;
        };

        this._ajaxError = function(req) {
            if (typeof calendar.onAjaxError === 'function') {
                var args = {};
                args.request = req;
                calendar.onAjaxError(args);
            }
            else if (typeof calendar.ajaxError === 'function') { // backwards compatibility
                calendar.ajaxError(req);
            }
        };

        this.dispose = function() {
            var c = calendar;

            clearInterval(c._visibilityInterval);

            if (!c._initialized) {
                return;
            }

            if (c._disposed) {
                return;
            }

            c._disposed = true;

            if (c._watchObserver) {
                c._watchObserver.disconnect();
            }

            c._pauseAutoRefresh();
            c._deleteEvents();

            if (c.nav.messageClose) { c.nav.messageClose.onclick = null; }
            if (c.nav.hourTable) {
                c.nav.hourTable.oncontextmenu = null;
                c.nav.hourTable.onmousemove = null;
            }
            if (c.nav.header) { c.nav.header.oncontextmenu = null; }
            if (c.nav.corner) { c.nav.corner.oncontextmenu = null; }
            if (c.nav.zoom) {
                c.nav.zoom.onmousemove = null;
                c.nav.zoom.oncontextmenu = null;
            }
            if (c.nav.scroll) {
                c.nav.scroll.onscroll = null;
                c.nav.scroll.root = null;
            }

            DayPilot.pu(c.nav.loading);

            c._disposeHourTable();
            c._disposeMain();
            c._disposeHeader();
            c._disposeCorner();

            c.nav.select = null;
            c.nav.cornerRight = null;
            c.nav.scrollable = null;
            c.nav.bottomLeft = null;
            c.nav.bottomRight = null;
            c.nav.allday = null;
            c.nav.zoom = null;
            c.nav.loading = null;
            c.nav.events = null;
            c.nav.header = null;
            c.nav.hourTable = null;
            c.nav.scrolltop = null;
            c.nav.scroll = null;
            c.nav.vsph = null;
            c.nav.main = null;
            c.nav.message = null;
            c.nav.messageClose = null;

            c.nav.top.removeAttribute("style");
            c.nav.top.removeAttribute("class");
            c.nav.top.removeEventListener("mouseleave", calendar._onTopMouseLeave);
            var resetHtml = !(calendar._react.reactDOM && DayPilot.browser.ie);
            if (resetHtml) {
                c.nav.top.innerHTML = "";
            }
            c.nav.top.dp = null;
            c.nav.top = null;

            DayPilot.ue(window, 'resize', c._onResize);

            DayPilotCalendar._unregister(c);

            if (typeof DayPilot.Bubble !== "undefined") {
                DayPilot.Bubble.cancelShowing();
                DayPilot.Bubble.hide({"calendar": c});
            }

            if (typeof DayPilot.Menu !== "undefined") {
                DayPilot.Menu.hide({"calendar": c});
            }
        };

        this._registerDispose = function() {
            this.nav.top.dispose = this.dispose;
        };

        this._callBackResponse = function(response) {
            calendar._updateView(response.responseText);
        };

        this._getCallBackHeader = function() {
            var h = {};

            h.v = this.v;
            h.control = "dpc";
            h.id = this.id;
            h.clientState = calendar.clientState;
            h.columns = this._getTreeState();

            h.days = calendar.days;
            h.startDate = calendar.startDate;
            h.cellDuration = calendar.cellDuration;
            h.cssClassPrefix = calendar.cssClassPrefix;
            h.heightSpec = calendar.heightSpec;
            h.businessBeginsHour = calendar.businessBeginsHour;
            h.businessEndsHour = calendar.businessEndsHour;
            h.viewType = calendar.viewType;

            h.dayBeginsHour = calendar.dayBeginsHour;
            h.dayEndsHour = calendar.dayEndsHour;
            h.headerLevels = calendar.headerLevels;
            // h.backColor = calendar.cellBackColor;
            // h.nonBusinessBackColor = calendar.cellBackColorNonBusiness;
            h.eventHeaderVisible = calendar.eventHeaderVisible;
            h.timeFormat = calendar.timeFormat;
            h.timeHeaderCellDuration = calendar.timeHeaderCellDuration;
            h.locale = calendar.locale;
            h.scrollY = calendar.scrollPos;
            h.showAllDayEvents = calendar.showAllDayEvents;
            h.tagFields = calendar.tagFields;
            h.weekStarts = calendar.weekStarts;

            // required for custom hour header rendering
            // h.hourNameBackColor = calendar.hourNameBackColor;
            // h.hourFontFamily = calendar.hourFontFamily;
            // h.hourFontSize = calendar.hourFontSize;
            // h.hourFontColor = calendar.hourFontColor;

            // export sync
            /*
            h.showHeader = calendar.showHeader;
            h.hourWidth = calendar.hourWidth;
            h.cellHeight = calendar.cellHeight;
            h.headerHeight = calendar.headerHeight;
            h.durationBarVisible = calendar.durationBarVisible;
            h.allDayEventHeight = calendar.allDayEventHeight;
            h.columnMarginRight = calendar.columnMarginRight;
            h.height = calendar.height;
            h.useEventBoxes = calendar.useEventBoxes;
            h.allDayEnd = calendar.allDayEnd;
            h.hideFreeCells = calendar.hideFreeCells;
            */

            h.selected = calendar.multiselect.events();

            // special
            h.hashes = calendar.hashes;

            return h;
        };

        this._out = function() {

            calendar._crosshairHide();

            // clear active areas
            // disabled, hides areas for the current calendar as well
            // DayPilot.Areas.hideAll();

            calendar._stopScroll();
            calendar._lastEventMoving = null;
        };

        this._getTreeState = function() {
            var tree = [];
            tree.ignoreToJSON = true; // preventing Gaia and prototype to mess up with Array serialization

            if (!this._columns) {
                return tree;
            }

            for (var i = 0; i < this._columns.length; i++) {
                var column = this._columns[i];
                var node = this._getNodeState(column);
                tree.push(node);
            }
            return tree;
        };

        this._getNodeState = function(column) {
            //var row = this.rows[i];

            var node = {};
            node.Value = column.id;
            node.Name = column.name;
            node.ToolTip = column.toolTip;
            node.Date = column.start;
            node.Children = this._getNodeChildren(column.children);

            return node;
        };

        this._getNodeChildren = function(array) {
            var children = [];
            children.ignoreToJSON = true; // preventing Gaia to mess up with Array serialization

            if (!array) {
                return children;
            }
            for (var i = 0; i < array.length; i++) {
                children.push(this._getNodeState(array[i]));
            }
            return children;
        };

        this._updateView = function(result, context) {

            //var start = new Date();
            var result = JSON.parse(result);

            if (result.BubbleGuid) {
                var guid = result.BubbleGuid;
                var bubble = this.bubbles[guid];
                delete this.bubbles[guid];

                calendar._loadingStop();
                if (typeof result.Result.BubbleHTML !== 'undefined') {
                    bubble.updateView(result.Result.BubbleHTML, bubble);
                }
                return;
            }

            if (result.CallBackRedirect) {
                document.location.href = result.CallBackRedirect;
                return;
            }

            if (typeof result.ClientState !== 'undefined') {
                calendar.clientState = result.ClientState;
            }

            if (result.UpdateType === "None") {
                calendar._loadingStop();

                calendar._fireAfterRenderDetached(result.CallBackData, true);
                //calendar.afterRender(result.CallBackData, true);

                if (result.Message) {
                    calendar.message(result.Message);
                }

                return;
            }

            calendar._clearCachedValues();

            // viewstate update
            if (result.VsUpdate) {
                var vsph = document.createElement("input");
                vsph.type = 'hidden';
                vsph.name = calendar.id + "_vsupdate";
                vsph.id = vsph.name;
                vsph.value = result.VsUpdate;
                calendar.nav.vsph.innerHTML = '';
                calendar.nav.vsph.appendChild(vsph);
            }

            calendar._deleteEvents();

            calendar.multiselect.clear(true);
            calendar.multiselect._initList = result.SelectedEvents;

            if (typeof result.TagFields !== 'undefined') {
                calendar.tagFields = result.TagFields;
            }

            if (typeof result.SortDirections !== 'undefined') {
                calendar.sortDirections = result.SortDirections;
            }

            if (result.UpdateType === "Full") {
                // generated
                calendar.colors = result.Colors;
                calendar.palette = result.Palette;
                calendar.dirtyColors = result.DirtyColors;
                calendar.cellProperties = result.CellProperties;
                calendar.cellConfig = result.CellConfig;

                if (calendar._columnsList() === calendar.columns) {
                    calendar.columns = result.Columns;
                }
                else {
                    calendar.columns.list = result.Columns;
                }


                // state
                // selectedeventvalue

                // properties
                calendar.days = result.Days; //
                calendar.startDate = new DayPilot.Date(result.StartDate).getDatePart(); //
                calendar.cellDuration = result.CellDuration; //
                calendar.heightSpec = result.HeightSpec ? result.HeightSpec : calendar.heightSpec;
                calendar.businessBeginsHour = result.BusinessBeginsHour ? result.BusinessBeginsHour : calendar.businessBeginsHour;
                calendar.businessEndsHour = result.BusinessEndsHour ? result.BusinessEndsHour : calendar.businessEndsHour;
                calendar.viewType = result.ViewType; //
                calendar.headerLevels = result.HeaderLevels; //
                calendar.backColor = result.BackColor ? result.BackColor : calendar.backColor;
                calendar.nonBusinessBackColor = result.NonBusinessBackColor ? result.NonBusinessBackColor : calendar.nonBusinessBackColor;
                calendar.eventHeaderVisible = result.EventHeaderVisible ? result.EventHeaderVisible : calendar.eventHeaderVisible;
                calendar.timeFormat = result.TimeFormat ? result.TimeFormat : calendar.timeFormat;
                calendar.timeHeaderCellDuration = typeof result.TimeHeaderCellDuration !== 'undefined' ? result.TimeHeaderCellDuration : calendar.timeHeaderCellDuration;
                calendar.locale = result.Locale ? result.Locale : calendar.locale;

                calendar.dayBeginsHour = typeof result.DayBeginsHour !== 'undefined' ? result.DayBeginsHour : calendar.dayBeginsHour;
                calendar.dayEndsHour = typeof result.DayEndsHour !== 'undefined' ? result.DayEndsHour : calendar.dayEndsHour;

                // corner
                // calendar.cornerBackColor = result.CornerBackColor;
                calendar.cornerHtml = result.CornerHTML;

                // hours
                calendar.hours = result.Hours;

                calendar._prepareColumns();
                calendar._expandCellProperties();
            }

            // hashes
            if (result.Hashes) {
                for (var key in result.Hashes) {
                    calendar.hashes[key] = result.Hashes[key];
                }
                //calendar.hashes = result.Hashes;
            }

            calendar._loadEvents(result.Events);
            calendar._updateHeaderHeight();

            if (result.UpdateType === "Full" || calendar.hideFreeCells) {
                calendar._drawHeader();
                calendar._autoHeaderHeight();
                calendar._deleteScrollLabels();
                calendar._updateMessagePosition();
                calendar._drawMain();
                calendar._drawHourTable();
                calendar._updateHeight();
                calendar._fixScrollHeader();
                calendar.clearSelection();
                calendar._updateColumnWidthSpec();

                if (typeof result.ScrollY !== "undefined") {
                    calendar.scrollToY(result.ScrollY);
                }
                else {
                    calendar.scrollToY(calendar.initScrollPos);
                }
            }

            calendar._showCurrentTime();
            calendar._show();  // if not visible

            calendar._drawEvents();
            calendar._drawEventsAllDay();

            if (calendar.heightSpec === "Parent100Pct") {
                calendar._resize();
            }

            if (calendar.timeRangeSelectedHandling !== "HoldForever") {
                calendar.clearSelection();
            }

            calendar._updateScrollLabels();

            if (calendar.todo) {
                if (calendar.todo.del) {
                    var del = calendar.todo.del;
                    del.parentNode.removeChild(del);
                    calendar.todo.del = null;
                }
            }

            calendar._fireAfterRenderDetached(result.CallBackData, true);

            calendar._loadingStop();

            calendar._startAutoRefresh();

            if (result.Message) {
                calendar.message(result.Message);
            }

        };

        this._fireAfterRenderDetached = function(data, isCallBack) {
            var afterRenderDelayed = function(data, isc) {
                return function() {
                    if (calendar._api2()) {
                        if (typeof calendar.onAfterRender === 'function') {
                            var args = {};
                            args.isCallBack = isc;
                            args.data = data;

                            calendar.onAfterRender(args);
                        }
                    }
                    else {
                        if (calendar.afterRender) {
                            calendar.afterRender(data, isc);
                        }
                    }
                };
            };

            window.setTimeout(afterRenderDelayed(data, isCallBack), 0);
        };

        this._createShadow = function(object, copyText) {
            var main = calendar.nav.events;

            var colCount = main.rows[0].cells.length;

            //var colWidth = main.clientWidth / colCount;
            //var i = Math.floor((calendar.coords.x - 45) / colWidth);
            // var i = Math.floor(calendar.coords.x / colWidth);
            var i = calendar._getColumnForPixels(calendar.coords.x);

            if (i < 0) {
                i = 0;
            }

            if (i >= colCount) {
                i = colCount - 1;
            }

            if (calendar.rtl) {
                i = calendar._columnsBottom.length - i - 1;
            }

            var column = main.rows[0].cells[i];

            var _startOffset = 0;
            var height = 0;
            var top = 0;

            if (typeof object.duration !== 'undefined') { // external drag&drop
                var duration = object.duration;
                top = Math.floor(((calendar.coords.y - _startOffset) + calendar.cellHeight / 2) / calendar.cellHeight) * calendar.cellHeight + _startOffset;
                height = duration * calendar.cellHeight / (60 * calendar.cellDuration);
                height = Math.max(height, calendar.cellHeight);
            }
            else {
                var e = object.event;
                //var data = object.data;
                height = e.part.height;
                top = e.part.top;
            }

            var shadow = createDiv();
            shadow.setAttribute('unselectable', 'on');
            shadow.style.position = 'absolute';
            shadow.style.width = '100%';
            shadow.style.height = height + 'px';
            shadow.style.left = '0px';
            shadow.style.top = top + 'px';
            shadow.style.zIndex = calendar._shadowZindex;
            shadow.exclude = true; // trying to fix the IE flickering issue
            //shadow.oncontextmenu = function(ev) { ev.preventDefault(); return false; };

            // registerEvent(shadow, DayPilot.touch.end, DayPilotCalendar._gTouchEnd);

            var inner = createDiv();
            shadow.appendChild(inner);

            shadow.className = calendar._prefixCssClass("_shadow");
            inner.className = this._prefixCssClass("_shadow_inner");

            column.events.appendChild(shadow);

            return shadow;
        };

        this._durationHours = function() {
            return this._duration() / (3600 * 1000);
        };

        this._businessHoursSpan = function() {
            if (this.businessBeginsHour > this.businessEndsHour) {
                return 24 - this.businessBeginsHour + this.businessEndsHour;
            }
            else {
                return this.businessEndsHour - this.businessBeginsHour;
            }
        };

        this._dayHoursSpan = function() {
            if (this.dayBeginsHour >= this.dayEndsHour) {
                return 24 - this.dayBeginsHour + this.dayEndsHour;
            }
            else {
                return this.dayEndsHour - this.dayBeginsHour;
            }

        };

        // in ticks
        this._duration = function(max) {
            var dHours = 0;

            if (this.heightSpec === 'BusinessHoursNoScroll') {
                dHours = this._businessHoursSpan();
            }
            else if (this.hideFreeCells && !max) {
                var addMinutes = (this._maxEnd - 1) * this.cellDuration / this.cellHeight;
                var addHours = Math.ceil(addMinutes / 60);
                var businessEnds = this.businessBeginsHour > this.businessEndsHour ? this.businessEndsHour + 24 : this.businessEndsHour;
                dHours = Math.max(this.dayBeginsHour + addHours, businessEnds) - this._visibleStart();
                //dHours = Math.max(this.dayBeginsHour + addHours, this.businessEndsHour) - this._visibleStart();
            }
            else {
                dHours = this._dayHoursSpan();
            }
            return dHours * 60 * 60 * 1000; // return ticks
        };

        // options: delay, rawHtml, cssClass
        this.message = function(text, opt) {
            if (text === null) {
                return;
            }

            if (!calendar._initialized) {
                return;
            }

            var options = {};
            var delay;
            if (typeof arguments[1] === "object") {
                options = arguments[1];
                delay = options.delay;
            }
            else {
                delay = opt;
            }

            var html = "";
            if (options.rawHtml) {
                html = text;
            }
            else {
                html = DayPilot.Util.escapeHtml(text);
            }

            delay = delay || this.messageHideAfter || 2000;

            var div;

            var top = this._totalHeaderHeight();
            var left = this.showHours ? this.hourWidth : 0;
            var right = DayPilot.sw(calendar._scrollElement());

            if (calendar.rtl) {
                var temp = left;
                left = right;
                right = temp;
            }

            if (!this.nav.message) {
                div = createDiv();
                div.style.position = "absolute";
                div.style.left = (left) + "px";
                div.style.top = (top) + "px";
                div.style.right = "0px";
                div.style.display = 'none';

                div.onmousemove = function() {
                    if (div.messageTimeout && !div.status) {
                        clearTimeout(div.messageTimeout);
                    }
                };

                div.onmouseout = function() {
                    if (calendar.nav.message.style.display !== 'none') {
                        div.messageTimeout = setTimeout(calendar._hideMessage, 500);
                    }
                };

                var inner = createDiv();
                inner.onclick = function() { calendar.nav.message.style.display = 'none'; };
                inner.className = this._prefixCssClass("_message");
                div.appendChild(inner);

                var close = createDiv();
                close.style.position = "absolute";
                close.className = this._prefixCssClass("_message_close");
                close.onclick = function() { calendar.nav.message.style.display = 'none'; };
                div.appendChild(close);

                //this.nav.top.appendChild(div);
                this.nav.top.insertBefore(div, this.nav.loading);
                this.nav.message = div;
                this.nav.messageClose = close;

            }
            else {
                div = calendar.nav.message;
                this.nav.message.style.top = top + "px";
            }

            if (this.nav.cornerRight) {
                this.nav.message.style.right = right + "px";
            }
            else {
                this.nav.message.style.right = "0px";
            }

            var showNow = function() {

                if (!calendar.nav.message) {  // UpdatePanel refresh
                    return;
                }

                var inner = calendar.nav.message.firstChild;
                inner.className = calendar._prefixCssClass("_message"); // clear any custom css that may have been set

                if (options.cssClass) {
                    addClass(inner, options.cssClass);
                }

                inner.innerHTML = html;

                var end = function() { div.messageTimeout = setTimeout(calendar._hideMessage, delay); };
                DayPilot.fade(calendar.nav.message, 0.2, end);
            };

            clearTimeout(div.messageTimeout);

            // another message was visible
            if (this.nav.message.style.display !== 'none') {
                DayPilot.fade(calendar.nav.message, -0.2, showNow);
            }
            else {
                showNow();
            }

        };

        this.message.show = function(html) {
            calendar.message(html);
        };

        this.message.hide = function() {
            calendar._hideMessage();
        };

        this._hideMessage = function() {
            var end = function() { calendar.nav.message.style.display = 'none'; };
            DayPilot.fade(calendar.nav.message, -0.2, end);
        };

        /*
        this._hideMessageNow = function() {
            if (this.nav.message) {
                this.nav.message.style.display = 'none';
            }
        };
        */

        this._updateMessagePosition = function() {
            if (this.nav.message) {
                this.nav.message.style.top = (this._totalHeaderHeight()) + "px";
            }
        };

        this._rowCount = function() {
            return this._duration() / (60 * 1000 * this.cellDuration);
        };

        this.eventClickPostBack = function(e, data) {
            this._postBack2('EventClick', data, e);
        };
        this.eventClickCallBack = function(e, data) {
            this._callBack2('EventClick', e, data);
        };

        this._eventClickDispatch = function(e) {
            var div = this;

            var e = e || window.event;
            var ctrlKey = e.ctrlKey;
            var metaKey = e.metaKey;

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            if (calendar.eventDoubleClickHandling === 'Disabled') {
                calendar._eventClickSingle(div, ctrlKey, metaKey, e);
                return;
            }

            if (!calendar.timeouts) {
                calendar.timeouts = [];
            }
            else {
                for (var toid in calendar.timeouts) {
                    window.clearTimeout(calendar.timeouts[toid]);
                }
                calendar.timeouts = [];
            }

            var eventClickDelayed = function(div, ctrlKey, metaKey, e) {
                return function() {
                    calendar._eventClickSingle(div, ctrlKey, metaKey, e);
                };
            };

            calendar.timeouts.push(window.setTimeout(eventClickDelayed(this, ctrlKey, metaKey, e), calendar.doubleClickTimeout));

        };

        this._eventClickSingle = function(thisDiv, ctrlKey, metaKey, originalEvent) {

            //var ev = ev || window.event;

            var e = thisDiv.event;
            if (!e.client.clickEnabled()) {
                return;
            }

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;
                args.ctrl = ctrlKey;
                args.meta = metaKey;
                args.originalEvent = originalEvent;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventClick === 'function') {
                    calendar.onEventClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(thisDiv);
                        break;
                    case 'Select':
                        calendar._eventSelect(thisDiv, e, ctrlKey, metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                }

                if (typeof calendar.onEventClicked === 'function') {
                    calendar.onEventClicked(args);
                }


            }
            else {
                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventClick(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(thisDiv);
                        break;
                    case 'Select':
                        calendar._eventSelect(thisDiv, e, ctrlKey, metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                }

            }

        };


        this.eventDoubleClickPostBack = function(e, data) {
            this._postBack2('EventDoubleClick', data, e);
        };
        this.eventDoubleClickCallBack = function(e, data) {
            this._callBack2('EventDoubleClick', e, data);
        };

        this._eventDoubleClickDispatch = function(ev) {

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            if (calendar.timeouts) {
                for (var toid in calendar.timeouts) {
                    window.clearTimeout(calendar.timeouts[toid]);
                }
                calendar.timeouts = null;
            }

            // choose the action

            var e = this.event;
            var ev = ev || window.event;

            /*
            if (!e.clickingAllowed()) {
            return;
            }*/


            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventDoubleClick === 'function') {
                    calendar.onEventDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'Edit':
                        if (!e.allday()) {
                            calendar._divEdit(this);
                        }
                        break;
                    case 'Select':
                        if (!e.allday()) {
                            calendar._eventSelect(this, e, ev.ctrlKey);
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventDoubleClicked === 'function') {
                    calendar.onEventDoubleClicked(args);
                }

            }
            else {
                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDoubleClick(e);
                        break;
                    case 'Edit':
                        if (!e.allday()) {
                            calendar._divEdit(this);
                        }
                        break;
                    case 'Select':
                        if (!e.allday()) {
                            calendar._eventSelect(this, e, ev.ctrlKey);
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

            }

        };

        this.eventRightClickPostBack = function(e, data) {
            this._postBack2('EventRightClick', data, e);
        };
        this.eventRightClickCallBack = function(e, data) {
            this._callBack2('EventRightClick', e, data);
        };

        this._eventRightClickDispatch = function(ev) {

            var e = this.event;

            if (ev.stopPropagation) {
                ev.stopPropagation();
            }

            if (!e.client.rightClickEnabled()) {
                return false;
            }

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventRightClick === 'function') {
                    calendar.onEventRightClick(args);
                    if (args.preventDefault.value) {
                        return false;
                    }
                }

                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventRightClicked === 'function') {
                    calendar.onEventRightClicked(args);
                }

            }
            else {
                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventRightClick(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }
            }

            if (ev.preventDefault) {
                ev.preventDefault();
            }
            return false;
        };

        this._createColumn = function(data) {
            return new DayPilot.Column(data, calendar);
        };

        this.headerClickPostBack = function(c, data) {
            this._postBack2('HeaderClick', data, c);
        };
        this.headerClickCallBack = function(c, data) {
            this._callBack2('HeaderClick', c, data);
        };

        this._headerClickDispatch = function(ev) {

            var data = this.data;
            var c = calendar._createColumn(data, calendar);
            // check if allowed

            if (calendar._api2()) {

                var args = {};
                args.header = {};
                args.header.id = data.id;
                args.header.name = data.name;
                args.header.start = data.start;
                args.column = c;
                args.originalEvent = ev;
                args.shift = ev.shiftKey;
                args.ctrl = ev.ctrlKey;
                args.meta = ev.metaKey;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onHeaderClick === 'function') {
                    calendar.onHeaderClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.headerClickHandling) {
                    case 'PostBack':
                        calendar.headerClickPostBack(c);
                        break;
                    case 'CallBack':
                        calendar.headerClickCallBack(c);
                        break;
                }

                if (typeof calendar.onHeaderClicked === 'function') {
                    calendar.onHeaderClicked(args);
                }
            }
            else {
                switch (calendar.headerClickHandling) {
                    case 'PostBack':
                        calendar.headerClickPostBack(c);
                        break;
                    case 'CallBack':
                        calendar.headerClickCallBack(c);
                        break;
                    case 'JavaScript':
                        calendar.onHeaderClick(c);
                        break;
                }
            }

/*
            switch (calendar.headerClickHandling) {
                case 'PostBack':
                    calendar.headerClickPostBack(c);
                    break;
                case 'CallBack':
                    calendar.headerClickCallBack(c);
                    break;
                case 'JavaScript':
                    calendar.onHeaderClick(c);
                    break;
            }
            */
        };

        this._headerMouseMove = function(ev) {

            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.columnBubble) {
                if (calendar.viewType === "Resources") {
                    var res = {};
                    res.calendar = calendar;
                    res.start = this.data.start;
                    res.name = this.data.name;
                    res.id = this.data.id;
                    res.toJSON = function() {
                        var json = {};
                        json.id = this.id;
                        json.start = this.start;
                        json.name = this.name;
                        return json;
                    };
                    calendar.columnBubble.showResource(res);
                }
                else {
                    var start = new DayPilot.Date(this.data.start);
                    var end = start.addDays(1);

                    var time = {};
                    time.calendar = calendar;
                    time.start = start;
                    time.end = end;
                    time.toJSON = function() {
                        var json = {};
                        json.start = this.start;
                        json.end = this.end;
                        return json;
                    };

                    calendar.columnBubble.showTime(time);
                }
            }

            var cell = this;
            var div = cell.firstChild; // rowheader
            if (!div.active) {
                //div.data = calendar.rows[td.index];  // TODO replace with custom object
                var data = cell.data;
                // var c = new DayPilot.Column(data.id, data.name, data.start);
                var c = calendar._createColumn(data);
                c.areas = cell.data.areas;

                DayPilot.Areas.showAreas(div, c);
            }

            if (typeof cmov !== "undefined" && cmov._active) {
                cmov._mouseMove(ev, cell);
            }


        };

        this._headerMouseOut = function(ev) {
            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.columnBubble) {
                calendar.columnBubble.hideOnMouseOut();
            }
            DayPilot.Areas.hideAreas(this.firstChild, ev);
        };

        this.eventDeletePostBack = function(e, data) {
            this._postBack2('EventDelete', data, e);
        };
        this.eventDeleteCallBack = function(e, data) {
            this._callBack2('EventDelete', e, data);
        };

        this._eventDeleteDispatch = function(object) {
            var e;
            if (object && object.isEvent) {
                e = object;
            }
            else {
                e = object.parentNode.parentNode.event;
            }

            if (typeof DayPilot.Bubble !== "undefined") {
                DayPilot.Bubble.hideActive();
                DayPilot.Bubble.cancelShowing();
            }

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventDelete === 'function') {
                    calendar.onEventDelete(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventDeleteHandling) {
                    case 'PostBack':
                        calendar.eventDeletePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDeleteCallBack(e);
                        break;
                    case 'Update':
                        calendar.events.remove(e);
                        break;
                }

                if (typeof calendar.onEventDeleted === 'function') {
                    calendar.onEventDeleted(args);
                }
            }
            else {
                switch (calendar.eventDeleteHandling) {
                    case 'PostBack':
                        calendar.eventDeletePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDeleteCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDelete(e);
                        break;
                }
            }
        };

        this.eventResizePostBack = function(e, newStart, newEnd, data) {
            if (!newStart) {
                throw 'newStart is null';
            }
            if (!newEnd) {
                throw 'newEnd is null';
            }

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._postBack2('EventResize', data, params);
        };

        this.eventResizeCallBack = function(e, newStart, newEnd, data) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._callBack2('EventResize', params, data);
        };

        this._invokeEvent = function(type, action, params, data) {

            if (type === 'PostBack') {
                calendar.postBack2(action, params, data);
            }
            else if (type === 'CallBack') {
                calendar._callBack2(action, params, data, "CallBack");
            }
            else if (type === 'Immediate') {
                calendar._callBack2(action, params, data, "Notify");
            }
            else if (type === 'Queue') {
                calendar.queue.add(new DayPilot.Action(this, action, params, data));
            }
            else if (type === 'Notify') {
                if (resolved._notifyType() === 'Notify') {
                    calendar._callBack2(action, params, data, "Notify");
                }
                else {
                    calendar.queue.add(new DayPilot.Action(calendar, action, params, data));
                }
            }
            else {
                throw new DayPilot.Exception("Invalid event invocation type");
            }
        };

        // just hours (int)
        this._visibleStart = function(max) {

            if (this.heightSpec === 'BusinessHoursNoScroll') {
                return this.businessBeginsHour;
            }
            else if (this.hideFreeCells && !max) {
                var addMinutes = (this._minStart) * this.cellDuration / this.cellHeight;
                var addHours = Math.floor(addMinutes / 60);
                addHours = Math.max(0, addHours);
                return Math.min(this.dayBeginsHour + addHours, this.businessBeginsHour);
            }
            else {
                return this.dayBeginsHour;
            }
        };

        this.visibleStart = function() {
            if (calendar.viewType === "Resources") {
                if (calendar._columnsBottom.isEmpty()) {
                    return DayPilot.Date.today();
                }
                var dates = createList(calendar._columnsBottom).map(function(column) {
                    return column.start.getTime();
                });
                var min = Math.min.apply(null, dates);
                return new DayPilot.Date(min);
            }
            return this._columnsBottom[0].start;
        };

        this.visibleEnd = function() {
            if (calendar.viewType === "Resources") {
                if (calendar._columnsBottom.isEmpty()) {
                    return DayPilot.Date.today().addDays(1);
                }
                var dates = createList(calendar._columnsBottom).map(function(column) {
                    return column.start.getTime();
                });
                var max = Math.max.apply(null, dates);
                return new DayPilot.Date(max).addDays(1);
            }
            var columns = this._columnsBottom;
            var max = columns.length - 1;
            return columns[max].start.addDays(1);
        };

        this._api2 = function() {
            return calendar.api === 2;
        };

        this._getResizingStartFromTop = function(e, shadowTop) {
            var start = e.start();
            var day = calendar._columnsBottom[e.part.dayIndex].start;
            var step = Math.floor(shadowTop / calendar.cellHeight);
            var minutes = step * calendar.cellDuration;
            var ts = minutes * 60 * 1000;
            var visibleStartOffset = calendar._visibleStart() * 60 * 60 * 1000;
            return day.addTime(ts + visibleStartOffset);
        };

        this._getResizingEndFromBottom = function(e, shadowBottom) {
            var step = Math.floor(shadowBottom / calendar.cellHeight);
            var minutes = step * calendar.cellDuration;
            var ts = minutes * 60 * 1000;
            var visibleStartOffset = calendar._visibleStart() * 60 * 60 * 1000;
            var day = calendar._columnsBottom[e.part.dayIndex].start;
            return day.addTime(ts + visibleStartOffset);
        };

        this._eventResizeDispatch = function(e, shadowHeight, shadowTop, border) {

            if (this.eventResizeHandling === 'Disabled') {
                return;
            }

            var newStart, newEnd;

            if (border === 'top') {
                newStart = calendar._getResizingStartFromTop(e, shadowTop);
                newEnd = e.end();

            }
            else if (border === 'bottom') {
                newStart = e.start();
                newEnd = calendar._getResizingEndFromBottom(e, shadowTop + shadowHeight);
            }

            if (calendar._api2()) {
                // API v2
                var args = {};

                var performResize = function() {
                    // make sure it can't be fired again
                    args.loaded = function () {};

                    calendar._clearResizingShadow();

                    if (args.preventDefault.value) {
                        return;
                    }

                    switch (calendar.eventResizeHandling) {
                        case 'PostBack':
                            calendar.eventResizePostBack(e, newStart, newEnd);
                            break;
                        case 'CallBack':
                            calendar.eventResizeCallBack(e, newStart, newEnd);
                            break;
                        case 'Notify':
                            calendar.eventResizeNotify(e, newStart, newEnd);
                            break;
                        case 'Update':
                            e.start(newStart);
                            e.end(newEnd);
                            calendar.events.update(e);
                            break;
                    }

                    if (typeof calendar.onEventResized === 'function') {
                        calendar.onEventResized(args);
                    }
                };

                args.e = e;
                args.control = calendar;
                args.newStart = newStart;
                args.newEnd = newEnd;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.async = false;
                args.hideShadow = function() {
                    calendar._clearResizingShadow();
                };
                args.loaded = function() {
                    performResize();
                };

                if (typeof calendar.onEventResize === 'function') {
                    calendar.onEventResize(args);
                    if (args.preventDefault.value) {
                        calendar._clearResizingShadow();
                        return;
                    }
                }

                if (!args.async) {
                    performResize();
                }

            }
            else {
                calendar._clearResizingShadow();
                switch (calendar.eventResizeHandling) {
                    case 'PostBack':
                        calendar.eventResizePostBack(e, newStart, newEnd);
                        break;
                    case 'CallBack':
                        calendar.eventResizeCallBack(e, newStart, newEnd);
                        break;
                    case 'JavaScript':
                        calendar.onEventResize(e, newStart, newEnd);
                        break;
                    case 'Notify':
                        calendar.eventResizeNotify(e, newStart, newEnd);
                        break;
                }
            }
        };

        this.eventResizeNotify = function(e, newStart, newEnd, data) {

            var old = new DayPilot.Event(e.copy(), this);

            e.start(newStart);
            e.end(newEnd);
            e.commit();

            calendar.update();

            this._invokeEventResize("Notify", old, newStart, newEnd, data);

        };

        this._invokeEventResize = function(type, e, newStart, newEnd, data) {
            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._invokeEvent(type, "EventResize", params, data);
        };


        this.eventMovePostBack = function(e, newStart, newEnd, newResource, data) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            params.newResource = newResource;

            this._postBack2('EventMove', data, params);
        };

        this.eventMoveCallBack = function(e, newStart, newEnd, newResource, data) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            params.newResource = newResource;

            this._callBack2('EventMove', params, data);
        };

        this._calculatePositionFromShadow = function(e, newColumnIndex, shadowTop) {

            var _startOffset = 0;
            var step = Math.floor((shadowTop - _startOffset) / calendar.cellHeight);

            var cellSize = calendar.cellDuration; // should be integer
            var boxStart = step * cellSize * 60 * 1000;
            var start = e.start();
            var end = e.end();
            var day = new Date();

            if (start instanceof DayPilot.Date) {
                start = start.toDate();
            }
            day.setTime(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate()));

            var startOffset = (calendar.useEventBoxes !== 'Never') ? start.getTime() - (day.getTime() + start.getUTCHours() * 3600 * 1000 + Math.floor(start.getUTCMinutes() / cellSize) * cellSize * 60 * 1000) : 0;
            var length = end.getTime() - start.getTime();
            var visibleStartOffset = calendar._visibleStart() * 3600 * 1000;

            if (typeof newColumnIndex === "undefined") {
                newColumnIndex = e.part.dayIndex;
            }
            var newColumn = this._columnsBottom[newColumnIndex];

            var date = newColumn.start.getTime();
            var newStartUTC = new Date();
            newStartUTC.setTime(date + boxStart + startOffset + visibleStartOffset);

            var newStart = new DayPilot.Date(newStartUTC);

            var newEnd = newStart.addTime(length);

            var newResource = newColumn.id;

            return {
                "start": newStart,
                "end": newEnd,
                "resource": newResource
            };
        };

        this._eventMoveDispatch = function(e, newColumnIndex, shadowTop, ev, drag) {

            if (calendar.eventMoveHandling === 'Disabled') {
                return;
            }

            var newPosition = calendar._calculatePositionFromShadow(e, newColumnIndex, shadowTop);

            var newStart = newPosition.start;
            var newEnd = newPosition.end;
            var newResource = newPosition.resource;

            var external = !!drag;

            if (calendar._api2()) {
                // API v2
                var args = {};

                var performMove = function() {

                    // make sure it can't be fired again
                    args.loaded = function () {};

                    calendar._clearMovingShadow();

                    if (args.preventDefault.value) {
                        return;
                    }

                    switch (calendar.eventMoveHandling) {
                        case 'PostBack':
                            calendar.eventMovePostBack(e, newStart, newEnd, newResource);
                            break;
                        case 'CallBack':
                            calendar.eventMoveCallBack(e, newStart, newEnd, newResource);
                            break;
                        case 'Notify':
                            calendar.eventMoveNotify(e, newStart, newEnd, newResource);
                            break;
                        case 'Update':
                            e.start(newStart);
                            e.end(newEnd);
                            e.resource(newResource);
                            if (external) {
                                e.commit();
                                calendar.events.add(e);
                            }
                            else {
                                calendar.events.update(e);
                            }

                            calendar._deleteDragSource();
                            break;
                    }

                    // calendar._clearMovingShadow();

                    if (typeof calendar.onEventMoved === 'function') {
                        calendar.onEventMoved(args);
                    }

                };

                args.e = e;
                args.control = calendar;
                args.newStart = newPosition.start;
                args.newEnd = newPosition.end;
                args.newResource = newPosition.resource;
                args.external = external;
                args.areaData = DpGlobal.movingAreaData;
                args.ctrl = false;
                if (ev) {
                    args.ctrl = ev.ctrlKey;
                }
                args.shift = false;
                if (ev) {
                    args.shift = ev.shiftKey;
                }
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.async = false;
                args.hideShadow = function() {
                    calendar._clearMovingShadow();
                };
                args.loaded = function() {
                    performMove();
                };

                if (typeof calendar.onEventMove === 'function') {
                    calendar.onEventMove(args);
                    if (args.preventDefault.value) {
                        calendar._clearMovingShadow();
                        return;
                    }
                }

                if (!args.async) {
                    performMove();
                }
            }
            else {
                calendar._clearMovingShadow();
                switch (calendar.eventMoveHandling) {
                    case 'PostBack':
                        calendar.eventMovePostBack(e, newStart, newEnd, newResource);
                        break;
                    case 'CallBack':
                        calendar.eventMoveCallBack(e, newStart, newEnd, newResource);
                        break;
                    case 'JavaScript':
                        calendar.onEventMove(e, newStart, newEnd, newResource, external, ev ? ev.ctrlKey : false, ev ? ev.shiftKey : false);
                        break;
                    case 'Notify':
                        calendar.eventMoveNotify(e, newStart, newEnd, newResource, null);
                        break;

                }
            }

        };

        this.eventMoveNotify = function(e, newStart, newEnd, newResource, data) {

            var old = new DayPilot.Event(e.copy(), this);

            e.start(newStart);
            e.end(newEnd);
            e.resource(newResource);
            e.commit();

            calendar.update();

            this._invokeEventMove("Notify", old, newStart, newEnd, newResource, data);

        };

        this._invokeEventMove = function(type, e, newStart, newEnd, newResource, data) {
            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            params.newResource = newResource;

            this._invokeEvent(type, "EventMove", params, data);
        };

        this._deleteDragSource = function() {
            if (calendar.todo) {
                if (calendar.todo.del) {
                    var del = calendar.todo.del;
                    del.parentNode.removeChild(del);
                    calendar.todo.del = null;
                }
            }
        };

        // called by DayPilot.Bubble
        this._bubbleCallBack = function(args, bubble) {
            var guid = calendar._recordBubbleCall(bubble);

            var params = {};
            params.args = args;
            params.guid = guid;

            calendar._callBack2("Bubble", params);
        };

        this._recordBubbleCall = function(bubble) {
            var guid = DayPilot.guid();
            if (!this.bubbles) {
                this.bubbles = [];
            }

            this.bubbles[guid] = bubble;
            return guid;
        };

        this.eventMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.e = e;
            params.command = command;

            this._postBack2('EventMenuClick', data, params);

        };
        this.eventMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.e = e;
            params.command = command;

            this._callBack2('EventMenuClick', params, data);

        };

        // called by DayPilot.Menu
        this._eventMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.eventMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.eventMenuClickCallBack(e, command);
                    break;
            }
        };

        this.timeRangeMenuClickPostBack = function(e, command, data) {
            //        this.postBack('TRM:', e.start, e.end, e.resource, command);
            var params = {};
            params.selection = e;
            params.command = command;

            this._postBack2("TimeRangeMenuClick", data, params);

        };
        this.timeRangeMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.selection = e;
            params.command = command;

            this._callBack2("TimeRangeMenuClick", params, data);
        };

        // called by DayPilot.Menu
        this._timeRangeMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.timeRangeMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.timeRangeMenuClickCallBack(e, command);
                    break;
            }
        };

        this.timeRangeSelectedPostBack = function(start, end, resource, data) {
            //this.postBack('FRE:', start, end, column);
            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._postBack2('TimeRangeSelected', data, range);
        };
        this.timeRangeSelectedCallBack = function(start, end, resource, data) {

            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._callBack2('TimeRangeSelected', range, data);
        };

        this._timeRangeSelectedDispatch = function(start, end, column, origin) {
            // make sure it's DayPilot.Date
            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);
            origin = origin || "click";

            var resource = column;

            if (calendar._api2()) {

                var args = {};
                args.start = start;
                args.end = end;
                args.resource = resource;
                args.control = calendar;
                args.origin = origin;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.toJSON = function() {
                    return copyProps(args, {}, ["start", "end", "resource"]);
                };


                if (typeof calendar.onTimeRangeSelect === 'function') {
                    calendar.onTimeRangeSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                // now perform the default builtin action
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end, resource);
                        break;
                    case 'CallBack':
                        calendar.timeRangeSelectedCallBack(start, end, resource);
                        break;
                }

                if (typeof calendar.onTimeRangeSelected === 'function') {
                    calendar.onTimeRangeSelected(args);
                }

            }
            else {
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end, column);
                        break;
                    case 'CallBack':
                        calendar.timeRangeSelectedCallBack(start, end, column);
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeSelected(start, end, column);
                        break;
                }
            }
        };

        this.timeRangeDoubleClickPostBack = function(start, end, column, data) {
            var range = {};
            range.start = start;
            range.end = end;
            range.resource = column;

            this._postBack2('TimeRangeDoubleClick', data, range);
            //        this.postBack('TRD:', start, end, column);
        };
        this.timeRangeDoubleClickCallBack = function(start, end, column, data) {

            var range = {};
            range.start = start;
            range.end = end;
            range.resource = column;

            this._callBack2('TimeRangeDoubleClick', range, data);
        };

        this._timeRangeClickDispatch = function(start, end, column) {
            if (!calendar._api2()) {
                return;
            }

            var resource = column;

            var args = {};
            args.start = start;
            args.end = end;
            args.resource = resource;

            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onTimeRangeClick === 'function') {
                calendar.onTimeRangeClick(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            if (typeof calendar.onTimeRangeClicked === 'function') {
                calendar.onTimeRangeClicked(args);
            }

        };


        this._timeRangeDoubleClickDispatch = function(start, end, column) {
            if (calendar._api2()) {

                var resource = column;

                var args = {};
                args.start = start;
                args.end = end;
                args.resource = resource;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeRangeDoubleClick === 'function') {
                    calendar.onTimeRangeDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end, resource);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end, resource);
                        break;
                }

                if (typeof calendar.onTimeRangeDoubleClicked === 'function') {
                    calendar.onTimeRangeDoubleClicked(args);
                }
            }
            else {
                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end, column);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end, column);
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeDoubleClick(start, end, column);
                        break;
                }
            }
        };

        this.eventEditPostBack = function(e, newText, data) {
            var params = {};
            params.e = e;
            params.newText = newText;

            this._postBack2("EventEdit", data, params);
        };

        this.eventEditCallBack = function(e, newText, data) {

            var params = {};
            params.e = e;
            params.newText = newText;

            this._callBack2("EventEdit", params, data);
        };

        this._eventEditDispatch = function(e, newText) {
            if (calendar._api2()) {

                var args = {};
                args.control = calendar;
                args.e = e;
                args.newText = newText;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventEdit === 'function') {
                    calendar.onEventEdit(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventEditHandling) {
                    case 'PostBack':
                        calendar.eventEditPostBack(e, args.newText);
                        break;
                    case 'CallBack':
                        calendar.eventEditCallBack(e, args.newText);
                        break;
                    case 'Update':
                        e.text(args.newText);
                        calendar.events.update(e);
                        break;
                }

                if (typeof calendar.onEventEdited === 'function') {
                    calendar.onEventEdited(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }
            }
            else {
                switch (calendar.eventEditHandling) {
                    case 'PostBack':
                        calendar.eventEditPostBack(e, newText);
                        break;
                    case 'CallBack':
                        calendar.eventEditCallBack(e, newText);
                        break;
                    case 'JavaScript':
                        calendar.onEventEdit(e, newText);
                        break;
                }
            }

        };

        this.eventSelectPostBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._postBack2('EventSelect', data, params);
        };

        this.eventSelectCallBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._callBack2('EventSelect', params, data);
        };

        this._eventSelectDispatch = function(div, e, ctrlKey, metaKey) {

            var m = calendar.multiselect;

            var allowDeselect = false;
            var isSelected = m.isSelected(e);
            var ctrlOrMeta = ctrlKey || metaKey;
            if (!ctrlOrMeta && isSelected && !allowDeselect && m._list.length === 1) {
                return;
            }

            if (calendar._api2()) {

                m.previous = m.events();

                var args = {};
                args.e = e;
                args.selected = m.isSelected(e);
                args.ctrl = ctrlKey;
                args.meta = metaKey;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventSelect === 'function') {
                    calendar.onEventSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'Update':
                        m._toggleDiv(div, ctrlKey);
                        break;
                }

                if (typeof calendar.onEventSelected === 'function') {
                    args.change = m.isSelected(e) ? "selected" : "deselected";
                    args.selected = m.isSelected(e);
                    calendar.onEventSelected(args);
                }

            }
            else {
                m.previous = m.events();
                m._toggleDiv(div, ctrlKey);
                var change = m.isSelected(e) ? "selected" : "deselected";

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'JavaScript':
                        calendar.onEventSelect(e, change);
                        break;
                }
            }

        };

        this.commandCallBack = function(command, data) {
            this._pauseAutoRefresh();

            var params = {};
            params.command = command;

            this._callBack2('Command', params, data);
        };

        this._onCellMouseDown = function(ev) {

            if (touch.active || touch.using) {
                //ev.preventDefault();
                return;
            }

            clearTimeout(DayPilotCalendar.selectedTimeout);

            if (DpGlobal.selecting) {
                return;
            }

            if (DayPilotCalendar.editing) {
                DayPilotCalendar.editing.blur();
                return;
            }

            // if double click is active, check if the click was inside
            if (calendar._selectedCells && calendar.timeRangeDoubleClickHandling !== 'Disabled') {
                // only if the click is on an active cell
                for (var i = 0; i < calendar._selectedCells.length; i++) {
                    if (this === calendar._selectedCells[i]) {
                        return;
                    }
                }
            }

            if (calendar.timeRangeSelectedHandling === "Disabled") {
                return;
            }

            //var button = (window.event) ? window.event.button : ev.which;
            var button = DayPilot.Util.mouseButton(ev);
            if (!button.left) {
                return;
            }

            var x = calendar._getColumnForPixels(calendar.coords.x, true);

            DayPilotCalendar._firstMousePos = calendar.coords;
            DayPilotCalendar._firstMousePos.calendar = calendar;
            calendar.clearSelection();  // initializes selectedCells if necessary
            DayPilotCalendar._topSelectedCell = this;
            DayPilotCalendar._bottomSelectedCell = this;
            DayPilotCalendar._selectedColumn = x;
            calendar._selectedCells.push(this);
            DayPilotCalendar._firstSelected = this;

            DpGlobal.selecting = {"calendar": calendar};
            calendar._activateSelection();

        };

        this._activateSelection = function() {

            var selection = this.getSelection();

            if (!selection) {
                return;
            }

            if (!calendar._selectedCells) {
                return;
            }

            (function activateSelectionNew() {

                var first = DayPilotCalendar._topSelectedCell;
                var last = DayPilotCalendar._bottomSelectedCell;

                // var columnIndex = first.parentNode.cells.indexOf(first);

                var columnIndex = (function() {
                    // it's the new div cell
                    if (first.data) {
                        return first.data.x;
                    }

                    var cells = first.parentNode.cells;
                    for (var i = 0; i < cells.length; i++) {
                        if (cells[i] === first) {
                            return i;
                        }
                    }
                    return -1;
                })();

                var format = calendar.timeRangeSelectingStartEndFormat;
                if (format === "Auto") {
                    format = resolved._timeFormat() === "Clock24Hours" ? "H:mm" : "h:mm tt";
                }

                var col = calendar._columnsBottom[columnIndex];

                if (!col) {
                    return;
                }

                var natural = DayPilotCalendar._topSelectedCell === DayPilotCalendar._firstSelected;

                var args = {};
                args.anchor = natural ? first.start : last.end;
                args.start = first.start;
                args.end = last.end;
                args.duration = new DayPilot.Duration(args.start, args.end);
                args.resource = col.id;
                args.allowed = true;
                args.html = null;
                args.cssClass = null;

                args.top = {};
                args.top.width = null;
                args.top.space = 5;
                args.top.html = args.start.toString(format, resolved._locale());
                args.top.enabled = calendar.timeRangeSelectingStartEndEnabled;

                args.bottom = {};
                args.bottom.width = null;
                args.bottom.space = 5;
                args.bottom.html = args.end.toString(format, resolved._locale());
                args.bottom.enabled = calendar.timeRangeSelectingStartEndEnabled;

                // calendar._touchMsg("before check");

                // disabled, prevented tap on touch devices
                /*if (!DpGlobal.selecting) {
                    return;
                }*/

                // calendar._touchMsg("after check");

                var previous = DpGlobal.selecting && DpGlobal.selecting.args;
                if (previous && previous.start === args.start && previous.end === args.end && previous.resource == args.resource) {
                    return;
                }

                if (!calendar.allowEventOverlap) {
                    var data = {
                        "id": null,
                        "start": args.start,
                        "end": args.end,
                        "resource": args.resource
                    };
                    if (calendar.events._overlaps(data)) {
                        args.allowed = false;
                    }
                }
                if (calendar._overDisabledCells(args.start, args.end, args.resource)) {
                    // addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                    args.allowed = false;
                }

                if (typeof calendar.onTimeRangeSelecting === "function" && args.allowed) {
                    calendar.onTimeRangeSelecting(args);
                }

                //deleteElement(calendar.elements.selection);
                //calendar.elements.selection = [];

                if (DpGlobal.selecting) {
                    DpGlobal.selecting.args = args;
                }

                // var top = calendar._getPixels(first.start, col.start).boxTop - calendar._autoHiddenPixels();
                // var bottom = calendar._getPixels(last.end, col.start).boxBottom - calendar._autoHiddenPixels();
                var top = calendar._getPixels(args.start, col.start).boxTop - calendar._autoHiddenPixels();
                var bottom = calendar._getPixels(args.end, col.start).boxBottom - calendar._autoHiddenPixels();
                var height = bottom - top;

                var div = (function() {
                    if (calendar.nav.activeSelection) {
                        return calendar.nav.activeSelection;
                    }
                    var div = createDiv();
                    div.setAttribute("unselectable", "on");
                    div.style.zIndex = calendar._shadowZindex;
                    div.style.position = "absolute";
                    div.style.left = "0px";
                    div.style.width = "100%";

                    div.onclick = function(e) {
                        if (calendar.timeRangeClickHandling === "Disabled") {
                            return;
                        }
                        var sel = calendar.getSelection();
                        if (!sel) {
                            return;
                        }
                        calendar._timeRangeClickDispatch(sel.start, sel.end, sel.resource);
                    };
                    div.ondblclick = function(e) {
                        if (calendar.timeRangeDoubleClickHandling === "Disabled") {
                            return;
                        }
                        clearTimeout(calendar._timeRangeClickTimeout);
                        var sel = calendar.getSelection();
                        if (!sel) {
                            return;
                        }
                        calendar._timeRangeDoubleClickDispatch(sel.start, sel.end, sel.resource);
                    };

                    var inner = createDiv();
                    inner.setAttribute("unselectable", "on");
                    inner.className = calendar._prefixCssClass("_shadow_inner");

                    div.appendChild(inner);

                    calendar.nav.events.rows[0].cells[columnIndex].selection.appendChild(div);
                    calendar.elements.selection.push(div);
                    calendar.nav.activeSelection = div;

                    return div;
                })();

                // reset
                div.className = calendar._prefixCssClass("_shadow");
                div.firstChild.innerHTML = "";

                // position
                div.style.top = top + "px";
                div.style.height = height + "px";

                var inner = div.firstChild;

                if (args.html) {
                    inner.innerHTML = args.html;
                }
                if (args.cssClass) {
                    addClass(div, args.cssClass);
                }
                if (!args.allowed) {
                    addClass(div, calendar._prefixCssClass("_shadow_forbidden"));
                }

                calendar._drawSelectionIndicators(div, columnIndex, args);
            })();

        };

        this._clearMovingShadow = function() {
            calendar._deleteShadow(DayPilotCalendar.movingShadow);
            DayPilotCalendar.movingShadow = null;
        };

        this._clearResizingShadow = function() {
            // deleteElement(DayPilotCalendar.resizingShadow);
            calendar._deleteShadow(DayPilotCalendar.resizingShadow);
            DayPilotCalendar.resizingShadow = null;
        };

        this._deleteShadow = function(shadow) {
            deleteElement(shadow);
            deleteElement(calendar.nav.indicatorTop);
            deleteElement(calendar.nav.indicatorBottom);
        };

        this._drawSelectionIndicators = function(div, columnIndex, args) {
            var cells = calendar.nav.events.rows[0].cells;
            var container = cells[columnIndex].events;
            // var container = div.parentNode;

            var isLastCol = columnIndex === cells.length - 1;

            // clear old divs
            deleteElement(calendar.nav.indicatorTop);
            deleteElement(calendar.nav.indicatorBottom);

            if (args.top.enabled) {
                var top = createDiv();
                top.style.zIndex = calendar._shadowZindex; // hack
                top.style.position = "absolute";
                top.style.top = div.offsetTop + "px";

                if (!isLastCol) {
                    top.style.left = (div.offsetWidth + args.top.space) + "px";
                }
                else {
                    top.style.right = "0px";
                }

                if (args.top.width) {
                    top.style.width = args.top.width + "px";
                }
                else {
                    top.style.whiteSpace = "nowrap";
                }

                //var top = DayPilot.Util.div(container, div.offsetLeft + div.offsetWidth + args.top.space, div.offsetTop, args.top.width, null);
                if (args.top.html) {
                    top.innerHTML = args.top.html;
                }
                top.className = calendar._prefixCssClass("_shadow_top");
                container.appendChild(top);
                calendar.elements.selection.push(top);
                calendar.nav.indicatorTop = top;
            }

            if (args.bottom.enabled) {
                var bottom = createDiv();
                bottom.style.zIndex = calendar._shadowZindex; // hack
                bottom.style.position = "absolute";
                bottom.style.top = (div.offsetTop + div.offsetHeight) + "px";
                if (!isLastCol) {
                    bottom.style.left = (div.offsetWidth + args.bottom.space) + "px";
                }
                else {
                    bottom.style.right = "0px";
                }

                if (args.bottom.width) {
                    bottom.style.width = args.bottom.width + "px";
                }
                else {
                    bottom.style.whiteSpace = "nowrap";
                }

                if (args.bottom.html) {
                    bottom.innerHTML = args.bottom.html;
                }

                bottom.className = calendar._prefixCssClass("_shadow_bottom");

                container.appendChild(bottom);

                var height = bottom.offsetHeight;

                bottom.style.top = (div.offsetTop + div.offsetHeight - height) + "px";


                calendar.elements.selection.push(bottom);
                calendar.nav.indicatorBottom = bottom;
            }

        };

        this._onCellMouseOut = function(ev) {
            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.cellBubble) {
                calendar.cellBubble.hideOnMouseOut();
            }

        };

        this._onCellMouseMove = function(ev) {

            if (typeof (DayPilotCalendar) === 'undefined') {
                return;
            }

            if (touch.active || touch.using) {
                return;
            }

            if (typeof DayPilot.Bubble !== 'undefined' && calendar.cellBubble) {
                var cell = {};
                cell.calendar = calendar;
                cell.start = this.start;
                cell.end = this.end;
                cell.resource = this.resource;
                cell.toJSON = function() {
                    var json = {};
                    json.start = this.start;
                    json.end = this.end;
                    json.resource = this.resource;
                    return json;
                };

                calendar.cellBubble.showCell(cell, this);
            }


            if (typeof cres !== "undefined" && cres._active) {
                cres._updateResShadow(cell, ev);
            }


            // moved to mainmousemove
        };

        this.getSelection = function() {
            if (!DayPilotCalendar._topSelectedCell) {
                return null;
            }
            if (!DayPilotCalendar._bottomSelectedCell) {
                return null;
            }

            var start = DayPilotCalendar._topSelectedCell.start;
            var end = DayPilotCalendar._bottomSelectedCell.end;
            var columnId = DayPilotCalendar._topSelectedCell.resource;

            return new DayPilot.Selection(start, end, columnId, calendar);
        };

        this._onMainMouseUp = function(ev) {
            // moved to gMouseUp
        };

        this._scroll = function(ev) {
            var scrolling = calendar.columnWidthSpec === "Fixed";

            if (scrolling || calendar._unifiedScrollable) {
                if (!calendar.nav.bottomLeft) {
                    return;
                }
                calendar.nav.bottomLeft.scrollTop = calendar.nav.bottomRight.scrollTop;
                if (calendar.nav.upperRight) {
                    calendar.nav.upperRight.scrollLeft = calendar.nav.bottomRight.scrollLeft;
                }

                calendar.nav.scrollLayer.scrollLeft = calendar.nav.bottomRight.scrollLeft;
            }

            var scroll = calendar._scrollDiv();

            calendar.scrollPos = scroll.scrollTop;
            calendar._scrollHeight = scroll.clientHeight;
            calendar.nav.scrollpos.value = calendar.scrollPos;

            calendar._updateScrollLabels();
            calendar._clearCachedValues();

            if (calendar.dynamicEventRendering === "Progressive") {
                clearTimeout(calendar._scrollTimeoutEvents);
                // calendar._stopScroll();

                if (calendar.scrollDelayEvents === 0) {
                    calendar._drawEventsOnScroll();
                }
                else {
                    calendar._scrollTimeoutEvents = setTimeout(function() {
                        calendar._drawEventsOnScroll();
                    }, calendar.scrollDelayEvents);
                }
            }

            if (calendar.columnWidthSpec === "Fixed") {
                clearTimeout(calendar._scrollTimeoutCells);
                // calendar._stopScroll();
                if (calendar.scrollDelayCells === 0) {
                    calendar._drawCellsOnScroll();
                }
                else {
                    calendar._scrollTimeoutCells = setTimeout(function() {
                        calendar._drawCellsOnScroll();
                    }, calendar.scrollDelayCells);
                }
            }

        };


        this._updateScrollLabels = function() {
            if (!this.scrollLabelsVisible) {
                return;
            }

            if (!this._scrollLabels) {
                return;
            }

            var required = this.nav && this.nav.main && this.nav.main.rows && this.nav.main.rows.length > 0 && this.nav.main.rows[0].cells.length > 0;

            if (!required) {
                return;
            }

            // update horizontal position
            var columns = this._columnsBottom;
            var hoursWidth = (this.showHours ? this.hourWidth : 0);
            //var colWidth = (this.nav.scroll.clientWidth - hoursWidth) / columns.length;
            var colWidth = this.nav.main.rows[0].cells[0].clientWidth;
            var iw = 10;
            var offset = 1;

            for (var i = 0; i < this.nav.scrollUp.length; i++) {
                var scrollUp = this.nav.scrollUp[i];
                var scrollDown = this.nav.scrollDown[i];

                var left = Math.floor(hoursWidth + i * colWidth + colWidth / 2 - (iw / 2) + offset);
                if (left < 0) { // check for invalid value
                    left = 0;
                }

                left -= calendar.nav.bottomRight.scrollLeft;

                if (scrollUp && scrollUp.style) {
                    scrollUp.style.left = left + "px";
                }
                if (scrollDown && scrollDown.style) {
                    scrollDown.style.left = left + "px";
                }
            }

            var hiddenPixels = this._autoHiddenPixels();

            // update vertical position
            for (var i = 0; i < this.nav.scrollUp.length; i++) {
                var up = this.nav.scrollUp[i];
                var down = this.nav.scrollDown[i];
                var minEnd = this._scrollLabels[i].minEnd - hiddenPixels;
                var maxStart = this._scrollLabels[i].maxStart - hiddenPixels;

                if (up && down) {
                    if (minEnd <= calendar.scrollPos && parseInt(up.style.left) >= calendar.hourWidth) {
                        up.style.top = (this._totalHeaderHeight()) + "px";
                        up.style.display = '';
                    }
                    else {
                        up.style.display = 'none';
                    }

                    if (maxStart >= calendar.scrollPos + calendar._scrollHeight && parseInt(down.style.left) >= calendar.hourWidth) {
                        // scrollHeight is updated on scrolling
                        down.style.top = (this._totalHeaderHeight() + this._scrollHeight - 10) + "px";
                        down.style.display = '';
                    }
                    else {
                        down.style.display = 'none';
                    }
                }
            }
        };

        this._createEdit = function(object) {

            var par = object.parentNode;

            var left = 0;
            var top = object.offsetTop;
            var width = object.parentNode.offsetWidth;
            var height = object.offsetHeight;

            if (object.event.allday()) {
                left = object.offsetLeft;
                width = object.offsetWidth;
            }

            var edit = document.createElement('textarea');
            edit.style.boxSizing = "border-box";
            edit.style.position = 'absolute';
            edit.style.width = width + 'px';
            edit.style.height = height + 'px'; //offsetHeight

            var fontFamily = DayPilot.gs(object, 'fontFamily');
            if (!fontFamily) fontFamily = DayPilot.gs(object, 'font-family');
            edit.style.fontFamily = fontFamily;

            var fontSize = DayPilot.gs(object, 'fontSize');
            if (!fontSize) fontSize = DayPilot.gs(object, 'font-size');
            edit.style.fontSize = fontSize;

            edit.style.left = left + 'px';
            edit.style.top = top + 'px';
            edit.style.border = '1px solid black';
            edit.style.padding = '0px';
            edit.style.marginTop = '0px';
            edit.style.backgroundColor = 'white';
            edit.value = (object.event.text() || "").trim();

            edit.event = object.event;
            par.appendChild(edit);
            return edit;
        };

        this._eventSelect = function(div, e, ctrlKey, metaKey) {
            calendar._eventSelectDispatch(div, e, ctrlKey, metaKey);
        };

        this.zoom = {};
        this.zoom.active = -1;
        this.zoom.setActive = function(index) {

            var level;
            if (typeof index === "number") {
                level = calendar.zoomLevels[index];
            }
            else if (typeof index === "string") {
                var i = calendar.zoom._findById(index);
                level = calendar.zoomLevels[i];
            }
            else {
                throw new DayPilot.Exception("Unexpected parameter type (string or number required): " + typeof index);
            }

            if (!level) {
                throw new DayPilot.Exception("Zoom level not found: " + index + " (" + (typeof index) + ")");
            }

            if (index === calendar.zoom.active) {
                return;
            }

            var hour = calendar.zoom._currentHourPos();

            calendar.zoom._applyLevelProps(index);

            if (calendar._initialized) {
                calendar.update();
            }

            if (hour) {
                calendar.scrollToHour(hour);
            }

        };

        this.zoom._findById = function(id) {
            return createList(calendar.zoomLevels).findIndex(function(level) {
                return level.id === id;
            });
        };

        this.zoom._currentHourPos = function() {
            var area = calendar._getDrawArea();
            if (!area) {
                return null;
            }
            var top = area.pixels.top;
            return calendar._pixelsToHours(top);
        };

        this.zoom._applyLevelProps = function(index) {

            // auto adjust
            var max = calendar.zoomLevels.length - 1;
            if (index > max) {
                index = max;
            }

            if (index < 0) {
                index = 0;
            }

            calendar.zoom.active = index;

            var level = calendar.zoomLevels[index];

            var args = {};
            // args.date = date || new DayPilot.Date(calendar.startDate);
            args.level = level;

            DayPilot.Util.ownPropsAsArray(level.properties).forEach(function(item) {
                // if (item.key.startsWith("on")) {
                if (item.key.indexOf("on") === 0) {
                    return;
                }
                if (typeof item.val === "function") {
                    calendar[item.key] = item.val(args);
                    return;
                }
                calendar[item.key] = item.val;
            });

            return args;
        };


        // internal methods for handling event selection
        this.multiselect = {};

        this.multiselect._initList = [];
        this.multiselect._list = [];
        this.multiselect._divs = [];
        this.multiselect._previous = []; // not used at the moment

        this.multiselect._serialize = function() {
            var m = calendar.multiselect;
            return JSON.stringify(m.events());
        };

        this.multiselect.events = function() {
            var m = calendar.multiselect;
            var events = [];
            events.ignoreToJSON = true;
            for (var i = 0; i < m._list.length; i++) {
                events.push(m._list[i]);
            }
            return events;
        };

        this.multiselect._updateHidden = function() {
            var h = calendar.nav.select;
            h.value = calendar.multiselect._serialize();
        };

        this.multiselect._toggleDiv = function(div, ctrl) {
            var m = calendar.multiselect;
            if (m.isSelected(div.event)) {
                if (calendar.allowMultiSelect) {
                    if (ctrl) {
                        m.remove(div.event, true);
                    }
                    else {
                        var count = m._list.length;
                        m.clear(true);
                        if (count > 1) {
                            m.add(div.event, true);
                        }

                    }
                }
                else { // clear all
                    m.clear(true);
                }
            }
            else {
                if (calendar.allowMultiSelect) {
                    if (ctrl) {
                        m.add(div.event, true);
                    }
                    else {
                        m.clear(true);
                        m.add(div.event, true);
                    }
                }
                else {
                    m.clear(true);
                    m.add(div.event, true);
                }
            }
            m.redraw();
            m._updateHidden();
        };

        // compare event with the init select list
        this.multiselect._shouldBeSelected = function(ev) {
            var m = calendar.multiselect;
            return m._isInList(ev, m._initList);
        };

        this.multiselect._alert = function() {
            var m = calendar.multiselect;
            var list = [];
            for (var i = 0; i < m._list.length; i++) {
                var event = m._list[i];
                list.push(event.value());
            }
            alert(list.join("\n"));
        };

        this.multiselect.add = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            if (m._indexOf(ev) === -1) {
                m._list.push(ev);
            }
            m._updateHidden();
            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.remove = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            var i = m._indexOf(ev);
            if (i !== -1) {
                m._list.splice(i, 1);
            }
            m._updateHidden();

            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.clear = function(dontRedraw) {
            var m = calendar.multiselect;
            m._list = [];

            m._updateHidden();

            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.redraw = function() {
            var m = calendar.multiselect;
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (m.isSelected(div.event)) {
                    m._divSelect(div);
                }
                else {
                    m._divDeselect(div);
                }
            }
        };

        this.multiselect._divSelect = function(div) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            var c = m._findContentDiv(div);
            addClass(c, cn);
            /*if (calendar.useEventSelectionBars) {
                m._divSelectTraditional(div);
            }*/
            m._divs.push(div);
        };

        this.multiselect._findContentDiv = function(div) {
            return div;
        };

        this.multiselect._divDeselectAll = function() {
            var m = calendar.multiselect;
            for (var i = 0; i < m._divs.length; i++) {
                var div = m._divs[i];
                m._divDeselect(div, true);
            }
            m._divs = [];
        };

        this.multiselect._divDeselect = function(div, dontRemoveFromCache) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            var c = m._findContentDiv(div);
            removeClass(c, cn);

            if (dontRemoveFromCache) {
                return;
            }
            var i = DayPilot.indexOf(m._divs, div);
            if (i !== -1) {
                m._divs.splice(i, 1);
            }

        };

        this.multiselect.isSelected = function(ev) {
            return calendar.multiselect._isInList(ev, calendar.multiselect._list);
        };

        this.multiselect._indexOf = function(ev) {
            var data = ev.data;
            for (var i = 0; i < calendar.multiselect._list.length; i++) {
                var item = calendar.multiselect._list[i];
                if (calendar._isSameEvent(item.data, data)) {
                    return i;
                }
            }
            return -1;
        };

        this.multiselect._isInList = function(e, list) {
            if (!list) {
                return false;
            }
            for (var i = 0; i < list.length; i++) {
                var ei = list[i];
                if (calendar._isSameEvent(e, ei)) {
                    return true;
                }
            }

            return false;
        };

        this._divEdit = function(object) {
            if (DayPilotCalendar.editing) {
                DayPilotCalendar.editing.blur();
                return;
            }

            var edit = this._createEdit(object);
            DayPilotCalendar.editing = edit;

            registerEvent(edit, DayPilot.touch.start, function(ev) {
                ev.stopPropagation();
            });

            edit.onblur = function() {
                if (!object.event) {
                    return;
                }
                // var id = object.event.value();
                // var tag = object.event.tag();
                var oldText = object.event.text();
                var newText = edit.value;

                DayPilotCalendar.editing = null;

                edit.onblur = null;

                //if (edit.)
                deleteElement(edit);
                //edit.parentNode.removeChild(edit);

                if (oldText === newText) {
                    return;
                }

                object.style.display = 'none';
                calendar._eventEditDispatch(object.event, newText);
            };

            edit.onkeypress = function(e) {
                var keynum = (window.event) ? event.keyCode : e.keyCode;
                if (keynum === 13) {
                    this.onblur();
                    e.preventDefault();
                    return false;
                }
            };

            edit.onkeyup = function(e) {
                var keynum = (window.event) ? event.keyCode : e.keyCode;

                if (keynum === 27) {
                    edit.onblur = null;
                    edit.parentNode && edit.parentNode.removeChild(edit);
                    DayPilotCalendar.editing = false;
                }

                return true;
            };

            edit.select();
            edit.focus();
        };

        this._generateColumns = function() {
            if (calendar.viewType === "Resources") {
                return false;
            }
            if (calendar._columnsList() && calendar._serverBased()) {
                return false;
            }
            return true;
        };

        // backwards compatibility
        this._columnsList = function() {
            if (DayPilot.isArray(calendar.columns)) {
                return calendar.columns;
            }
            return calendar.columns.list;
        };

        this.columns = {};
        this.columns.list = [];
        this.columns._loadInProgress = false;

        this.columns.filter = function(param) {
            calendar._columnFilter.params = param;

            if (calendar._initialized) {
                calendar._update();
            }

        };

        this.columns.find = function(date, id) {
            var isResources = calendar.viewType === "Resources";
            date = new DayPilot.Date(date);
            var col = calendar._columnsBottom.find(function(col) {
                var resMatches = !isResources || col.id === id;
                var colEnd = col.start.addDays(1);
                if (resMatches && col.start <= date && date < colEnd) {
                    return true;
                }
                return false;
            });
            if (!col) {
                return null;
            }
            return calendar._createColumn(col, calendar);
        };

        this.columns.load = function(url, success, error) {

            if (!url) {
                throw new DayPilot.Exception("columns.load(): 'url' parameter required");
            }

            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.columns.list = data;
                    if (calendar._initialized) {
                        calendar.update();
                    }
                }
            };

            var usePost = calendar.columnsLoadMethod && calendar.columnsLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                DayPilot.ajax({
                    "method": "GET",
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
        };


        this._prepareColumns = function() {
            var generateColumns = calendar._generateColumns();
            calendar._headerLevelMax = 0;

            if (generateColumns) {
                var generated = this._createDaysViewColumns();
                this._columnsBottom = this._loadColumnCollection(generated);
            }
            else {
                this._columns = this._loadColumnCollection(this._columnsList() || []);
                this._columnsBottom = this._getColumns(resolved._headerLevels(), true);
            }
        };

        this._bottomColumnsHaveWidth = function() {
            return calendar._columnsBottom.find(function(c) { return typeof c.width === "number"; });
        };

        this._getVisibleRange = function() {
            var start = this.startDate.getDatePart();
            var days = this.days;

            switch (this.viewType) {
                case "Day":
                    days = 1;
                    break;
                case "Week":
                    days = 7;
                    // TODO let weekStarts property override it?
                    start = start.firstDayOfWeek(resolved._weekStarts());
                    break;
                case "WorkWeek":
                    days = 5;
                    start = start.firstDayOfWeek(resolved._weekStarts());
                    while (start.dayOfWeek() !== 1) { // look for the next Monday
                        start = start.addDays(1);
                    }
                    break;
                /*case "Resources":
                    start = calendar.visibleStart().getDatePart();
                    end = calendar.visibleEnd().getDatePart();
                    days = DayPilot.DateUtil.daysDiff(start, end);
                    break;*/
            }

            var end = start.addDays(days);

            var result = {};
            result.start = start;
            result.end = end;
            result.days = days;

            return result;
        };


        this._createDaysViewColumns = function() {
            var columns = [];

            var visible = this._getVisibleRange();
            var start = visible.start;
            var days = visible.days;

            for (var i = 0; i < days; i++) {

                var column = {};
                column.start = start.addDays(i);

                var pattern = resolved._locale().datePattern;
                if (calendar.headerDateFormat) {
                    pattern = calendar.headerDateFormat;
                }
                column.name = column.start.toString(pattern, resolved._locale());
                column.html = column.name;

                columns.push(column);
            }

            return columns;
        };

        this._columnFilter = {};
        this._headerLevelMax = 0;

        this._filterColumns = function() {
            if (calendar._generateColumns()) {
                return;
            }
            if (typeof calendar.onColumnFilter === "function") {
                calendar._loadEvents(null, {"preLoadOnly": true});
                this._filterColumnList(calendar._columnsBottom);
                this._columnsBottom = this._getColumns(resolved._headerLevels(), true);
            }

            var hasWidth = calendar._bottomColumnsHaveWidth();
            if (hasWidth) {
                calendar._rebalanceColWidths();
            }
        };

        this._filterColumnList = function(list) {
            if (!list) {
                return;
            }
            list.forEach(function(c) {
                calendar._filterColumn(c);
            });
        };

        this._filterColumn = function(activated) {
            var column = activated.data;
            var isBottom = !column.children || column.children.length === 0;

            if (typeof calendar.onColumnFilter === "function" && calendar._columnFilter.params) {
                if (isBottom) {
                    var parent = activated.parent;
                    var args = {};
                    args.visible = true;
                    args.column = calendar._createColumn(activated, calendar);
                    args.filter = calendar._columnFilter.params;
                    args.filterParam = args.filter;

                    calendar.onColumnFilter(args);

                    if (args.visible) {
                        parent && parent._makeVisibleOnFilter();
                    }
                    else {
                        activated.hidden = true;
                    }
                }
                else {
                    activated.hidden = true;
                }
            }

            calendar._filterColumnList(activated.children);
        };

        this._loadColumn = function(column, parent) {
            var activated = {};

            activated.id = column.id;
            activated.start = new DayPilot.Date(column.start || calendar.startDate).getDatePart(); // use default value
            activated.name = column.name;

            activated.html = column.html || column.name;
            activated.toolTip = column.toolTip;
            activated.backColor = column.backColor;
            activated.areas = column.areas;
            activated.level = parent ? parent.level + 1 : 0;

            activated.parent = parent;
            activated.data = column;

            activated.width = column.width;

            var isBottom = !column.children || column.children.length === 0;
            calendar._headerLevelMax = Math.max(calendar._headerLevelMax, activated.level);


            activated._makeVisibleOnFilter = function() {
                activated.hidden = false;
                if (activated.parent) {
                    activated.parent._makeVisibleOnFilter();
                }
            };

            activated._getChildren = function(level, inherit) {
                var list = [];
                if (level <= 1) {
                    if (!this.hidden) {
                        list.push(this);
                    }
                    return list;
                }

                if (!this.children || this.children.length === 0) {
                    if (inherit) {
                        if (!this.hidden) {
                            list.push(this);
                        }
                    }
                    else {
                        list.push("empty");
                    }
                    return list;
                }

                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    var subChildren = child._getChildren(level - 1, inherit);

                    for (var j = 0; j < subChildren.length; j++) {
                        list.push(subChildren[j]);
                    }
                }

                return list;

            };

            activated._getChildrenCount = function(level) {
                var count = 0;

                if (!this.children || this.children.length <= 0 || level <= 1) {
                    var visible = !this.hidden;
                    return visible ? 1 : 0;
                }

                for (var i = 0; i < this.children.length; i++) {
                    count += this.children[i]._getChildrenCount(level - 1);
                }

                return count;

            };

            activated._putIntoBlock = function(ep) {

                for (var i = 0; i < this.blocks.length; i++) {
                    var block = this.blocks[i];
                    if (block._overlapsWith(ep.part.top, ep.part.height)) {
                        block.events.push(ep);
                        block.min = Math.min(block.min, ep.part.top);
                        block.max = Math.max(block.max, ep.part.top + ep.part.height);
                        return i;
                    }
                }

                // no suitable block found, create a new one
                var block = [];
                block.lines = [];
                block.events = [];

                block._overlapsWith = function(start, width) {
                    var end = start + width - 1;

                    if (!(end < this.min || start > this.max - 1)) {
                        return true;
                    }

                    return false;
                };
                block._putIntoLine = function(ep) {
                    var thisCol = this;

                    for (var i = 0; i < this.lines.length; i++) {
                        var line = this.lines[i];
                        if (line._isFree(ep.part.top, ep.part.height)) {
                            line.push(ep);
                            return i;
                        }
                    }

                    var line = [];
                    line._isFree = function(start, width) {
                        //var free = true;
                        var end = start + width - 1;
                        var max = this.length;

                        for (var i = 0; i < max; i++) {
                            var e = this[i];
                            if (!(end < e.part.top || start > e.part.top + e.part.height - 1)) {
                                return false;
                            }
                        }

                        return true;
                    };

                    line.push(ep);

                    this.lines.push(line);

                    return this.lines.length - 1;

                };

                block.events.push(ep);
                block.min = ep.part.top;
                block.max = ep.part.top + ep.part.height;

                this.blocks.push(block);

                return this.blocks.length - 1;

            };

            activated._putIntoLine = function(ep) {
                var thisCol = this;

                for (var i = 0; i < this.lines.length; i++) {
                    var line = this.lines[i];
                    if (line._isFree(ep.part.top, ep.part.height)) {
                        line.push(ep);
                        return i;
                    }
                }

                var line = [];
                line._isFree = function(start, width) {
                    //var free = true;
                    var end = start + width - 1;
                    var max = this.length;

                    for (var i = 0; i < max; i++) {
                        var e = this[i];
                        if (!(end < e.part.top || start > e.part.top + e.part.height - 1)) {
                            return false;
                        }
                    }

                    return true;
                };

                line.push(ep);

                this.lines.push(line);

                return this.lines.length - 1;
            };

            activated._visibleStart = function() {
                return activated.start.addHours(calendar._visibleStart(true));
            };

            activated._visibleEnd = function() {
                var duration = calendar._duration(true);
                return activated._visibleStart().addTime(duration);
            };

            if (column.children) {
                activated.children = this._loadColumnCollection(column.children, activated);
            }

            return activated;
        };

        this._loadColumnCollection = function(cc, parent) {

            var activated = createList();

            createList(cc).forEach(function(item) {
                var col = calendar._loadColumn(item, parent);
                activated.push(col);
            });

            return activated;

        };

        this._getColumns = function(level, inherit) {
            var source = this._generateColumns() ? this._columnsBottom : this._columns;
            var list = createList();

            for (var i = 0; i < source.length; i++) {
                var children = source[i]._getChildren(level, inherit);
                for (var j = 0; j < children.length; j++) {
                    list.push(children[j]);
                }
                //list.concat(children);
            }
            return list;

        };

        this.selectTimeRange = function(start, end, resource, dontFireEvent) {

            if (!start) {
                return;
            }

            if (!end) {
                return;
            }

            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);

            var top = calendar._findCell(start, resource, true);
            var bottom = calendar._findCell(end, resource);

            if (!top) {
                return;
            }
            if (!bottom) {
                return;
            }
            if (top.data.x !== bottom.data.x) {
                return;
            }

            DayPilotCalendar._topSelectedCell = top;
            DayPilotCalendar._firstSelected = top;
            DayPilotCalendar._bottomSelectedCell = bottom;
            calendar._selectedCells = DayPilotCalendar._getCellsAbove(bottom);
            DayPilotCalendar._selectedColumn = top.data.x;

            calendar._activateSelection();

            if (!dontFireEvent) {
                setTimeout(function() {
                    calendar._timeRangeSelectedDispatch(start, end, resource, "api");
                }, 0);
            }

        };

        calendar._findCell = function(time, resource, startOnly) {
            var bottom = calendar._columnsBottom;
            var main = calendar.nav.main;

            var resourcesView = calendar.viewType === "Resources";
            var column = bottom.find(function(c) {
                var resourceMatches = resourcesView ? c.id === resource : true;
                var timeMatches = c._visibleStart() <= time && time < c._visibleEnd();
                return resourceMatches && timeMatches;
            });

            if (!column) {
                return;
            }
            var x = bottom.indexOf(column);

            var cell = (function findCell() {
                for (var y = 0; y < calendar._rowCount(); y++) {
                    var cell = main.rows[y].cells[x];
                    if (!cell) {
                        continue;
                    }
                    var data = cell.data;
                    var matches = data.start <= time && time <= data.end;
                    if (startOnly) {
                        matches = data.start <= time && time < data.end;
                    }
                    if (matches) {
                        return cell;
                    }
                }
                return null;
            })();

            if (cell) {
                return cell;
            }
        };

        /* cres */

        this._columnMoving = {};
        var cmov = this._columnMoving;

        cmov._drawMoveHandle = function(cellInfo) {
            var div = cellInfo.div.firstChild;
            // var column = cell.column;

            var handle = createDiv();
            var handleStyle = handle.style;
            handleStyle.position = "absolute";
            handleStyle.left = "2px";
            handleStyle.top = "2px";
            handleStyle.bottom = "2px";
            handleStyle.width = "15px";
            // handleStyle.backgroundColor = "green";
            handleStyle.opacity = "0.5";
            handleStyle.cursor = "move";
            handleStyle.display = "none";
            handle.className = calendar._prefixCssClass("_colmove_handle");

            rePassive(div, "mouseenter", function(ev) {
                if (!cmov._active && !cres._active) {
                    handleStyle.display = "";
                }
            });
            rePassive(div, "mouseleave", function(ev) {
                handleStyle.display = "none";
            });

            handle.onmousedown = function (ev) {
                cmov._startMoving(ev, cellInfo);
            };

            if (!div.$) {
                div.$ = {};
            }
            div.$._hideMoveHandle = function() {
                handleStyle.display = "none";
            };
            div.$._showMoveHandle = function() {
                handleStyle.display = "";
            };

            div.appendChild(handle);
        };

        cmov._startMoving = function(ev, cellInfo) {
            var header = calendar.nav.header;

            var movingInfo = {};
            movingInfo._cell = cellInfo;
            movingInfo._cursor = header.style.cursor;
            var div = cellInfo.div;

            cmov._active = movingInfo;
            DpGlobal.colMoving = cmov;

            div.$ && div.$._hideResizeHandle && div.$._hideResizeHandle();

            addClass(div, calendar._prefixCssClass("_colmove_source"));
            header.style.cursor = "move";

        };

        cmov._parentColumns = function(activatedColumn) {
            var result = [];
            var parent = activatedColumn.parent;

            if (parent) {
                result.push(parent.data);
                result = result.concat(cmov._parentColumns(parent));
            }

            return result;
        };

        cmov._stopMoving = function() {
            if (!cmov._active.target) {
                cleanup();
                return;
            }
            var header = calendar.nav.header;
            var active = cmov._active;
            var position = active.position;
            var div = active.div;
            var src = cmov._active._cell.column;
            var srcColumn = src.data;
            var srcParent = src.parent;
            var target = active.target;
            var targetColumn = target.data;
            var targetParent = target.parent;
            var targetArray = targetParent ? targetParent.data.children : calendar._columnsList();
            var srcArray = srcParent ? srcParent.data.children : calendar._columnsList();
            // var srcParents = cmov._parentColumns(src);
            var targetParents = cmov._parentColumns(target);

            function cleanup() {
                removeClass(cmov._active._cell.div, calendar._prefixCssClass("_colmove_source"));
                if (header) {
                    header.style.cursor = active._cursor;
                }
                if (div) {

                    div.remove();
                }
                cmov._active = null;
            };

            if (targetParents.includes(srcColumn)) {
                cleanup();
                return;
            }

            if (targetColumn === srcColumn) {
                cleanup();
                return;
            }

            if (position === "forbidden") {
                cleanup();
                return;
            }

            var args = {};
            args.source = calendar._createColumn(src);
            args.target = calendar._createColumn(target);
            args.position = position;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            }

            if (typeof calendar.onColumnMove === "function") {
                calendar.onColumnMove(args);
                if (args.preventDefault.value) {
                    cleanup();
                    return;
                }
            }

            if (resolved._columnMoveHandlingIs("Update")) {
                DayPilot.rfa(srcArray, srcColumn);
                var targetIndex = targetArray.indexOf(targetColumn);

                if (position === "child") {
                    var children = targetColumn.children || [];
                    children.push(srcColumn);
                    targetColumn.children = children;
                }
                else if (position === "before") {
                    targetArray.splice(targetIndex, 0, srcColumn);
                }
                else if (position === "after") {
                    targetArray.splice(targetIndex + 1, 0, srcColumn);
                }

                calendar._update();
            }

            // onBeforeColumnMoved
            if (typeof calendar.onColumnMoved === "function") {
                calendar.onColumnMoved(args);
            }

            cleanup();

        };

        cmov._mouseMove = function(ev, target) {
            var iconWidth = 12;
            var iconHeight = 12;
            var column = target.data;
            var sameLevelOnly = calendar.columnMoveSameLevelOnly;

            var div = cmov._active.div;
            var src = cmov._active._cell.column;
            var divStyle;
            if (!div) {
                div = createDiv();
                divStyle = div.style;
                divStyle.position = "absolute";
                // divStyle.backgroundColor = "green";
                divStyle.width = iconWidth + "px";
                divStyle.height = iconHeight + "px";
                divStyle.top = "0px";
                cmov._active.div = div;
            }
            else {
                divStyle = div.style;
            }

            var rect = target.getBoundingClientRect();
            var width = rect.width;
            var height = rect.height;
            var offset = DayPilot.mo3(target, ev);
            var children = column.children || [];
            var childrenCount = children.length;
            var edge = childrenCount === 0 ? 0.25 : 0.5;
            var position = null;
            var targetParents = cmov._parentColumns(target.data);

            div.className = "";

            var forbidden = false;
            if (src === column) {
                forbidden = true;
            }

            if (sameLevelOnly) {
                edge = 0.5;
            }

            if (targetParents.includes(src.data)) {
                position = "forbidden";
            }
            else if (forbidden) {
                position = "forbidden";
            }
            else if (offset.x < width * edge) {
                position = "before";
            }
            else if (offset.x > width * (1 - edge)) {
                position = "after";
            }
            else if (childrenCount == 0) {
                position = "child";
            }

            if (sameLevelOnly) {
                if (src.level !== column.level) {
                    position = "forbidden";
                }
            }


            var args = {};
            args.position = position;
            args.source = calendar._createColumn(src);
            args.target = calendar._createColumn(target.data);

            if (typeof calendar.onColumnMoving === "function") {
                calendar.onColumnMoving(args);
            }

            position = args.position;

            if (position === "forbidden") {
                divStyle.left = (width * 0.5 - iconWidth * 0.5) + "px";
                divStyle.top = (height/2 - 2) + "px";
                div.className = calendar._prefixCssClass("_colmove_position_forbidden");
            }
            else if (position === "before") {
                divStyle.left = "0px";
                divStyle.top = (height*0.5 - iconHeight * 0.5) + "px";
                div.className = calendar._prefixCssClass("_colmove_position_before");
            }
            else if (position === "after") {
                divStyle.left = (width - iconWidth - 1) + "px";
                divStyle.top = (height*0.5 - iconHeight * 0.5) + "px";
                div.className = calendar._prefixCssClass("_colmove_position_after");
            }
            else if (position === "child") {
                divStyle.left = (width * 0.5 - iconWidth * 0.5) + "px";
                divStyle.top = (height - iconHeight - 1) + "px";
                div.className = calendar._prefixCssClass("_colmove_position_child");
            }

            if (div.parentNode !== target) {
                div.remove();
                target.appendChild(div);
            }

            cmov._active.target = column;
            cmov._active.position = position;

        };

        this._columnResizing = {};
        var cres = this._columnResizing;

        cres._drawResizeHandle = function(cellInfo) {
            var div = cellInfo.div.firstChild;
            // var column = cell.column;

            var handle = createDiv();
            var handleStyle = handle.style;
            handleStyle.position = "absolute";
            handleStyle.right = "0px";
            handleStyle.top = "0px";
            handleStyle.bottom = "0px";
            handleStyle.width = "4px";
            handleStyle.cursor = "e-resize";
            handleStyle.display = "none";
            handle.className = calendar._prefixCssClass("_colheader_splitter");

            rePassive(div, "mouseenter", function(ev) {
                if (!cmov._active && !cres._active) {
                    handleStyle.display = "";
                }
            });
            rePassive(div, "mouseleave", function(ev) {
                if (!cres._active) {
                    handleStyle.display = "none";
                }
            });

            handle.onmousedown = function (ev) {
                cres._startResizing(ev, cellInfo);
            };

            if (!div.$) {
                div.$ = {};
            }
            div.$._hideResizeHandle = function() {
                handleStyle.display = "none";
            };

            div.appendChild(handle);
        };

        cres._startResizing = function(ev, cellInfo) {
            var coords = DayPilot.mo3(calendar.nav.header, ev);
            var column = cellInfo.column;
            var div = cellInfo.div.firstChild;

            var resizingInfo = {};
            resizingInfo._startX = coords.x;
            resizingInfo._cell = cellInfo;
            resizingInfo._columnX = cellInfo.x;
            resizingInfo._column = cellInfo.column;

            div.$ && div.$._hideMoveHandle && div.$._hideMoveHandle();

            // always resizes the bottom
            if (cellInfo.y !== resolved._headerLevels() - 1) {
                var bottom = column._getChildren(resolved._headerLevels() - cellInfo.y, true);
                var last = bottom[bottom.length - 1];
                if (last) {
                    resizingInfo._columnX = calendar._columnsBottom.indexOf(last);
                }
            }

            cres._active = resizingInfo;
            DpGlobal.colResizing = cres;
        };

        cres._updateResShadow = function(cell, ev) {

            var bottom = calendar._columnsBottom;
            var mo = DayPilot.mo3(calendar.nav.header, ev);
            var column = cres._active._column;
            var offsetCells = mo.x - cres._active._startX;
            var y = cres._active._cell.y;
            var resizingParents = y !== resolved._headerLevels() - 1;
            var fixed = calendar.columnWidthSpec === "Fixed";
            var minWidth = calendar.columnWidthMin;
            var colIndex = cres._active._columnX;

            var adjusted = 0;
            var totalpx = calendar.nav.main.clientWidth;
            var onePctIsPx = totalpx / 100;
            var minWidthPct = minWidth /onePctIsPx;
            var addPct = offsetCells / onePctIsPx;
            var adjustedPct = 0;
            var width = 0;

            if (resizingParents) {
                var childrenAtBottom = column._getChildren(resolved._headerLevels() - y, true);
                var defaultWidth = fixed ? calendar.columnWidth : 100 / bottom.length;
                var totalWidth = childrenAtBottom.reduce(function(prev, current) { return prev + (current.width || defaultWidth)}, 0);
                var newTotal = fixed ? totalWidth + offsetCells : totalWidth + addPct;

                var ratio = newTotal / totalWidth;

                // fixed mode: use rounded values + remainder for the last column
                var remainder = 0;
                childrenAtBottom.forEach(function(c, i) {
                    var isLast = i === childrenAtBottom.length - 1;
                    var width = c.width || defaultWidth;
                    var newWidth = width * ratio;
                    var roundedWidth = Math.round(newWidth);

                    if (fixed) {
                        remainder += newWidth - roundedWidth;
                        newWidth = roundedWidth;
                    }

                    if (newWidth < minWidth) {
                        adjusted += newWidth - minWidth;
                        newWidth = minWidth;
                    }
                    c.width = newWidth;
                    if (isLast) {
                        c.width += remainder;
                    }
                });

                if (!fixed) {
                    adjustRemainingColumns();

                    // apply to all children proportionally
                    var adjustmentFix = width;
                    var childrenTotal = childrenAtBottom.reduce(function(p, c) {return p + c.width || defaultWidth}, 0);
                    childrenAtBottom.forEach(function(c) {
                        var w = c.width || defaultWidth;
                        var fraction = w / childrenTotal;
                        c.width = w + adjustmentFix * fraction;
                    });
                }

            }
            else {
                var originalWidth = calendar._getColumnDimensions()[colIndex].width;
                var column = bottom[colIndex];

                if (fixed) {
                    width = originalWidth + offsetCells;
                    if (width < minWidth) {
                        adjusted = width - minWidth;
                        width = minWidth;
                    }
                }
                else {
                    width = column.width + addPct;
                    if (width < minWidthPct) {
                        adjustedPct = width - minWidthPct;
                        addPct = minWidthPct - column.width;
                        width = minWidthPct;
                    }
                    width = Math.max(width, 1);

                    adjustRemainingColumns();
                }
                column.width = width;
            }

            cres._active._startX = mo.x - adjusted;

            calendar._rebalanceColWidths();
            calendar._clearCachedValues();
            cres._updateColumnWidths();

            function getRemainingTotalPct() {
                var remainingTotalPct = 0;
                for (var x = colIndex + 1; x < bottom.length; x++) {
                    remainingTotalPct += bottom[x].width || defaultWidth;
                }
                return remainingTotalPct;
            }

            function adjustRemainingColumns() {
                var remainingTotalPct = getRemainingTotalPct();

                var addedForMin = 0;
                for (var x = colIndex + 1; x < bottom.length; x++) {
                    var cb = bottom[x];
                    var cbWidth = cb.width || defaultWidth;
                    var fractionOfSubtract = cbWidth / remainingTotalPct;
                    cb.width = cbWidth - addPct * fractionOfSubtract;
                    if (cb.width < 1) {
                        addedForMin += 1 - cb.width;
                        cb.width = 1;
                    }
                }

                width -= addedForMin;
                adjustedPct += addedForMin;

                adjusted = adjustedPct * onePctIsPx;
            }

        };

        cres._stopResizing = function() {
            var bottom = calendar._columnsBottom;
            var div = cres._active._cell.div.firstChild;

            var column = cres._active._column;

            div.$ && div.$._showMoveHandle && div.$._showMoveHandle();
            cres._active = null;

            var args = {};
            args.column = calendar._createColumn(column);  // column object?
            args.newWidth = column.width;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            if (typeof calendar.onColumnResize === "function") {
                calendar.onColumnResize(args);
            }

            if (args.preventDefault.value) {
                // reset positions
                calendar.update();
                return;
            }

            if (resolved._columnResizeHandlingIs("Update")) {
                bottom.forEach(function(c) {
                    c.data.width = c.width;
                });
            }

            if (typeof calendar.onColumnResized === "function") {
                calendar.onColumnResized(args);
            }

        };

        cres._updateColumnWidths = function () {
            // update left/width of column headers, cells
            var coldims = calendar._getColumnDimensions();
            var fixed = calendar.columnWidthSpec === "Fixed";
            var header = calendar.nav.header;
            var main = calendar.nav.main;
            var events = calendar.nav.events;
            var corner = calendar.nav.unifiedCornerRight;

            header.rows.forEach(function(r, y) {
                if (y === resolved._headerLevels() - 1) {
                    return;
                }
                var rowColDims = calendar._getColSpans(y);
                r.cells.forEach(function(c, x) {
                    var coldim = rowColDims[x];
                    c.style.left = coldim.left + coldim.unit;
                    c.style.width = coldim.width + coldim.unit;
                });
            });

            var maxRowIndex = resolved._headerLevels() - 1;
            for (var i = 0; i < calendar._columnsBottom.length; i++) {
                var coldim = coldims[i];
                var domCell = header.rows[maxRowIndex].cells[i];
                domCell.style.left = coldim.left + coldim.unit;
                domCell.style.width = coldim.width + coldim.unit;
                if (fixed) {
                    domCell.firstChild.style.width = coldim.width  + coldim.unit;
                }
            }

            main.rows.forEach(function (r) {
                r.cells.forEach(function (c, x) {
                    var w = coldims[x].width + coldims[x].unit;
                    var left = coldims[x].left + coldims[x].unit;
                    if (c.style.width !== w) {
                        c.style.width = w;
                        if (fixed) {
                            c.firstChild.style.width = w;
                        }
                    }
                    if (c.style.left !== left) {
                        c.style.left = left;
                    }
                });
            });

            events.rows[0].cells.forEach(function(c, x) {
                var w = coldims[x].width + coldims[x].unit;
                var left = coldims[x].left + coldims[x].unit;
                if (c.style.width !== w) {
                    c.style.width = w;
                    if (fixed) {
                        c.firstChild.style.width = w;
                    }
                }
                if (c.style.left !== left) {
                    c.style.left = left;
                }
            });

            if (fixed) {
                var lastCol = coldims[coldims.length - 1];
                var left = lastCol.left + lastCol.width;
                corner.style.left = left + "px";

                main.style.width = left + "px";
            }
        };

        /* cres end */

        this._rebalanceColWidths = function() {
            if (calendar.columnWidthSpec === "Fixed") {
                return;
            }
            var bottom = calendar._columnsBottom;
            var defaultWidth = 100 / bottom.length;
            var total = bottom.reduce(function(previous, current) {
                return previous + (current.width || defaultWidth);
            }, 0);
            var ratio = total / 100;
            // var remainder = 0;
            bottom.forEach(function(c, i) {
                var isLast = bottom.length - 1;
                var width = c.width || defaultWidth;
                c.width = width / ratio;

/*                var roundedWidth = Math.round(c.width);
                remainder += roundedWidth - c.width;
                c.width = roundedWidth;
                if (isLast) {
                    c.width += remainder;
                }*/

            });
        };

        this._drawEventsAllDay = function() {
            if (!this.showAllDayEvents) {
                return;
            }

            var header = this.nav.header;

            if (!header) {
                return;
            }

            header.style.display = 'none';

            var columns = this._columnsBottom.length;

            for (var j = 0; j < this._allDay.lines.length; j++) {
                var line = this._allDay.lines[j];

                for (var i = 0; i < line.length; i++) {
                    //var data = this.eventsAllDay[i];
                    var data = line[i];
                    var cache = data.cache || data.data;

                    var wrap = createDiv();
                    wrap.style.position = "absolute";
                    if (calendar.rtl) {
                        wrap.style.right = (100.0 * data.part.colStart / columns) + "%";
                    }
                    else {
                        wrap.style.left = (100.0 * data.part.colStart / columns) + "%";
                    }
                    wrap.style.width = (100.0 * data.part.colWidth / columns) + "%";
                    wrap.style.height = resolved._allDayEventHeight() + 'px';
                    wrap.style.top = (resolved._headerLevels() * resolved._headerHeight() + j * (resolved._allDayEventHeight())) + "px";

                    var div = createDiv();
                    div.event = data;

                    div.setAttribute("unselectable", "on");
                    div.style.position = 'absolute';
                    div.style.inset = "2px";

                    div.className = this._prefixCssClass("_alldayevent");

                    if (!calendar.allDayEventTextWrappingEnabled) {
                        div.style.whiteSpace = "nowrap";
                    }

                    if (cache.cssClass) {
                        addClass(div, cache.cssClass);
                    }

                    // prevention of global alignment changes
                    div.style.textAlign = 'left';
                    div.style.lineHeight = "1.2";

                    if (data.client.clickEnabled()) {
                        div.onclick = this._eventClickDispatch;
                    }
                    if (data.client.doubleClickEnabled()) {
                        div.ondblclick = this._eventDoubleClickDispatch;
                    }

                    if (data.client.clickEnabled() || data.client.doubleClickEnabled()) {
                        div.style.cursor = "pointer";
                    }
                    else {
                        div.style.cursor = "default";
                    }

                    registerEvent(div, "contextmenu", this._eventRightClickDispatch);

                    div.onmousemove = function(ev) {
                        var div = this;
                        var e = div.event;
                        var cache = e.cache || e.data;
                        if (!div.active) {
                            var areas = [];
                            if (e.client.deleteEnabled()) {
                                areas.push({"action":"JavaScript","v":"Hover","w":17,"h":17,"top":3,"right":3, "css": calendar._prefixCssClass("_event_delete"),"js":function(e) { calendar._eventDeleteDispatch(e); } });
                            }

                            var list = cache.areas;
                            if (list && list.length > 0) {
                                areas = areas.concat(list);
                            }
                            DayPilot.Areas.showAreas(div, e, null, areas);

                            addClass(div, calendar._prefixCssClass("_alldayevent_hover"));
                        }

                        if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble && calendar.eventHoverHandling !== 'Disabled') {
                            calendar.bubble.showEvent(this.event);
                        }
                    };
                    div.onmouseout = function(ev) {
                        var div = this;
                        removeClass(div, calendar._prefixCssClass("_alldayevent_hover"));
                        DayPilot.Areas.hideAreas(this, ev);
                        if (calendar.bubble) {
                            calendar.bubble.hideOnMouseOut();
                        }
                    };

                    if (this.showToolTip && !this.bubble) {
                        div.setAttribute("title", data.client.toolTip());
                    }

                    var startsHere = data.start().getTime() === data.part.start.getTime();
                    var endsHere = data.end().getTime() === data.part.end.getTime();

                    var back = cache.backColor;

                    var inner = createDiv();
                    inner.setAttribute("unselectable", "on");
                    inner.className = this._prefixCssClass("_alldayevent_inner");

                    if (back) {
                        inner.style.background = back;
                    }

                    if (cache.fontColor) {
                        inner.style.color = cache.fontColor;
                    }

                    if (cache.borderColor === "darker" && cache.backColor) {
                        inner.style.borderColor = DayPilot.ColorUtil.darker(cache.backColor, 2);
                    }
                    else {
                        inner.style.borderColor = cache.borderColor;
                    }


                    if (calendar.rtl) {
                        if (!startsHere) {
                            addClass(div, this._prefixCssClass("_alldayevent_continueright"));
                        }
                        if (!endsHere) {
                            addClass(div, this._prefixCssClass("_alldayevent_continueleft"));
                        }
                    }
                    else {
                        if (!startsHere) {
                            addClass(div, this._prefixCssClass("_alldayevent_continueleft"));
                        }
                        if (!endsHere) {
                            addClass(div, this._prefixCssClass("_alldayevent_continueright"));
                        }
                    }

                    // moved to domAdd() below
/*                    if (data.client.innerHTML()) {
                        inner.innerHTML = data.client.innerHTML();
                    }
                    else {
                        inner.innerHTML = data.text();
                    }*/

                    div.appendChild(inner);

                    if (DayPilot.isArray(cache.areas)) {
                        cache.areas.filter(function(a) { return DayPilot.Areas.isVisible(a);}).forEach(function(a) {
                            var ad = DayPilot.Areas.createArea(div, data, a);
                            div.appendChild(ad);
                        });
                    }

                    if (calendar._api2()) {
                        if (typeof calendar.onAfterEventRender === 'function') {
                            var args = {};
                            args.e = div.event;
                            args.div = div;

                            calendar.onAfterEventRender(args);
                        }
                    }
                    else {
                        if (calendar.afterEventRender) {
                            calendar.afterEventRender(div.event, div);
                        }
                    }


                    (function domAdd() {

                        var args = {};
                        args.control = calendar;
                        args.e = data;
                        args.element = null;

                        div.domArgs = args;

                        if (typeof calendar.onBeforeEventDomAdd === "function") {
                            calendar.onBeforeEventDomAdd(args);
                        }

                        if (args.element) {
                            var target = inner;
                            if (target) {
                                args._targetElement = target;

                                var isReactComponent = isReactComp(args.element);
                                if (isReactComponent) {
                                    calendar._react._ensureDom();
                                    calendar._react._render(args.element, target);
                                }
                                else {
                                    target.appendChild(args.element);
                                }
                            }
                        }
                        else {
                            inner.innerHTML = data.client.innerHTML();
                        }
                    })();


                    wrap.appendChild(div);
                    this.nav.allday.appendChild(wrap);
                    // this.nav.allday.appendChild(div);

                    //new DayPilot.Event(div, calendar);
                    this.elements.events.push(div);
                }
            }

            header.style.display = '';
        };

        this._deleteEvents = function(allDayOnly) {
            calendar.multiselect._divDeselectAll();

            if (this.elements.events) {

                for (var i = 0; i < this.elements.events.length; i++) {
                    var div = this.elements.events[i];

                    var object = div.event;

                    if (object && allDayOnly && !object.allday()) {
                        continue;
                    }

                    calendar._deleteEvent(div);

                }
            }

            this.elements.events = [];

        };

        this._deleteEvent = function(div) {

            var object = div.event;


            var domArgs = div.domArgs;
            div.domArgs = null;

            if (domArgs && typeof calendar.onBeforeEventDomRemove === "function") {
                calendar.onBeforeEventDomRemove(domArgs);
            }

            if (domArgs && typeof calendar.onBeforeEventDomAdd === "function" && calendar._react.reactDOM) {
                var target = domArgs && domArgs._targetElement;
                if (target) {
                    var isReact = isReactComp(domArgs.element);
                    if (isReact) {
                        calendar._react._ensureDom();
                        calendar._react._unmount(target);
                    }
                }
            }

            if (object) {
                object.div = null;
                object.root = null;
                object.rendered = false;
            }

            div.onclick = null;
            div.onclickSave = null;
            div.ondblclick = null;
            div.oncontextmenu = null;
            div.onmouseover = null;
            div.onmouseout = null;
            div.onmousemove = null;
            div.onmousedown = null;

            if (div.firstChild && div.firstChild.firstChild && div.firstChild.firstChild.tagName && div.firstChild.firstChild.tagName.toUpperCase() === 'IMG') {
                var img = div.firstChild.firstChild;
                img.onmousedown = null;
                img.onmousemove = null;
                img.onclick = null;

            }

            if (div !== DpGlobal.moving) {
                div.helper = null;
                div.event = null;
            }

            deleteElement(div);

        };


        this._eventIsInView = function(e) {
            if (e.isAllDay()) {
                // always keep visible
                return true;
/*
                var startcol = calendar._getColX(e.part.colStart);
                var endcol = calendar._getColX(e.part.colStart + e.part.colWidth - 1);

                var area = this._getDrawArea();
                var left = area.pixels.left;
                var right = area.pixels.right;

                var eventLeft = startcol.left;
                var eventRight = endcol.left + endcol.width;
                var horizontalOut = right <= eventLeft || left >= eventRight;

                return !horizontalOut;
*/
            }
            else {
                var cd = calendar._getColX(e.part.dayIndex);

                var area = this._getDrawArea();
                var left = area.pixels.left;
                var right = area.pixels.right;
                var top = area.pixels.top;
                var bottom = area.pixels.bottom;

                var eWidth = (e.part.width/100) * cd.width;

                var eventLeft = e.part.left + cd.left;
                var eventRight = eventLeft + eWidth;
                var eventTop = e.part.top - this._autoHiddenPixels();
                var eventBottom = eventTop + e.part.height;

                var horizontalOut = right <= eventLeft || left >= eventRight;
                var verticalOut = bottom <= eventTop || top >= eventBottom;

                return !horizontalOut && !verticalOut;
            }
        };

        this._drawEvent = function(e) {
            var main = this.nav.events;
            var cache = e.cache || e.data;

            // var borderColor = cache.borderColor || this.eventBorderColor;
            if (e.rendered) {
                return;
            }

            var shouldBeSelected = calendar.multiselect._shouldBeSelected(e);
            var inView = calendar._eventIsInView(e);

            var dynamic = calendar.dynamicEventRendering === "Progressive" && calendar.columnWidthSpec === "Fixed";
            var forced = false;

            if (!forced && !shouldBeSelected && dynamic && !inView) { // dynamic rendering, event outside of the current view
                return;
            }

            var div = createDiv();
            //div.data = data;
            div.setAttribute("unselectable", "on");
            div.style.MozUserSelect = 'none';
            div.style.KhtmlUserSelect = 'none';
            div.style.WebkitUserSelect = 'none';
            div.style.position = 'absolute';
            div.className = this._prefixCssClass("_event");
            div.style.left = e.part.left + '%';
            div.style.top = (e.part.top - this._autoHiddenPixels()) + 'px';
            div.style.width = e.part.width + '%';
            div.style.height = Math.max(e.part.height, 2) + 'px';

            div.style.overflow = 'hidden';

            div.isFirst = e.part.start.getTime() === e.start().getTime();
            div.isLast = e.part.end.getTime() === e.end().getTime();

            if (e.client.clickEnabled()) {
                div.onclick = this._eventClickDispatch;
            }
            if (e.client.doubleClickEnabled()) {
                div.ondblclick = this._eventDoubleClickDispatch;
            }
            //div.addEventListener("contextmenu", this._eventRightClickDispatch, false);
            //div.oncontextmenu = this._eventRightClickDispatch;
            registerEvent(div, "contextmenu", this._eventRightClickDispatch);
            div.onmousemove = this._onEventMouseMove;
            div.onmouseout = this._onEventMouseOut;
            div.onmousedown = this._onEventMouseDown;

            reNonPassive(div, DayPilot.touch.start, this._touch.onEventTouchStart);
            rePassive(div, DayPilot.touch.move, this._touch.onEventTouchMove);
            rePassive(div, DayPilot.touch.end, this._touch.onEventTouchEnd);

            // inner divs
            // var inside = [];

            if (cache.cssClass) {
                addClass(div, cache.cssClass);
            }

            if (this.showToolTip && !this.bubble) {
                div.setAttribute("title", e.client.toolTip());
            }

            var inner = createDiv();
            inner.setAttribute("unselectable", "on");
            inner.className = calendar._prefixCssClass("_event_inner");

            // moved to domAdd() below
            // inner.innerHTML = data.client.innerHTML();

            if (cache.fontColor) {
                inner.style.color = cache.fontColor;
            }

            if (cache.backColor) {
                inner.style.background = cache.backColor;
            }
            if (cache.borderColor) {
                if (cache.borderColor === "darker" && cache.backColor) {
                    inner.style.borderColor = DayPilot.ColorUtil.darker(cache.backColor, 2);
                }
                else {
                    inner.style.borderColor = cache.borderColor;
                }
            }
            if (cache.backgroundImage) {
                inner.style.backgroundImage = "url(" + cache.backgroundImage + ")";
                if (cache.backgroundRepeat) {
                    inner.style.backgroundRepeat = cache.backgroundRepeat;
                }
            }

            div.appendChild(inner);

            // TODO
            if (e.client.barVisible()) {
                var height = e.part.height - 2;
                //var barLeft = 100 * data.part.barLeft / (width); // %
                //var barWidth = Math.ceil(100 * data.part.barWidth / (width)); // %
                var barTop =  100 * e.part.barTop / height; // %
                var barHeight = Math.ceil(100 * e.part.barHeight / height); // %

                var bar = createDiv();
                bar.setAttribute("unselectable", "on");
                bar.className = this._prefixCssClass("_event_bar");
                bar.style.position = "absolute";

                if (cache.barBackColor) {
                    bar.style.backgroundColor = cache.barBackColor;
                }
                var barInner = createDiv();
                barInner.setAttribute("unselectable", "on");
                barInner.className = this._prefixCssClass("_event_bar_inner");
                barInner.style.top = barTop + "%";
                //barInner.setAttribute("barWidth", data.part.barWidth);  // debug
                if (0 < barHeight && barHeight <= 1) {
                    barInner.style.height = "1px";
                }
                else {
                    barInner.style.height = barHeight + "%";
                }

                if (cache.barColor) {
                    barInner.style.backgroundColor = cache.barColor;
                }


                bar.appendChild(barInner);
                div.appendChild(bar);
            }

            var areas = cache.areas ? DayPilot.Areas.copy(cache.areas) : [];

            var col = calendar._columnsBottom[e.part.dayIndex];

            areas.forEach(function(area) {
                if (area.start) {
                    area.top = calendar._getPixels(new DayPilot.Date(area.start), col.start).top - e.part.top - calendar._autoHiddenPixels();
                }
                if (area.end) {
                    area.bottom = e.part.top + e.part.height - calendar._getPixels(new DayPilot.Date(area.end), col.start).top - calendar._autoHiddenPixels();
                }
            });

            if (e.client.deleteEnabled()) {
                areas.push({"action":"JavaScript","v":"Hover","w":17,"h":17,"top":2,"right":2, "css": calendar._prefixCssClass("_event_delete"),"js":function(e) { calendar._eventDeleteDispatch(e); } });
            }

            DayPilot.Areas.attach(div, e, {"areas": areas});

            (function domAdd() {

                var args = {};
                args.control = calendar;
                args.e = e;
                args.element = null;

                div.domArgs = args;

                if (typeof calendar.onBeforeEventDomAdd === "function") {
                    calendar.onBeforeEventDomAdd(args);
                }

                if (args.element) {
                    var target = inner;
                    if (target) {
                        args._targetElement = target;

                        var isReactComponent = isReactComp(args.element);
                        if (isReactComponent) {
                            calendar._react._ensureDom();
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }
                else {
                    inner.innerHTML = e.client.innerHTML();
                }
            })();


            if (!main.rows[0].cells[e.part.dayIndex]) { // temporary fix for multirow header, but won't hurt later
                return;
            }

            var wrapper = main.rows[0].cells[e.part.dayIndex].events;
            wrapper.appendChild(div);

            calendar._makeChildrenUnselectable(div);
            div.event = e;

            if (calendar.multiselect._shouldBeSelected(e)) {
                calendar.multiselect.add(div.event, true);
            }

            e.rendered = true;

            if (calendar._api2()) {
                if (typeof calendar.onAfterEventRender === 'function') {
                    var args = {};
                    args.e = div.event;
                    args.div = div;

                    calendar.onAfterEventRender(args);
                }
            }
            else {
                if (calendar.afterEventRender) {
                    calendar.afterEventRender(div.event, div);
                }
            }

            calendar.elements.events.push(div);
        };

        this._makeChildrenUnselectable = function(el) {
            var c = (el && el.childNodes) ? el.childNodes.length : 0;
            for (var i = 0; i < c; i++) {
                try {
                    var child = el.childNodes[i];
                    if (child.nodeType === 1) {
                        child.setAttribute("unselectable", "on");
                        this._makeChildrenUnselectable(child);
                    }
                }
                catch (e) {
                    //alert(e + " " + child.type);
                }
            }
        };

        this._drawEvents = function() {
            //this.multiselect._list = [];

            var start = new Date();

            for (var i = 0; i < this._columnsBottom.length; i++) {
                var col = this._columnsBottom[i];

                if (!col.blocks) {
                    continue;
                }

                for (var m = 0; m < col.blocks.length; m++) {
                    var block = col.blocks[m];
                    for (var j = 0; j < block.lines.length; j++) {
                        var line = block.lines[j];

                        for (var k = 0; k < line.length; k++) {
                            var e = line[k];

                            e.part.width = 100 / block.lines.length;
                            e.part.left = e.part.width * j;

                            if (this.eventArrangement === 'Cascade') {
                                var isLastBlock = (j === block.lines.length - 1);
                                if (!isLastBlock) {
                                    e.part.width = e.part.width * 1.5;
                                }
                            }
                            if (this.eventArrangement === 'Full') {
                                e.part.left = e.part.left / 2;
                                e.part.width = 100 - e.part.left;
                            }

                            if (!e.allday()) {
                                this._drawEvent(e);
                            }
                        }
                    }
                }
            }

            this.multiselect.redraw();

            var end = new Date();
            var diff = end.getTime() - start.getTime();
        };

        this._drawEventsOnScroll = function() {
            calendar.elements.events.forEach(function(div) {
                if (div.event && !calendar._eventIsInView(div.event)) {
                    calendar._deleteEvent(div);
                }
            });

            calendar._cache._eps.forEach(function(e) {
                calendar._drawEvent(e);
            });

            calendar.elements.events = calendar.elements.events.filter(function(div) { return !!div.event; });
        };

        this._drawCellsOnScroll = function() {

            if (!calendar._columnsBottom || calendar._columnsBottom.length === 0) {
                return;
            }

            // get x, y from viewport data
            var area = calendar._getDrawArea();

            for (var x = area.xStart; x <= area.xEnd; x++) {
                for (var y = area.yStart; y <= area.yEnd; y++) {
                    calendar._drawCell(x, y);
                }
            }
            calendar._deleteCellsOut();

            // calendar._doAutoScroll(calendar.coords);
        };


        calendar._deleteCellsOut = function() {
            var area = calendar._getDrawArea();
            var rowCount = this._rowCount();
            var colCount = calendar._columnsBottom.length;
            for (var x = 0; x < colCount; x++) {
                var xOut = true;
                if (area.xStart <= x && x <= area.xEnd) {
                    xOut = false;
                }
                for (var y = 0; y < rowCount; y++) {
                    var yOut = true;
                    if (area.yStart <= y && y <= area.yEnd) {
                        yOut = false;
                    }
                    var cell = calendar.elements.cells[x + "_" + y];
                    if (cell && (yOut || xOut)) {
                        cell.remove();
                        calendar.elements.cells[x + "_" + y] = null;
                    }
                }
            }
        };

        this._drawEventsFromLines = function() {
            //return;
            this.multiselect._list = [];

            for (var i = 0; i < this._columnsBottom.length; i++) {
                var col = this._columnsBottom[i];

                for (var j = 0; j < col.lines.length; j++) {
                    var line = col.lines[j];

                    for (var k = 0; k < line.length; k++) {
                        var e = line[k];

                        e.part.width = 100 / col.lines.length;
                        e.part.left = e.Width * j;

                        if (!e.allday()) {
                            this._drawEvent(e);
                        }
                    }
                }
            }

        };

        this._prefixCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            if (prefix) {
                return prefix + part;
            }
            else {
                return "";
            }
        };

        this._versionCheck = function() {

            // check licensing restrictions

            switch (calendar._productCode) {
                case "aspnet":
                    if (!this._isAspnetWebForms()) {
                        throw new DayPilot.Exception("ASP.NET WebForms environment required. https://doc.daypilot.org/common/asp-net-webforms-required/");
                    }
                    break;
                case "netmvc":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-asp-net-mvc/");
                    }
                    break;
                case "javaxx":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-java/");
                    }
                    break;
            }
        };

        this._show = function() {
            if (this.nav.top.style.visibility === 'hidden') {
                this.nav.top.style.visibility = 'visible';
            }
        };

        this._totalHeight = function() {
            var height = this._totalHeaderHeight() + this._getScrollableHeight();

            calendar.debug.message("Getting totalHeight, headerHeight: " + this._totalHeaderHeight() + " scrollable: " + this._getScrollableHeight());

            if (height < 0) {
                return 0;
            }
            return height;
        };

        this._onTopMouseLeave = function() {
            calendar._out();
        };

        this._drawTop = function() {

            var top = this.nav.top;

            //this.nav.top = document.getElementById(this.id);
            top.dp = this;
            top.innerHTML = '';

            top.style.MozUserSelect = 'none';
            top.style.KhtmlUserSelect = 'none';
            top.style.WebkitUserSelect = 'none';

            top.style.WebkitTapHighlightColor = "rgba(0,0,0,0)";
            top.style.WebkitTouchCallout = "none";

            top.style.position = 'relative';
            if (this.width) {
                top.style.width = this.width;
            }
            if (this.rtl) {
                top.style.direction = "rtl";
            }
            //this.nav.top.style.width = this.width ? this.width : '100%';
            if (this.heightSpec === "Parent100Pct") {
                top.style.height = "100%";
            }
            else {
                top.style.height = this._totalHeight() + "px";
            }

            if (this.hideUntilInit) {
                top.style.visibility = 'hidden';
            }

            if (!this.visible) {
                top.style.display = "none";
            }

            top.addEventListener("mouseleave", calendar._onTopMouseLeave);

            var scroll = createDiv();
            this.nav.scroll = scroll;
            scroll.style.height = this._getScrollableHeight() + "px";

            // addClass(top, this._prefixCssClass("_main"));

            scroll.style.position = "relative";

            // this muse be called after setting overflow on this.nav.scroll because it's used to detect the scrollbar
            if (this.showHeader) {
                var header = this._drawTopHeaderDiv();
                top.appendChild(header);
            }

            // fixing the column alignment bug
            // solved thanks to http://stackoverflow.com/questions/139000/div-with-overflowauto-and-a-100-wide-table-problem
            scroll.style.zoom = 1;
            scroll.style.position = "absolute";
            scroll.style.left = "0px";
            scroll.style.right = "0px";
            scroll.style.top = this._totalHeaderHeight() + "px";
            scroll.className = calendar._prefixCssClass("_scroll");

            var wrap = this._drawScrollable();
            this.nav.scrollable = wrap.firstChild;
            scroll.appendChild(wrap);
            top.appendChild(this.nav.scroll);

            this.nav.vsph = createDiv();
            this.nav.vsph.style.display = "none";

            this.nav.top.appendChild(this.nav.vsph);

            this.nav.scrollpos = document.createElement("input");
            this.nav.scrollpos.type = "hidden";
            this.nav.scrollpos.id = calendar.id + "_scrollpos";
            this.nav.scrollpos.name = this.nav.scrollpos.id;
            top.appendChild(this.nav.scrollpos);

            this.nav.select = document.createElement("input");
            this.nav.select.type = "hidden";
            this.nav.select.id = calendar.id + "_select";
            this.nav.select.name = this.nav.select.id;
            this.nav.select.value = null;  // used to be selectedEventValue on the server side
            top.appendChild(this.nav.select);

            this.nav.scrollLayer = createDiv();
            this.nav.scrollLayer.style.position = 'absolute';
            this.nav.scrollLayer.style.top = '0px';
            this.nav.scrollLayer.style.left = '0px';
            top.appendChild(this.nav.scrollLayer);

            this.nav.scrollUp = [];
            this.nav.scrollDown = [];

            var loading = createDiv();
            loading.style.position = 'absolute';
            loading.style.top = '0px';
            loading.style.left = (this.hourWidth + 5) + "px";
            loading.className = calendar._prefixCssClass("_loading");
            loading.innerHTML = calendar._xssTextHtml(this.loadingLabelText, this.loadingLabelHtml);
            loading.style.display = 'none';
            this.nav.loading = loading;

            top.appendChild(loading);

        };

        this._updateRowWidths = function() {
            var scrolling = this.columnWidthSpec === 'Fixed';

            var headerRow = this.nav.header && this.nav.header.rows[this.nav.header.rows.length - 1]; // last
            var eventsRow = this.nav.events.rows[0];

            for (var i = 0; i < calendar._columnsBottom.length; i++) {
                var headerCell = headerRow && headerRow.cells[i];
                var eventsCell = eventsRow.cells[i];
                var headerDiv = headerCell && headerCell.firstChild;
                var data = calendar._columnsBottom[i];

                if (scrolling) {
                    var width = data.width ? data.width : calendar.columnWidth;
                    headerDiv && (headerDiv.style.width = width + "px");
                    if (eventsCell) {
                        eventsCell.style.width = width + "px";
                    }
                }
                else {
                    if (!calendar._divBasedGrid) {
                        headerDiv && (headerDiv.style.width = null);
                        if (eventsCell) {
                            eventsCell.style.width = null;
                        }
                    }
                }
            }
        };

        this._scrollElement = function() {
            return this._unifiedScrollable ? calendar.nav.bottomRight : calendar.nav.scroll;
        };

        this._updateColumnWidthSpec = function() {
            var scrolling = this.columnWidthSpec === 'Fixed';

            if (!scrolling) {
                var element = calendar._scrollElement();
                if (this.heightSpec === "Fixed") {
                    element.style.overflowY = "scroll";
                }
                else if (this.heightSpec === 'BusinessHours' && this._durationHours() <= this.businessEndsHour - this.businessBeginsHour) {
                    element.style.overflow = "hidden";
                }
                else if (this.heightSpec !== "Full" && this.heightSpec !== "BusinessHoursNoScroll") {
                    element.style.overflow = "auto";
                }
                else {
                    element.style.overflow = "hidden";
                }
            }

            if (scrolling) {
                var scrollbarSpace = 0;
                var w = calendar._getTotalFixedColumnWidth();
                var scrollDiv = calendar._scrollDiv();

                if (w > scrollDiv.clientWidth) {
                    scrollbarSpace = DayPilot.sw(calendar.nav.bottomRight);
                }

                calendar.nav.headerParent && (calendar.nav.headerParent.style.width = (w + scrollbarSpace) + "px");
                calendar.nav.main.style.width = w + "px";
                calendar.nav.events.style.width = w + "px";
                calendar.nav.crosshair.style.width = w + "px";
            }
            else {
                calendar.nav.headerParent && (calendar.nav.headerParent.style.width = "100%");
                calendar.nav.main.style.width = "100%";
                calendar.nav.events.style.width = "100%";
                calendar.nav.crosshair.style.width = "100%";
            }

            this._updateRowWidths();

        };

        // used during full update
        this._drawHourTable = function() {
            // clear old hour table
            if (!this._fasterDispose) {
                DayPilot.pu(this.nav.hourTable);
            }
            else {
                this._disposeHourTable();
            }

            if (this.nav.hoursPlaceholder) {
                this.nav.hoursPlaceholder.innerHTML = '';
                this.nav.hourTable = this._createHourTable2();
                this.nav.hoursPlaceholder.appendChild(this.nav.hourTable);
            }
        };

        this._disposeHourTable = function() {
            if (!this.nav.hourTable) {
                return;
            }


            calendar.elements.timeHeaders.forEach(function(div) {
                var domArgs = div.domArgs;
                div.domArgs = null;

                if (typeof calendar.onBeforeTimeHeaderDomRemove === "function") {
                    calendar.onBeforeTimeHeaderDomRemove(domArgs);
                }

                if (typeof calendar.onBeforeTimeHeaderDomAdd === "function" && calendar._react.reactDOM) {
                    var target = domArgs && domArgs._targetElement;
                    if (target) {
                        var isReact = isReactComp(domArgs.element);
                        if (isReact) {
                            calendar._react._ensureDom();
                            calendar._react._unmount(target);
                        }
                    }
                }
            });

            for (var i = 0; i < this.nav.hourTable.rows.length; i++) {
                var row = this.nav.hourTable.rows[i];
                var div = row.cells[0].firstChild;
                div.data = null;
                div.onmousemove = null;
                div.onmouseout = null;
            }

            calendar.elements.timeHeaders = [];
        };

        // used during initial load only
        this._drawScrollable = function() {
            var zoom = createDiv();
            zoom.style.zoom = 1;
            zoom.style.position = 'relative';
            zoom.onmousemove = this._onMainMouseMove;
            zoom.oncontextmenu = this._onMainRightClick;

            reNonPassive(zoom, DayPilot.touch.start, this._touch._onMainTouchStart);
            reNonPassive(zoom, DayPilot.touch.move, this._touch._onMainTouchMove);
            reNonPassive(zoom, DayPilot.touch.end, this._touch._onMainTouchEnd);

            registerEvent(zoom, "contextmenu", function(ev) {
                var ev = ev || window.event;
                ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
            });

            if (navigator.msPointerEnabled) {
                zoom.style.msTouchAction = "none";
                zoom.style.touchAction = "none";
            }

            // required for detection of calendar under touch position
            zoom.daypilotMainD = true;
            zoom.calendar = this;

            var bottomLeft = null;
            var hoursPlaceholder = null;

            if (this.showHours) {
                var left = createDiv();
                left.style.cssFloat = "left";
                if (calendar.rtl) {
                    left.style.cssFloat = "right";
                }
                left.style.width = (this.hourWidth) + "px";
                left.style.height = this._getScrollableHeight() + "px";
                left.style.overflow = "hidden";
                left.style.position = "relative";

                zoom.appendChild(left);
                bottomLeft = left;

                var scrollbarSpace = 30;
                //var height = (this._duration() * this.cellHeight) / (60000 * this.cellDuration) + scrollbarSpace;
                var height = calendar._getInnerHeight() + scrollbarSpace;

                hoursPlaceholder = createDiv();
                hoursPlaceholder.style.height = (height) + "px";

                left.appendChild(hoursPlaceholder);
            }

            var bottomRight = createDiv();
            bottomRight.style.height = this._getScrollableHeight() + "px";
            if (this.showHours) {
                if (calendar.rtl) {
                    bottomRight.style.marginRight = (this.hourWidth) + "px";
                }
                else {
                    bottomRight.style.marginLeft = (this.hourWidth) + "px";
                }
            }
            bottomRight.style.position = "relative";
            bottomRight.style.overflow = "auto";
            zoom.appendChild(bottomRight);

            if (hoursPlaceholder) {
                this.nav.hourTable = this._createHourTable2();
                hoursPlaceholder.appendChild(this.nav.hourTable);
            }

            var parent = createDiv();
            parent.style.height = "0px";
            parent.style.position = "relative";

            parent.appendChild(this._createCellsTable());

            var crosshair = createDiv();
            crosshair.style.position = "absolute";
            crosshair.style.top = "0px";
            crosshair.style.left = "0px";
            crosshair.style.width = "100%";
            crosshair.style.height = "0px";
            parent.appendChild(crosshair);
            this.nav.crosshair = crosshair;

            parent.appendChild(this._createEventsTable());

            bottomRight.appendChild(parent);

            this.nav.grid = parent;

            this.nav.zoom = zoom;
            this.nav.bottomLeft = bottomLeft;
            this.nav.bottomRight = bottomRight;
            this.nav.hoursPlaceholder = hoursPlaceholder;
            return zoom;
        };

        this._createCellsTable = function() {
            if (calendar._divBasedGrid) {
                var main = createDiv();
                calendar.nav.main = main;
                return main;
            }
            else {
                var table = document.createElement("table");

                table.cellPadding = "0";
                table.cellSpacing = "0";
                table.border = "0";
                var scrolling = this.columnWidthSpec === 'Fixed';

                if (!scrolling) {
                    table.style.width = "100%";
                }
                table.style.border = "0px none";
                table.style.margin = "0px";
                table.style.tableLayout = 'fixed';

                this.nav.main = table;
                // this.nav.events = table;

                return table;

            }

        };

        this._getTotalScrollableWidth = function() {
            var fixed = this.columnWidthSpec === 'Fixed';
            if (!fixed) {
                return "100%";
            }
            else {
                return calendar._getTotalFixedColumnWidth() + "px";
            }
        };

        this._getTotalFixedColumnWidth = function() {
            var total = 0;
            for (var i = 0; i < calendar._columnsBottom.length; i++) {
                var column = calendar._columnsBottom[i];
                if (column.width) {
                    total += column.width;
                }
                else {
                    total += calendar.columnWidth;
                }
            }
            return total;
        };

        this._createEventsTable = function() {
            if (calendar._divBasedGrid) {
                var navEvents = createDiv();
                navEvents.style.userSelect = "none";
                navEvents.style.position = "absolute";
                navEvents.style.left = "0px";
                navEvents.style.right = "0px";
                navEvents.style.top = "0px";
                navEvents.style.height = "0px";

                calendar.nav.events = navEvents;
                return navEvents;
            }
            else {
                var table = document.createElement("table");

                table.style.position = "absolute";
                table.style.top = "0px";
                table.cellPadding = "0";
                table.cellSpacing = "0";
                table.border = "0";
                table.style.width = calendar._getTotalScrollableWidth();
                table.style.border = "0px none";
                table.style.margin = "0px";
                table.style.tableLayout = 'fixed';

                this.nav.events = table;
                var create = true;
                var columns = this._columnsBottom;
                var cl = columns.length;

                var r = (create) ? table.insertRow(-1) : table.rows[0];

                for (var j = 0; j < cl; j++) {
                    var c = (create) ? r.insertCell(-1) : r.cells[j];

                    if (create) {

                        c.style.padding = '0px';
                        c.style.border = '0px none';
                        c.style.height = '0px';
                        c.style.overflow = 'visible';
                        if (!calendar.rtl) {
                            c.style.textAlign = 'left';
                        }

                        /*
                        if (calendar.columnWidthSpec === "Fixed") {
                            if (columns[j].width) {
                               c.style.width = columns[j].width + "px";
                            }
                            else {
                                c.style.width = calendar.columnWidth + "px";
                            }
                        }
                        */

                        calendar._initializeEventCell(c);
                    }
                }

                return table;
            }
        };

        this._createHourTable = function() {
            var table = document.createElement("table");
            table.cellSpacing = "0";
            table.cellPadding = "0";
            table.border = "0";
            table.style.margin = "0px";
            table.style.border = '0px none';
            table.style.width = this.hourWidth + "px";
            table.oncontextmenu = function() { return false; };
            table.onmousemove = function() { calendar._crosshairHide(); };

            var hours = calendar._hourRowCount();
            for (var i = 0; i < hours; i++) {
                this._createHourRow(table, i);
            }

            return table;

        };

        this._createHourTable2 = function() {
            var table = createDiv();
            table.style.width = this.hourWidth + "px";
            table.style.position = "relative";
            table.oncontextmenu = function() { return false; };
            table.onmousemove = function() { calendar._crosshairHide(); };
            table.rows = [];

            var hours = calendar._hourRowCount();
            for (var i = 0; i < hours; i++) {
                this._createHourRow2(table, i);
            }

            return table;

        };

        this._hourRowCount = function() {
            return this._duration() / (this.timeHeaderCellDuration * 60 * 1000);  // duration in ticks
        };

        this._hourRowHeight = function() {
            return (this.cellHeight * 60 / this.cellDuration) / (60 / this.timeHeaderCellDuration);
        };

        this._autoHiddenRows = function() {
            return (this._visibleStart() - this._visibleStart(true)) * (60 / this.cellDuration);
        };

        this._autoHiddenHours = function() {
            return (this._visibleStart() - this._visibleStart(true));
        };

        this._autoHiddenPixels = function() {
            return this._autoHiddenRows() * this.cellHeight;
        };

        this._createHourRow = function(table, i) {
            var height = calendar._hourRowHeight();

            var r = table.insertRow(-1);
            r.style.height = height + "px";

            var c = r.insertCell(-1);
            c.valign = "bottom";
            c.setAttribute("unselectable", "on");
            c.style.padding = '0px';
            c.style.border = '0px none';

            var div = createDiv();
            div.className = this._prefixCssClass("_rowheader");
            div.style.position = "relative";
            div.style.width = this.hourWidth + "px";
            div.style.height = (height) + "px";
            div.style.overflow = 'hidden';
            div.setAttribute("unselectable", "on");

            var inner = createDiv();
            inner.className = this._prefixCssClass("_rowheader_inner");
            inner.setAttribute("unselectable", "on");

            var props = calendar._hourRowProps(i);

            var html = props.html;
            var data = props.data;


            if (data) {
                div.data = data;
                div.onmousemove = calendar._onTimeHeaderMouseMove;
                div.onmouseout = calendar._onTimeHeaderMouseOut;
            }

            var argsElement = null;

            var args = {};
            args.header = data;

            // onBeforeTimeHeaderDomAdd
            if (typeof calendar.onBeforeTimeHeaderDomAdd === "function") {
                args.element = null;

                calendar.onBeforeTimeHeaderDomAdd(args);

                argsElement = args.element;
            }

            // or c?
            div.domArgs = args;
            if (argsElement) {
                var target = inner;
                // target.domArgs = args;
                args._targetElement = target;
                var isReactComponent = isReactComp(argsElement);
                if (isReactComponent) {
                    calendar._react._ensureDom();
                    calendar._react._render(argsElement, target);
                }
                else {
                    target.appendChild(argsElement);
                }
            }
            else {
                inner.innerHTML = html;
            }

            // inner.innerHTML = html;

            div.appendChild(inner);

            calendar.elements.timeHeaders.push(div);

            c.appendChild(div);
        };

        this._createHourRow2 = function(table, i) {
            var height = calendar._hourRowHeight();


            var r = createDiv();
            r.style.position = "absolute";
            r.style.top = (i*height) + "px";
            r.style.height = height + "px";
            table.rows[i] = r;

            var c = createDiv();
            r.appendChild(c);

            r.cells = [c];

            var div = createDiv();
            div.className = this._prefixCssClass("_rowheader");
            div.style.position = "relative";
            div.style.width = this.hourWidth + "px";
            div.style.height = (height) + "px";
            div.style.overflow = 'hidden';
            div.setAttribute("unselectable", "on");

            var inner = createDiv();
            inner.className = this._prefixCssClass("_rowheader_inner");
            inner.setAttribute("unselectable", "on");

            var props = calendar._hourRowProps(i);

            var html = props.html;
            var data = props.data;

            if (data) {
                div.data = data;
                div.onmousemove = calendar._onTimeHeaderMouseMove;
                div.onmouseout = calendar._onTimeHeaderMouseOut;
            }

            var argsElement = null;

            var args = {};
            args.header = data;

            // onBeforeTimeHeaderDomAdd
            if (typeof calendar.onBeforeTimeHeaderDomAdd === "function") {
                args.element = null;

                calendar.onBeforeTimeHeaderDomAdd(args);

                argsElement = args.element;
            }

            // or c?
            div.domArgs = args;
            if (argsElement) {
                var target = inner;
                // target.domArgs = args;
                args._targetElement = target;
                var isReactComponent = isReactComp(argsElement);
                if (isReactComponent) {
                    calendar._react._ensureDom();
                    calendar._react._render(argsElement, target);
                }
                else {
                    target.appendChild(argsElement);
                }
            }
            else {
                inner.innerHTML = html;
            }

            // inner.innerHTML = html;

            div.appendChild(inner);

            calendar.elements.timeHeaders.push(div);

            c.appendChild(div);

            table.appendChild(r);
        };


        this._hourRowProps = function(i) {
            var html, data;

            if (this.hours) {
                var index = i + this._autoHiddenHours();
                data = this.hours[index];
                html = data.html;
            }

            var cellDuration = this.timeHeaderCellDuration;

            var start = this.startDate.addMinutes(cellDuration * i + 60*this._visibleStart());
            var hour = start.getHours();

            var am = hour < 12;
            var sup;
            if (this._resolved._timeFormat() === "Clock12Hours") {
                if (am) {
                    sup = "AM";
                }
                else {
                    sup = "PM";
                }
            }
            else {
                sup = "00";
            }

            if (!html) {
                var text = createDiv();
                text.setAttribute("unselectable", "on");


                if (this._resolved._timeFormat() === "Clock12Hours") {
                    hour = hour % 12;
                    if (hour === 0) {
                        hour = 12;
                    }
                }

                if (this.timeHeaderCellDuration !== 60) {
                    hour += ":" + start.toString("mm");
                }

                text.innerHTML = hour;

                if (this.timeHeaderCellDuration === 60) {
                    var span = document.createElement("span");
                    span.setAttribute("unselectable", "on");
                    span.className = this._prefixCssClass("_rowheader_minutes");
                    span.innerHTML = sup;
                    text.appendChild(span);
                }

                html = text.outerHTML;

            }

            var args = {};
            args.header = {};
            args.header.hours = start.getHours();
            args.header.minutes = start.getMinutes();
            args.header.start = start.toString("HH:mm");
            args.header.text = null;
            args.header.html = html;
            args.header.areas = data ? data.areas : null;
            args.header.time = new DayPilot.Duration(start.getTimePart());

            if (typeof calendar.onBeforeTimeHeaderRender === 'function') {
                calendar.onBeforeTimeHeaderRender(args);

                if (args.header.html !== null) {
                    html = args.header.html;
                }
            }

            data = args.header;

            var result = {};
            result.start = start;
            result.hour = hour;
            result.html = html;
            result.data = data;
            result.sup = sup;
            if (args.header.text) {
                result.text = args.header.text;
            }

            return result;
        };

        this._onTimeHeaderMouseMove = function(ev) {
            calendar._crosshairHide();

            var div = this;
            if (!div.active) {
                DayPilot.Areas.showAreas(div, div.data);
            }

        };

        this._onTimeHeaderMouseOut = function(ev) {
            DayPilot.Areas.hideAreas(this, ev);
        };

        this._getScrollableHeight = function() {
            switch (this.heightSpec) {
                case "Fixed":
                    return this.height;
                case "Parent100Pct":
                    return this.height;
                case "Full":
                    return this._getInnerHeight();
                case "BusinessHours":
                case "BusinessHoursNoScroll":
                    var dHours = this._businessHoursSpan();
                    return dHours * this.cellHeight * 60 / this.cellDuration;
                default:
                    throw new DayPilot.Exception("DayPilot.Calendar: Unexpected 'heightSpec' value.");

            }
        };

        this._getInnerHeight = function() {
            return (calendar._duration() * this.cellHeight) / (60000 * calendar.cellDuration);
        };

        this._totalHeaderHeight = function() {
            if (!this.showHeader) {
                return 0;
            }
            var headerRowsHeight = resolved._headerLevels() * resolved._headerHeight();
            if (this.showAllDayEvents && resolved._allDayHeaderHeight()) {
                return headerRowsHeight + resolved._allDayHeaderHeight();
            }
            else {
                return headerRowsHeight;
            }
        };

        this._autoHeaderHeight = function() {
            if (!this.headerHeightAutoFit) {
                return;
            }

            var max = 0;
            //for (var i = 0; i < this._columnsBottom.length; i++) {
            for (var x = 0; x < this.nav.header.rows.length; x++) {
                var row = this.nav.header.rows[x];
                for (var i = 0; i < row.cells.length; i++) {
                    var cell = row.cells[i];
                    var div = cell.firstChild;
                    var inner = div.firstChild;

                    var oldHeight = div.style.height;
                    div.style.height = "auto";

                    inner.style.position = "static";

                    var h = div.offsetHeight;

                    div.style.height = oldHeight;
                    inner.style.position = '';

                    max = Math.max(max, h);
                }
            }

            if (max > this.headerHeight) {
                this._cache.headerHeight = max;
                this._updateHeaderHeight();
                this._drawHeader();
            }

        };

        this._scrollbarVisible = function() {
            var element = this._unifiedScrollable ? calendar.nav.bottomRight : calendar.nav.scroll;

            return DayPilot.sw(element) > 0;

            /*
            if (this.heightSpec === 'Parent100Pct') {
                var inner = (this._duration() * this.cellHeight) / (60000 * this.cellDuration);
                return inner > this.height;
            }
            return this.nav.scroll.style.overflow !== 'hidden';
            */
        };

        this._drawTopHeaderDiv = function() {
            var header = createDiv();
            //header.setAttribute("data-id", "header-div");
            var scrolling = this.columnWidthSpec === 'Fixed';
            if (!scrolling) {
                header.style.overflow = "auto";
            }

            header.style.position = "absolute";
            header.style.left = "0px";
            header.style.right = "0px";

            // to match main grid structure
            var zoom = createDiv();
            zoom.style.position = "relative";
            zoom.style.zoom = "1";

            var relative = null;
            var scrolling = this.columnWidthSpec === 'Fixed';
            if (scrolling || this._unifiedScrollable) {
                var left = createDiv();
                left.style.cssFloat = "left";
                if (calendar.rtl) {
                    left.style.cssFloat = "right";
                }
                left.style.width = (this.hourWidth) + "px";

                if (this.showHours) {
                    var corner = this._drawCorner();
                    this.nav.corner = corner;
                    left.appendChild(corner);
                    zoom.appendChild(left);

                    this.nav.upperLeft = left;
                }

                var right = createDiv();
                if (this.showHours) {
                    if (calendar.rtl) {
                        right.style.marginRight = (this.hourWidth) + "px";
                    }
                    else {
                        right.style.marginLeft = (this.hourWidth) + "px";
                    }
                }
                right.style.position = "relative";
                right.style.overflow = "hidden";
                right.style.height = this._totalHeaderHeight() + "px";
                right.className = calendar._prefixCssClass("_colheader_back");

                right.onmousemove = function(ev) {
                    var cell = this;
                    if (typeof cres !== "undefined" && cres._active) {
                        cres._updateResShadow(cell, ev);
                    }
                };

                zoom.appendChild(right);
                this.nav.upperRight = right;

                var inner = createDiv();
                inner.className = calendar._prefixCssClass("_colheader_back_inner");
                right.appendChild(inner);

                relative = createDiv();
                relative.style.position = "relative";
                /*
                moved to updateColumnWidthSpec
                if (scrolling) {
                    relative.style.width = (this._columnsBottom.length * this.columnWidth + scrollbarSpace) + "px";
                }
                else {
                    relative.style.width = "100%";
                }
                */

                right.appendChild(relative);


            }
            else {

                var table = document.createElement("table");
                table.cellPadding = "0";
                table.cellSpacing = "0";
                table.border = "0";
                table.style.margin = "0px";
                table.style.width = "100%";
                table.style.borderCollapse = 'separate';
                //table.style.position = "absolute";
                table.style.border = "0px none";

                var r = table.insertRow(-1);
                this.nav.fullHeader = table;


                if (this.showHours) {
                    // corner
                    var c = r.insertCell(-1);
                    c.style.padding = '0px';
                    c.style.border = '0px none';

                    var corner = this._drawCorner();
                    c.appendChild(corner);
                    this.nav.corner = corner;
                }

                // top header
                c = r.insertCell(-1);
                //var mid = c;

                c.style.width = "100%";
                c.valign = "top";
                c.style.position = 'relative';  // ref point
                c.style.padding = '0px';
                c.style.border = '0px none';

                relative = createDiv();
                //relative.setAttribute("data-id", "nav.mid");
                relative.style.position = "relative";
                relative.style.height = this._totalHeaderHeight() + "px";
                relative.style.overflow = "hidden";
                c.appendChild(relative);
                this.nav.mid = relative;

                zoom.appendChild(table);

            }

            this.nav.headerParent = relative;
            this.nav.headerParent.onmousemove = function(ev) { ev.insideMainD = true; };  // FF
            this._createNavHeader();

            var scrollbar = this._scrollbarVisible();

            // above the vertical scrollbar
            //if (this.heightSpec !== "Full" && this.heightSpec !== "BusinessHoursNoScroll") {
            var scrolling = this.columnWidthSpec === 'Fixed';
            if (scrollbar && !scrolling) {
                this._createCornerRightTd();
            }

            header.appendChild(zoom);

            return header;

        };

        this._createNavHeader = function() {
            this.nav.unifiedCornerRight = null;

            if (calendar._divBasedGrid) {
                this.nav.header = createDiv();
                this.nav.header.style.position = "relative";
            }
            else {
                this.nav.header = document.createElement("table");
                this.nav.header.style.margin = "0px";
                this.nav.header.cellPadding = "0";
                this.nav.header.cellSpacing = "0";
                //this.nav.header.border = "0";
                var scrolling = this.columnWidthSpec === 'Fixed';
                if (!scrolling) {
                    this.nav.header.width = "100%";
                }
                this.nav.header.style.tableLayout = "fixed";
                //this.nav.header.style.borderCollapse = 'separate';
                this.nav.header.oncontextmenu = function() { return false; };
            }

            this.nav.header.setAttribute("dp-id", "header");
            this.nav.headerParent.appendChild(this.nav.header);

            this.nav.header.onmousemove = function() {
                calendar._crosshairHide();
            };

            if (this.nav.allday) {
                deleteElement(this.nav.allday);
            }

            var allday = createDiv();
            allday.style.position = 'absolute';
            allday.style.top = "0px";
            allday.style.height = "0px";
            allday.setAttribute("dp-id", "allday");

            var fixed = this.columnWidthSpec === 'Fixed';
            if (!fixed) {
                allday.style.left = "0px";
                allday.style.right = "0px";
                //allday.style.width = "100%";
            }
            else {
                allday.style.width = (this._columnsBottom.length * this.columnWidth) + "px";
            }


            this.nav.allday = allday;
            this.nav.headerParent.appendChild(allday);

        };

        this._createCornerRightTd = function() {
            if (!this.nav.fullHeader) {
                return;
            }

            var r = this.nav.fullHeader.rows[0];
            var c = r.insertCell(-1);

            c.style.padding = '0px';
            c.style.verticalAlign = 'top';
            c.setAttribute("unselectable", "on");
            //c.innerHTML = "&nbsp;";

            var inside = createDiv();
            inside.setAttribute("unselectable", "on");
            inside.className = this._prefixCssClass('_cornerright');
            inside.style.overflow = "hidden";
            inside.style.position = "relative";
            inside.style.width = "16px";
            inside.style.height = this._totalHeaderHeight() + "px";

            var inner = createDiv();
            inner.className = this._prefixCssClass('_cornerright_inner');
            inside.appendChild(inner);

            c.appendChild(inside);

            this.nav.cornerRight = inside;
        };

        this._drawCorner = function() {
            var wrap = createDiv();
            wrap.style.position = 'relative';
            wrap.className = this._prefixCssClass("_corner");
            wrap.style.width = this.hourWidth + "px";
            wrap.style.height = this._totalHeaderHeight() + "px";
            wrap.style.overflow = "hidden";
            wrap.oncontextmenu = function() { return false; };

            var corner = createDiv();
            corner.className = this._prefixCssClass("_corner_inner");
            corner.setAttribute("unselectable", "on");

            // don't draw content here
            // corner.innerHTML = args.html ? args.html : '';

            wrap.appendChild(corner);

            var inner2 = createDiv();
            inner2.style.position = 'absolute';
            inner2.style.padding = '2px';
            inner2.style.top = '0px';
            inner2.style.left = '1px';
            inner2.style.backgroundColor = "#FF6600";
            inner2.style.color = "white";
            inner2.innerHTML = "\u0044\u0045\u004D\u004F";
            inner2.setAttribute("unselectable", "on");

            if (DayPilot.Util.isNullOrUndefined("K5woOes")) wrap.appendChild(inner2);

            return wrap;
        };

        this._disposeCorner = function() {
            if (!calendar.nav.corner) {
                return;
            }
            if (!calendar.nav.corner.firstChild) {
                return;
            }

            var target = calendar.nav.corner.firstChild;

            var domArgs = target.domArgs;
            target.domArgs = null;

            if (!domArgs) {
                return;
            }

            if (typeof calendar.onBeforeCornerDomRemove === "function") {
                calendar.onBeforeCornerDomRemove(domArgs);
            }

            if (typeof calendar.onBeforeCornerDomAdd === "function" && calendar._react.reactDOM) {
                // var target = calendar.divCorner;
                if (target) {
                    var isReact = isReactComp(domArgs.element);
                    if (isReact) {
                        calendar._react._ensureDom();
                        calendar._react._unmount(target);
                    }
                }
            }

        };

        this._disposeMain = function() {
            var table = this.nav.main;
            table.root = null;
            table.onmouseup = null;

            for (var y = 0; y < table.rows.length; y++) {
                var r = table.rows[y];
                for (var x = 0; x < r.cells.length; x++) {
                    var c = r.cells[x];
                    c.root = null;

                    c.onmousedown = null;
                    c.onmousemove = null;
                    c.onmouseout = null;
                    c.onmouseup = null;
                    c.onclick = null;
                    c.ondblclick = null;
                    c.oncontextmenu = null;
                }
            }

            if (!this._fasterDispose) DayPilot.pu(table);
        };

        this._deleteScrollLabels = function() {
            for (var i = 0; this.nav.scrollUp && i < this.nav.scrollUp.length; i++) {
                this.nav.scrollLayer.removeChild(this.nav.scrollUp[i]);
            }

            for (var i = 0; this.nav.scrollDown && i < this.nav.scrollDown.length; i++) {
                this.nav.scrollLayer.removeChild(this.nav.scrollDown[i]);
            }

            this.nav.scrollUp = [];
            this.nav.scrollDown = [];

        };

        this._initializeEventCell = function(c) {

            var div = createDiv();
            div.style.marginRight = calendar.columnMarginRight + "px";
            div.style.position = 'relative';
            div.style.height = '1px';
            div.style.marginTop = '-1px';
            c.events = div;

            var sep = createDiv();
            sep.style.position = "relative";
            sep.style.height = "1px";
            sep.style.marginTop = "-1px";
            c.separators = sep;

            var selection = createDiv();
            selection.style.position = 'relative';
            selection.style.height = '1px';
            selection.style.marginTop = '-1px';
            c.selection = selection;

            c.appendChild(sep);
            c.appendChild(selection);
            c.appendChild(div);
        };

        this._drawMain = function() {
            if (calendar._divBasedGrid) {
                calendar._drawMainDivBased();
            }
            else {
                calendar._drawMainTableBased();
            }
        };

        this._drawScrollLabels = function() {
            if (this.scrollLabelsVisible) {
                var columns = this._columnsBottom;
                var hoursWidth = (this.showHours ? this.hourWidth : 0);
                var colWidth = (this.nav.scroll.clientWidth - hoursWidth) / columns.length;
                for (var i = 0; i < columns.length; i++) {
                    var scrollUp = createDiv();
                    scrollUp.style.position = 'absolute';
                    scrollUp.style.top = '0px';
                    scrollUp.style.left = (hoursWidth + 2 + i * colWidth + colWidth / 2) + "px";
                    scrollUp.style.display = 'none';


                    var img = createDiv();
                    img.style.height = '10px';
                    img.style.width = '10px';
                    img.className = this._prefixCssClass("_scroll_up");
                    scrollUp.appendChild(img);

                    this.nav.scrollLayer.appendChild(scrollUp);
                    this.nav.scrollUp.push(scrollUp);

                    var scrollDown = createDiv();
                    scrollDown.style.position = 'absolute';
                    scrollDown.style.top = '0px';
                    scrollDown.style.left = (hoursWidth + 2 + i * colWidth + colWidth / 2) + "px";
                    scrollDown.style.display = 'none';

                    var img = createDiv();
                    img.style.height = '10px';
                    img.style.width = '10px';
                    img.className = this._prefixCssClass("_scroll_down");
                    scrollDown.appendChild(img);

                    this.nav.scrollLayer.appendChild(scrollDown);
                    this.nav.scrollDown.push(scrollDown);
                }
            }
        };


        this._drawEventParents = function() {
            var events = this.nav.events;

            // clear
            events.innerHTML = "";

            events.rows = [{"cells":[]}];

/*
            var columns = calendar._columnsBottom;
            var fixed = this.columnWidthSpec === 'Fixed';
            var start = 0;
*/

            calendar._getColumnDimensions().forEach(function(coldim, x) {
                var cell = createDiv();
                cell.style.height = "1px";
                cell.style.overflow = "visible";
                cell.style.position = "absolute";
                cell.style.left = coldim.left + coldim.unit;
                cell.style.right = coldim.left + coldim.unit;  // rtl
                cell.style.width = coldim.width + coldim.unit;

                calendar._initializeEventCell(cell);
                events.appendChild(cell);

                events.rows[0].cells.push(cell);
            });

        };

        this._getColumnDimensions = function() {
            var useWidth = calendar._bottomColumnsHaveWidth();
            var columns = calendar._columnsBottom;
            var fixed = this.columnWidthSpec === 'Fixed';
            var start = 0;

            return DayPilot.list.for(columns.length, function(i) {
                var col = {};

                var width = 0;
                var unit = "";
                if (fixed) {
                    unit = "px";
                    width = columns[i].width ? columns[i].width : calendar.columnWidth;
                }
                else {
                    unit = "%";
                    if (useWidth) {
                        width = columns[i].width;
                    }
                    else {
                        width = floor2(100 / columns.length);
                    }

                }

                col.left = start;
                col.width = width;
                col.unit = unit;

                start += width;

                return col;
            });

            function floor2(num) {
                if (DayPilot.browser.ie || DayPilot.browser.edge) {
                    return Math.floor(num * 100) / 100;
                }
                else {
                    return num;
                }

            }
        };

        this._drawMainDivBased = function() {

            var table = this.nav.main;
            var scrollable = this.nav.scrollable;
            // var step = this.cellDuration * 60 * 1000;
            var rowCount = this._rowCount();
            var autoHiddenCells = this._autoHiddenHours() * (60/this.cellDuration);

            var columns = calendar._columnsBottom;

            (function cleanOld() {
                calendar.elements.cells = {};
                table.innerHTML = "";
                table.rows = [];
            })();


            // move away
            scrollable.daypilotMainD = true;
            scrollable.calendar = this;
            calendar._drawScrollLabels();

            calendar._drawEventParents();

            // var colDimensions = calendar._getColumnDimensions();

            for (var y = 0; y < rowCount; y++) {

                // var top = y * calendar.cellHeight;
                table.rows.push({
                    "cells": []
                });


                if (DayPilot.browser.ie) {
                    // prevent missing vertical lines in IE 11 (overlaps)
                    for (var x = columns.length - 1; x >= 0; x--) {
                        calendar._drawCell(x, y);
                    }
                }
                else {
                    for (var x = 0; x < columns.length; x++) {
                        calendar._drawCell(x, y);
                    }

                }
            }

            // require for angular/inital empty resources view (no columns)
            table.style.height = (rowCount * calendar.cellHeight) + "px";

        };


        calendar._cellPosPx = function(x, y) {
            var result = {};

            var coldim = calendar._getColX(x);
            var top = y * calendar.cellHeight;

            result.left = coldim.left;
            result.width = coldim.width;
            result.right = result.left + result.width;
            result.top = top;
            result.height = calendar.cellHeight;
            result.bottom = result.top + result.height;

            return result;
        };

        calendar._drawCell = function(x, y) {

            var dynamic = calendar.columnWidthSpec === "Fixed" && !DayPilot.browser.ie;

            if (calendar.elements.cells[x + "_" + y]) { // already rendered
                return;
            }

            if (dynamic) {
                var pos = calendar._cellPosPx(x, y);
                var area = calendar._getDrawArea();

                var horizontalOut = area.pixels.right <= pos.left || area.pixels.left >= pos.right;
                // turned off because it prevented time range selection (fixed column width, column hierarchy)
                // fixed in _cellsForRange
                var verticalOut = area.pixels.bottom <= pos.top || area.pixels.top >= pos.bottom;
                // var verticalOut = false;

                var isInView = !horizontalOut && !verticalOut;

                if (!isInView) {
                    return;
                }
            }

            var coldim = calendar._getColX(x);
            var step = this.cellDuration * 60 * 1000;
            var top = y * calendar.cellHeight;

            var col = calendar._columnsBottom[x];

            var c = createDiv();
            c.style.position = "absolute";
            c.style.left = coldim.left + coldim.unit;
            c.style.right = coldim.left + coldim.unit;  // rtl
            c.style.width = coldim.width + coldim.unit;
            c.style.top = top + "px";

            // backwards compatibility, remove
            c.start = col.start.addTime(y * step).addHours(calendar._visibleStart());
            c.end = c.start.addTime(step);
            c.resource = col.id;

            // data object
            c.data = {};
            c.data.x = x;
            c.data.y = y;
            c.data.start = c.start;
            c.data.end = c.end;
            c.data.resource = c.resource;
            c.data.calendar = calendar;

            if (!calendar.cellProperties) {
                calendar.cellProperties = {};
            }

            var cell = {};
            cell.resource = c.resource;
            cell.start = c.start;
            cell.end = c.end;

            var index = x + "_" + y;
            var cellProps = ['cssClass', 'html', 'backImage', 'backRepeat', 'backColor', 'business', 'areas', 'disabled'];

            cell.properties = calendar.cellProperties[index];
            if (!calendar.cellProperties[index]) {
                var cp = cell.properties = {};
                cp.cssClass = null;
                cp.html = null;
                cp.backImage = null;
                cp.backRepeat = null;
                cp.backColor = null;
                cp.business = calendar._isBusinessCell(c.start, c.end);

                calendar.cellProperties[index] = cp;
            }

            if (typeof calendar.onBeforeCellRender === 'function') {
                var args = {};
                args.cell = cell;

                calendar.onBeforeCellRender(args);

                copyProps(args.cell, args.cell.properties, cellProps);
            }


            //calendar.cellProperties[index] = cell;

            var props = calendar._getProperties(x, y);

            var content;
            c.root = calendar;
            c.setAttribute("unselectable", "on");

            content = createDiv();
            content.className = calendar._prefixCssClass("_cell");
            content.style.position = "relative";
            content.style.height = (calendar.cellHeight) + "px";
            //content.style.width = '100%';
            content.style.overflow = 'hidden';
            content.setAttribute("unselectable", "on");

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_cell_inner");
            content.appendChild(inner);

            c.appendChild(content);

            c.onmousedown = calendar._onCellMouseDown;
            c.onmousemove = calendar._onCellMouseMove;
            c.onmouseout = calendar._onCellMouseOut;

            registerEvent(c, DayPilot.touch.end, calendar._touch._onCellTouchEnd);

            c.oncontextmenu = function() {
                if (!this.selected) {
                    calendar.clearSelection();
                    DayPilotCalendar._selectedColumn = x;
                    calendar._selectedCells.push(this);
                    DayPilotCalendar._firstSelected = this;
                    DayPilotCalendar._topSelectedCell = this;
                    DayPilotCalendar._bottomSelectedCell = this;

                    calendar._activateSelection();
                }

                if (calendar.timeRangeRightClickHandling === "Disabled") {
                    return false;
                }

                return false;
            };

            var backColor = calendar._getColor(x, y); // = c.style.backgroundColor
            content = c.firstChild;

            var scrolling = calendar.columnWidthSpec === 'Fixed';
            if (scrolling) {
                if (col.width) {
                    content.style.width = col.width + "px";
                }
                else {
                    content.style.width = calendar.columnWidth + "px";
                }
            }

            if (backColor) {
                content.firstChild.style.background = backColor;
            }

            var business = props ? props.business : calendar._isBusinessCell(c.start, c.end);
            if (business) {
                addClass(content, calendar._prefixCssClass("_cell_business"));
            }

            var html = content.firstChild;

            // reset custom properties
            if (html) {
                html.innerHTML = ''; // reset
            }
            content.style.backgroundImage = "";
            content.style.backgroundRepeat = "";

            if (props) {
                if (props.html) {
                    html.innerHTML = props.html;
                }
                if (props.cssClass) {
                    addClass(content, props.cssClass);
                }
                if (props.backImage) {
                    content.style.backgroundImage = "url('" + props.backImage + "')";
                }
                if (props.backRepeat) {
                    content.style.backgroundRepeat = props.backRepeat;
                }
                if (props.areas) {
                    var areaObject = {};
                    areaObject.start = c.start;
                    areaObject.end = c.end;
                    areaObject.resource = c.resource;

                    var areas = createList(props.areas).filter(function(a) {
                        if (a.end && new DayPilot.Date(a.end) <= c.start) {
                            return false;
                        }
                        if (a.start && new DayPilot.Date(a.start) >= c.end) {
                            return false;
                        }
                        return true;
                    });
                    areas.forEach(function(a) {
                        if (!a.start && !a.end) {
                            return;
                        }
                        if (a.start) {
                            var startTicks = new DayPilot.Date(a.start).getTime() - c.start.getTime();
                            a.top = calendar._ticksToPixels(startTicks);
                        }

                        if (a.end) {
                            var endTicks = new DayPilot.Date(a.end).getTime() - c.start.getTime();
                            a.height = calendar._ticksToPixels(endTicks) - a.top;
                        }
                    });

                    DayPilot.Areas.attach(content, areaObject, {"areas": areas});
                }
            }

            calendar.nav.main.appendChild(c);
            calendar.nav.main.rows[y].cells[x] = c;

            calendar.elements.cells[x + "_" + y] = c;

            if (typeof calendar.onAfterCellRender === 'function') {
                var args = {};
                // args.cell = copyProps(cell, {}, ["x", "y", "displayY", "start", "end", "resource", "grid"]);
                args.cell = copyProps(cell, {}, ["start", "end", "resource"]);
                args.div = content;

                calendar.onAfterCellRender(args);
            }

        };



        // draw time cells
        this._drawMainTableBased = function() {

            //this._updateColumnWidthSpec();

            var table = this.nav.main;
            var step = this.cellDuration * 60 * 1000;
            var rowCount = this._rowCount();
            var autoHiddenCells = this._autoHiddenHours() * (60/this.cellDuration);

            var columns = calendar._columnsBottom;
            //var create = !this._tableCreated || table.rows.length === 0 || columns.length !== table.rows[0].cells.length || rowCount !== table.rows.length; // redraw only if number of columns changes
            var create = true; // always redraw

            var scrollY = 0;

            if (table) {

                scrollY = calendar._scrollDiv().scrollTop;

                this._disposeMain();
/*
                if (calendar._browser.ielt9 && create) {
                    deleteElement(this.nav.scrollable.parentNode);
                    var wrap = this._drawScrollable();
                    this._enableScrolling();
                    this.nav.scrollable = wrap.firstChild;
                    this.nav.scroll.appendChild(wrap);
                    //this._drawScrollable();
                    table = this.nav.main;
                }
*/
            }


            this.nav.scrollable.daypilotMainD = true;
            this.nav.scrollable.calendar = this;

            //var i = 0;
            while (table && table.rows && table.rows.length > 0 && create) {
                if (!this._fasterDispose) DayPilot.pu(table.rows[0]);
                /*
                var row = table.rows[0];
                while (calendar._browser.ie && row.cells && row.cells.length > 0) {
                    row.deleteCell(0);
                }*/
                table.deleteRow(0);
            }

            this._tableCreated = true;

            // scroll labels
            if (this.scrollLabelsVisible) {
                var columns = this._columnsBottom;
                var hoursWidth = (this.showHours ? this.hourWidth : 0);
                var colWidth = (this.nav.scroll.clientWidth - hoursWidth) / columns.length;
                for (var i = 0; i < columns.length; i++) {
                    var scrollUp = createDiv();
                    scrollUp.style.position = 'absolute';
                    scrollUp.style.top = '0px';
                    scrollUp.style.left = (hoursWidth + 2 + i * colWidth + colWidth / 2) + "px";
                    scrollUp.style.display = 'none';


                    var img = createDiv();
                    img.style.height = '10px';
                    img.style.width = '10px';
                    img.className = this._prefixCssClass("_scroll_up");
                    scrollUp.appendChild(img);

                    this.nav.scrollLayer.appendChild(scrollUp);
                    this.nav.scrollUp.push(scrollUp);

                    var scrollDown = createDiv();
                    scrollDown.style.position = 'absolute';
                    scrollDown.style.top = '0px';
                    scrollDown.style.left = (hoursWidth + 2 + i * colWidth + colWidth / 2) + "px";
                    scrollDown.style.display = 'none';

                    var img = createDiv();
                    img.style.height = '10px';
                    img.style.width = '10px';
                    img.className = this._prefixCssClass("_scroll_down");
                    scrollDown.appendChild(img);

                    this.nav.scrollLayer.appendChild(scrollDown);
                    this.nav.scrollDown.push(scrollDown);
                }
            }

            var cl = columns.length;

            if (this._separateEventsTable) {
                var events = this.nav.events;

                while (events && events.rows && events.rows.length > 0 && create) {
                    if (!this._fasterDispose) DayPilot.pu(events.rows[0]);
                    events.deleteRow(0);
                }

                // TODO identical code is in createEventsTable, merge
                var r = (create) ? events.insertRow(-1) : events.rows[0];

                for (var j = 0; j < cl; j++) {
                    var c = (create) ? r.insertCell(-1) : r.cells[j];

                    if (create) {

                        c.style.padding = '0px';
                        c.style.border = '0px none';
                        c.style.height = '1px';
                        c.style.overflow = 'visible';
                        var scrolling = this.columnWidthSpec === 'Fixed';
                        if (scrolling) {
                            if (columns[j].width) {
                                c.style.width = columns[j].width + "px";
                            }
                            else {
                               c.style.width = this.columnWidth + "px";
                            }
                        }
                        if (!calendar.rtl) {
                            c.style.textAlign = 'left';
                        }

                        calendar._initializeEventCell(c);
                    }
                }
            }

            for (var i = 0; i < rowCount; i++) {
                var r = (create) ? table.insertRow(-1) : table.rows[i];
                //var y = i + autoHiddenCells;
                var y = i;

                if (create) {
                    r.style.MozUserSelect = 'none';
                    r.style.KhtmlUserSelect = 'none';
                    r.style.WebkitUserSelect = 'none';
                }

                for (var j = 0; j < cl; j++) {
                    var col = this._columnsBottom[j];

                    var c = (create) ? r.insertCell(-1) : r.cells[j];

                    // always update
                    //c.start = col.start.addTime(i * step).addHours(this._visibleStart()).addHours(-this._autoHiddenHours());
                    c.start = col.start.addTime(y * step).addHours(this._visibleStart());
                    c.end = c.start.addTime(step);
                    c.resource = col.id;

                    if (!this.cellProperties) {
                        this.cellProperties = {};
                    }

                    var cell = {};
                    cell.resource = c.resource;
                    cell.start = c.start;
                    cell.end = c.end;

                    var index = j + "_" + y;

                    cell.cssClass = null;
                    cell.html = null;
                    cell.backImage = null;
                    cell.backRepeat = null;
                    cell.backColor = null;
                    cell.business = this._isBusinessCell(c.start, c.end);

                    if (this.cellProperties[index]) {
                        copyProps(this.cellProperties[index], cell, ['cssClass', 'html', 'backImage', 'backRepeat', 'backColor', 'business', 'areas', 'disabled']);
                    }

                    if (typeof this.onBeforeCellRender === 'function') {
                        var args = {};
                        args.cell = cell;

                        this.onBeforeCellRender(args);
                    }

                    this.cellProperties[index] = cell;

                    var props = calendar._getProperties(j, y);

                    var content;
                    if (create) {
                        c.root = this;

                        // c.style.padding = '0px';
                        // c.style.border = '0px none';
                        // c.style.verticalAlign = 'top';

                        // c.style.height = calendar.cellHeight + 'px';

                        // c.style.overflow = 'hidden';
                        c.setAttribute("unselectable", "on");

                        content = createDiv();
                        content.className = calendar._prefixCssClass("_cell");
                        content.style.position = "relative";
                        content.style.height = (calendar.cellHeight) + "px";
                        //content.style.width = '100%';
                        content.style.overflow = 'hidden';
                        content.setAttribute("unselectable", "on");

                        var inner = createDiv();
                        inner.className = calendar._prefixCssClass("_cell_inner");
                        content.appendChild(inner);

                        c.appendChild(content);

                    }
                    else {
                        content = c.firstChild;
                        content.className = calendar._prefixCssClass("_cell"); // must be reset
                    }

                    c.onmousedown = this._onCellMouseDown;
                    c.onmousemove = this._onCellMouseMove;
                    c.onmouseout = this._onCellMouseOut;

                    registerEvent(c, DayPilot.touch.end, this._touch._onCellTouchEnd);

                    c.oncontextmenu = function() {
                        if (!this.selected) {
                            calendar.clearSelection();
                            DayPilotCalendar._selectedColumn = DayPilotCalendar._getColumn(this);
                            calendar._selectedCells.push(this);
                            DayPilotCalendar._firstSelected = this;
                            DayPilotCalendar._topSelectedCell = this;
                            DayPilotCalendar._bottomSelectedCell = this;

                            calendar._activateSelection();
                        }

                        if (calendar.timeRangeRightClickHandling === "Disabled") {
                            return false;
                        }

                        return false;
                    };


                    var backColor = calendar._getColor(j, y); // = c.style.backgroundColor
                    content = c.firstChild;

                    var scrolling = this.columnWidthSpec === 'Fixed';
                    if (scrolling) {
                        if (col.width) {
                            content.style.width = col.width + "px";
                        }
                        else {
                            content.style.width = this.columnWidth + "px";
                        }
                    }

                    if (backColor) {
                        content.firstChild.style.background = backColor;
                    }

                    var business = props ? props.business : this._isBusinessCell(c.start, c.end);
                    if (business) {
                        addClass(content, calendar._prefixCssClass("_cell_business"));
                    }

                    var html = content.firstChild;

                    // reset custom properties
                    if (html) {
                        html.innerHTML = ''; // reset
                    }
                    content.style.backgroundImage = "";
                    content.style.backgroundRepeat = "";

                    if (props) {
                        if (props.html) {
                            html.innerHTML = props.html;
                        }
                        if (props.cssClass) {
                            addClass(content, props.cssClass);
                        }
                        if (props.backImage) {
                            content.style.backgroundImage = "url('" + props.backImage + "')";
                        }
                        if (props.backRepeat) {
                            content.style.backgroundRepeat = props.backRepeat;
                        }
                        if (props.areas) {
                            var areaObject = {};
                            areaObject.start = c.start;
                            areaObject.end = c.end;
                            areaObject.resource = c.resource;

                            var areas = createList(props.areas).filter(function(a) {
                                if (a.end && new DayPilot.Date(a.end) <= c.start) {
                                    return false;
                                }
                                if (a.start && new DayPilot.Date(a.start) >= c.end) {
                                    return false;
                                }
                                return true;
                            });
                            areas.forEach(function(a) {
                                if (!a.start && !a.end) {
                                    return;
                                }
                                if (a.start) {
                                    var startTicks = new DayPilot.Date(a.start).getTime() - c.start.getTime();
                                    a.top = calendar._ticksToPixels(startTicks);
                                }

                                if (a.end) {
                                    var endTicks = new DayPilot.Date(a.end).getTime() - c.start.getTime();
                                    a.height = calendar._ticksToPixels(endTicks) - a.top;
                                }
                            });

                            DayPilot.Areas.attach(content, areaObject, {"areas": areas});
                        }
                    }
                }
            }

            table.onmouseup = this._onMainMouseUp;
            table.root = this;

            table.style.height = (rowCount * calendar.cellHeight) + "px";

            calendar.nav.scrollable.style.display = '';

            calendar._scrollDiv().scrollTop = scrollY;

        };

        this._onMainRightClick = function(ev) {

            if (touch.detected) {
                return;
            }

            var selection = calendar.getSelection();

            if (!selection) {
                return;
            }

            var args = {};
            args.start = selection.start;
            args.end = selection.end;
            args.resource = selection.resource;

            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onTimeRangeRightClick === "function") {
                calendar.onTimeRangeRightClick(args);
                if (args.preventDefault.value) {
                    return false;
                }
            }

            if (calendar.timeRangeRightClickHandling === "ContextMenu" && calendar.contextMenuSelection) {
                calendar.contextMenuSelection.show(calendar.getSelection());
            }

            if (typeof calendar.onTimeRangeRightClicked === "function") {
                calendar.onTimeRangeRightClicked(args);
            }
        };

        this._isBusinessCell = function(start, end) {
            if (this.businessBeginsHour < this.businessEndsHour)
            {
                return !(start.getHours() < this.businessBeginsHour || start.getHours() >= this.businessEndsHour || start.getDayOfWeek() === 6 || start.getDayOfWeek() === 0);
            }

            if (start.getHours() >= this.businessBeginsHour)
            {
                return true;
            }

            if (start.getHours() < this.businessEndsHour)
            {
                return true;
            }

            return false;
        };

        this._onMainMouseMove = function(ev) {

            ev = ev || window.event;
            ev.insideMainD = true;
            if (window.event  && window.event.srcElement) {
                window.event.srcElement.inside = true;
            }

            // clear others
            for (var i = 0; i < DayPilotCalendar._registered.length; i++) {
                var r = DayPilotCalendar._registered[i];
                if (r !== calendar && r._out) {
                    r._out();
                }
            }

            DayPilotCalendar.activeCalendar = this; // required for moving

            var ref = calendar.nav.main; // changed from this.nav.scrollable
            calendar.coords = DayPilot.mo3(ref, ev);

            var mousePos = DayPilot.mc(ev);

            var crosshair = calendar.crosshairType && calendar.crosshairType !== "Disabled";
            // var inTimeHeader = calendar.coords.x < calendar.hourWidth;
            var inTimeHeader = false;
            if (DpGlobal.moving || DpGlobal.resizing || DpGlobal.selecting || inTimeHeader) {
                calendar._crosshairHide();
            }
            else if (crosshair) {
                calendar._crosshair();
            }

            if (DpGlobal.resizing) {
                calendar._updateResizingShadow(mousePos);
            }
            else if (DpGlobal.moving) {

                if (!DpGlobal.moving.helper) {
                    deleteElement(DayPilotCalendar.movingShadow);
                    DayPilotCalendar.movingShadow = null;
                    return;
                }

                if (!DayPilotCalendar.movingShadow) {

                    // don't start dragging unless a minimal move has been performed
                    var distance = 3;
                    if (DayPilot.distance(mousePos, DayPilotCalendar._originalMouse) > distance) {

                        // fixes the ie8 bug (incorrect offsetX and offsetY cause flickering during move if there are inline elements in the event
                        DayPilotCalendar.movingShadow = calendar._createShadow(DpGlobal.moving, !calendar._browser.ie);
                        DayPilotCalendar.movingShadow.style.width = (DayPilotCalendar.movingShadow.parentNode.offsetWidth + 1) + 'px';
                    }
                    else {
                        return;
                    }
                }

                if (!calendar.coords) {
                    return;
                }

                addClass(DpGlobal.moving, calendar._prefixCssClass("_event_moving_source"));

                var _step = calendar.cellHeight;
                var _startOffset = 0;

                var offset = DayPilotCalendar.moveOffsetY;
                if (!offset) {
                    offset = _step / 2; // for external drag
                }
                if (this.moveBy === "Top") {
                    offset = 0;
                }

                var newTop = Math.floor(((calendar.coords.y - offset - _startOffset) + _step / 2) / _step) * _step + _startOffset;

                if (newTop < _startOffset) {
                    newTop = _startOffset;
                }

                var main = calendar.nav.main;
                var max = calendar._divBasedGrid ? calendar._rowCount() * calendar.cellHeight : main.clientHeight;

                var height = parseInt(DayPilotCalendar.movingShadow.style.height);  // DayPilotCalendar.moving.data.height
                if (newTop + height > max) {
                    newTop = max - height;
                }

                // var colWidth = main.clientWidth / main.rows[0].cells.length;
                // var colWidth = main.clientWidth / calendar._columnsBottom.length;
                // var column = Math.floor((calendar.coords.x) / colWidth);

                var column = calendar._getColumnForPixels(calendar.coords.x);

                if (column < 0) {
                    column = 0;
                }

                if (column >= calendar._columnsBottom.length) {
                    column = calendar._columnsBottom.length - 1;
                }

                if (calendar.rtl) {
                    column = calendar._columnsBottom.length - column - 1;
                }

                var shadow = DayPilotCalendar.movingShadow;
                var e = DpGlobal.moving.event;
                var newPosition = calendar._calculatePositionFromShadow(e, column, newTop);
                var format = calendar.eventMovingStartEndFormat;
                if (format === "Auto") {
                    format = resolved._timeFormat() === "Clock24Hours" ? "H:mm" : "h:mm tt";
                }

                var args = {};
                args.e = e;
                args.start = newPosition.start;
                args.end = newPosition.end;
                args.resource = newPosition.resource;
                args.html = null;
                args.cssClass = null;
                args.allowed = true;
                args.areaData = DpGlobal.movingAreaData;

                args.top = {};
                args.top.width = null;
                args.top.space = 5;
                args.top.html = args.start.toString(format, resolved._locale());
                args.top.enabled = calendar.eventMovingStartEndEnabled;

                args.bottom = {};
                args.bottom.width = null;
                args.bottom.space = 5;
                args.bottom.html = args.end.toString(format, resolved._locale());
                args.bottom.enabled = calendar.eventMovingStartEndEnabled;

                args.external = !!DayPilotCalendar.drag;

                (function updateShadow() {

                    var last = calendar._lastEventMoving;
                    var changed = !(last && last.start.getTime() === newPosition.start.getTime() && last.end.getTime() === newPosition.end.getTime() && last.resource === newPosition.resource);

                    if (!changed) {
                        return;
                    }

                    // reset
                    shadow.className = calendar._prefixCssClass("_shadow");
                    shadow.firstChild.innerHTML = "";

                    calendar._lastEventMoving = args;
                    shadow.args = args;

                    if (!calendar.allowEventOverlap) {
                        var data = {
                            "id": e.id(),
                            "start": args.start,
                            "end": args.end,
                            "resource": args.resource
                        };
                        if (calendar.events._overlaps(data)) {
                            // update the shadow
                            addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                            args.allowed = false;
                        }
                    }
                    if (calendar._overDisabledCells(args.start, args.end, args.resource)) {
                        addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                        args.allowed = false;
                    }

                    removeClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));

                    if (typeof calendar.onEventMoving === "function" && args.allowed) {
                        calendar.onEventMoving(args);
                    }

                    if (!DpGlobal.moving) {
                        return;
                    }

                    if (args.html) {
                        shadow.firstChild.innerHTML = args.html;
                    }

                    if (args.cssClass) {
                        addClass(shadow, args.cssClass);
                    }

                    if (!args.allowed) {
                        addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                    }

                    DayPilotCalendar.movingShadow.style.top = newTop + 'px';

                    var events = calendar.nav.events;
                    if (column < events.rows[0].cells.length && column >= 0 && DayPilotCalendar.movingShadow.column !== column) {
                        DayPilotCalendar.movingShadow.column = column;
                        DayPilotCalendar.moveShadow(events.rows[0].cells[column]);
                    }

                    var columnIndex = column;
                    var div = shadow;
                    calendar._drawSelectionIndicators(div, columnIndex, args);

                })();

            }
            else if (DayPilotCalendar._firstMousePos) {

                // var abs = DayPilot.mo3(calendar.nav.events, )
                var x = calendar._getColumnForPixels(calendar.coords.x, true);
                var y = Math.floor(calendar.coords.y / calendar.cellHeight);

                y = DayPilot.Util.atLeast(0, y);

                var thisCell = calendar.nav.main.rows[y].cells[x];

                // activate selecting on first move
                if (!DpGlobal.selecting) {
                    var first = DayPilotCalendar._firstMousePos;
                    // var now = DayPilot.mo3(calendar.nav.events, ev || window.event);
                    var now = calendar.coords;
                    if (first.x !== now.x || first.y !== now.y) {
                        DpGlobal.selecting = {"calendar": calendar};
                    }
                }

                if (!DpGlobal.selecting) {
                    return;
                }

                var mousePos = calendar.coords;

                var thisColumn = x;
                if (thisColumn !== DayPilotCalendar._selectedColumn) {
                    thisCell = calendar.nav.main.rows[y].cells[DayPilotCalendar._selectedColumn];
                }

                var selecting = DpGlobal.selecting;
                selecting.origin = "drag";
                if (selecting.last && selecting.last.x === x && selecting.last.y === y) {
                    return;
                }
                selecting.last = {"x": x, "y": y};

                // clean
                // calendar.clearSelection();

                // new selected cells
                if (mousePos.y < DayPilotCalendar._firstMousePos.y) {
                    calendar._selectedCells = DayPilotCalendar._getCellsBelow(thisCell);
                    DayPilotCalendar._topSelectedCell = calendar._selectedCells[0];
                    DayPilotCalendar._bottomSelectedCell = DayPilotCalendar._firstSelected;
                }
                else {
                    calendar._selectedCells = DayPilotCalendar._getCellsAbove(thisCell);
                    DayPilotCalendar._topSelectedCell = DayPilotCalendar._firstSelected;
                    DayPilotCalendar._bottomSelectedCell = calendar._selectedCells[0];
                }

                calendar._activateSelection();

            }

            if (DayPilotCalendar.drag) {

                // drag detected
                if (DayPilotCalendar.gShadow) {
                    document.body.removeChild(DayPilotCalendar.gShadow);
                }
                DayPilotCalendar.gShadow = null;

                if (!DayPilotCalendar.movingShadow && calendar.coords) {
                    var shadow = calendar._createShadow(DayPilotCalendar.drag, false);

                    if (shadow) {
                        DayPilotCalendar.movingShadow = shadow;

                        var now = DayPilot.Date.today();

                        var evData = {
                            'id': DayPilotCalendar.drag.id,
                            'start': now,
                            'end': now.addSeconds(DayPilotCalendar.drag.duration),
                            'text': DayPilotCalendar.drag.text
                        };

                        var options = DayPilotCalendar.drag._dragOptions;
                        var data = DayPilotCalendar.drag._dragData;
                        var source = data || options;
                        if (source) {
                            var skip = ['duration', 'element', 'remove', 'id', 'text'];
                            if (source === options) {
                                skip.push("data");
                            }
                            for (var name in source) {
                                if (DayPilot.contains(skip, name)) {
                                    continue;
                                }
                                evData[name] = source[name];
                            }
                        }

                        var event = new DayPilot.Event(evData, calendar);
                        event.external = true;

                        DpGlobal.moving = {};
                        DpGlobal.moving.event = event;
                        DpGlobal.moving.helper = {};
                    }
                }

                ev.cancelBubble = true;
            }

            // disabled
            calendar._doAutoScroll(calendar.coords);

        };

        this._checkShadowOverlap = function(shadow) {
            var top = DayPilotCalendar.movingShadow.offsetTop;
            var e = DpGlobal.moving.event;
            var colindex = DayPilotCalendar.movingShadow.column;
        };


        this._overDisabledCells = function(start, end, resource) {
            var over = calendar._cellsForRange(start, end, resource).some(function(cell) { return cell.disabled; });
            return over;
        };


        this._cellsForRange = function(start, end, resource) {

            // var start = new Date().getTime();
            var cells = [];

            var step = calendar.cellDuration * 60 * 1000;
            for (var x = 0; x < calendar._columnsBottom.length; x++) {
                var col = calendar._columnsBottom[x];

                for (var y = 0; y < calendar._rowCount(); y++) {
                    var name = x + "_" + y;
                    var cell = calendar.cellProperties[name];

                    var cellStart = col.start.addTime(y * step).addHours(calendar._visibleStart());
                    var cellEnd = cellStart.addTime(step);
                    var resmatch = !resource || resource === col.id;

                    if (resmatch && overlaps(start, end, cellStart, cellEnd) && cell) {
                        cells.push(cell);
                    }
                }
            }

            return cells;
        };


        // mousePos: x,y with global coordinates (pageX, pageY)
        this._updateResizingShadow = function(mousePos) {
            if (!DpGlobal.resizing.event) {   // UpdatePanel refresh
                DpGlobal.resizing = null;
                deleteElement(DayPilotCalendar.resizingShadow);
                DayPilotCalendar.resizingShadow = null;
                return;
            }
            if (!DayPilotCalendar.resizingShadow) {
                //DayPilotCalendar.deleteShadow(DayPilotCalendar.resizingShadow);
                DayPilotCalendar.resizingShadow = calendar._createShadow(DpGlobal.resizing, false);
            }
            // make sure the cursor is correct
            //DayPilotCalendar.resizingShadow.style.cursor = 'n-resize';

            //DayPilotCalendar.resizing.dirty = true;
            var _step = DpGlobal.resizing.event.calendar.cellHeight;
            var _startOffset = 0;
            var delta = (mousePos.y - DayPilotCalendar._originalMouse.y);

            var e = DpGlobal.resizing.event;
            var start = e.start();
            var end = e.end();

            if (DpGlobal.resizing.dpBorder === 'bottom') {
                var newHeight = Math.floor(((DayPilotCalendar._originalHeight + DayPilotCalendar._originalTop + delta) + _step / 2) / _step) * _step - DayPilotCalendar._originalTop + _startOffset;

                if (newHeight < _step)
                    newHeight = _step;

                var max = calendar._divBasedGrid ? calendar._rowCount() * calendar.cellHeight : calendar.nav.main.clientHeight;
                if (DayPilotCalendar._originalTop + newHeight > max) {
                    newHeight = max - DayPilotCalendar._originalTop;
                }

                DayPilotCalendar.resizingShadow.style.height = (newHeight) + 'px';

                end = calendar._getResizingEndFromBottom(e, DayPilotCalendar._originalTop + newHeight);

            }
            else if (DpGlobal.resizing.dpBorder === 'top') {
                var newTop = Math.floor(((DayPilotCalendar._originalTop + delta - _startOffset) + _step / 2) / _step) * _step + _startOffset;

                if (newTop < _startOffset) {
                    newTop = _startOffset;
                }

                if (newTop > DayPilotCalendar._originalTop + DayPilotCalendar._originalHeight - _step) {
                    newTop = DayPilotCalendar._originalTop + DayPilotCalendar._originalHeight - _step;
                }

                var newHeight = DayPilotCalendar._originalHeight - (newTop - DayPilotCalendar._originalTop);

                if (newHeight < _step) {
                    newHeight = _step;
                }
                else {
                    DayPilotCalendar.resizingShadow.style.top = newTop + 'px';
                }

                DayPilotCalendar.resizingShadow.style.height = (newHeight) + 'px';

                start = calendar._getResizingStartFromTop(e, newTop);

            }

            var shadow = DayPilotCalendar.resizingShadow;
            var format = calendar.eventResizingStartEndFormat;
            if (format === "Auto") {
                format = resolved._timeFormat() === "Clock24Hours" ? "H:mm" : "h:mm tt";
            }

            var args = {};
            args.e = e;
            args.start = start;
            args.end = end;
            args.resource = e.resource();
            args.allowed = true;
            args.html = null;
            args.cssClass = null;

            args.top = {};
            args.top.width = null;
            args.top.space = 5;
            args.top.html = args.start.toString(format, resolved._locale());
            args.top.enabled = calendar.eventResizingStartEndEnabled;

            args.bottom = {};
            args.bottom.width = null;
            args.bottom.space = 5;
            args.bottom.html = args.end.toString(format, resolved._locale());
            args.bottom.enabled = calendar.eventResizingStartEndEnabled;


            shadow.args = args;

            // reset
            shadow.firstChild.innerHTML = "";
            shadow.className = calendar._prefixCssClass("_shadow");

            if (!calendar.allowEventOverlap) {
                var data = {
                    "id": e.id(),
                    "start": args.start,
                    "end": args.end,
                    "resource": args.resource
                };
                if (calendar.events._overlaps(data)) {
                    addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                    args.allowed = false;
                }
            }
            if (calendar._overDisabledCells(args.start, args.end, args.resource)) {
                addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
                args.allowed = false;
            }

            if (typeof calendar.onEventResizing === "function" && args.allowed) {
                calendar.onEventResizing(args);
            }

            if (args.html) {
                shadow.firstChild.innerHTML = args.html;
            }
            if (args.cssClass) {
                addClass(shadow, args.cssClass);
            }
            if (!args.allowed) {
                addClass(shadow, calendar._prefixCssClass("_shadow_forbidden"));
            }

            var columnIndex = e.part.dayIndex;
            var div = shadow;
            calendar._drawSelectionIndicators(div, columnIndex, args);

        };

        this.temp = {};
        this.temp.getPosition = function() {
           var coords = calendar._table._getCellCoords();

           if (!coords) {
               return null;
           }

           //var td = calendar.nav.main.rows[cellCoords.y + extraCells].cells[cellCoords.x];

           var column = calendar._columnsBottom[coords.x];

           var cell = {};
           cell.resource = column.id;
           cell.start = new DayPilot.Date(column.start).addHours(calendar._visibleStart(true)).addMinutes(coords.y*calendar.cellDuration);
           cell.end = cell.start.addMinutes(calendar.cellDuration);

           return cell;
        };

        this._table = {};
        this._table._getCellCoords = function() {
            var result = {};
            result.x = 0;
            result.y = 0;

            if (!calendar.coords) {
                return null;
            }

            result.x = calendar._getColumnForPixels(calendar.coords.x);

            var _startOffset = 0;
            var row = Math.floor((calendar.coords.y - _startOffset) / calendar.cellHeight);
            // result.y = row;
            result.y = DayPilot.Util.atLeast(0, row);

            if (result.x < 0) {
                return null;
            }

            return result;
        };

        this._table.col = function(table, x) {
            var result = {};
            result.left = 0;
            result.width = 0;

            if (!table) {
                return null;
            }

            if (!table.rows) {
                return null;
            }

            if (table.rows.length === 0) {
                return null;
            }

            if (table.rows[0].cells.length == 0) {
                return null;
            }

            var cell = table.rows[0].cells[x];

            if (!cell) {
                return null;
            }
            var t = DayPilot.abs(table);
            var c = DayPilot.abs(cell);

            result.left = c.x - t.x;
            result.width = cell.offsetWidth;

            return result;
        };

        this._crosshair = function() {
            var hourTable = calendar.nav.hourTable;

            this._crosshairHide();

            if (!this.elements.crosshair) {
                this.elements.crosshair = [];
            }


            var cellCoords = this._table._getCellCoords();

            if (!cellCoords) {
                return;
            }

            var column = cellCoords.x;

            if (column === null) {
                return;
            }

            var y = Math.floor(cellCoords.y / (60 / calendar.cellDuration) * (60 / calendar.timeHeaderCellDuration));

            if (y < 0) {
                return;
            }

            if (hourTable) { // not accessible when ShowHours = true
                if (y >= hourTable.rows.length) {
                    return;
                }

                var vertical = createDiv();
                vertical.style.position = "absolute";
                vertical.style.left = "0px";
                vertical.style.right = "0px";
                vertical.style.top = "0px";
                vertical.style.bottom = "0px";
                vertical.className = calendar._prefixCssClass("_crosshair_left");

                hourTable.rows[y].cells[0].firstChild.appendChild(vertical);
                this.elements.crosshair.push(vertical);
            }

            if (this.nav.header) {
                var horizontal = createDiv();
                horizontal.style.position = "absolute";
                horizontal.style.left = "0px";
                horizontal.style.right = "0px";
                horizontal.style.top = "0px";
                horizontal.style.bottom = "0px";
                horizontal.className = calendar._prefixCssClass("_crosshair_top");

                var row = this.nav.header.rows[resolved._headerLevels() - 1];
                if (row.cells[column]) {
                    row.cells[column].firstChild.appendChild(horizontal);
                    this.elements.crosshair.push(horizontal);
                }
            }

            if (this.crosshairType === "Header") {
                return;
            }

            var layer = this.nav.crosshair;

            var _startOffset = 0;
            var top = Math.floor(((calendar.coords.y - _startOffset)) / calendar.cellHeight) * calendar.cellHeight + _startOffset;
            var height = calendar.cellHeight;

            var fullh = createDiv();
            fullh.style.position = "absolute";
            fullh.style.left = "0px";
            fullh.style.right = "0px";
            fullh.style.top = top + "px";
            fullh.style.height = height + "px";
            fullh.className = calendar._prefixCssClass("_crosshair_horizontal");
            fullh.onmousedown = this._onCrosshairMouseDown;

            layer.appendChild(fullh);
            this.elements.crosshair.push(fullh);

            var fixedCol = column;
            if (DayPilot.browser.ie) {
                fixedCol = calendar._columnsBottom.length - 1 - column;
            }
            var col = this._table.col(this.nav.main, fixedCol);
            // height = this.nav.main.clientHeight;
            height = calendar._getInnerHeight();

            if (col) {
                var fullv = createDiv();
                fullv.style.position = "absolute";
                fullv.style.left = col.left + "px";
                fullv.style.width = col.width + "px";
                fullv.style.top = "0px";
                fullv.style.height = height + "px";
                /*fullv.style.backgroundColor = this.crosshairColor;
                fullv.style.opacity = this.crosshairOpacity / 100;
                fullv.style.filter = "alpha(opacity=" + this.crosshairOpacity + ")";*/
                fullv.className = calendar._prefixCssClass("_crosshair_vertical");
                fullv.onmousedown = this._onCrosshairMouseDown;

                layer.appendChild(fullv);
                this.elements.crosshair.push(fullv);
            }

        };

        this._onCrosshairMouseDown = function(ev) {
            var main = calendar.nav.main;
            calendar._crosshairHide();

            calendar.coords = DayPilot.mo3(main, ev);
            var cellCoords = calendar._table._getCellCoords();
            var extraCells = 0; // events

            var x = cellCoords.x;
            if (DayPilot.browser.ie) {
                x = calendar._columnsBottom.length - 1 - cellCoords.x;
            }

            var cell = main.rows[cellCoords.y + extraCells].cells[x];

            calendar._onCellMouseDown.apply(cell, [ev]);
        };

        this._crosshairHide = function() {
            if (!this.elements.crosshair || this.elements.crosshair.length === 0) {
                return;
            }

            for (var i = 0; i < this.elements.crosshair.length; i++) {
                var e = this.elements.crosshair[i];
                if (e && e.parentNode) {
                    e.parentNode.removeChild(e);
                }
            }
            this.elements.crosshair = [];
        };

        this._expandCellProperties = function() {
            if (!this.cellConfig) {
                return;
            }

            var config = this.cellConfig;

            if (config.vertical) {
                for (var x = 0; x < config.x; x++) {
                    var def = this.cellProperties[x + "_0"];
                    for (var y = 1; y < config.y; y++) {
                        this.cellProperties[x + "_" + y] = def;
                    }
                }
            }

            if (config.horizontal) {
                for (var y = 0; y < config.y; y++) {
                    var def = this.cellProperties["0_" + y];
                    for (var x = 1; x < config.x; x++) {
                        this.cellProperties[x + "_" + y] = def;
                    }
                }
            }

            if (config["default"]) {
                var def = config["default"];
                for (var y = 0; y < config.y; y++) {
                    for (var x = 0; x < config.x; x++) {
                        if (!this.cellProperties[x + "_" + y]) {
                            this.cellProperties[x + "_" + y] = def;
                        }
                    }
                }
            }
        };

        this._getProperties = function(x, y) {
            if (!this.cellProperties) {
                return null;
            }
            return this.cellProperties[x + "_" + y];

        };

        this._isBusiness = function(x, y) {
            var index = x + '_' + y;
            if (this.cellProperties && this.cellProperties[index]) {
                return this.cellProperties[index].business;
            }
            return false;
        };

        this._getColor = function(x, y) {
            var index = x + '_' + y;
            if (this.cellProperties && this.cellProperties[index]) {
                return this.cellProperties[index].backColor;
            }
            return null;

        };

        this._disposeHeader = function() {
            var table = this.nav.header;
            if (table && table.rows) {
                for (var y = 0; y < table.rows.length; y++) {
                    var r = table.rows[y];
                    for (var x = 0; x < r.cells.length; x++) {

                        var c = r.cells[x];
                        c.onclick = null;
                        c.onmousemove = null;
                        c.onmouseout = null;

                        var div = c;
                        var domArgs = div.domArgs;
                        div.domArgs = null;

                        if (typeof calendar.onBeforeHeaderDomRemove === "function") {
                            calendar.onBeforeHeaderDomRemove(domArgs);
                        }

                        if (typeof calendar.onBeforeHeaderDomAdd === "function" && calendar._react.reactDOM) {
                            var target = domArgs && domArgs._targetElement;
                            if (target) {
                                var isReact = isReactComp(domArgs.element);
                                if (isReact) {
                                    calendar._react._ensureDom();
                                    calendar._react._unmount(target);
                                }
                            }
                        }

                    }
                }
            }
            if (table) {
                if (!this._fasterDispose) DayPilot.pu(table);
                table.innerHTML = "";
                table.rows = [];
            }
        };


        this._getColSpans = function(y) {
            var level = y + 1;
            var lastRow = (level === resolved._headerLevels());
            var columns = this._getColumns(level);
            var x = 0;
            var left = 0;
            var coldims = calendar._getColumnDimensions();
            var parentcoldims = [];
            var fixed = this.columnWidthSpec === 'Fixed';
            var unit = fixed ? "px" : "%";

            if (!lastRow) {
                for (var i = 0; i < columns.length; i++) {
                    var data = columns[i];
                    var coldim = coldims[i];
                    var nonEmpty = data._getChildren ? true : false;
                    var colspan = nonEmpty ? data._getChildrenCount(resolved._headerLevels() - level + 1) : 1;
                    var width = 0;
                    DayPilot.list.for(colspan, function() {
                        var childCol = coldims[x];
                        width += childCol.width;
                        x += 1;
                    });
                    parentcoldims.push({
                        "left": left,
                        "width": width,
                        "unit": unit
                    });
                    left += width;
                }

            }
            // except the last row
            /*else {
                parentcoldims.push({
                    "left": left,
                    "width": width
                });
            }*/
            return parentcoldims;
        };

        this._drawHeaderRowDivBased = function(y) {

            var level = y + 1;

            var columns = this._getColumns(level);
            var columnsInherited = this._getColumns(level, true);
            var len = columns.length;
            var lastRow = (level === resolved._headerLevels());


            var coldims = calendar._getColumnDimensions();
            // var top = y * calendar.headerHeight;
            var top = y * resolved._headerHeight();

            var cells = [];
            calendar.nav.header.rows.push({
                "cells": cells
            });

            var parentcoldims = calendar._getColSpans(y);

            function drawHeaderCell(i) {
                var data = columns[i];
                var coldim = coldims[i];

                if (!coldim) {
                    return;
                }

                var args = {};
                args.header = {};
                args.header.cssClass = null;
                args.column = calendar._createColumn(data, calendar);
                var argsElement = null;

                if (calendar._api2()) {
                    if (typeof calendar.onBeforeHeaderRender === 'function') {
                        // TODO deep copy of children, areas?
                        copyProps(data, args.header, ['id', 'start', 'name', 'html', 'backColor', 'toolTip', 'areas', 'children']);
                        calendar.onBeforeHeaderRender(args);
                        copyProps(args.header, data, ['html', 'backColor', 'toolTip', 'areas', 'cssClass']);
                    }
                }

                var nonEmpty = data._getChildren ? true : false;

                var width = coldim.width;
                var left = coldim.left;
                if (!lastRow) {
                    left = parentcoldims[i].left;
                    width = parentcoldims[i].width;
                }

                var cell = createDiv();
                cell.style.position = "absolute";
                cell.style.top = top + "px";
                cell.style.left = left + coldim.unit;
                cell.style.right = left + coldim.unit;  // priority for rtl
                cell.style.width = width + coldim.unit;
                cell.data = data;

                cells.push(cell);

                if (nonEmpty) {
                    cell.onclick = calendar._headerClickDispatch;
                    cell.onmousemove = calendar._headerMouseMove;
                    cell.onmouseout = calendar._headerMouseOut;
                    if (data.toolTip) {
                        cell.title = data.toolTip;
                    }
                }
                cell.style.overflow = "hidden";
                cell.style.height = (resolved._headerHeight()) + "px";

                var div = createDiv();

                div.setAttribute("unselectable", "on");
                div.style.userSelect = "none";
                div.style.position = "relative";
                div.style.height = resolved._headerHeight() + "px";

                div.className = calendar._prefixCssClass('_colheader');
                if (data.cssClass) {
                    DayPilot.Util.addClass(div, data.cssClass);
                }

                if (!calendar.headerTextWrappingEnabled) {
                    div.style.whiteSpace = 'nowrap';
                }

                var inner = createDiv();
                inner.className = calendar._prefixCssClass('_colheader_inner');
                if (data.backColor) {
                    inner.style.background = data.backColor;
                }
                div.appendChild(inner);
                cell.appendChild(div);

                if (resolved._columnResizing() && typeof cres !== "undefined" && cres._drawResizeHandle) {
                    (function() {
                        var resizeCell = {};
                        resizeCell.column = columnsInherited[i];
                        resizeCell.x = i;
                        resizeCell.y = y;
                        resizeCell.div = cell;
                        cres._drawResizeHandle(resizeCell);
                    })();
                }

                if (resolved._columnMoving() && nonEmpty && typeof cmov !== "undefined" && cmov._drawMoveHandle) {
                    (function() {
                        var resizeCell = {};
                        resizeCell.column = columnsInherited[i];
                        resizeCell.x = i;
                        resizeCell.y = y;
                        resizeCell.div = cell;
                        cmov._drawMoveHandle(resizeCell);
                    })();
                }

                calendar._updateHeaderActiveAreas(div, data);

                if (typeof calendar.onBeforeHeaderDomAdd === "function") {
                    args.element = null;

                    calendar.onBeforeHeaderDomAdd(args);

                    argsElement = args.element;
                }

                cell.domArgs = args;
                if (argsElement) {
                    var target = inner;
                    // target.domArgs = args;
                    args._targetElement = target;
                    var isReactComponent = isReactComp(argsElement);
                    if (isReactComponent) {
                        calendar._react._ensureDom();
                        calendar._react._render(argsElement, target);
                    }
                    else {
                        target.appendChild(argsElement);
                    }
                }
                else {
                    if (nonEmpty) {
                        div.firstChild.innerHTML = data.html || "";
                    }
                }

                calendar.nav.header.appendChild(cell);

            }

            if (DayPilot.browser.ie) {
                for (var i = len -1; i >= 0; i--) {
                    drawHeaderCell(i);
                }
            }
            else {
                for (var i = 0; i < len; i++) {
                    drawHeaderCell(i);
                }
            }

        };

        this._drawHeaderRowTableBased = function(level, create) {

            // column headers
            var r = (create) ? this.nav.header.insertRow(-1) : this.nav.header.rows[level - 1];

            var columns = this._getColumns(level);
            var len = columns.length;
            var lastRow = (level === resolved._headerLevels());

            for (var i = 0; i < len; i++) {
                var data = columns[i];

                if (calendar._api2()) {
                    if (typeof calendar.onBeforeHeaderRender === 'function') {
                        var args = {};
                        args.header = {};
                        // TODO deep copy of children, areas?
                        copyProps(data, args.header, ['id', 'start', 'name', 'html', 'backColor', 'toolTip', 'areas', 'children']);
                        this.onBeforeHeaderRender(args);
                        copyProps(args.header, data, ['html', 'backColor', 'toolTip', 'areas']);
                    }
                }

                var nonEmpty = data._getChildren ? true : false;

                var cell = (create) ? r.insertCell(-1) : r.cells[i];
                cell.data = data;

                if (lastRow) { // use the width spec only for the last row, otherwise use colspan
                }
                else {
                    var colspan = 1;
                    if (nonEmpty) {
                        colspan = data._getChildrenCount(resolved._headerLevels() - level + 1);
                    }
                    cell.colSpan = colspan;
                }

                if (nonEmpty) {
                    cell.onclick = this._headerClickDispatch;
                    cell.onmousemove = this._headerMouseMove;
                    cell.onmouseout = this._headerMouseOut;
                    if (data.toolTip) {
                        cell.title = data.toolTip;
                    }
                }
                cell.style.overflow = 'hidden';
                cell.style.padding = '0px';
                cell.style.border = '0px none';
                cell.style.height = (resolved._headerHeight()) + "px";

                var div = (create) ? createDiv() : cell.firstChild;

                if (create) {
                    div.setAttribute("unselectable", "on");
                    div.style.MozUserSelect = 'none';
                    div.style.KhtmlUserSelect = 'none';
                    div.style.WebkitUserSelect = 'none';
                    div.style.position = 'relative';
                    div.style.height = resolved._headerHeight() + "px";

                    div.className = calendar._prefixCssClass('_colheader');

                    var inner = createDiv();
                    inner.className = calendar._prefixCssClass('_colheader_inner');
                    if (data.backColor) {
                        inner.style.background = data.backColor;
                    }
                    div.appendChild(inner);

                    cell.appendChild(div);
                }
                else {
                    div.style.height = resolved._headerHeight() + "px";
                }

                this._updateHeaderActiveAreas(div, data);


                if (nonEmpty) {
                    div.firstChild.innerHTML = data.html;
                }
            }

        };


        this._updateHeaderActiveAreas = function(div, data) {

            // delete active areas
            var tobedeleted = [];
            for (var j = 0; j < div.childNodes.length; j++) {
                var node = div.childNodes[j];
                if (node.isActiveArea) {
                    tobedeleted.push(node);
                }
            }

            for (var j = 0; j < tobedeleted.length; j++) {
                var node = tobedeleted[j];
                deleteElement(node);
            }

            // areas (permanently visible)
            if (data.areas) {
                var areas = data.areas;
                for (var j = 0; j < areas.length; j++) {
                    var area = areas[j];
                    if (!DayPilot.Areas.isVisible(area)) {
                        continue;
                    }
                    // var o = new DayPilot.Column(data.id, data.name, data.start);
                    var o = calendar._createColumn(data);
                    var a = DayPilot.Areas.createArea(div, o, area);
                    div.appendChild(a);
                }
            }

        };

        this._drawHeader = function() {
            if (calendar._divBasedGrid) {
                calendar._drawHeaderDivBased();
            }
            else {
                calendar._drawHeaderTableBased();
            }
        };

        this._drawHeaderDivBased = function() {
            var header = calendar.nav.header;

            // cleanup
/*
            header.innerHTML = "";
            header.rows = [];
*/
            calendar._disposeHeader();

            if (!this.showHeader) {
                return;
            }

            var columns = this._getColumns(resolved._headerLevels(), true);
            var len = columns.length;

            this._headerCreated = true;

            // corner
            var corner = calendar.nav.corner;
            if (corner) {
                if (!this._fasterDispose) DayPilot.pu(corner.firstChild);

                var args = {};
                // args.html = calendar.cornerHTML || calendar.cornerHtml;
                args.html = calendar._xssTextHtml(calendar.cornerText, calendar.cornerHtml);
                var argsElement = null;

                calendar._disposeCorner();

                if (typeof calendar.onBeforeCornerRender === "function") {
                    calendar.onBeforeCornerRender(args);
                }

                if (typeof calendar.onBeforeCornerDomAdd === "function") {
                    args.element = null;

                    calendar.onBeforeCornerDomAdd(args);

                    argsElement = args.element;
                }

                if (argsElement) {
                    var target = corner.firstChild;
                    target.domArgs = args;
                    var isReactComponent = isReactComp(argsElement);
                    if (isReactComponent) {
                        calendar._react._ensureDom();
                        calendar._react._render(argsElement, target);
                    }
                    else {
                        target.appendChild(argsElement);
                    }
                }
                else {
                    corner.firstChild.innerHTML = args.html || "";
                }

            }

            for (var y = 0; y < resolved._headerLevels(); y++) {
                this._drawHeaderRowDivBased(y);
            }

            if (this.showAllDayEvents) {
                var cells = [];
                calendar.nav.header.rows.push({
                    "cells": cells
                });

                var coldims = calendar._getColumnDimensions();
                var top = resolved._headerLevels() * resolved._headerHeight();

                for (var i = 0; i < len; i++) {
                    var data = columns[i];
                    var coldim = coldims[i];

                    var cell = createDiv();
                    cell.data = data;
                    cell.style.overflow = 'hidden';
                    cell.style.position = "absolute";
                    cell.style.left = coldim.left + coldim.unit;
                    cell.style.right = coldim.left + coldim.unit;  // rtl
                    cell.style.width = coldim.width + coldim.unit;
                    cell.style.top = top + "px";

                    var div = createDiv();
                    div.setAttribute("unselectable", "on");
                    div.style.userSelect = "none";
                    div.style.overflow = "hidden";
                    div.style.position = "relative";
                    div.style.height = resolved._allDayHeaderHeight() + "px";
                    div.className = this._prefixCssClass("_alldayheader");

                    var inner = createDiv();
                    inner.className = this._prefixCssClass("_alldayheader_inner");
                    div.appendChild(inner);

                    cell.appendChild(div);
                    div.style.height = resolved._allDayHeaderHeight() + "px";

                    cells.push(cell);
                    header.appendChild(cell);
                }
            }

            // calendar.nav.headerParent.appendChild(header);
        };

        this._drawHeaderTableBased = function() {
            if (!this.showHeader) {
                return;
            }

            var header = this.nav.header;
            var create = true;

            var columns = this._getColumns(resolved._headerLevels(), true);
            var len = columns.length;

            // 2018-01-23 always re-creating the header (to fix angular 2+ all-day change)
            deleteElement(this.nav.header);
            this._createNavHeader();

            while (this._headerCreated && header && header.rows && header.rows.length > 0 && create) {
                if (!this._fasterDispose) DayPilot.pu(header.rows[0]);
                header.deleteRow(0);
            }

            this._headerCreated = true;

            // var html = calendar.cornerHTML || calendar.cornerHtml;

            // corner
            var corner = calendar.nav.corner;
            if (corner) {
                if (!this._fasterDispose) DayPilot.pu(corner.firstChild);

                var args = {};
                args.html = calendar._xssTextHtml(calendar.cornerText, calendar.cornerHtml);
                if (typeof calendar.onBeforeCornerRender === "function") {
                    calendar.onBeforeCornerRender(args);
                }

                corner.firstChild.innerHTML = args.html ? args.html : '';
            }

            for (var i = 0; i < resolved._headerLevels(); i++) {
                this._drawHeaderRowTableBased(i + 1, create);
            }

            if (!this.showAllDayEvents) {
                return;
            }

            // all day events
            var r = (create) ? this.nav.header.insertRow(-1) : this.nav.header.rows[resolved._headerLevels()];

            for (var i = 0; i < len; i++) {
                var data = columns[i];

                var cell = (create) ? r.insertCell(-1) : r.cells[i];
                cell.data = data;
                cell.style.padding = '0px';
                cell.style.border = '0px none';
                cell.style.overflow = 'hidden';

                var div = (create) ? createDiv() : cell.firstChild;

                if (create) {
                    div.setAttribute("unselectable", "on");
                    div.style.MozUserSelect = 'none';
                    div.style.KhtmlUserSelect = 'none';
                    div.style.WebkitUserSelect = 'none';
                    div.style.overflow = 'hidden';
                    div.style.position = "relative";
                    div.style.height = resolved._allDayHeaderHeight() + "px";
                    div.className = this._prefixCssClass("_alldayheader");

                    var inner = createDiv();
                    inner.className = this._prefixCssClass("_alldayheader_inner");
                    div.appendChild(inner);

                    cell.appendChild(div);
                }
                div.style.height = resolved._allDayHeaderHeight() + "px";

            }
        };

        this._loadingStart = function(immediately) {

            var delay = immediately ? 0 : 100;

            if (this.callbackTimeout) {
                window.clearTimeout(this.callbackTimeout);
            }

            this.callbackTimeout = window.setTimeout(function() {
                if (calendar.loadingLabelVisible && calendar.nav.loading) {
                    calendar.nav.loading.innerHTML = calendar._xssTextHtml(this.loadingLabelText, this.loadingLabelHtml);
                    calendar.nav.loading.style.top = (calendar._totalHeaderHeight() + 5) + "px";
                    calendar.nav.loading.style.display = '';
                }
            }, delay);

        };

        this._loadingStop = function() {
            if (this.callbackTimeout) {
                window.clearTimeout(this.callbackTimeout);
            }

            if (this.nav.loading) {
                this.nav.loading.style.display = 'none';
            }
        };

        this._hourOffsetInPixels = function(hour) {
            var hoursPlus = calendar._visibleStart(true);
            if (hour < hoursPlus) {
                hour += 24;
            }
            var pixels = (hour - hoursPlus) * (60/calendar.cellDuration) * calendar.cellHeight;
            return pixels;
        };

        this._pixelsToHours = function(pixels) {
            var hoursPlus = calendar._visibleStart(true);
            return pixels/(60/calendar.cellDuration)/calendar.cellHeight + hoursPlus;
        };

        this._enableScrolling = function() {

            var scrollDiv = this._scrollDiv();
            var scrollPos = this.initScrollPos;
            if (!scrollPos) {
                var hour = this.businessBeginsHour;
                scrollPos = calendar._hourOffsetInPixels(hour);
            }

            scrollDiv.root = this;
            scrollDiv.onscroll = this._scroll;

            calendar._clearCachedValues();

            // initial position
            if (scrollDiv.scrollTop === 0) {
                scrollDiv.scrollTop = scrollPos - this._autoHiddenPixels();
            }
            else {
                this._scroll();
            }

        };

        this._visible = function() {
            var el = calendar.nav.top;
            if (!el) {
                return false;
            }
            return el.offsetWidth > 0 && el.offsetHeight > 0;
        };

        this._waitForVisibility = function() {
            var visible = calendar._visible;

            if (visible()) {
                calendar._watchWidthChanges();
                return;
            }

            if (!calendar._visibilityInterval) {
                calendar._visibilityInterval = setInterval(function() {
                    if (visible()) {
                        clearInterval(calendar._visibilityInterval);
                        calendar._enableScrolling();
                        calendar._fixScrollHeader();

                        calendar._watchWidthChanges();
                    }
                }, 100);
            }
        };

        this.scrollToY = function(pixels) {
            var scrollDiv = this._scrollDiv();
            scrollDiv.scrollTop = pixels;
        };

        this.scrollToHour = function(hour) {
            var pixels = calendar._hourOffsetInPixels(hour);
            var scrollDiv = this._scrollDiv();
            scrollDiv.scrollTop = pixels - this._autoHiddenPixels();
        };

        this._scrollDiv = function() {
            var scrolling = this.columnWidthSpec === 'Fixed';
            return scrolling || this._unifiedScrollable ? this.nav.bottomRight : this.nav.scroll;
        };

        this.onCallbackError = function(result, context) {
            alert("Error!\r\nResult: " + result + "\r\nContext:" + context);
        };

        // disabled, don't show in the API
        //this.scrollbarVisible = this._scrollbarVisible;

        this._fixScrollHeader = function() {

            if (!calendar.showHeader) {
                return;
            }

            var show = this._scrollbarVisible();
            var visible = !!this.nav.cornerRight;

            if (this._unifiedScrollable) {
                if (this.nav.unifiedCornerRight) {
                    deleteElement(this.nav.unifiedCornerRight);
                }

                var scrollDiv = calendar._scrollDiv();
                // var fraction = scrollDiv.getBoundingClientRect().width - scrollDiv.offsetWidth;
                var clientWidth = calendar.nav.main.getBoundingClientRect().width;

                var fullw = calendar._getTotalScrollableWidth();
                if (fullw !== "100%" && parseInt(fullw) < clientWidth) {
                    return;
                }

                var w = DayPilot.sw(this.nav.bottomRight);

                // corner right
                // var lastcoldim = calendar._getColumnDimensions().last();
                // var totalcolw = lastcoldim.left + lastcoldim.width;

                var c;
                if (calendar._divBasedGrid) {
                    c = createDiv();
                    c.style.position = "absolute";
                    c.style.left = clientWidth + "px";
                    c.style.right = clientWidth + "px"; // rtl
                    c.style.height = calendar._totalHeaderHeight() + "px";

                    calendar.nav.headerParent.appendChild(c);
                    calendar.nav.unifiedCornerRight = c;

                    calendar.nav.header.style.width = clientWidth + "px";
                    if (calendar.nav.allday) {
                        calendar.nav.allday.style.width = clientWidth + "px";
                    }
                }
                else {
                    this.nav.unifiedCornerRight = this.nav.header.rows[0].insertCell(-1);
                    c = this.nav.unifiedCornerRight;
                    c.rowSpan = this.nav.header.rows.length;
                }


                c.style.width = w + "px";

                var corner = createDiv();
                corner.className = calendar._prefixCssClass("_cornerright");
                corner.setAttribute("unselectable", "on");
                corner.style.overflow = "hidden";
                corner.style.height = this._totalHeaderHeight() + "px";
                corner.style.position = "relative";

                var inner = createDiv();
                inner.className = calendar._prefixCssClass("_cornerright_inner");
                corner.appendChild(inner);

                c.appendChild(corner);

                var scrollable = this.columnWidthSpec === "Fixed";
                // all-day wrapper
                if (!scrollable && this.nav.allday) {
                    if (calendar.rtl) {
                        this.nav.allday.style.left = w + "px";
                    }
                    else {
                        this.nav.allday.style.right = w + "px";
                    }

                }

                return;
            }


            if (show !== visible) {  // change required
                if (show) {  // show it
                    this._createCornerRightTd();
                }
                else {  // hide it
                    if (this.nav.fullHeader && this.nav.fullHeader.rows[0].cells.length === 3) {
                        var c = this.nav.fullHeader.rows[0].cells[2];
                        if (c.parentNode) {
                            c.parentNode.removeChild(c);
                        }
                    }
                    this.nav.cornerRight = null;
                }
            }

            // now fix the width
            var d = this.nav.cornerRight;

            if (!d) {
                return;
            }
            var w = DayPilot.sw(calendar._scrollElement());

            if (d) {
                d.style.width = (w) + 'px';
            }
            return w;
        };

        // interval defined in seconds, minimum 30 seconds
        this._startAutoRefresh = function(forceEnabled) {
            if (forceEnabled) {
                this.autoRefreshEnabled = true;
            }

            if (!this.autoRefreshEnabled) {
                return;
            }

            if (this._autoRefreshCount >= this.autoRefreshMaxCount) {
                return;
            }

            //this.autoRefreshCount = 0; // reset
            this._pauseAutoRefresh();

            var interval = this.autoRefreshInterval;
            if (!interval || interval < 10) {
                throw new DayPilot.Exception("The minimum autoRefreshInterval is 10 seconds");
            }
            //this.autoRefresh = interval * 1000;
            this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
        };

        this._pauseAutoRefresh = function() {
            if (this.autoRefreshTimeout) {
                window.clearTimeout(this.autoRefreshTimeout);
            }
        };

        this._doRefresh = function() {
            if (!DpGlobal.resizing && !DpGlobal.moving && !DayPilotCalendar.drag && !DpGlobal.selecting) {
                var skip = false;
                if (typeof this.onAutoRefresh === 'function') {
                    var args = {};
                    args.i = this._autoRefreshCount;
                    args.preventDefault = function() {
                        this.preventDefault.value = true;
                    };

                    calendar.onAutoRefresh(args);
                    if (args.preventDefault.value) {
                        skip = true;
                    }
                }
                if (!skip && this._serverBased()) {
                    this.commandCallBack(this.autoRefreshCommand);
                }
                this._autoRefreshCount++;

            }
            if (this._autoRefreshCount < this.autoRefreshMaxCount) {
                this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
            }
        };

        this._onResize = function() {
            calendar._resize();
        };

        this._resize = function() {
            calendar._updateHeight();
            if (calendar.heightSpec === "Parent100Pct") {
                calendar.setHeight(parseInt(calendar.nav.top.clientHeight, 10));
            }

            calendar._fixScrollHeader();
            calendar._updateScrollLabels();
            calendar._clearCachedValues();
        };

        this._wd = null;
        this._widthChangeDetectionInterval = null;
        calendar._watchObserver = null;
        this._watchWidthChanges = function() {

            var fix = function() {
                calendar._resize();
                calendar._scroll();
            };

            if (!calendar.watchWidthChanges) {
                return;
            }

            // not supported in IE
            if (typeof ResizeObserver === "function") {

                if (calendar._watchObserver) {
                    return;
                }

                var observer = new ResizeObserver(fix);
                observer.observe(calendar.nav.top);
                calendar._watchObserver = observer;

                return;
            }

            // legacy, used in IE
            if (calendar._widthChangeDetectionInterval) {
                return;
            }

            var check = function() {
                if (!calendar.nav || !calendar.nav.top) {  // disposed object
                    clearInterval(calendar._widthChangeDetectionInterval);
                    return;
                }
                if (!calendar._wd) {
                    calendar._wd = {};
                    calendar._wd.counter = 0;
                    calendar._wd.changed = false;
                    calendar._wd.width = calendar.nav.top.offsetWidth;
                    return;
                }
                if (calendar._wd.width !== calendar.nav.top.offsetWidth) {
                    calendar._wd.changed = true;
                    calendar._wd.counter = 0;
                    calendar._wd.width = calendar.nav.top.offsetWidth;
                }
                if (calendar._wd.changed) {
                    calendar._wd.counter += 1;
                }
                if (calendar._wd.changed && calendar._wd.counter > 0) {
                    calendar._wd.changed = false;
                    fix();
                }
            };

            this._widthChangeDetectionInterval = setInterval(check, 200);

            // record the current width immediately
            check();
        };


        this._registerGlobalHandlers = function() {
            if (!DayPilotCalendar._globalHandlers) {
                DayPilotCalendar._globalHandlers = true;
                registerEvent(document, 'mousemove', DayPilotCalendar._gMouseMove);
                registerEvent(document, 'mouseup', DayPilotCalendar._gMouseUp);
                reNonPassive(document, DayPilot.touch.move, DayPilotCalendar._gTouchMove);
                registerEvent(document, DayPilot.touch.end, DayPilotCalendar._gTouchEnd);
                //registerEvent(window, 'unload', DayPilotCalendar._gUnload);
            }
            registerEvent(window, 'resize', this._onResize);
        };

        this._onEventMouseDown = function(ev) {

            if (touch.active || touch.using) {  // ie
                return;
            }

            ev = ev || window.event;
            var button = DayPilot.Util.mouseButton(ev);

            if (DayPilotCalendar.editing) {
                DayPilotCalendar.editing.blur();
                return;
            }

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
                DayPilot.Bubble.cancelShowing();
            }

            if ((this.style.cursor === 'n-resize' || this.style.cursor === 's-resize') && button.left) {
                // set
                DpGlobal.resizing = this;
                DayPilotCalendar._originalMouse = DayPilot.mc(ev);
                DayPilotCalendar._originalHeight = this.offsetHeight;
                DayPilotCalendar._originalTop = this.offsetTop;

                // shadow
                // 1 line, moved to scroll.mousemove
                //DayPilotCalendar.resizingShadow = DayPilotCalendar.createShadow(this, false, calendar.shadow);

                // cursor
                //document.body.style.cursor = this.style.cursor;
                calendar.nav.top.style.cursor = this.style.cursor;

                // disabled, causes problems, maybe even leaks
                //this.onclickSave = this.onclick;
                //this.onclick = null;
            }
            else if ((this.style.cursor === 'move' || (calendar.moveBy === 'Full' && this.event.client.moveEnabled())) && button.left) {
                DpGlobal.moving = this;
                var helper = DpGlobal.moving.helper = {};
                helper.oldColumn = calendar._columnsBottom[this.event.part.dayIndex].id;
                DayPilotCalendar._originalMouse = DayPilot.mc(ev);
                DayPilotCalendar._originalTop = this.offsetTop;

                var offset = DayPilot.mo3(this, ev);
                if (offset) {
                    DayPilotCalendar.moveOffsetY = offset.y;
                }
                else {
                    DayPilotCalendar.moveOffsetY = 0;
                }

                calendar.nav.top.style.cursor = this.style.cursor;
            }

            return false;
        };

        this._doBeforeEventRender = function(i) {
            var cache = this._cache.events;
            var data = this.events.list[i];
            var evc = {};

            // make a copy
            for (var name in data) {
                evc[name] = data[name];
            }

            if (calendar.showEventStartEnd) {
                var sameday = data.start.getDatePart().getTime() === data.end.getDatePart().getTime();
                var pattern = sameday ? resolved._locale().timePattern : resolved._locale().dateTimePattern;

                var startTime = data.start.toString(pattern);
                var endTime = data.end.toString(pattern);
                evc.html = calendar._xssTextHtml(evc.text) + " (" + startTime + " - " + endTime + ")";
            }

            if (typeof this.onBeforeEventRender === 'function') {
                var args = {};
                args.e = evc;
                args.data = evc;
                this.onBeforeEventRender(args);
            }

            cache[i] = evc;

        };

        this._autoscrolltimeout = null;

        this._doAutoScroll = function(coords) {

            var dragInProgress = DpGlobal.moving || DpGlobal.resizing || DpGlobal.selecting;
            var autoscrollAlways = calendar.autoScroll === "Always";
            var autoscrollDrag = calendar.autoScroll === "Drag" && dragInProgress;

            var autoscrollEnabled = autoscrollAlways || autoscrollDrag;
            // var autoscrollHorizontalDisabled = calendar.cellWidthSpec === "Auto";
            var autoscrollHorizontalDisabled = false;
            var autoscrollVerticalDisabled = false;

            // autoscroll
            if (autoscrollEnabled) {

                var scrollDiv = calendar.nav.bottomRight;
                // var coords = { x: calendar.coords.x, y: calendar.coords.y };
                coords.x -= scrollDiv.scrollLeft;
                coords.y -= scrollDiv.scrollTop;

                var width = scrollDiv.clientWidth;
                var height = scrollDiv.clientHeight;

                var border = 30;

                var left = coords.x < border ? coords.x : 0;
                var right = width - coords.x < border ? width - coords.x : 0;

                var top = coords.y < border ? coords.y : 0;
                var bottom = height - coords.y < border ? height - coords.y : 0;

                var x = 0;
                var y = 0;

                var speed = 50;

                if (left) {
                    x = -speed*invertedPct(left, border);
                }
                if (right) {
                    x = speed*invertedPct(right, border);
                }

                if (top) {
                    y = -speed*invertedPct(top, border)/2;
                }
                if (bottom) {
                    y = speed*invertedPct(top, border)/2;
                }

                if (autoscrollVerticalDisabled) {
                    y = 0;
                }

                if (autoscrollHorizontalDisabled) {
                    x = 0;
                }

                if (x || y) {
                    calendar._startScroll(x, y);
                }
                else {
                    calendar._stopScroll();
                }
            }

            function invertedPct(value, max) {
                return 1 - value/max;
            }

        };

        this._startScroll = function(stepX, stepY) {
            //var step = 10;
            this._stopScroll();
            this._scrollabit(stepX, stepY);
        };

        this._scrollabitX = function(step) {
            if (!step) {
                return false;
            }
            var scroll = calendar.nav.bottomRight;
            var total = scroll.scrollWidth;
            var start = scroll.scrollLeft;
            var width = scroll.clientWidth;
            var right = start + width;

            if (step < 0 && start <= 0) {
                return false;
            }

            if (step > 0 && right >= total) {
                return false;
            }

            scroll.scrollLeft += step;
            calendar.coords.x += step;

            calendar._scrollabitUpdateShadow();

            return true;
        };

        this._scrollabitY = function(step) {
            if (!step) {
                return false;
            }
            var scroll = calendar.nav.bottomRight;
            var total = scroll.scrollHeight;
            var start = scroll.scrollTop;
            var height = scroll.clientHeight;
            var bottom = start + height;

            if (step < 0 && start <= 0) {
                return false;
            }

            if (step > 0 && bottom >= total) {
                return false;
            }

            scroll.scrollTop += step;
            calendar.coords.y += step;

            calendar._scrollabitUpdateShadow();

            // this is not necessary, it's linked using nav.scroll.onscroll
            //this.divTimeScroll.scrollTop = this.nav.scroll.scrollTop;

            return true;
        };


        this._scrollabitUpdateShadow = function() {
            /*
            if (DayPilotScheduler._resizing && DayPilotScheduler._resizing.event.calendar === calendar) {
                calendar._mouseMoveUpdateResizing();
            }
            else if (DayPilotScheduler._moving  && (DayPilotScheduler._movingEvent.calendar === calendar || (DayPilotScheduler._movingEvent.calendar && DayPilotScheduler._movingEvent.calendar.dragOutAllowed))) {
                if (!DayPilotScheduler._moving.event) {
                    DayPilotScheduler._moving.event = DayPilotScheduler._movingEvent;
                }
                calendar._mouseMoveUpdateMoving();
            }
            else if (DayPilotScheduler._range && DayPilotScheduler._range.calendar === calendar) {
                calendar._mouseMoveUpdateRange();
            }*/
        };

        this._scrollabit = function(stepX, stepY) {

            var moved = this._scrollabitX(stepX) || this._scrollabitY(stepY);
            if (!moved) {
                return;
            }

            var delayed = function(stepX, stepY) {
                return function() {
                    calendar._scrollabit(stepX, stepY);
                };
            };

            this._autoScrollTimeout = window.setTimeout(delayed(stepX, stepY), 200);

        };

        this._stopScroll = function() {
            if (calendar._autoScrollTimeout) {
                window.clearTimeout(calendar._autoScrollTimeout);
                calendar._autoScrollTimeout = null;
            }
        };


        this._touch = {};
        var touch = calendar._touch;

        touch.active = false;
        touch.start = null;
        touch.timeout = null;

        touch.startcell = null;

        // internal API
        touch.relativeCoords = function(ev) {
            return touch._relativeCoords(ev);
        };

        touch.startResizing = function(div, border, coords) {
            touch._startResizing(div, border, coords);
        }

        touch.startMoving = function(div, coords) {
            touch._startMoving(div, coords);
        };

        this._touch._getCellCoords = function(ev) {
            var x, y;

            if (ev.touches) {
                x = ev.touches[0].pageX;
                y = ev.touches[0].pageY;
            }
            else {
                x = ev.pageX;
                y = ev.pageY;
            }

            var abs = DayPilot.abs(calendar.nav.main);
            var pos = {x: x - abs.x, y: y - abs.y};

            var w = (calendar.nav.main.clientWidth / calendar._columnsBottom.length);

            var cellY = Math.floor(pos.y / calendar.cellHeight);
            cellY = DayPilot.Util.atLeast(0, cellY);
            cellY = DayPilot.Util.atMost(calendar._rowCount() - 1, cellY);

            var coords = {
                "pageX": x,
                "pageY": y,
                //"abs": abs,
                "x": Math.floor(pos.x / w),  // keep negative value
                "y": cellY,
                "toString" : function() { return "x: " + this.x + " y:" + this.y; }
            };

            return coords;
        };

        this._touch._startSelecting = function(coords) {

            var cell = calendar.nav.main.rows[coords.y].cells[coords.x];
            touch.startcell = coords;

            calendar.clearSelection();

            // don't use this flag, it's for mouse cursor
            // DpGlobal.selecting = true;
            DayPilotCalendar._selectedColumn = coords.x;
            calendar._selectedCells.push(cell);
            DayPilotCalendar._firstSelected = cell;

            DayPilotCalendar._topSelectedCell = cell;
            DayPilotCalendar._bottomSelectedCell = cell;

            DpGlobal.selecting = {"calendar": calendar};

            calendar._activateSelection();

        };


        this._touch._extendSelection = function(coords) {

            var x = DayPilotCalendar._selectedColumn;

            var cell = calendar.nav.main.rows[coords.y].cells[x];

            calendar.clearSelection();

            DpGlobal.selecting = {"calendar": calendar, "origin": "drag"};

            // new selected cells
            if (coords.y < touch.startcell.y) {
              calendar._selectedCells = DayPilotCalendar._getCellsBelow(cell);
              DayPilotCalendar._topSelectedCell = calendar._selectedCells[0];
              DayPilotCalendar._bottomSelectedCell = DayPilotCalendar._firstSelected;
            }
            else {
              calendar._selectedCells = DayPilotCalendar._getCellsAbove(cell);
              DayPilotCalendar._topSelectedCell = DayPilotCalendar._firstSelected;
              DayPilotCalendar._bottomSelectedCell = calendar._selectedCells[0];
            }

            calendar._activateSelection();
        };

        this._touch.detected = false;

        this._touch._onMainTouchStart = function(ev) {

            if (isMouseEvent(ev)) {
                return;
            }

            var coords = touch._getCellCoords(ev);
            if (coords.x < 0) {
                return;
            }

            touch.start = true;
            touch.detected = true;

            if (touch.active) {
                return;
            }

            // pinch
            if (ev.touches.length > 1) {
                return;
            }

            touch.using = true;
            touch.startCoords = coords;

            var holdfor = calendar.tapAndHoldTimeout;
            touch.timeout = window.setTimeout(function() {
                //alert("timeout");
                ev.preventDefault();
                touch.active = true;
                touch.start = false;
                switch (calendar.timeRangeTapAndHoldHandling) {
                    case "Select":
                        // alert(coords.pageX + "/" + coords.pageY);
                        // alert(coords.abs);
                        //alert(coords.x + "/" + coords.y);
                        touch._startSelecting(coords);
                        //alert(coords.pageX + "/" + coords.pageY);
                        //calendar.nav.corner.firstChild.innerHTML = coords.pageX + "/" + coords.pageY;
                        break;
                    case "ContextMenu":
                        // TODO select it
                        touch._startSelecting(coords);
                        touch.active = false; // prevent the default selection action
                        // invoke menu
                        if (calendar.contextMenuSelection) {
                            calendar.contextMenuSelection.show(calendar.getSelection());
                        }
                        break;
                }
            }, holdfor);
        };

        this._touch._onCellTouchMove = function(ev) {
        };

        this._touch._onCellTouchEnd = function(ev) {

            if (!touch.active) {
                window.clearTimeout(touch.timeout);  // not sure

                // if not moved
                if (touch.start) {
                    (function selectCell(cell) {
                        if (calendar.timeRangeSelectedHandling === "Disabled") {
                            return;
                        }


                        calendar.clearSelection();

                        calendar._selectedCells = [cell];
                        DayPilotCalendar._topSelectedCell = cell;
                        DayPilotCalendar._bottomSelectedCell = cell;

                        calendar._activateSelection();

                        var sel = calendar.getSelection();
                        sel.toString = function() {
                            return "start: " + this.start + "\nend: " + this.end;
                        };

                        setTimeout(function() {
                            calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);
                        }, 10);

                    })(this);
                }

                return;
            }

            ev.preventDefault();
            ev.stopPropagation();

            touch.startcell = null;
            touch.start = false;

            var sel = calendar.getSelection();
            sel.toString = function() {
                return "start: " + this.start + "\nend: " + this.end;
            };
            calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);

            // prevent alert-initiated touchstart on iOS
            window.setTimeout(function() {
                touch.active = false;
            }, 500);

        };

        this._touch._startMoving = function(div, coords) {
            DpGlobal.moving = div;
            var helper = DpGlobal.moving.helper = {};
            helper.oldColumn = calendar._columnsBottom[div.event.part.dayIndex].id;
            DayPilotCalendar._originalMouse = coords;
            DayPilotCalendar._originalTop = this.offsetTop;

            var abs = DayPilot.abs(div);
            DayPilotCalendar.moveOffsetY = coords.y - abs.y;

            //document.title = "moveOffsetY:" + DayPilotCalendar.moveOffsetY;

            if (!DayPilotCalendar.movingShadow) {
                DayPilotCalendar.movingShadow = calendar._createShadow(DpGlobal.moving, !calendar._browser.ie);
                DayPilotCalendar.movingShadow.style.width = (DayPilotCalendar.movingShadow.parentNode.offsetWidth + 1) + 'px';
            }

        };

        this._touch._startResizing = function(div, border, coords) {
            DpGlobal.resizing = div;
            div.dpBorder = border;
            DayPilotCalendar._originalMouse = coords;   // DayPilot.mc()
            DayPilotCalendar._originalHeight = div.offsetHeight;
            DayPilotCalendar._originalTop = div.offsetTop;
        };

        this._touch._updateResizing = function(coords) {
            calendar._updateResizingShadow(coords);
        };

        // coords relative to main
        this._touch._updateMoving = function() {

            var coords = calendar.coords;

            var _step = calendar.cellHeight;
            var _startOffset = 0;

            var offset = DayPilotCalendar.moveOffsetY;
            if (!offset) {
              offset = _step / 2; // for external drag
            }

            var newTop = Math.floor(((coords.y - offset - _startOffset) + _step / 2) / _step) * _step + _startOffset;

            if (newTop < _startOffset) {
              newTop = _startOffset;
            }

            var main = calendar.nav.main;
            // var max = main.clientHeight;
            var max = calendar._getInnerHeight();

            var height = parseInt(DayPilotCalendar.movingShadow.style.height);  // DayPilotCalendar.moving.data.height

            if (newTop + height > max) {
              newTop = max - height;
            }

            DayPilotCalendar.movingShadow.style.top = newTop + 'px';

            DayPilotCalendar.movingShadow.allowed = true;
            // TODO include onEventMoving

            // var colWidth = main.clientWidth / calendar._columnsBottom.length;
            // var column = Math.floor((calendar.coords.x) / colWidth);
            var column = calendar._getColumnForPixels(calendar.coords.x);

            if (column < 0) {
              column = 0;
            }

            var events = calendar.nav.events;
            if (column < events.rows[0].cells.length && column >= 0 && DayPilotCalendar.movingShadow.column !== column) {
              DayPilotCalendar.movingShadow.column = column;
              DayPilotCalendar.moveShadow(events.rows[0].cells[column]);
            }

        };

        this._touch.onEventTouchStart = function(ev) {
            if (touch.active) {
                return;
            }

            if (isMouseEvent(ev)) {
                return;
            }

            ev.stopPropagation();
            touch.preventEventTap = false;
            touch.using = true;

            // ie
            touch.startCoords = touch._getCellCoords(ev);

            var div = this;
            var x = ev.touches ? ev.touches[0].pageX : ev.pageX;
            var y = ev.touches ? ev.touches[0].pageY : ev.pageY;
            var coords  = { x: x, y: y, div: this};

            // nav.scrollable is a wrong reference
            //var abs = DayPilot.abs(calendar.nav.scrollable);
            calendar.coords = touch._relativeCoords(ev);


            var holdfor = calendar.tapAndHoldTimeout;
            touch.timeout = window.setTimeout(function() {

                var e = div.event;

                touch.active = true;
                switch (calendar.eventTapAndHoldHandling) {
                    case "Move":
                        if (e.client.moveEnabled()) {
                            touch._startMoving(div, coords);
                        }
                        break;
                    case "ContextMenu":
                        var menu = e.client.contextMenu();

                        if (DayPilot.Menu) {
                            DayPilot.Menu.touchPosition(ev);
                        }

                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                }
            }, holdfor);

        };

        this._touch._onMainTouchMove = function(ev) {

            if (isMouseEvent(ev)) {
                return;
            }

            touch.start = false;

            if (touch.timeout) {
                var coords = touch._getCellCoords(ev);
                if (coords && touch.startCoords) {
                    if (coords.pageX !== touch.startCoords.pageX || coords.pageY !== touch.startCoords.pageY) {
                        window.clearTimeout(calendar._touch.timeout);
                    }
                }
            }

            if (DpGlobal.moving && DayPilotCalendar.movingShadow) {
                ev.preventDefault();
                calendar.coords = touch._relativeCoords(ev);
                touch._updateMoving();
                return;
            }
            else if (DpGlobal.resizing) {
                ev.preventDefault();
                var t = ev.touches ? ev.touches[0] : ev;
                var coords = {x: t.pageX, y: t.pageY };
                touch._updateResizing(coords);
                return;
            }
            else if (touch.startcell) {
                ev.preventDefault();

                if (!touch.active) {
                    window.clearTimeout(touch.timeout);
                    return;
                }

                var coords = touch._getCellCoords(ev);
                //calendar._touchMsg("coords: " + coords.x + "/" + coords.y);
                touch._extendSelection(coords);
            }

            touch.preventEventTap = true;
        };

        this._touch._relativeCoords = function(ev) {
            var ref = calendar.nav.main;

            var x = ev.touches ? ev.touches[0].pageX : ev.pageX;
            var y = ev.touches ? ev.touches[0].pageY : ev.pageY;

            var abs = DayPilot.abs(ref);
            var coords = {x: x - abs.x, y: y - abs.y, "toString": function() { return "x: " + this.x + ", y:" + this.y; } };
            return coords;
        };


        this._touch._onMainTouchEnd = function(ev) {

            if (isMouseEvent(ev)) {
                return;
            }

            if (DpGlobal.moving) {
                touch.active = false;

                // testing: disabled
                ev.preventDefault();
                ev.stopPropagation();

                var top = DayPilotCalendar.movingShadow.offsetTop;

                // DayPilotCalendar.deleteShadow(DayPilotCalendar.movingShadow);
                // deleteElement(DayPilotCalendar.movingShadow);
                var dpEvent = DpGlobal.moving.event;
                var calendar = dpEvent.calendar;
                calendar._deleteShadow(DayPilotCalendar.movingShadow);
                var newColumnIndex = DayPilotCalendar.movingShadow.column;


                var args = DayPilotCalendar.movingShadow;

                // stop moving on the client
                removeClass(DpGlobal.moving, calendar._prefixCssClass("_event_moving_source"));
                DpGlobal.moving = null;
                DayPilotCalendar.movingShadow = null;

                if (!args.allowed) {
                    calendar._clearMovingShadow();
                    return;
                }

                dpEvent.calendar._eventMoveDispatch(dpEvent, newColumnIndex, top, ev, DayPilotCalendar.drag);
            }
            else if (touch.startcell) {

                if (!touch.active) {
                    window.clearTimeout(touch.timeout);  // not sure
                    return;
                }

                ev.preventDefault();

                touch.startcell = null;

                var sel = calendar.getSelection();
                sel.toString = function() {
                    return "start: " + this.start + "\nend: " + this.end;
                };
                calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);

                // prevent alert-initiated touchstart on iOS
                window.setTimeout(function() {
                    touch.active = false;
                }, 500);

            }
        };

        this._touch.onEventTouchMove = function(ev) {
            // don't call ev.stopPropagation() here, it would prevent moving the event shadow
            touch.preventEventTap = true;
        };

        this._touch.onEventTouchEnd = function(ev) {

            if (isMouseEvent(ev)) {
                return;
            }

            // quick tap
            if (!touch.active) {
                if (touch.preventEventTap) {
                    return;
                }
                // disabled to test double click
                // ev.preventDefault();
                window.clearTimeout(touch.timeout);
                calendar._eventClickSingle(this, false, false, ev);
                return;
            }

            touch.active = false;
            if (touch.timeout) {
                window.clearTimeout(touch.timeout);
                return;
            }
            // disabled to test double click
            // ev.preventDefault();
        };

        this._onEventMouseMove = function(ev) {

            // const
            var resizeMargin = 5;
            // var moveMargin = Math.max(calendar.durationBarWidth, 10);
            var moveMargin = 10;
            var w = 5;

            var header = (calendar.moveBy === 'Top');

            if (typeof (DayPilotCalendar) === 'undefined') {
                return;
            }

            // position
            var offset = DayPilot.mo3(this, ev);

            if (!offset) {
                return;
            }

            calendar.eventOffset = offset;

            var div = this;
            if (!div.active) {
                // areas activated using attach()
                addClass(div, calendar._prefixCssClass("_event_hover"));
            }

            if (DpGlobal.resizing || DpGlobal.moving) {
                return;
            }

            var isFirstPart = this.isFirst;
            var isLastPart = this.isLast;

            if (calendar.moveBy === "Disabled" || calendar.moveBy === "None") {
                return;
            }

            if (!header && offset.x <= moveMargin && this.event.client.moveEnabled()) {

                if (isFirstPart) {
                    this.style.cursor = 'move';
                }
                else {
                    this.style.cursor = 'not-allowed';
                }
            }
            else if (!header && offset.y <= resizeMargin && this.event.client.resizeEnabled()) {
                if (isFirstPart) {
                    this.style.cursor = "n-resize";
                    this.dpBorder = 'top';
                }
                else {
                    this.style.cursor = 'not-allowed';
                }
            }
            else if (header && offset.y <= moveMargin && this.event.client.moveEnabled()) {
                this.style.cursor = "move";
            }
            else if (this.offsetHeight - offset.y <= resizeMargin && this.event.client.resizeEnabled()) {
                if (isLastPart) {
                    this.style.cursor = "s-resize";
                    this.dpBorder = 'bottom';
                }
                else {
                    this.style.cursor = 'not-allowed';
                }
            }
            else if (!DpGlobal.resizing && !DpGlobal.moving) {
                if (this.event.client.clickEnabled())
                    this.style.cursor = 'pointer';
                else
                    this.style.cursor = 'default';
            }

            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble && calendar.eventHoverHandling !== 'Disabled') {
                if (this.style.cursor === 'default' || this.style.cursor === 'pointer') {
                    var notMoved = this._lastOffset && offset.x === this._lastOffset.x && offset.y === this._lastOffset.y;
                    if (!notMoved) {
                        this._lastOffset = offset;
                        calendar.bubble.showEvent(this.event);
                    }
                    //calendar.bubble.showEvent(this.event);
                }
                else {
                    // disabled, hiding on click
                    //DayPilotBubble.hideActive();
                }
            }


        };

        this._onEventMouseOut = function(ev) {
            removeClass(this, calendar._prefixCssClass("_event_hover"));
            if (calendar.bubble) {
                calendar.bubble.hideOnMouseOut();
            }

            DayPilot.Areas.hideAreas(this, ev);

        };

        this._currentTimeTimeout = null;

        this._showCurrentTime = function() {
            if (this.showCurrentTime) {
                this._clearSeparators();
                var time = new DayPilot.Date().addMinutes(calendar.showCurrentTimeOffset);
                if (calendar.showCurrentTimeMode === "Full") {
                    this._drawSeparatorWide(time);
                }
                else if (calendar.showCurrentTimeMode === "Day") {
                    this._drawSeparator(time);
                }
                else {
                    throw new DayPilot.Exception("Invalid DayPilot.Calendar.showCurrentTimeMode value: " + calendar.showCurrentTimeMode);
                }

                if (this.nav.events && !this._currentTimeTimeout) {  // not disposed
                    var refreshIntervalSeconds = 30;
                    this._currentTimeTimeout = setTimeout(function() {
                        calendar._currentTimeTimeout = null;
                        calendar._showCurrentTime();
                    }, refreshIntervalSeconds * 1000);
                }
            }
        };

        this._clearSeparators = function() {
            deleteElement(calendar.elements.separators);
            calendar.elements.separators = [];
        };

        this._drawSeparator = function(date) {
            var ticks = date.getTime();
            var main = calendar.nav.events;

            if (!main) {
                return;
            }

            for(var i = 0; i < calendar._columnsBottom.length; i++) {
                var col = calendar._columnsBottom[i];

                var duration = calendar._duration(true);
                var colStart = new DayPilot.Date(col.start).addHours(this._visibleStart(true));
                var colStartTicks = colStart.getTime();
                var colEnd = colStart.addTime(duration);
                var colEndTicks = colEnd.getTime();

                if (colStartTicks <= ticks && ticks <= colEndTicks) {
                    var partStartPixels = this._getPixels(date, col.start).top - 1 - calendar._autoHiddenPixels();
                    var cell = main.rows[0].cells[i];
                    var wrap = cell.separators;

                    var div = createDiv();
                    div.style.position = "absolute";
                    div.style.top = partStartPixels + "px";
                    div.style.height = "1px";
                    div.style.left = "0px";
                    div.style.right = "0px";
                    div.className = calendar._prefixCssClass("_now");

                    wrap.insertBefore(div, wrap.firstChild);

                    calendar.elements.separators.push(div);
                }

            }
        };

        this._drawSeparatorWide = function(date) {
            var ticks = date.getTime();
            var main = calendar.nav.events;

            if (!main) {
                return;
            }

            var col = calendar._columnsBottom[0];
            if (!col) {
                return;
            }
            var adjustedDate = col.start.getDatePart().addTime(date.getTimePart());
            var partStartPixels = this._getPixels(adjustedDate, col.start).top - 1;

            for(var i = 0; i < calendar._columnsBottom.length; i++) {
                var col = calendar._columnsBottom[i];

                var duration = calendar._duration(true);
                var colStart = new DayPilot.Date(col.start).addHours(this._visibleStart(true));
                var colStartTicks = colStart.getTime();
                var colEnd = colStart.addTime(duration);
                var colEndTicks = colEnd.getTime();

                if (colStartTicks <= ticks && ticks <= colEndTicks) {
                    var div = createDiv();
                    div.style.position = "absolute";
                    div.style.top = partStartPixels + "px";
                    div.style.height = "1px";
                    div.style.left = "0px";
                    div.style.right = "0px";
                    div.className = calendar._prefixCssClass("_now");

                    calendar.nav.events.appendChild(div);

                    calendar.elements.separators.push(div);

                    return;
                }

            }

        };

        this._loadEvents = function(events, options) {

            if (!events) {
                events = this.events.list;
            }
            else {
                this.events.list = events;
            }

            if (!events) {
                return;
            }

            var preloadOnly = options && options.preloadOnly;

            this._allDay = {};
            this._allDay.events = [];
            this._allDay.lines = [];

            var length = events.length;
            var duration = this._duration(true);

            this._cache.pixels = {};
            this._cache._eps = [];

            var loadCache = [];

            this._scrollLabels = [];

            this._minStart = 10000;
            this._maxEnd = 0;

            // make sure it's DayPilot.Date
            this.startDate = new DayPilot.Date(this.startDate);

            for (var i = 0; i < length; i++) {
                var e = events[i];


                if (typeof e !== "object") {
                    throw new DayPilot.Exception("Event data item must be an object");
                }
                if (!e.start) {
                    throw new DayPilot.Exception("Event data item must specify 'start' property");
                }

                e.start = new DayPilot.Date(e.start);
                e.end = new DayPilot.Date(e.end);
            }

            if (!preloadOnly) {
                if (typeof this.onBeforeEventRender === 'function' || calendar.showEventStartEnd) {  // make sure .html is pregenerated for showEventStartEnd
                    for (var i = 0; i < length; i++) {
                        //var e = events[i];
                        this._doBeforeEventRender(i);
                    }
                }
            }

            var isResourcesView = this.viewType === 'Resources';

            var visible = this._getVisibleRange();

            var allStart = visible.start;
            var allEnd = visible.end;

            //calendar.debug.message("allStart: " + allStart);

            for (var i = 0; i < this._columnsBottom.length; i++) {
                var scroll = {};
                scroll.minEnd = 1000000;
                scroll.maxStart = -1;
                this._scrollLabels.push(scroll);

                var col = this._columnsBottom[i];
                col.events = [];
                col.lines = [];
                col.blocks = [];

                var colStart = new DayPilot.Date(col.start).addHours(this._visibleStart(true));
                var colStartTicks = colStart.getTime();
                var colEnd = colStart.addTime(duration);
                var colEndTicks = colEnd.getTime();

                if (isResourcesView) {
                    allStart = colStart.getDatePart();
                    allEnd = colStart.addDays(1);
                }

                for (var j = 0; j < length; j++) {
                    if (loadCache[j]) {
                        continue;
                    }

                    var e = events[j];

                    var cache = null;
                    if (!preloadOnly && typeof calendar.onBeforeEventRender === 'function') {
                        //var index = DayPilot.indexOf(calendar.events.list, e);
                        cache = calendar._cache.events[j];
                    }

                    if (cache) {
                        if (cache.hidden) {
                            continue;
                        }
                    }
                    else if (e.hidden) {
                        continue;
                    }

                    var start = e.start;
                    var end = e.end;

                    var startTicks = start.getTime();
                    var endTicks = end.getTime();

                    if (endTicks < startTicks) {  // skip invalid events
                        continue;
                    }

                    if (e.allday) {
                        var belongsHere = false;

                        if (startTicks === endTicks) {
                            belongsHere = !(endTicks < allStart.getTime() || startTicks >= allEnd.getTime());
                        }
                        else if (calendar.allDayEnd === 'Date') {
                            belongsHere = !(endTicks < allStart.getTime() || startTicks >= allEnd.getTime());
                        }
                        else {
                            belongsHere = !(endTicks <= allStart.getTime() || startTicks >= allEnd.getTime());
                        }

                        if (isResourcesView) {
                            belongsHere = belongsHere && (e.resource === col.id || col.id === "*");
                        }

                        if (belongsHere) {
                            var ep = new DayPilot.Event(e, this);
                            ep.part.start = allStart.getTime() < startTicks ? start : allStart;
                            ep.part.end = allEnd.getTime() > endTicks ? end : allEnd;
                            ep.part.colStart = DayPilot.DateUtil.daysDiff(allStart, ep.part.start);
                            ep.part.colWidth = DayPilot.DateUtil.daysSpan(ep.part.start, ep.part.end) + 1;

                            if (isResourcesView) {
                                ep.part.colStart = i;
                                ep.part.colWidth = 1;
                            }

                            if (typeof calendar.onEventFilter === "function" && calendar.events._filterParams) {
                                var args = {};
                                args.filter = calendar.events._filterParams;
                                args.filterParam = args.filter;
                                args.visible = true;
                                args.e = ep;

                                calendar.onEventFilter(args);

                                if (!args.visible) {
                                    continue;
                                }
                            }

                            this._allDay.events.push(ep);

                            if (!preloadOnly) {
                                if (typeof this.onBeforeEventRender === 'function' || calendar.showEventStartEnd) {
                                    ep.cache = this._cache.events[j];
                                }
                            }

                            // always put into cache, it can have just one box
                            loadCache[j] = true;

                            if (isResourcesView && (ep.part.start.getTime() !== startTicks || ep.part.end.getTime() !== endTicks)) {
                                loadCache[j] = false;
                            }

                        }

                        continue;
                    }

                    var cache = null;
                    if (!preloadOnly && typeof calendar.onBeforeEventRender === 'function') {
                        //var index = DayPilot.indexOf(calendar.events.list, e);
                        cache = calendar._cache.events[j];
                    }

                    if (cache) {
                        if (cache.hidden) {
                            continue;
                        }
                    }
                    else if (e.hidden) {
                        continue;
                    }

                    // belongs here
                    var belongsHere = false;
                    if (isResourcesView) {
                        belongsHere = (col.id === e.resource) && !(endTicks <= colStartTicks || startTicks >= colEndTicks);
                    }
                    else {
                        belongsHere = !(endTicks <= colStartTicks || startTicks >= colEndTicks) || (endTicks === startTicks && startTicks === colStartTicks);
                    }

                    if (belongsHere) {

                        var ep = new DayPilot.Event(e, calendar);
                        ep.part.dayIndex = i;
                        ep.part.start = colStartTicks < startTicks ? start : colStart;
                        ep.part.end = colEndTicks > endTicks ? end : colEnd;

                        var partStartPixels = this._getPixels(ep.part.start, col.start);
                        var partEndPixels = this._getPixels(ep.part.end, col.start);

                        var top = partStartPixels.top;
                        var bottom = partEndPixels.top;

                        // events in the hidden areas
                        if (top === bottom && (partStartPixels.cut || partEndPixels.cut)) {
                            continue;
                        }

                        ep.part.box = resolved._useBox(endTicks - startTicks);

                        var _startOffset = 0;
                        // continue here **************************
                        if (ep.part.box) {
                            var boxBottom = partEndPixels.boxBottom;

                            ep.part.top = Math.floor(top / this.cellHeight) * this.cellHeight + _startOffset + 1;
                            ep.part.height = Math.max(Math.ceil(boxBottom / this.cellHeight) * this.cellHeight - ep.part.top, this.cellHeight - 1) + 1;
                            ep.part.barTop = Math.max(top - ep.part.top - 1, 0);  // minimum 0
                            ep.part.barHeight = Math.max(bottom - top - 2, 1);  // minimum 1
                        }
                        else {
                            ep.part.top = top + _startOffset;
                            ep.part.height = Math.max(bottom - top, 0);
                            ep.part.barTop = 0;
                            ep.part.barHeight = Math.max(bottom - top - 2, 1);
                        }

                        if (typeof calendar.onEventFilter === "function" && calendar.events._filterParams) {
                            var args = {};
                            args.filter = calendar.events._filterParams;
                            args.visible = true;
                            args.e = ep;

                            calendar.onEventFilter(args);

                            if (!args.visible) {
                                continue;
                            }
                        }

                        var start = ep.part.top;
                        var end = ep.part.top + ep.part.height;

                        if (start > scroll.maxStart) {
                            scroll.maxStart = start;
                        }
                        if (end < scroll.minEnd) {
                            scroll.minEnd = end;
                        }

                        if (start < this._minStart) {
                            this._minStart = start;
                        }
                        if (end > this._maxEnd) {
                            this._maxEnd = end;
                        }
                        col.events.push(ep);

                        if (!preloadOnly) {
                            if (typeof this.onBeforeEventRender === 'function' || calendar.showEventStartEnd) {
                                ep.cache = this._cache.events[j];
                            }
                        }

                        if (ep.part.start.getTime() === startTicks && ep.part.end.getTime() === endTicks) {
                            loadCache[j] = true;
                        }

                        calendar._cache._eps.push(ep);
                    }
                }
            }

            // sort events inside columns
            for (var i = 0; i < this._columnsBottom.length; i++) {
                var col = this._columnsBottom[i];
                col.events.sort(this._eventComparer);

                // put into lines
                for (var j = 0; j < col.events.length; j++) {
                    var e = col.events[j];
                    col._putIntoBlock(e);
                }

                for (var j = 0; j < col.blocks.length; j++) {
                    var block = col.blocks[j];
                    block.events.sort(this._eventComparerCustom);
                    for (var k = 0; k < block.events.length; k++) {
                        var e = block.events[k];
                        block._putIntoLine(e);
                    }
                }
            }

            // sort allday events
            this._allDay.events.sort(this._eventComparerCustom);

            this._allDay._putIntoLine = function(ep) {
                var thisCol = this;

                for (var i = 0; i < this.lines.length; i++) {
                    var line = this.lines[i];
                    if (line._isFree(ep.part.colStart, ep.part.colWidth)) {
                        line.push(ep);
                        return i;
                    }
                }

                var line = [];
                line._isFree = function(start, width) {
                    //var free = true;
                    var end = start + width - 1;
                    var max = this.length;

                    for (var i = 0; i < max; i++) {
                        var e = this[i];
                        if (!(end < e.part.colStart || start > e.part.colStart + e.part.colWidth - 1)) {
                            return false;
                        }
                    }

                    return true;
                };

                line.push(ep);

                this.lines.push(line);

                return this.lines.length - 1;
            };

            for (var i = 0; i < this._allDay.events.length; i++) {
                var e = this._allDay.events[i];
                this._allDay._putIntoLine(e);
            }

            var lines = Math.max(this._allDay.lines.length, 1);
            this._cache.allDayHeaderHeight = lines * (resolved._allDayEventHeight() + 2) + 2; // overriding
        };

        this._eventComparer = function(a, b) {
            if (!a || !b || !a.start || !b.start) {
                return 0; // no sorting, invalid arguments
            }

            var byStart = a.start().ticks - b.start().ticks;
            if (byStart !== 0) {
                return byStart;
            }

            var byEnd = b.end().ticks - a.end().ticks; // desc
            return byEnd;
        };

        this._eventComparerCustom = function(a, b) {
            if (!a || !b) {
                //calendar.debug("no sorting, invalid arguments");
                return 0; // no sorting, invalid arguments
            }

            if (!a.data || !b.data || !a.data.sort || !b.data.sort || a.data.sort.length === 0 || b.data.sort.length === 0) { // no custom sorting, using default sorting (start asc, end asc);
                //calendar.debug("using default comparer: " + a.Sort + ' ' + b.Sort);
                return calendar._eventComparer(a, b);
            }
            //calendar.debug("using custom comparer");

            var result = 0;
            var i = 0;
            while (result === 0 && typeof a.data.sort[i] !== "undefined" && typeof b.data.sort[i] !== "undefined") {
                if (a.data.sort[i] === b.data.sort[i]) {
                    result = 0;
                }
                else if (typeof a.data.sort[i] === "number" && typeof b.data.sort[i] === "number") {
                    result = a.data.sort[i] - b.data.sort[i];
                }
                else {
                    result = calendar._stringComparer(a.data.sort[i], b.data.sort[i], calendar.sortDirections[i]);
                }
                i++;
            }

            return result;
        };

        this._stringComparer = function(a, b, direction) {
            var asc = (direction !== "desc");
            var aFirst = asc ? -1 : 1;
            var bFirst = -aFirst;

            if (a === null && b === null) {
                return 0;
            }
            // nulls first
            if (b === null) { // b is smaller
                return bFirst;
            }
            if (a === null) {
                return aFirst;
            }

            //return asc ? a.localeCompare(a, b) : -a.localeCompare(a, b);

            var ar = [];
            ar[0] = a;
            ar[1] = b;

            ar.sort();

            return a === ar[0] ? aFirst : bFirst;
        };

        this._findEventDiv = function(e) {
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (div.event === e || div.event.data === e.data) {
                    return div;
                }
            }
            return null;
        };

        this.events.find = function(id) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }

            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].id === id) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        this.events.findRecurrent = function(masterId, time) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }
            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].recurrentMasterId === masterId && calendar.events.list[i].start.getTime() === time.getTime()) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        this.events.all = function() {
            var list = [];
            for (var i = 0; i < calendar.events.list.length; i++) {
                var e = new DayPilot.Event(calendar.events.list[i], calendar);
                list.push(e);
            }
            return createList(list);
        };

        this.events.edit = function(e) {
            function startEditing() {
                var div = calendar._findEventDiv(e);
                if (!div) {
                    return;
                }
                calendar._divEdit(div);
            }
            startEditing();
            //setTimeout(startEditing);
        };


        this.events.update = function(e, data) {
            if (typeof e === "object" && !(e instanceof DayPilot.Event)) {
                // updateByData
                // var data = e;
                var ev = calendar.events.find(e.id);
                if (!ev) {
                    throw new DayPilot.Exception("The event to be updated was not found");
                }
                calendar.events.remove(ev);
                calendar.events.add(e);
                return;
            }

            var params = {};
            params.oldEvent = new DayPilot.Event(e.copy(), calendar);
            params.newEvent = new DayPilot.Event(e.temp(), calendar);

            var action = new DayPilot.Action(calendar, "EventUpdate", params, data);

            e.commit();

            if (calendar._initialized) {
                calendar._update({"eventsOnly": true});
            }

            calendar._angular.notify();

            return action;
        };


        this.events.remove = function(e, data) {

            if (typeof e === "string" || typeof e === "number") {
                var id = e;
                var fe = calendar.events.find(id);
                if (!fe) {
                    throw new DayPilot.Exception("The event to be removed was not found");
                }
                calendar.events.remove(fe);
                return;
            }

            var params = {};
            params.e = new DayPilot.Event(e.data, calendar);

            var action = new DayPilot.Action(calendar, "EventRemove", params, data);

            var index = DayPilot.indexOf(calendar.events.list, e.data);
            calendar.events.list.splice(index, 1);

            if (calendar._initialized) {
                calendar._update({"eventsOnly": true});
            }

            calendar._angular.notify();

            return action;
        };

        this.events.add = function(e, data) {

            if (!(e instanceof DayPilot.Event)) {
                e = new DayPilot.Event(e);
            }

            e.calendar = calendar;

            if (!calendar.events.list) {
                calendar.events.list = [];
            }

            calendar.events.list.push(e.data);

            var params = {};
            params.e = e;

            var action = new DayPilot.Action(calendar, "EventAdd", params, data);

            if (calendar._initialized) {
                // calendar.update();
                calendar._update({"eventsOnly": true});
            }

            calendar._angular.notify();

            return action;

        };

        this.events.filter = function(args) {
            calendar.events._filterParams = args;
            // calendar._update();
            calendar._update({"eventsOnly": true});
        };


        this.events.load = function(url, success, error) {
            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.events.list = data;
                    if (calendar._initialized) {
                        // calendar.update();
                        calendar._update({"eventsOnly": true});
                    }
                }
            };

            var usePost = calendar.eventsLoadMethod && calendar.eventsLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "data": { "start": calendar.visibleStart().toString(), "end": calendar.visibleEnd().toString()},
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                var fullUrl = url;
                var queryString = "start=" + calendar.visibleStart().toString() + "&end=" + calendar.visibleEnd().toString();
                if (fullUrl.indexOf("?") > -1) {
                    fullUrl += "&" + queryString;
                }
                else {
                    fullUrl += "?" + queryString;
                }

                DayPilot.ajax({
                    "method": "GET",
                    "url": fullUrl,
                    "success": onSuccess,
                    "error": onError
                });
            }

        };


        this.events.forRange = function(start, end) {
            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);

            return createList(calendar.events.list).filter(function(item) {
                var estart = new DayPilot.Date(item.start);
                var eend = new DayPilot.Date(item.end);
                return overlaps(start, end, estart, eend);
            }).map(function(item) {
                return new DayPilot.Event(item, calendar);
            });
        };


        this.events._overlaps = function(e) {
            if (!e) {
                throw new DayPilot.Exception("Error checking overlap for null (internal error)");
            }

            var data = e instanceof DayPilot.Event ? e.data : e;
            var start = new DayPilot.Date(data.start);
            var end = new DayPilot.Date(data.end);

            var overlapping = createList(calendar.events.list).find(function(item) {
                if (calendar._isSameEvent(data, item)) {
                    return false;
                }
                if (calendar.viewType == "Resources" && data.resource !== item.resource) {
                    return false;
                }
                if (item.allday) {
                    return false;
                }
                var itemStart = new DayPilot.Date(item.start);
                var itemEnd = new DayPilot.Date(item.end);
                return overlaps(start, end, itemStart, itemEnd);
            });
            return !!overlapping;
        };

        this._isSameEvent = function(data1, data2) {
            return DayPilot.Util.isSameEvent(data1, data2);
        };

        this._react = {};
        this._react.reactDOM = null;
        this._react.react = null;
        this._react._ensureDom = function() {
            if (!calendar._react.reactDOM) {
                throw new DayPilot.Exception("Can't reach ReactDOM");
            }
        };
        this._react._render = function(component, target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                if (!root) {
                    root = rd.createRoot(target);
                    target._root = root;
                }
                root.render(component);
            }
            else {
                rd.render(component, target);
            }

        };
        this._react._unmount = function(target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                setTimeout(function() {
                    root.unmount();
                }, 0);
            }
            else {
                rd.unmountComponentAtNode(target);
            }
        };


        this.queue = {};
        this.queue.list = [];
        this.queue.list.ignoreToJSON = true;

        this.queue.add = function(action) {
            if (!action) {
                return;
            }
            if (action.isAction) {
                calendar.queue.list.push(action);
            }
            else {
                throw new DayPilot.Exception("DayPilot.Action object required for queue.add()");
            }
        };

        this.queue.notify = function(data) {
            var params = {};
            params.actions = calendar.queue.list;
            calendar._callBack2('Notify', params, data, "Notify");

            calendar.queue.list = [];
        };


        this.queue.clear = function() {
            calendar.queue.list = [];
        };

        this.queue.pop = function() {
            return calendar.queue.list.pop();
        };

        this._update = function(args) {

            if (!this._initialized || !this._columnsBottom) {  // not initialized yet, don't update
                return;
            }

            var args = args || {};
            var full = !args.eventsOnly;

            calendar._clearCachedValues();

            if (full) {
                if (!this._serverBased()) {
                    calendar.cellProperties = {};
                }

                calendar._resolved._clearCache();

                calendar._deleteEvents();

                calendar._prepareVariables();
                calendar._prepareColumns();
                calendar._filterColumns();
                calendar._loadEvents();

                calendar._drawHeader();
                calendar._autoHeaderHeight();
                calendar._updateHeaderHeight();
                calendar._deleteScrollLabels();
                calendar._updateMessagePosition();
                calendar._hideSelection();
                calendar._drawMain();
                calendar._activateSelection();
                calendar._drawHourTable();

                calendar._updateHeight();
                calendar._fixScrollHeader();

                calendar._updateColumnWidthSpec();
                calendar._updateTheme();

                calendar._drawEvents();
                calendar._drawEventsAllDay();

                calendar._showCurrentTime();

                calendar._updateScrollLabels();
            }
            else {  // events only
                calendar._deleteEvents();
                calendar._loadEvents();
                calendar._updateHeaderHeight();
                calendar._drawEvents();
                calendar._drawEventsAllDay();
                calendar._updateScrollLabels();
            }

            if (this.visible) {
                this.show();
            }
            else {
                this.hide();
            }

        };

        this.update = function(options) {

            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Calendar instance that hasn't been initialized yet.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Calendar instance that has been disposed.");
            }


            // if not initialized yet, load the options but don't update
            if (!calendar._initialized) {
                calendar._loadOptions(options);
                return;
            }

            // selected single-property updates are optimized
            if (DayPilot.Util.isOnlyProperty(options, "events")) {
                calendar.events.list = options.events;
                calendar._update({"eventsOnly": true});
                return;
            }

            // full update
            this._loadOptions(options);
            this._update();

            if (typeof calendar.onAfterRender === 'function') {
                var args = {};
                args.isUpdate = true;
                args.data = null;

                calendar.onAfterRender(args);
            }

        };

        this._updateTheme = function() {

            var className = calendar._prefixCssClass("_main");
            if (calendar.cssClass) {
                className += " " + calendar.cssClass;
            }
            if (calendar.rtl) {
                className += " " + calendar._prefixCssClass("_direction_rtl");
            }

            var needsUpdate = calendar.nav.top.className !== className;
            if (!needsUpdate) {
                return;
            }

            calendar.nav.top.className = className;
            var corner = calendar.nav.corner;
            corner.className = calendar._prefixCssClass("_corner");
            corner.firstChild.className = calendar._prefixCssClass("_corner_inner");
            var cr = calendar.nav.unifiedCornerRight;
            if (cr) {
                cr.firstChild.className = calendar._prefixCssClass("_cornerright");
                cr.firstChild.firstChild.className = calendar._prefixCssClass("_cornerright_inner");
            }
        };


        this.show = function() {
            calendar.visible = true;
            calendar.nav.top.style.display = '';
            calendar._resize();
            // already in _resize()
            // calendar._fixScrollHeader();
            calendar._scroll();
        };

        this.hide = function() {
            calendar.visible = false;
            calendar.nav.top.style.display = 'none';
        };

        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function() {
            if (calendar._angular.scope) {
                calendar._angular.scope["$apply"]();
            }
        };

        this.debug = new DayPilot.Debug(this);

        this._getColumnForPixels = function(x, dontAdjustHack) {

            if (x < 0) {
                return 0;
            }

            if (calendar.rtl) {
                x = calendar.nav.main.offsetWidth - x;
            }

            var i = 0;
            var cells = calendar.nav.events.rows[0].cells;

            if (DayPilot.browser.ie && !dontAdjustHack) {
                for (var j = cells.length - 1; j >= 0; j--) {
                    var cell = cells[j];
                    var width = cell.offsetWidth;
                    i += width;
                    if (x < i) {
                        return j;
                    }
                }
            }
            else {
                for (var j = 0; j < cells.length; j++) {
                    var cell = cells[j];
                    var width = cell.offsetWidth;
                    i += width;
                    if (x < i) {
                        return j;
                    }
                }
                return cells.length - 1;
            }
            return null;
        };

        this._getPixels = function(date, start) {
            if (!start) {
                start = this.startDate;
            }

            var startTicks = start.getTime();
            var ticks = date.getTime();

            var cache = this._cache.pixels[ticks + "_" + startTicks];
            if (cache) {
                return cache;
            }

            var visibleStart = this._visibleStart(true);

            startTicks = start.addHours(this._visibleStart(true)).getTime();

            var boxTicks = this.cellDuration * 60 * 1000;
            var topTicks = ticks - startTicks;
            var boxOffsetTicks = topTicks % boxTicks;

            var boxStartTicks = topTicks - boxOffsetTicks;
            var boxEndTicks = boxStartTicks + boxTicks;
            if (boxOffsetTicks === 0) {
                boxEndTicks = boxStartTicks;
            }

            // it's linear scale so far
            var result = {};
            result.cut = false;
            result.top = this._ticksToPixels(topTicks);
            result.boxTop = this._ticksToPixels(boxStartTicks);
            result.boxBottom = this._ticksToPixels(boxEndTicks);

            this._cache.pixels[ticks + "_" + startTicks] = result;

            return result;
        };

        this._ticksToPixels = function(ticks) {
            return Math.floor((this.cellHeight * ticks) / (1000 * 60 * this.cellDuration));
        };

        this._prepareVariables = function() {
            this.startDate = new DayPilot.Date(this.startDate).getDatePart();
            this._allDayHeaderHeight = resolved._allDayEventHeight() + 4;
        };

        this._updateHeaderHeight = function() {
            var header = this._totalHeaderHeight();
            var total = this._totalHeight();
            //var scroll = total - header;

            if (this.nav.corner) {
                this.nav.corner.style.height = header + "px";
            }
            if (this.nav.cornerRight) {
                this.nav.cornerRight.style.height = header + "px";
            }
            if (this.nav.mid) {
                this.nav.mid.style.height = header + "px";
            }

            if (this.showAllDayEvents && this.nav.header) {
                var row = this.nav.header.rows[this.nav.header.rows.length - 1];
                for (var i = 0; i < row.cells.length; i++) {
                    var column = row.cells[i];
                    column.firstChild.style.height = resolved._allDayHeaderHeight() + "px";
                }
            }

            if (this.nav.upperRight) {
                this.nav.upperRight.style.height = header + "px";
            }

            this.nav.scroll.style.top = header + "px";
            this.nav.top.style.height = total + "px";
            /*
            if (this.heightSpec === "Parent100Pct") {
                this.nav.scroll.style.height = scroll + "px";
            }*/
        };

        this._updateHeight = function() {
            var sh = this._getScrollableHeight();

            if (this.nav.scroll && sh > 0) {
                this.nav.scroll.style.height = sh + "px";
                this._scrollHeight = calendar.nav.scroll.clientHeight;

                // scrolling
                if (this.nav.bottomLeft) {
                    this.nav.bottomLeft.style.height = sh + "px";
                }
                if (this.nav.bottomRight) {
                    this.nav.bottomRight.style.height = sh + "px";
                }
            }

            if (this.heightSpec === "Parent100Pct") {
                this.nav.top.style.height = "100%";
            }
            else {
                this.nav.top.style.height = this._totalHeight() + "px";
            }

        };

        this.setHeight = function(pixels) {
            if (this.heightSpec !== "Parent100Pct") {
                this.heightSpec = "Fixed";
            }
            this.height = pixels - (this._totalHeaderHeight());
            this._updateHeight();
        };

        this._getDimensionsFromCss = function(className) {
            var div = createDiv();
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.className = this._prefixCssClass(className);

            document.body.appendChild(div);
            var height = div.offsetHeight;
            var width = div.offsetWidth;
            document.body.removeChild(div);

            var result = {};
            result.height = height;
            result.width = width;
            return result;
        };

        this._resolved = {};

        var resolved = this._resolved;

        resolved._columnResizing = function() {
            return calendar.columnResizeHandling !== "Disabled";
        };

        resolved._columnMoving = function() {
            return calendar.columnMoveHandling !== "Disabled";
        };

        resolved._columnResizeHandlingIs = function(val) {
            return calendar.columnResizeHandling === val;
        };

        resolved._columnMoveHandlingIs = function(val) {
            return calendar.columnMoveHandling === val;
        };

        resolved._xssProtectionEnabled = function() {
            return calendar.xssProtection !== "Disabled";
        };

        resolved._locale = function() {
            return DayPilot.Locale.find(calendar.locale);
        };

        resolved._weekStarts = function() {
            if (typeof calendar.weekStarts === 'number') {
                return calendar.weekStarts;
            }
            else {
                return resolved._locale().weekStarts;
            }
        };

        resolved._timeFormat = function() {
            if (calendar.timeFormat !== 'Auto') {
                return calendar.timeFormat;
            }
            return resolved._locale().timeFormat;
        };

        resolved._useBox = function(durationTicks) {
            if (calendar.useEventBoxes === 'Always') {
                return true;
            }
            if (calendar.useEventBoxes === 'Never') {
                return false;
            }
            return durationTicks < calendar.cellDuration * 60 * 1000;
        };

        resolved._notifyType = function() {
            var type;
            if (calendar.notifyCommit === 'Immediate') {
                type = "Notify";
            }
            else if (calendar.notifyCommit === 'Queue') {
                type = "Queue";
            }
            else {
                throw new DayPilot.Exception("Invalid notifyCommit value: " + calendar.notifyCommit);
            }

            return type;
        };

        resolved._headerLevels = function() {
            if (calendar.headerLevels === "Auto") {
                return calendar._headerLevelMax + 1;
            }
            return calendar.headerLevels;
        };

        resolved._clearCache = function() {
            delete calendar._cache.allDayEventHeight;
            delete calendar._cache.allDayHeaderHeight;
            delete calendar._cache.headerHeight;
        };

        resolved._allDayEventHeight = function() {
            if (calendar._cache.allDayEventHeight) {
                return calendar._cache.allDayEventHeight;
            }
            var height = calendar._getDimensionsFromCss("_alldayevent_height").height;
            if (!height) {
                height = calendar.allDayEventHeight;
            }
            calendar._cache.allDayEventHeight = height;
            return height;
        };

        resolved._allDayHeaderHeight = function() {
            if (calendar._cache.allDayHeaderHeight) {
                return calendar._cache.allDayHeaderHeight;
            }
            var height = calendar._allDayHeaderHeight;
            calendar._cache.allDayHeaderHeight = height;
            return height;
        };

        resolved._headerHeight = function() {
            if (calendar._cache.headerHeight) {
                return calendar._cache.headerHeight;
            }
            var height = calendar._getDimensionsFromCss("_header_height").height;
            if (!height) {
                height = calendar.headerHeight;
            }
            calendar._cache.headerHeight = height;
            return height;
        };


        // export
        this.exportAs = function(format, options) {
            if (!calendar._visible()) {
                throw new DayPilot.Exception("DayPilot.Calendar.exportAs(): The instance must be visible during export.");
            }

            var board = img._generate(format, options);
            return new DayPilot.Export(board);
        };

        this._img = {};
        var img = this._img;

        img._options = null;
        img._mode = null;

        // ff, ch, ie 9+
        img._generate = function(format, options) {

            /*
            area: "viewport" | "range" | "full"
            scale: number
            quality: number (JPEG only)
            width: number (full only)


            */

            if (typeof format === "object") {
                options = format;
                format = null;
            }

            var options = options || {};
            var format = format || options.format || "svg";
            var scale = options.scale || 1;

            if (format === "config") {
                return;
            }

            // backwards compatibility
            if (format.toLowerCase() === "jpg") {
                format = "jpeg";
            }

            var mode = options.area || "viewport";
            img._options = options;
            img._mode = mode;

            // make sure event positions are calculated
            /*img.getRows().forEach(function(row) {
             calendar._updateEventPositionsInRow(row);
             });*/

            var width = img._getWidth();
            var height = img._getHeight();

            var board;
            switch (format.toLowerCase()) {
                case "svg":
                    board = new DayPilot.Svg(width, height);
                    break;
                case "png":
                    board = new DayPilot.Canvas(width, height, "image/png", scale);
                    break;
                case "jpeg":
                    board = new DayPilot.Canvas(width, height, "image/jpeg", scale, options.quality);
                    break;
                default:
                    throw new DayPilot.Exception("Export format not supported: " + format);
            }

            var rectangles = img._getRectangles();

            // main
            var backColor = new DayPilot.StyleReader(calendar.nav.top).getBackColor();
            var borderColor = new DayPilot.StyleReader(calendar.nav.top).get("border-top-color");
            var visible = new DayPilot.StyleReader(calendar.nav.top).get("border-top-width") !== "0px";
            if (!visible) {
                borderColor = "white";
            }
            var cornerBackground = new DayPilot.StyleReader(calendar.nav.corner.firstChild).getBackColor(backColor);

            // hours

            var hourHeader = calendar.nav.hourTable.rows[0].cells[0].firstChild.firstChild;
            var minutesHeader = hourHeader.getElementsByClassName(calendar._prefixCssClass("_rowheader_minutes"))[0];
            var dividerColor = new DayPilot.StyleReader(hourHeader).get("border-right-color");
            var hourHeaderBackColor = new DayPilot.StyleReader(hourHeader).getBackColor(backColor);
            var hourHeaderFont = new DayPilot.StyleReader(hourHeader).getFont();
            var hourHeaderSupFont = hourHeaderFont;
            var hourHeaderSupPaddingRight = 0;
            if (minutesHeader) {
                hourHeaderSupFont = new DayPilot.StyleReader(hourHeader.firstChild.childNodes[1]).getFont() || hourHeaderSupFont;
                hourHeaderSupPaddingRight = new DayPilot.StyleReader(hourHeader.firstChild.childNodes[1]).getPx("padding-right") || hourHeaderSupPaddingRight;
            }
            var hourHeaderColor = new DayPilot.StyleReader(hourHeader).get("color");

            // columns
            var timeHeader = calendar.nav.header.rows[0].cells[0].firstChild.firstChild;
            var timeHeaderBackground = new DayPilot.StyleReader(timeHeader).getBackColor(backColor);
            var timeHeaderFont = new DayPilot.StyleReader(timeHeader).getFont();
            var timeHeaderColor = new DayPilot.StyleReader(timeHeader).get("color");
            var timeHeaderBorderColor = new DayPilot.StyleReader(timeHeader).get("border-right-color");

            // all-day
            var allDayHeaderParent = calendar.nav.header.rows[calendar.nav.header.rows.length - 1].cells[0].firstChild;
            var allDayHeader = allDayHeaderParent.firstChild;
            var allDayHeaderParentBack = new DayPilot.StyleReader(allDayHeaderParent).getBackColor(backColor);
            var allDayHeaderBackground = new DayPilot.StyleReader(allDayHeader).getBackColor(allDayHeaderParentBack);

            // cells
            var cell = calendar.nav.main.rows[0].cells[0].firstChild.firstChild;
            var cellBorderColor = new DayPilot.StyleReader(cell).get("border-right-color");

            var cell = img._fakeCell();
            var nonBusinessBackColor = new DayPilot.StyleReader(cell.firstChild).getBackColor();
            addClass(cell, calendar._prefixCssClass("_cell_business"));
            var businessBackColor = new DayPilot.StyleReader(cell.firstChild).getBackColor();
            // var cellFont = new DayPilot.StyleReader(cell.firstChild).getFont();
            // var cellColor = new DayPilot.StyleReader(cell.firstChild).get("color");
            deleteElement(cell);


            var viewportOffsetTop = img._getViewportOffsetTop();

            var colWidth = 0;
            if (calendar.columnWidthSpec === "Fixed") {
                colWidth = calendar.columnWidth;
            }
            else {
                colWidth = rectangles.gridContent.w / calendar._columnsBottom.length;
            }

            // background
            board.fillRect(rectangles.main, "white");
            board.fillRect(rectangles.main, backColor);

            // hour headers
            var top = rectangles.corner.h - viewportOffsetTop;
            DayPilot.list.for(calendar._hourRowCount(), function(i) { return calendar._hourRowProps(i); }).forEach(function(row) {
                var height = calendar._hourRowHeight();
                // var text = row.html;
                //var text = row.start.toString("H:mm");
                var hour = row.hour;
                var sup = row.sup;

                var text = row.text ? row.text : hour;

                var supWidth = 0;
                if (minutesHeader) {
                    supWidth = 20;
                }

                var rect = {"x": 0, "y": top, "w": rectangles.grid.x + 1, "h": height + 1};
                var rectText = {"x": 0, "y": top, "w": rectangles.grid.x + 1 - supWidth, "h": height + 1};
                var rectTextSup = {"x": rectText.w, "y": top, "w": supWidth - hourHeaderSupPaddingRight - 1, "h": height + 1};

                var backColor = hourHeaderBackColor;
                board.fillRect(rect, backColor);
                // board.text(rectText, text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle}, args.fontColor, args.horizontalAlignment);
                board.text(rectText, text, hourHeaderFont, hourHeaderColor, "right");
                if (minutesHeader) {
                    board.text(rectTextSup, sup, hourHeaderSupFont, hourHeaderColor, "right");
                }
                board.rect(rect, dividerColor);

                top += height;

            });

            var step = calendar.cellDuration * 60 * 1000;

            // cells
            var left = rectangles.grid.x;
            createList(calendar._columnsBottom).forEach(function(col, x) {
                var width = colWidth;
                var top = rectangles.grid.y - viewportOffsetTop;
                // not rows
                DayPilot.list.for(calendar._rowCount()).forEach(function(row, y) {

                    var props = calendar._getProperties(x, y) || {};

                    var backColorDetected = null;
                    if (props.cssClass) {
                        var cell = img._fakeCell();
                        addClass(cell, props.cssClass);
                        backColorDetected = new DayPilot.StyleReader(cell.firstChild).getBackColor();
                        deleteElement(cell);
                    }

                    var height = calendar.cellHeight;

                    var rect = {"x": left, "y": top, "w": width + 1, "h": height + 1};


                    var isBusiness = props.business; // this._isBusinessCell(c.start, c.end);

                    var args = {};
                    args.cell = {};
                    args.cell.start = col.start.addTime(y * step).addHours(calendar._visibleStart());
                    args.cell.end = args.cell.start.addTime(step);
                    args.cell.resource = col.id;

                    copyProps(props, args.cell, ['cssClass', 'html', 'backImage', 'backRepeat', 'backColor', 'business']);

                    args.backColor = backColorDetected || (isBusiness ? businessBackColor : nonBusinessBackColor);

                    if (typeof calendar.onBeforeCellExport === "function") {
                        calendar.onBeforeCellExport(args);
                    }

                    board.fillRect(rect, args.backColor);
                    board.rect(rect, cellBorderColor);

                    top += height;
                });
                left += width;
            });

            // events
            var colLeft = rectangles.grid.x;
            createList(calendar._columnsBottom).forEach(function(col) {

                createList(col.events).forEach(function(e) {

                    var cache = e.cache || e.data;

                    // detection
                    var eventDiv = img._fakeEvent();
                    eventDiv.className += " " + cache.cssClass;
                    var barDiv = eventDiv.firstChild;
                    var eventInnerDiv = eventDiv.childNodes[1];
                    var eventBarBackColor = new DayPilot.StyleReader(barDiv).getBackColor();
                    var eventBarColor = new DayPilot.StyleReader(barDiv.firstChild).getBackColor();
                    var eventBarWidth = new DayPilot.StyleReader(barDiv.firstChild).getPx("width");

                    var eventBorderColor = new DayPilot.StyleReader(eventInnerDiv).get("border-right-color");
                    var eventFont = new DayPilot.StyleReader(eventInnerDiv).getFont();
                    var eventColor = new DayPilot.StyleReader(eventInnerDiv).get("color");
                    var eventBackColor = new DayPilot.StyleReader(eventInnerDiv).getBackColor();
                    var eventPadding = {};
                    eventPadding.left = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-left");
                    eventPadding.right = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-right");
                    eventPadding.top = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-top");
                    eventPadding.bottom = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-bottom");

                    deleteElement(eventDiv);
                    // END detection

                    var left = colLeft + colWidth*e.part.left/100;
                    var width = (colWidth - calendar.columnMarginRight)*e.part.width/100;
                    var top = e.part.top + rectangles.grid.y - calendar._autoHiddenPixels() - viewportOffsetTop;
                    var height = e.part.height;

                    //var cache = e.cache || e.data;
                    var backColor = cache.backColor || eventBackColor;
                    var barColor  = cache.barColor || eventBarColor;
                    var barBackColor  = cache.barBackColor || eventBarBackColor;
                    var borderColor = cache.borderColor || eventBorderColor;

                    var args = {};
                    args.e = e;
                    args.text = e.text ? e.text() : e.client.html();
                    // args.text = e.client.html();
                    args.fontSize = eventFont.size;
                    args.fontFamily = eventFont.family;
                    args.fontStyle = eventFont.style;
                    args.fontColor = eventColor;
                    args.backColor = backColor;
                    args.borderColor = borderColor;
                    args.horizontalAlignment = "left";
                    args.barWidth = eventBarWidth;
                    args.barColor = barColor;
                    args.barBackColor = barBackColor;

                    if (typeof calendar.onBeforeEventExport === "function") {
                        calendar.onBeforeEventExport(args);
                    }

                    var rect = {"x": left, "y": top, "w": width + 1, "h": height + 1};

                    var rectInner = copyProps(rect);

/*                    if (e.client.barVisible()) {
                        rectInner.x += args.barWidth;
                        rectInner.w -= args.barWidth;
                    }*/

                    var rectText = copyProps(rectInner);
                    rectText.x += eventPadding.left;
                    rectText.w -= eventPadding.left + eventPadding.right;
                    rectText.y += eventPadding.top;
                    rectText.h -= eventPadding.top + eventPadding.bottom;

                    board.fillRect(rect, args.backColor);
                    if (e.client.barVisible()) {
                        var rectBar = {"x": rect.x, "y": rect.y, "w": args.barWidth, "h": rect.h};
                        var rectBarInner = {"x": rect.x, "y": rect.y + 1 + e.part.barTop, "w": args.barWidth, "h": e.part.barHeight + 1};

                        board.fillRect(rectBar, args.barBackColor);
                        board.fillRect(rectBarInner, args.barColor);
                    }

                    board.text(rectText, args.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle}, args.fontColor, args.horizontalAlignment);
                    board.rect(rect, args.borderColor);

                    var left = rect.x;
                    var right = rect.x + rect.w - 2;
                    var top = rect.y;

                    createList(cache.areas).forEach(function(area) {

                        if (!DayPilot.Areas.isVisible(area)) {
                            return;
                        }

                        var areaLeft = area.left;
                        if (area.start) {
                            areaLeft = calendar.getPixels(new DayPilot.Date(area.start)).left - e.part.left;
                        }

                        var width = area.width || area.w;
                        var height = area.height || area.h;

                        if (!areaLeft) {
                            areaLeft = right - width - left;
                        }

                        if (area.right) {
                            width = (e.part.width - area.right) - areaLeft;
                        }
                        else if (area.end) {
                            width = calendar.getPixels(new DayPilot.Date(area.end)).left - area.left - e.part.left + 1;
                        }
                        var areaTop = area.top;

                        if (typeof area.bottom === "number") {
                            height = (e.part.height - area.bottom) - areaTop;
                        }

                        var rect = {"x": left + areaLeft, "y": top + areaTop, "w": width, "h": height};

                        if (area.backColor) {
                            board.fillRect(rect, area.backColor);
                        }
                        if (area.image) {
                            var img = new Image();
                            img.src = area.image;
                            board.image(rect, img);
                        }
                        else if (area.html) {
                            board.text(rect, area.html, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle} , area.fontColor || args.fontColor, null, area.padding);
                        }

                    });

                });

                colLeft += colWidth;
            });

            // corner
            board.fillRect(rectangles.corner, cornerBackground);

            // draw column headers
            // var fixed = this.columnWidthSpec === 'Fixed';
            var colwbase = 1;
            if (calendar.columnWidthSpec !== "Fixed") {
                colwbase = rectangles.gridContent.w/100;
            }

            // column headers
            DayPilot.list.for(resolved._headerLevels()).forEach(function(level) {
                var left = rectangles.gridContent.x;
                var top = calendar.headerHeight * level;
                //var columns = calendar._generateColumns() ? calendar._columnsBottom : calendar._columns;
                var columns = calendar._getColumns(level + 1);
                var coldims = calendar._getColSpans(level);

                createList(columns).forEach(function(col, i) {

                    // col properties:
                    // copyProps(data, args.header, ['id', 'start', 'name', 'html', 'backColor', 'toolTip', 'areas', 'children']);
                    // this.onBeforeHeaderRender(args);
                    // copyProps(args.header, data, ['html', 'backColor', 'toolTip', 'areas']);

                    var args = {};
                    args.text = DayPilot.Util.stripTags(col.html);
                    args.horizontalAlignment = "center";
                    args.verticalAlignment = "center";
                    args.backColor = col.backColor || timeHeaderBackground;
                    args.fontSize = timeHeaderFont.size;
                    args.fontFamily = timeHeaderFont.family;
                    args.fontStyle = timeHeaderFont.style;
                    args.fontColor = timeHeaderColor;
                    args.header = {};
                    args.header.level = level;
                    copyProps(col, args.header, ['id', 'start', 'name', 'html', 'backColor']);

                    if (typeof calendar.onBeforeHeaderExport === "function") {
                        calendar.onBeforeHeaderExport(args);
                    }

                    var lastrow = coldims.length === 0;

                    var width = lastrow  ? colWidth : coldims[i].width * colwbase;
                    var x = lastrow ? left : left + coldims[i].left * colwbase;
                    var height = calendar.headerHeight;

                    var cellRect = {"x": x, "y": top, "w": width + 1, "h": height + 1};

                    board.fillRect(cellRect, args.backColor);
                    board.rect(cellRect, timeHeaderBorderColor);
                    board.text(cellRect, args.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle}, args.fontColor, args.horizontalAlignment, 0, args.verticalAlignment);

                    if (lastrow) {
                        left += colWidth;
                    }
                });
            });

            // all-day events
            (function() {
                if (!calendar.showAllDayEvents) {
                    return;
                }

                // header
                var top = calendar.headerHeight * resolved._headerLevels();
                var left = rectangles.gridContent.x;
                createList(calendar._columnsBottom).forEach(function(col) {
                    var width = colWidth;
                    var height = resolved._allDayHeaderHeight();

                    var cellRect = {"x": left, "y": top, "w": width + 1, "h": height + 1};

                    // var text = col.html;

                    board.fillRect(cellRect, allDayHeaderBackground);
                    board.rect(cellRect, timeHeaderBorderColor);

                    left += colWidth;

                });

                // all-day events
                createList(calendar._allDay.lines).forEach(function(line, j) {
                    createList(line).forEach(function(e) {

                        // detection
                        var eventDiv = img._fakeEvent("alldayevent");
                        eventDiv.className += " " + e.data.cssClass;
                        // var barDiv = eventDiv.firstChild;
                        var eventInnerDiv = eventDiv.firstChild;
                        // var eventBarBackColor = new DayPilot.StyleReader(barDiv).getBackColor();
                        // var eventBarColor = new DayPilot.StyleReader(barDiv.firstChild).getBackColor();
                        // var eventBarWidth = new DayPilot.StyleReader(barDiv.firstChild).getPx("width");

                        var eventBorderColor = new DayPilot.StyleReader(eventInnerDiv).get("border-right-color");
                        var eventFont = new DayPilot.StyleReader(eventInnerDiv).getFont();
                        var eventColor = new DayPilot.StyleReader(eventInnerDiv).get("color");
                        var eventBackColor = new DayPilot.StyleReader(eventInnerDiv).getBackColor();
                        var eventPadding = {};
                        eventPadding.left = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-left");
                        eventPadding.right = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-right");
                        eventPadding.top = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-top");
                        eventPadding.bottom = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-bottom");

                        deleteElement(eventDiv);
                        // END detection

                        var cache = e.cache || e.data;
                        var backColor = cache.backColor || eventBackColor;
                        var borderColor = cache.borderColor || eventBorderColor;
                        var fontColor = cache.fontColor || eventColor;

                        var args = {};
                        args.e = e;
                        args.text = e.text ? e.text() : e.client.html();
                        args.fontSize = eventFont.size;
                        args.fontFamily = eventFont.family;
                        args.fontStyle = eventFont.style;
                        args.fontColor = fontColor;
                        args.backColor = backColor;
                        args.borderColor = borderColor;
                        args.horizontalAlignment = "left";

                        if (typeof calendar.onBeforeEventExport === "function") {
                            calendar.onBeforeEventExport(args);
                        }

                        // var left = (100.0 * data.part.colStart / columns) + "%";
                        var left = e.part.colStart * colWidth + rectangles.gridContent.x + 2;
                        var width = e.part.colWidth * colWidth - 4;
                        var height = resolved._allDayEventHeight() - 1;
                        var top = (resolved._headerLevels() * resolved._headerHeight() + j * (resolved._allDayEventHeight())) + 2;

                        var rect = {"x": left, "y": top, "w": width, "h": height};
                        var rectText = copyProps(rect);
                        rectText.x += eventPadding.left;
                        rectText.w -= eventPadding.left + eventPadding.right;
                        rectText.y += eventPadding.top;
                        rectText.h -= eventPadding.top + eventPadding.bottom;

                        board.fillRect(rect, args.backColor);
                        //var text = e.client.html();

                        board.text(rectText, args.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle}, args.fontColor, args.horizontalAlignment);
                        board.rect(rect, args.borderColor);

                        var right = rect.x + rect.w - 2;

                        // areas
                        // check:
                        // - areas source (e.data.areas)
                        // missing:
                        // - right (is it event right?)
                        var areas = cache.areas;
                        var ewidth = width;
                        var eheight = height;
                        createList(areas).forEach(function(area) {

                            if (!DayPilot.Areas.isVisible(area)) {
                                return;
                            }

                            var areaLeft = area.left;
                            var width = area.width || area.w;
                            var height = area.height || area.h;

                            if (!areaLeft) {
                                areaLeft = right - width - left;
                            }

                            if (area.right) {
                                width = (ewidth - area.right) - areaLeft;
                            }
                            var areaTop = area.top;

                            if (typeof area.bottom === "number") {
                                height = (eheight - area.bottom) - areaTop;
                            }

                            var rect = {"x": left + areaLeft, "y": top + areaTop, "w": width, "h": height};

                            if (area.backColor) {
                                board.fillRect(rect, area.backColor);
                            }
                            if (area.image) {
                                var img = new Image();
                                img.src = area.image;
                                board.image(rect, img);
                            }
                            else if (area.html) {
                                board.text(rect, area.html, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle} , area.fontColor || args.fontColor, null, area.padding);
                            }

                        });

                    });
                });
            })();

            // frame
            board.rect(rectangles.main, borderColor);
            board.line(rectangles.grid.x, 0, rectangles.grid.x, rectangles.main.h, dividerColor);
            board.line(0, rectangles.grid.y, rectangles.main.w, rectangles.grid.y, dividerColor);

            return board;

        };

        img._fakeCell = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_cell");

            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_cell_inner");
            div.appendChild(inner);

            // calendar.divCells.appendChild(div);
            //var c = calendar.nav.main.rows[0].insertCell(-1);

            calendar.nav.bottomRight.appendChild(div);

            return div;
        };


        img._fakeEvent = function(type) {
            type = type || "event";   // "event" | "alldayevent"

            var div = createDiv();
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_" + type);

            if (type === "event") {
                var bar = createDiv();
                bar.className = calendar._prefixCssClass("_event_bar");
                var barInner = createDiv();
                barInner.className = calendar._prefixCssClass("_event_bar_inner");
                bar.appendChild(barInner);
                div.appendChild(bar);
            }

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_" + type + "_inner");
            div.appendChild(inner);

            var wrapper = calendar.nav.events.rows[0].cells[0].events;
            if (type === "alldayevent") {
                wrapper = calendar.nav.allday;
            }
            wrapper.appendChild(div);

            return div;
        };

        img._getViewportOffsetTop = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    return 0;
                case "viewport":
                    var scroll = calendar._scrollDiv();
                    return scroll.scrollTop;
                case "range":
                    var scroll = calendar._scrollDiv();
                    return scroll.scrollTop;
            }
        };

        img._getWidth = function() {
            var mode = img._mode;

            var fullw = calendar.nav.top.clientWidth;
            var contentw = fullw - calendar.hourWidth;
            var colCount = calendar._columnsBottom.length;
            var clientWidth = Math.floor(contentw/colCount) * colCount + calendar.hourWidth;

            switch (mode) {
                case "viewport":
                case "full":
                case "range":
                    if (typeof img._options.width === "number") {
                        return img._options.width;
                    }
                    return clientWidth;

                /*
                 case "viewport":
                 return calendar.nav.top.offsetWidth;
                 case "range":
                 return calendar.getPixels(img.getRangeEnd()).boxRight - calendar.getPixels(img.getRangeStart()).boxLeft + img.getRowHeaderWidth();
                 */
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img._getHeight = function() {
            var mode = img._mode;

            switch (mode) {
                case "full":
                    return calendar._getInnerHeight() + calendar._totalHeaderHeight();
                case "viewport":
                    return calendar.nav.top.offsetHeight - DayPilot.sh(calendar.nav.scroll) - 1;
                /*
                 case "viewport":
                 return calendar.nav.top.offsetHeight - DayPilot.sh(calendar.nav.scroll) - 1;
                 case "range":
                 var rows = img.getRows();
                 if (rows.length === 0) {
                 return calendar._getTotalHeaderHeight();
                 }
                 else {
                 var from = rows.first();
                 var to = rows.last();
                 // return to.top - from.top + to.height + calendar._getTotalHeaderHeight();
                 return to.top - from.top + to.height + calendar._getTotalHeaderHeight();
                 }
                 */
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img._getRectangles = function() {
            var rowHeaderWidth = img._getRowHeaderWidth();
            var columnHeaderHeight = calendar._totalHeaderHeight();

            var rectangles = {};
            rectangles.main = {"x": 0, "y": 0, "w": img._getWidth(), "h": img._getHeight()};
            rectangles.corner = {"x": 0, "y": 0, "w": rowHeaderWidth, "h": columnHeaderHeight};
            rectangles.grid = {"x": rowHeaderWidth, "y": columnHeaderHeight, "w": img._getWidth() - rowHeaderWidth, "h": img._getHeight() - columnHeaderHeight};

            var width = img._innerWidth();
            var height = calendar._getInnerHeight();
            rectangles.gridContent = {"x": rowHeaderWidth, "y": columnHeaderHeight, "w": width, "h": height};

            return rectangles;
        };

        img._getRowHeaderWidth = function() {
            return calendar.hourWidth;
        };

        img._innerWidth = function() {
            var w = calendar._scrollDiv().offsetWidth;
            var colc = calendar._columnsBottom.length;
            return Math.floor(w/colc) * colc;
            /*
             if (this.columnWidthSpec === 'Fixed') {
             return calendar.hourWidth + calendar._scrollDiv().clientWidth;
             }
             return calendar.nav.top.clientWidth;
             */
        };

        this._isShortInit = function() {
            return !!this.backendUrl;

            /*
            // make sure it has a place to ask
            if (this.backendUrl) {
                return (typeof calendar.events.list === 'undefined') || (!calendar.events.list);
            }
            else {
                return false;
            }*/
        };

        this._loadTop = function() {
            if (this.id && this.id.tagName) {
                this.nav.top = this.id;
            }
            else if (typeof this.id === "string") {
                this.nav.top = document.getElementById(this.id);
                if (!this.nav.top) {
                    throw new DayPilot.Exception("DayPilot.Calendar: The placeholder element not found: '" + id + "'.");
                }
            }
            else {
                throw new DayPilot.Exception("DayPilot.Calendar() constructor requires the target element or its ID as a parameter");
            }
            this.nav.limit;
        };


        this._initShort = function() {
            this._loadTop();
            this._prepareVariables();
            this._prepareColumns();
            this._drawTop();
            this._drawHeader();
            this._autoHeaderHeight();
            this._drawMain();
            this._updateTheme();
            this._fixScrollHeader();
            this._enableScrolling();
            this._registerGlobalHandlers();
            this._registerDispose();
            this._updateColumnWidthSpec();
            DayPilotCalendar._register(this);

            this._resize(); // adjust the height if 100%

            this._showCurrentTime();

            this._waitForVisibility();
            this._startAutoRefresh();
            this._callBack2('Init');
        };

        this.init = function() {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.")
            }

            this._loadTop();

            if (this.nav.top.dp) {
                if (this.nav.top.dp === calendar) {
                    return calendar;
                }
                if (this._isAspnetWebForms()) { // updatepanel
                    return calendar;
                }
                throw new DayPilot.Exception("The target placeholder was already initialized by another DayPilot component instance.");
            }

            this._versionCheck();

            var loadFromServer = this._isShortInit();

            if (loadFromServer) {
                this._initShort();
                this._initialized = true;
                return this;
            }

            this._prepareVariables();
            this._prepareColumns();
            this._expandCellProperties();

            if (!this.events.list) {
                this.events.list = [];
            }

            this._loadEvents();

            this._drawTop();
            this._drawHeader();
            this._autoHeaderHeight();
            this._drawMain();
            this._updateTheme();

            this._show();
            this._updateColumnWidthSpec();

            this._fixScrollHeader();
            this._enableScrolling();
            this._registerGlobalHandlers();
            this._registerDispose();
            DayPilotCalendar._register(this);

            this._updateHeaderHeight();
            this._drawEvents();
            this._drawEventsAllDay();

            this._resize(); // adjust the height if 100%

            if (this.messageHTML) {
                window.setTimeout(function() { calendar.message(calendar.messageHTML); }, 0);
            }

            this._showCurrentTime();

            this._fireAfterRenderDetached(null, false);

            if (calendar.initEventEnabled) {
                setTimeout(function() {
                    calendar._callBack2("Init");
                });
            }

            this._waitForVisibility();
            // this._watchWidthChanges();
            this._startAutoRefresh();
            this._initialized = true;
            this._postInit();

            return this;
        };

        this._specialHandling = null;
        this._loadOptions = function(options) {
            if (!options) {
                return;
            }
            var specialHandling = {
                "events": {
                    "preInit": function() {
                        var events = this.data;
                        if (!events) {
                            return;
                        }
                        if (DayPilot.isArray(events.list)) {
                            calendar.events.list = events.list;
                        }
                        else {
                            calendar.events.list = events;
                        }
                    }
                },
                "columns": {
                    "preInit": function() {
                        if (calendar._columnsList() === calendar.columns) {
                            calendar.columns = this.data;
                        }
                        else {
                            calendar.columns.list = this.data;
                        }
                    }
                },
                "scrollToHour": {
                    "postInit": function() {
                        if (typeof this.data !== 'undefined') {
                            calendar.scrollToHour(this.data);
                        }
                    }
                },
                "zoom": {
                    "preInit": function() {
                        var index = this.data;

                        if (typeof index === "string") {
                            var id = index;
                            index = calendar.zoom._findById(id);
                        }

                        var levelChanged = index !== calendar.zoom.active;

                        var hour = calendar.zoom._currentHourPos();
                        var args = calendar.zoom._applyLevelProps(index);

                        if (levelChanged) {
                            this.hour = hour;
                        }
                        else {
                            this.hour = null;
                        }
                    },
                    "postInit": function() {
                        if (this.hour) {
                            calendar.scrollToHour(this.hour);
                        }
                    }
                },

            };
            this._specialHandling = specialHandling;

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    calendar[name] = options[name];
                }
            }

        };

        this._postInit = function() {
            var specialHandling = this._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
        };

        // communication between components
        this.internal = {};
        // ASP.NET
        this.internal.initialized = function() {
            return calendar._initialized;
        };

        // DayPilot.Action
        this.internal.invokeEvent = this._invokeEvent;
        // DayPilot.Menu
        this.internal.eventMenuClick = this._eventMenuClick;
        this.internal.timeRangeMenuClick = this._timeRangeMenuClick;
        // DayPilot.Bubble
        this.internal.bubbleCallBack = this._bubbleCallBack;
        this.internal.findEventDiv = this._findEventDiv;

        this.internal.eventDeleteDispatch = this._eventDeleteDispatch;
        this.internal.xssTextHtml = calendar._xssTextHtml;

        this.internal.touch = this._touch;

        // React
        this.internal.enableReact = function (react, reactDOM) {
            calendar._react.react = react;
            calendar._react.reactDOM = reactDOM;
        };
        this.internal.reactRefs = function() {
            return copyProps(calendar._react, {}, ["react", "reactDOM"]);
        };

        // Angular
        this.internal.loadOptions = calendar._loadOptions;


        this.Init = this.init;
        this._loadOptions(options);
    };


    var DayPilotCalendar = {};

    // internal selecting
    DayPilotCalendar._topSelectedCell = null;
    DayPilotCalendar._bottomSelectedCell = null;
    DayPilotCalendar._selectedColumn = null;
    DayPilotCalendar._firstSelected = null;
    DayPilotCalendar._firstMousePos = null;

    // internal resizing
    DayPilotCalendar._originalMouse = null;
    DayPilotCalendar._originalHeight = null;
    DayPilotCalendar._originalTop = null;
    //DayPilotCalendar.resizing = null;
    DayPilotCalendar._globalHandlers = false;

    // internal moving
    //DayPilotCalendar.moving = null;
    //DayPilotCalendar.originalLeft = null;

    // internal editing
    DayPilotCalendar.editing = false;
    DayPilotCalendar.originalText = null;

    // scrollbar width
    //DayPilotCalendar.scrollWidth = null;

    // helpers
    DayPilotCalendar._register = function(calendar) {
        if (!DayPilotCalendar._registered) {
            DayPilotCalendar._registered = [];
        }
        var r = DayPilotCalendar._registered;

        for (var i = 0; i < r.length; i++) {
            if (r[i] === calendar) {
                return;
            }
        }
        r.push(calendar);
    };

    DayPilotCalendar._unregister = function(calendar) {
        var a = DayPilotCalendar._registered;
        if (a) {
            var i = DayPilot.indexOf(a, calendar);
            if (i !== -1) {
                a.splice(i, 1);
            }
            if (a.length === 0) {
                a = null;
            }
        }

        if (!a) {
            DayPilot.ue(document, 'mousemove', DayPilotCalendar._gMouseMove);
            DayPilot.ue(document, 'mouseup', DayPilotCalendar._gMouseUp);
            DayPilot.ue(document, 'touchmove', DayPilotCalendar._gTouchMove);
            DayPilot.ue(document, 'touchend', DayPilotCalendar._gTouchEnd);
            //DayPilot.ue(window, 'unload', DayPilotCalendar._gUnload);
            DayPilotCalendar._globalHandlers = false;
        }
    };


    DayPilotCalendar._getCellsAbove = function(cell) {
        if (cell.data && cell.data.calendar._divBasedGrid) {
            var calendar = cell.data.calendar;
            var array = [];
            var yStart = cell.data.y;
            var x = cell.data.x;
            var yEnd = DayPilotCalendar._firstSelected.data.y;

            for (var y = yStart; y >= yEnd; y--) {
                array.push(calendar.nav.main.rows[y].cells[x]);
            }
            return array;
        }
        else {

            var array = [];
            var c = DayPilotCalendar._getColumn(cell);

            var tr = cell.parentNode;

            var select = null;
            while (tr && select !== DayPilotCalendar._firstSelected) {
                select = tr.getElementsByTagName("td")[c];
                array.push(select);
                tr = tr.previousSibling;
                while (tr && tr.tagName !== "TR") {
                    tr = tr.previousSibling;
                }
            }
            return array;
        }
    };

    DayPilotCalendar._getCellsBelow = function(cell) {

        if (cell.data && cell.data.calendar._divBasedGrid) {
            var calendar = cell.data.calendar;
            var array = [];
            var yStart = cell.data.y;
            var x = cell.data.x;
            var yEnd = DayPilotCalendar._firstSelected.data.y;

            for (var y = yStart; y <= yEnd; y++) {
                array.push(calendar.nav.main.rows[y].cells[x]);
            }
            return array;
        }
        else {
            var array = [];
            var c = DayPilotCalendar._getColumn(cell);
            var tr = cell.parentNode;

            var select = null;
            while (tr && select !== DayPilotCalendar._firstSelected) {
                select = tr.getElementsByTagName("td")[c];
                array.push(select);
                tr = tr.nextSibling;
                while (tr && tr.tagName !== "TR") {
                    tr = tr.nextSibling;
                }
            }
            return array;
        }
    };

    DayPilotCalendar._getColumn = function(cell) {
        var i = 0;
        if (!cell) {
            return null;
        }
        while (cell.previousSibling) {
            cell = cell.previousSibling;
            if (cell.tagName === "TD") {
                i++;
            }
        }
        return i;
    };

    DayPilotCalendar._gTouchMove = function(ev) {

        if (isMouseEvent(ev)) {
            return;
        }

        if (DayPilotCalendar.drag) {
            ev.preventDefault();

            var x = ev.touches ? ev.touches[0].pageX : ev.pageX;
            var y = ev.touches ? ev.touches[0].pageY : ev.pageY;

            var mousePos = {};
            mousePos.x = x;
            mousePos.y = y;

            var calendar = (function() {
                var clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
                var clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;
                var el = document.elementFromPoint(clientX, clientY);
                while (el && el.parentNode) {
                    el = el.parentNode;
                    if (el.daypilotMainD) {
                        return el.calendar;
                    }
                }
                return false;
            })();

            if (calendar) {

                // hide the global shadow
                if (DayPilotCalendar.gShadow) {
                    document.body.removeChild(DayPilotCalendar.gShadow);
                }
                DayPilotCalendar.gShadow = null;

                calendar.coords = calendar._touch._relativeCoords(ev);

                // copied from onmainmousemove

                if (!DayPilotCalendar.movingShadow && calendar.coords) {

                    var shadow = calendar._createShadow(DayPilotCalendar.drag, false);

                    if (shadow) {
                        DayPilotCalendar.movingShadow = shadow;

                        var now = DayPilot.Date.today();

                        var ev = { 'value': DayPilotCalendar.drag.id, 'start': now, 'end': now.addSeconds(DayPilotCalendar.drag.duration), 'text': DayPilotCalendar.drag.text };
                        var event = new DayPilot.Event(ev, calendar);
                        //event.calendar = calendar;
                        //event.root = calendar;
                        event.external = true;

                        DpGlobal.moving = {};
                        DpGlobal.moving.event = event;
                        DpGlobal.moving.helper = {};
                    }
                }

                if (DpGlobal.moving) {
                    calendar._touch._updateMoving();
                }
            }
            else {

                // hide the local shadow
                deleteElement(DayPilotCalendar.movingShadow);
                var c = DpGlobal.moving && DpGlobal.moving.event && DpGlobal.moving.event.calendar;
                if (c) {
                    removeClass(DpGlobal.moving, c._prefixCssClass("_event_moving_source"));
                }
                DpGlobal.moving = null;
                DayPilotCalendar.movingShadow = null;

                if (!DayPilotCalendar.gShadow) {
                    DayPilotCalendar.gShadow = DayPilotCalendar.createGShadow(DayPilotCalendar.drag.shadowType);
                }

                var shadow = DayPilotCalendar.gShadow;
                shadow.style.left = mousePos.x + 'px';
                shadow.style.top = mousePos.y + 'px';
            }
        }
    };

    DayPilotCalendar._gTouchEnd = function(ev) {
        if (isMouseEvent(ev)) {
            return;
        }

        DayPilotCalendar._gMouseUp(ev);
    };

    DayPilotCalendar._gMouseMove = function(ev) {

        if (typeof (DayPilotCalendar) === 'undefined') {
            return;
        }

        // quick and dirty inside detection
        // hack, but faster then recursing through the parents
        if (ev.insideMainD) {  // FF
            return;
        }
        else if (ev.srcElement) {  // IE
            if (ev.srcElement.inside) {
                return;
            }
        }

        var mousePos = DayPilot.mc(ev);

        if (DayPilotCalendar.drag) {

            var options = DayPilotCalendar.drag._dragOptions;

            var cursor = "move";
            if (typeof options.externalCursor === "string") {
                cursor = options.externalCursor;
            }
            document.body.style.cursor = cursor;

            if (!DayPilotCalendar.gShadow) {
                DayPilotCalendar.gShadow = DayPilotCalendar.createGShadow(DayPilotCalendar.drag.shadowType);
            }

            var shadow = DayPilotCalendar.gShadow;
            var offset = 5;
            var x = mousePos.x - offset;
            var y = mousePos.y - offset;
            shadow.style.left = x + 'px';
            shadow.style.top = y + 'px';
            shadow.style.cursor = cursor;

            if (options.externalHtml) {
                shadow.innerHTML = options.externalHtml;
            }
            if (options.externalCssClass) {
                addClass(shadow, options.externalCssClass);
            }

            // removeClass(DpGlobal.moving, calendar._prefixCssClass("_event_moving_source"));
            DpGlobal.moving = null;
            deleteElement(DayPilotCalendar.movingShadow);
            DayPilotCalendar.movingShadow = null;
        }

        for (var i = 0; i < DayPilotCalendar._registered.length; i++) {
            if (DayPilotCalendar._registered[i]._out) {
                DayPilotCalendar._registered[i]._out();
            }
        }

    };

    DayPilotCalendar._gUnload = function(ev) {

        if (!DayPilotCalendar._registered) {
            return;
        }
        var r = DayPilotCalendar._registered;

        for (var i = 0; i < r.length; i++) {
            var c = r[i];
            //c.dispose();

            DayPilotCalendar._unregister(c);
        }

    };

    DayPilotCalendar._gMouseUp = function(e) {
        var e = e || window.event;

        if (DpGlobal.resizing) {
            if (!DayPilotCalendar.resizingShadow) {
                DpGlobal.resizing.style.cursor = 'default';
                //document.body.style.cursor = 'default';
                DpGlobal.resizing.event.calendar.nav.top.style.cursor = 'auto';
                DpGlobal.resizing = null;
                return;
            }

            var dpEvent = DpGlobal.resizing.event;
            var border = DpGlobal.resizing.dpBorder;
            var height = DayPilotCalendar.resizingShadow.clientHeight;
            var top = DayPilotCalendar.resizingShadow.offsetTop;

            var args = DayPilotCalendar.resizingShadow.args;
            var calendar = dpEvent.calendar;

            // stop resizing on the client
            DpGlobal.resizing.style.cursor = 'default';
            calendar.nav.top.style.cursor = 'auto';

            DpGlobal.resizing.onclick = null;  // trying to prevent onclick, the event should be always recreated

            DpGlobal.resizing = null;

            if (!args.allowed) {
                calendar._clearResizingShadow();
                return;
            }

            dpEvent.calendar._eventResizeDispatch(dpEvent, height, top, border);
        }
        else if (DpGlobal.moving) {

            var cleanup = function() {
                DpGlobal.movingAreaData = null;
                var calendar = DpGlobal.moving && DpGlobal.moving.event && DpGlobal.moving.event.calendar;
                if (calendar) {
                    removeClass(DpGlobal.moving, calendar._prefixCssClass("_event_moving_source"));
                }
                DpGlobal.moving = null;
                deleteElement(DayPilotCalendar.movingShadow);
                DayPilotCalendar.movingShadow = null;
            };

            if (!DpGlobal.moving.helper) {   // UpdatePanel refreshed during moving
                cleanup();
                return;
            }
            if (!DayPilotCalendar.movingShadow) {
                DpGlobal.moving.event.calendar.nav.top.style.cursor = 'auto';
                cleanup();
                return;
            }


            // var oldColumn = DpGlobal.moving.helper.oldColumn;
            var top = DayPilotCalendar.movingShadow.offsetTop;

            var dpEvent = DpGlobal.moving.event;
            var calendar = dpEvent.calendar;

            calendar._lastEventMoving = args;

            var newColumnIndex = DayPilotCalendar.movingShadow.column;

            var drag = DayPilotCalendar.drag;

            DpGlobal.moving.event.calendar.nav.top.style.cursor = 'auto';

            var args = DayPilotCalendar.movingShadow.args;

            // moved to cleanup
            // DpGlobal.moving = null;

            if (drag) {
                if (!dpEvent.calendar.todo) {
                    dpEvent.calendar.todo = {};
                }
                dpEvent.calendar.todo.del = drag.element;
            }

            if (args && !args.allowed) {
                calendar._clearMovingShadow();
                cleanup();
                return;
            }

            var ev = e || window.event;
            dpEvent.calendar._eventMoveDispatch(dpEvent, newColumnIndex, top, ev, drag);

            cleanup();
        }
        else if (DpGlobal.selecting) {

            var fire = function() {

                var selecting = DpGlobal.selecting;
                var calendar = DpGlobal.selecting.calendar;
                var origin = DpGlobal.selecting.origin;

                DayPilotCalendar._firstMousePos = null;
                DpGlobal.selecting = null;

                if (!selecting.args.allowed) {
                    calendar.clearSelection();
                    return;
                }

                if (calendar.timeRangeDoubleClickHandling === "Disabled") {
                    var sel = calendar.getSelection();
                    if (!sel) {
                        return;
                    }
                    calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource, origin);
                }
                else {
                    calendar._timeRangeClickTimeout = setTimeout(function() {
                        var sel = calendar.getSelection();
                        if (!sel) {
                            return;
                        }
                        calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource, origin);
                    }, calendar.doubleClickTimeout);
                }
            };

            if (DpGlobal.selecting && DayPilotCalendar._topSelectedCell !== null) {
                fire();
            }
            else {  // delayed
                DayPilotCalendar.selectedTimeout = setTimeout(fire, 100);
            }
        }
        // legacy, can be removed
        else if (DayPilotCalendar._firstMousePos) {

            var calendar = DayPilotCalendar._firstMousePos.calendar;
            DpGlobal.selecting = {};
            DpGlobal.selecting.calendar = calendar;
            //calendar.clearSelection();
            calendar._activateSelection();

            if (!DpGlobal.selecting.args.allowed) {
                return;
            }

            DayPilotCalendar._firstMousePos = null;
            DpGlobal.selecting = null;

            if (calendar.timeRangeDoubleClickHandling === "Disabled") {
                var sel = calendar.getSelection();
                calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);
            }
            else {
                calendar._timeRangeClickTimeout = setTimeout(function() {
                    var sel = calendar.getSelection();
                    calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);
                }, calendar.doubleClickTimeout);
            }

        }
        else if (DpGlobal.colResizing) {
            var cres = DpGlobal.colResizing;
            DpGlobal.colResizing = null;
            cres._stopResizing();
        }
        else if (DpGlobal.colMoving) {
            var cmov = DpGlobal.colMoving;
            DpGlobal.colMoving = null;
            cmov._stopMoving();
        }

        // clean up external drag helpers
        if (DayPilotCalendar.drag) {
            DayPilotCalendar.drag = null;

            document.body.style.cursor = '';
        }

        if (DayPilotCalendar.gShadow) {
            document.body.removeChild(DayPilotCalendar.gShadow);
            DayPilotCalendar.gShadow = null;
        }

        DayPilotCalendar.moveOffsetY = null; // clean for next external drag

    };

    DayPilotCalendar.dragStart = function(element, duration, id, text, type) {
        DayPilot.us(element);

        var drag = DayPilotCalendar.drag = {};
        drag.element = element;
        drag.duration = duration;
        drag.text = text;
        drag.id = id;
        drag.shadowType = type ? type : 'Fill';  // default value

        drag._dragOptions = { "id":id, "text": text, "duration":duration, "externalHtml": text};

        return false;
    };

    DayPilot.Calendar.def = {};

    /*
     * options: {
     *      element: dom element,
     *      duration: duration in minutes,
     *      text: event text,
     *      id: id,
     *      keepElement: whether to keep the original element
     * }
     */
    DayPilot.Calendar.makeDraggable = function(options) {
        var element = options.element;
        var removeElement = options.keepElement ? null : element;

        var data = options.data || {};

        var id = typeof options.id !== "undefined" ? options.id : data.id;
        var text = typeof options.text === "string" ? options.text : data.text || "";
        var duration = options.duration || data.duration;

        if (duration instanceof DayPilot.Duration) {
            duration = duration.totalSeconds();
        }
        if (!duration) {
            if (data.start && data.end) {
                duration = new DayPilot.Duration(data.start, data.end).totalSeconds();
            }
            else {
                duration = 60;
            }
        }


        if (navigator.msPointerEnabled) {
            element.style.msTouchAction = "none";
            element.style.touchAction = "none";
        }

        var mousedown = function(ev) {

            // DayPilotCalendar.dragStart(removeElement, duration, options.id, options.text);
            startDragging();

            var element = (ev.target || ev.srcElement);
            if(element.tagName) {
                var tagname = element.tagName.toLowerCase();
                if(tagname === "textarea" || tagname === "select" || tagname === "input") {
                    return false;
                }
            }
            ev.preventDefault && ev.preventDefault();
            return false;

            /*
             var ev = ev || window.event;
             ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;
             return false;
             */
        };

        var touchstart = function(ev) {

            if (isMouseEvent(ev)) {
                return;
            }

            var holdfor = 0;

            window.setTimeout(function() {
                startDragging();

                DayPilotCalendar._gTouchMove(ev);

                ev.preventDefault();
            }, holdfor);

            ev.preventDefault();
        };

        function startDragging() {
            // TODO create drag.event = new DayPilot.Event() here
            // TODO merge with DayPilot.Scheduler.startDragging()

            var drag = DayPilotCalendar.drag = {};
            drag.element = removeElement;
            drag.id = id;
            drag.duration = duration;
            drag.text = text;
            // drag.data = options;
            drag.shadowType = "Fill";

            drag._dragOptions = options;
            drag._dragData = options.data;
        }

        //element.addEventListener(DayPilot.touch.start, touchstart, false);
        DayPilot.us(element);  // make it unselectable
        registerEvent(element, "mousedown", mousedown);

        reNonPassive(element, DayPilot.touch.start, touchstart);

        element.cancelDraggable = function() {
            DayPilot.ue(element, "mousedown", mousedown);
            DayPilot.ue(element, DayPilot.touch.start, touchstart);
            delete element.cancelDraggable;
        };

    };

    DayPilot.Calendar.stopDragging = function() {

        // 1. external drag and drop
        if (DayPilotCalendar.drag) {
            DayPilotCalendar.drag = null;
            document.body.style.cursor = '';
        }

        if (DayPilotCalendar.gShadow) {
            document.body.removeChild(DayPilotCalendar.gShadow);
            DayPilotCalendar.gShadow = null;
        }

        // TODO: remove source class from event (if dragged from Calendar)

        // 2. resizing
        if (DpGlobal.resizing) {
            var calendar = DpGlobal.resizing.event.calendar;

            // stop resizing on the client
            DpGlobal.resizing.style.cursor = 'default';
            DpGlobal.resizing.onclick = null;  // trying to prevent onclick, the event should be always recreated
            DpGlobal.resizing = null;

            calendar.nav.top.style.cursor = 'auto';
            calendar._clearResizingShadow();

        }

        // 3. moving
        if (DpGlobal.moving) {
            var calendar = DpGlobal.moving && DpGlobal.moving.event && DpGlobal.moving.event.calendar;

            if (calendar) {
                calendar._lastEventMoving = null;
                removeClass(DpGlobal.moving, calendar._prefixCssClass("_event_moving_source"));
                calendar._clearMovingShadow();
            }

            DpGlobal.movingAreaData = null;
            DpGlobal.moving = null;

        }

        // 4. time range selecting
        if (DpGlobal.selecting || DayPilotCalendar._firstMousePos) {
            var calendar = DpGlobal.selecting.calendar;

            DayPilotCalendar._firstMousePos = null;
            DpGlobal.selecting = null;

            if (calendar) {
                calendar.clearSelection();
            }
        }

    };


    DayPilot.Calendar.registerDropTarget = function(options) {
        options = options || {};
        var element = options.element;

        var onDragOver = options.onDragOver;
        var isDragOver = typeof onDragOver === "function";
        var onDrop = options.onDrop;
        var isDrop = typeof onDrop === "function";
        var onDragLeave = options.onDragLeave;
        var isDragLeave = typeof onDragLeave === "function";

        if (!element) {
            throw new DayPilot.Exception("registerDropTarget(options): options.element must be specified");
        }

        element.addEventListener("mousemove", function(ev) {
            var drag = DayPilotCalendar.drag;
            if (!drag) {
                return;
            }
            var data = drag._dragData;
            if (!data) {
                return;
            }
            if (!isDragOver) {
                return;
            }
            var args = {};
            args.data = data;
            onDragOver(args);
        });

        element.addEventListener("mouseleave", function(ev) {
            var drag = DayPilotCalendar.drag;
            if (!drag) {
                return;
            }
            var data = drag._dragData;
            if (!data) {
                return;
            }
            if (!isDragLeave) {
                return;
            }
            var args = {};
            args.data = data;
            onDragLeave(args);
        });

        element.addEventListener("mouseup", function(ev) {
            var drag = DayPilotCalendar.drag;
            if (!drag) {
                return;
            }
            var data = drag._dragData;
            if (!data) {
                return;
            }
            if (!isDrop) {
                return;
            }

            var args = {};
            args.data = data;
            onDrop(args);

            if (drag.element) {
                deleteElement(drag.element);
            }

        });

    };

    DayPilotCalendar.createGShadow = function(type) {

        var shadow = createDiv();
        shadow.setAttribute('unselectable', 'on');
        shadow.style.position = 'absolute';
        shadow.style.width = '100px';
        shadow.style.height = '20px';
        shadow.style.border = '2px dotted #666666';
        shadow.style.zIndex = shadowZindex;
        shadow.style.pointerEvents = "none";

        if (type === 'Fill') {    // transparent
            shadow.style.backgroundColor = "#aaaaaa";
            shadow.style.opacity = 0.5;
            shadow.style.filter = "alpha(opacity=50)";
            shadow.style.border = '2px solid #aaaaaa';
        }

        document.body.appendChild(shadow);

        return shadow;
    };

    DayPilotCalendar.moveShadow = function(column) {
        var shadow = DayPilotCalendar.movingShadow;
        //var parent = shadow.parentNode;

        // debugger;
        //parent.style.display = 'none';

        if (shadow.parentNode) {
            shadow.parentNode.removeChild(shadow);
        }
        column.firstChild.appendChild(shadow);
        shadow.style.left = '0px';

        // shadow.style.width = (DayPilotCalendar.movingShadow.parentNode.offsetWidth) + 'px';
        shadow.style.width = '';
        shadow.style.right = '0px';
    };

    DayPilot.Column = function(col, calendar) {
        var column = this;

        column.id = col.id;
        column.name = col.name;
        column.data = col.data;
        column.date = new DayPilot.Date(col.start);
        column.start = column.date;
        column.calendar = calendar;

        column.events = {};
        column.events.all = function() {
            var list = createList();
            for (var i = 0; i < col.events.length; i++) {
                list.push(col.events[i]);
            }
            return list;
        };

        column.events.isEmpty = function() {
            return col.events.length === 0;
        };

        column.events.forRange = function(start, end) {
            start = new DayPilot.Date(start);
            end = end ? new DayPilot.Date(end) : col._visibleEnd();
            var result = createList();
            for (var i = 0; i < column.events.length; i++) {
                var ev = column.events[i];
                if (overlaps(ev.start(), ev.end(), start, end)) {
                    result.push(ev);
                }
            }
            return result;
        };

        column.events.totalDuration = function() {
            var ticks = 0;
            column.events.all().forEach(function(item) {
                ticks += item.part.end.getTime() - item.part.start.getTime();
            });
            return new DayPilot.Duration(ticks);
        };


        // legacy
        column.value = col.id;

        column.toJSON = function() {
            var json = {};
            json.id = this.id;
            if (this.date) {
                json.date = this.date.toString();
            }
            json.name = this.name;
            json.value = this.value;
            return json;
        };

    };

    // experimental jQuery bindings
    if (typeof jQuery !== 'undefined') {
        (function($) {
            $.fn.daypilotCalendar = function(options) {
                var first = null;
                var j = this.each(function() {
                    if (this.daypilot) { // already initialized
                        return;
                    };

                    var daypilot = new DayPilot.Calendar(this.id, options);
                    daypilot.init();
                    this.daypilot = daypilot;
                    /*
                    for (var name in options) {
                        daypilot[name] = options[name];
                    }*/

                    if (!first) {
                        first = daypilot;
                    }
                });
                if (this.length === 1) {
                    return first;
                }
                else {
                    return j;
                }
            };
        })(jQuery);
    }

    (function registerAngularModule() {

        var app = DayPilot.am();

        if (!app) {
            return;
        }

        app.directive("daypilotCalendar", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element.replaceWith(this["template"].replace("{{id}}", attrs["id"]));

                    return function link(scope, element, attrs) {
                        var calendar = new DayPilot.Calendar(element[0]);
                        calendar._angular.scope = scope;
                        calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Calendar object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }

                            }
                        }

                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        var events = attrs["events"] || attrs["daypilotEvents"];

                        watch.call(scope, config, function (value, oldVal) {
                            for (var name in value) {
                                calendar[name] = value[name];
                            }
                            calendar.update();
                        }, true);

                        watch.call(scope, events, function(value) {
                            calendar.events.list = value;
                            calendar._update({"eventsOnly": true});
                        }, true);

                    };
                }
            };
        }]);

    })();

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright © 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
	var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.DatePicker !== 'undefined') {
        return;
    }

    DayPilot.DatePicker = function(properties) {
        this.v = '2023.2.5592';
        var navigatorId = "navigator_" + new Date().getTime();
        var This = this;

        this.onShow = null;
        this.onTimeRangeSelect = null;
        this.onTimeRangeSelected = null;
        // this.dateFormat = null;

        this.prepare = function() {
            this.locale = "en-us";
            this.target = null;
            this.targetAlignment = "left";
            this.resetTarget = true;
            this.pattern = this._resolved.locale().datePattern;    // "M/d/yyyy"
            this.theme = "navigator_default";
            this.patterns = [];
            this.zIndex = null;

            // load settings
            if (properties) {
                for (var name in properties) {
                    this[name] = properties[name];
                }
            }

        };

        this.init = function() {

            this.date = new DayPilot.Date(this.date);

            var value = this._readFromTarget();

            if (this.resetTarget && !value) {
                this._writeToTarget(this.date);
            }
            else if (!this.resetTarget) {
                This.date = value;
            }

            var target = this._element();
            if (target) {
                target.addEventListener("input", function() {
                    This.date = This._readFromTarget();
                    if (This.date) {
                        This.navigator.select(This.date, {dontNotify: true});
                    }
                });
            }

            document.addEventListener("mousedown", function() {
                This.close();
            });

            return this;

        };

        this.close = function() {
            if (!this._visible) {
                return;
            }

            this._visible = false;

            if (this.navigator) {
                this.navigator.dispose();
            }
            this.div.innerHTML = '';
            if (this.div && this.div.parentNode === document.body) {
                document.body.removeChild(this.div);
            }
        };

        this.setDate = function(date) {
            this.date = new DayPilot.Date(date);
            this._writeToTarget(this.date);
        };

        this._readFromTarget = function() {
            // recognized targets: input (value), other DOM elements (innerHTML)
            var element = this._element();

            if (!element) {
                return this.date;
            }

            var value = null;
            if (element.tagName === "INPUT") {
                value = element.value;
            }
            else {
                value = element.innerText;
            }

            if (!value) {
                return null;
            }

            var date = DayPilot.Date.parse(value, This.pattern);
            for (var i = 0; i < This.patterns.length; i++) {
                if (date) {
                    return date;
                }
                date = DayPilot.Date.parse(value, This.patterns[i]);
            }

            return date;
        };

        this._writeToTarget = function(date) {
            var element = this._element();

            if (!element) {
                return;
            }

            var value = date.toString(This.pattern, This.locale);
            if (element.tagName === "INPUT") {
                element.value = value;
            }
            else {
                element.innerHTML = value;
            }

        };

        this._resolved = {};
        this._resolved.locale = function() {
            return DayPilot.Locale.find(This.locale);
        };

/*        this._resolved.dateFormat = function() {
            if (typeof This.dateFormat === "string") {
                return This.dateFormat;
            }
            return This._resolved.locale().datePattern;
        }*/

        this._element = function() {
            var id = this.target;
            // accept DOM element or id (string)
            var element = (id && id.nodeType && id.nodeType === 1 ) ? id : document.getElementById(id);
            return element;
        };

        Object.defineProperty(this, "visible", {
            get: function() { return This._visible; }
        });

        this.show = function() {

            if (this._visible) {
                return;
            }

            var element = this._element();
            var navigator = this.navigator;

            var navigator = new DayPilot.Navigator(navigatorId);
            navigator.api = 2;
            navigator.cssOnly = true;
            navigator.theme = This.theme;
            navigator.weekStarts = "Auto";
            navigator.locale = This.locale;
            navigator.onTimeRangeSelected = function(args) {
                This.date = args.start;

                var start = args.start.addTime(navigator._pickerTimePart);
                var value = start.toString(This.pattern, This.locale);

                var args = {};
                args.start = start;
                args.date = start;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof This.onTimeRangeSelect ===  'function') {
                    This.onTimeRangeSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                This._writeToTarget(value);
                This.close();

                if (typeof This.onTimeRangeSelected === 'function') {
                    This.onTimeRangeSelected(args);
                }
            };

            this.navigator = navigator;

            var position = DayPilot.abs(element);
            var height = element.offsetHeight;

            var align = This.targetAlignment;

            var div = document.createElement("div");
            div.style.position = "absolute";

            if (align === "left") {
                div.style.left = position.x + "px";
            }


            div.style.top = (position.y + height) + "px";
            if (This.zIndex) {
                div.style.zIndex = This.zIndex;
            }

            var nav = document.createElement("div");
            nav.id = navigatorId;
            div.appendChild(nav);

            div.addEventListener("mousedown", function(ev) {
                var ev = ev || window.event;
                ev.cancelBubble = true;
                ev.stopPropagation && ev.stopPropagation();
            });

            document.body.appendChild(div);

            this.div = div;

            var selected = This._readFromTarget() || new DayPilot.Date().getDatePart();

            navigator.startDate = selected;
            navigator._pickerTimePart = selected.getTimePart();
            // navigator.selectionStart = selected.getDatePart();
            navigator.selectionDay = selected.getDatePart();
            navigator.init();

            if (align === "right") {
                var left = (position.x + element.offsetWidth - navigator.nav.top.offsetWidth);
                div.style.left = left + "px";
            }

            this._visible = true;
            if (this.onShow) {
                this.onShow();
            }
        };

        this.prepare(); // prepare only called once, in the constructor
        this.init();
    };


})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Gantt !== 'undefined' && DayPilot.Gantt.def) {
        return;
    }

    var doNothing = function() { };

    DayPilot.Gantt = function(id, options) {
        this.v = '2023.2.5592';

        var calendar = this;
        this.id = id; // referenced
        this.isGantt = true;

        var scheduler = new DayPilot.Scheduler(id);
        this.scheduler = scheduler;

        // scheduler setup
        scheduler.viewType = "Resources";
        //scheduler.taskMoveHandling = "Update";
        //scheduler.linksEnabled = true;

        scheduler.onCallBackHeader = function(args) {
            args.header.taskGroupMode = calendar.taskGroupMode;
            args.header.rowHeaderColumns = calendar.columns;
            args.header.clientState = calendar.clientState;
        };

        scheduler.onGetNodeState = function(args) {

            var getTags = function(task) {
                var result = {};
                if (task.tags) {
                    for (var name in task.tags) {
                        result[name] = "" + task.tags[name];
                    }
                }
                return result;
            };


            var getNode = function(row) {
                var task = row.task;

                var result = {};
                result.start = task.start;
                result.end = task.end;
                result.id = task.id;
                result.complete = task.complete;
                result.text = task.text;
                result.type = task.type;
                result.expanded = row.expanded;
                result.loaded = row.loaded;
                result.tags = getTags(task);
                result.versions = task.versions;

                result.children = scheduler.internal.getNodeChildren(row.children);

                return result;
            };

            args.result = getNode(args.row);
            args.preventDefault();
        };

        scheduler._taskVersionJson = function(version) {

        };

        scheduler.onCallBackResult = function(args) {
            var result = args.result;
            args.preventDefault();

            var scrollToTask = function() {
                if (result.scrollToTaskId) {
                    scheduler.scrollToResource(result.scrollToTaskId);
                }
            };

            if (result.updateType === "None") {
                scrollToTask();
                return;
            }

            var update = function(list) {
                for (var i = 0; i < list.length; i++) {
                    var name = list[i];
                    if (typeof result[name] !== "undefined") {
                        calendar[name] = result[name];
                    }
                }
            };

            // data
            calendar.links.list = result.links;
            calendar.tasks.list = result.tasks;

            // callback-changeable properties
            calendar.startDate = new DayPilot.Date(result.startDate);
            update(['days', 'cellDuration', 'cellGroupBy', 'cellWidth', 'cellWidthSpec', 'cornerHtml', 'separators', 'rowMinHeight', 'rowMarginBottom', 'taskGroupMode', 'selectedRows']);

            // server-generated properties
            update(['cellProperties', 'cellConfig', 'timeHeader', 'timeHeaders', 'timeline', 'columns']);
            /*
            calendar.cellProperties = result.cellProperties;
            calendar.cellConfig = result.cellConfig;
            calendar.timeHeader = result.timeHeader;
            calendar.timeHeaders = result.timeHeaders;
            calendar.timeline = result.timeline;
            */

            wrap.translate();
            wrap._loadTasks();
            wrap._loadLinks();
            scheduler.update();
            scheduler.show();

            scrollToTask();
        };

        // default properties
        this.taskGroupMode = "Auto"; // behavior of task groups/parent nodes

        // translated scheduler properties
        this.autoRefreshCommand = "refresh";
        this.autoRefreshEnabled = false;
        this.autoRefreshInterval = 60;
        this.autoRefreshMaxCount = 20;
        this.autoScroll = "Drag";
        if (typeof DayPilot.Bubble === "function") {
            this.bubbleTask = new DayPilot.Bubble();
            this.bubbleCell = new DayPilot.Bubble();
            this.bubbleRow = new DayPilot.Bubble();
        } else {
            this.bubbleTask = null;
            this.bubbleCell = null;
            this.bubbleRow = null;
        }
        this.cellDuration = 1440;
        this.cellGroupBy = "Month";
        this.cellWidth = 40;
        this.cellWidthSpec = "Fixed";
        this.completeBarVisible = true;
        this.completeBarHeight = 3;
        this.contextMenuTask = null;
        this.contextMenuRow = null;
        this.contextMenuLink = null;
        this.cornerText = "";
        this.cornerHtml = null;
        this.crosshairType = 'Header';
        this.doubleClickTimeout = 300;
        this.progressiveTaskRendering = 'Progressive';
        this.progressiveTaskRenderingMargin = 500;
        this.progressiveTaskRenderingCacheSweeping = false;
        this.progressiveTaskRenderingCacheSize = 200;
        this.floatingTasks = true;
        this.floatingTimeHeaders = true;
        this.headerHeight = 30;
        this.height = 300;
        this.heightSpec = "Max";
        this.hideBorderFor100PctHeight = false;
        this.hideUntilInit = false;
        this.linkBottomMargin = 17;
        this.linkPointSize = 10;
        this.loadingLabelVisible = true;
        this.loadingLabelText = "Loading...";
        this.loadingLabelHtml = null;
        this.locale = "en-us";
        this.messageBarPosition = "Top";
        this.messageHideAfter = 5000;
        this.progressiveRowRendering = true;
        this.progressiveRowRenderingPreload = 25;
        this.rowHeaderColumnsMergeParents = false;
        this.rowHeaderScrolling = false;
        this.rowHeaderSplitterWidth = 3;
        this.rowHeaderHideIconEnabled = true;
        this.rowHeaderWidth = 80;
        this.rowHeaderWidthAutoFit = true;
        this.rowMarginBottom = 4;
        this.rowMinHeight = 0;
        this.scrollDelayTasks = 200;
        this.scrollDelayCells = 20;
        this.scrollDelayFloats = 0;
        this.scale = "Day";
        this.selectedRows = [];
        this.snapToGrid = true;
        this.syncTasks = true;
        this.syncLinks = true;
        this.tapAndHoldTimeout = 300;
        this.taskHeight = 34;
        this.taskHtmlLeftMargin = 20;
        this.taskHtmlRightMargin = 20;
        this.taskResizeMargin = 5;
        this.taskMovingStartEndEnabled = false;
        this.taskMovingStartEndFormat = "MMMM d, yyyy";
        this.taskResizingStartEndEnabled = false;
        this.taskResizingStartEndFormat = "MMMM d, yyyy";
        this.theme = "gantt_default";
        this.treeAnimation = true;
        this.treeAutoExpand = true;
        this.treeIndent = 20;
        this.treeImageMarginLeft = 0;
        this.treeImageMarginTop = 3;
        this.treeImageMarginRight = 5;
        this.treeImageWidth = 10;
        this.treeImageHeight = 10;
        //this.timeHeaders = [ { "groupBy": "Default" }, {"groupBy": "Cell" }];
        this.timeline = null;
        this.timeHeaders = [ { "groupBy": "Month", "format": "MMMM yyyy"}, { "groupBy": "Day", "format": "d"}];
        this.useEventBoxes = "Never";
        this.visible = true;
        this.weekStarts = "Auto";
        this.xssProtection = "Enabled"; // "Disabled"

        // 2015-05-26
        this.taskVersionsEnabled = false;
        this.taskVersionHeight = 24;
        this.taskVersionMargin = 2;
        this.taskVersionPosition = "Above";

        // event handling
        this.taskMoveHandling = "Update";
        this.taskClickHandling = "Enabled";
        this.taskResizeHandling = "Update";
        this.linkCreateHandling = "Update";
        this.taskRightClickHandling = "ContextMenu";
        this.taskDoubleClickHandling = "Disabled";
        //this.taskDeleteHandling = "Update";
        this.tasksLoadMethod = "GET";
        this.rowCreateHandling = "Disabled";
        this.rowMoveHandling = "Update";
        this.rowClickHandling = "Disabled";
        this.rowDoubleClickHandling = "Disabled";
        this.rowEditHandling = "Update";
        this.rowSelectHandling = "Update";

        this.clientState = {};

        this.separators = [];

        this.members = {};
        this.members.obsolete = [];
        this.members.ignore = [
            "members",
            "scheduler",
            "internal",
            "cellProperties"
        ];
        this.members.noCssOnly = [];

        this.links = {};
        this.links.list = [];
        this.links.add = function(link) {
            if (!link) {
                return;
            }
            var data = link.isLink ? link.data : link;
            calendar.links.list.push(data);

            if (calendar._initialized) {
                wrap._loadLinks();
                scheduler.update();
            }

            calendar._angular.notify();

        };

        this.links.remove = function(link) {
            if (!link) {
                return;
            }

            var data;
            if (link.isLink) {
                data = link.data;
            }
            else {
                data = link;
            }

            var index = DayPilot.indexOf(calendar.links.list, data);

            if (index === -1) {
                return;
            }

            calendar.links.list.splice(index, 1);
            if (calendar._initialized) {
                wrap._loadLinks();
                scheduler.update();
            }

            calendar._angular.notify();
        };

        this.links.find = function(id) {
            if (!DayPilot.isArray(calendar.links.list)) {
                return null;
            }
            for (var i = 0; i < calendar.links.list.length; i++) {
                var link = calendar.links.list[i];
                if (link.id === id) {
                    return new DayPilot.Link(link, calendar);
                }
            }
            return null;
        };

        this.links.findByFromTo = function(from, to) {
            if (!DayPilot.isArray(calendar.links.list)) {
                return null;
            }
            for (var i = 0; i < calendar.links.list.length; i++) {
                var link = calendar.links.list[i];
                if (link.from === from && link.to === to) {
                    return new DayPilot.Link(link, calendar);
                }
            }
            return null;
        };

        this.links.load = function(url, success, error) {
            scheduler.links.load(url, function(args) {
                if (typeof success === "function") {
                    success(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }
                calendar.links.list = args.data;
            }, error, {
                "dontAddStartEnd": true
            });
        };

        this._refresh = {};
        var refresh = this._refresh;

        refresh.timeout = null;
        refresh.update = function() {
            if (!calendar._initialized) {
                return;
            }

            window.clearTimeout(refresh.timeout);

            refresh.timeout = setTimeout(function() {
                wrap._loadTasks();
                scheduler.update();
            }, 0);
        };

        this.tasks = {};
        this.tasks.list = [];
        this.tasks.add = function(task) {
            if (!task) {
                return;
            }
            if (task instanceof DayPilot.Event) {
                throw "DayPilot.Task object required. You have supplied DayPilot.Event.";
            }
            var data = task.isTask ? task.data : task;
            calendar.tasks.list.push(data);

            refresh.update();

            calendar._angular.notify();
        };

        this.tasks.find = function(id) {
            var data = tasktools.findInCache(id);
            if (!data) {
                return null;
            }
            return new DayPilot.Task(data, calendar);
        };

        this.tasks.update = function(task) {
            // commit
            if (!task) {
                return;
            }
            var data = null;
            if (task.isTask) {
                task.commit();
                data = task.data;
            }
            else if (typeof task === "object") {
                data = task;
            }
            else {
                throw "DayPilot.Task or task data object expected";
            }

            var t = calendar.tasks.find(data.id);
            if (!t) {
                return;
            }

            /*var i = calendar.tasks.list.indexOf(t.data);
            calendar.tasks.splice(i, 1, t.data);*/

            var parent = tasktools.findParentArray(t.data);
            var i = parent.indexOf(t.data);
            parent.splice(i, 1, data);

            refresh.update();

            calendar._angular.notify();

        };


        /**
         * Removes a task, including children.
         * @param task
         */
        this.tasks.remove = function(task) {
            if (!task) {
                return;
            }
            if (!task.isTask) {
                throw "DayPilot.Task object expected";
            }
            var parentArray = tasktools.findParentArray(task.data);
            if (!parentArray) {
                return;
            }

            var sourceIndex = DayPilot.indexOf(parentArray, task.data);
            parentArray.splice(sourceIndex, 1);

            refresh.update();

            calendar._angular.notify();
        };

        this.tasks.load = function(url, success, error) {

            if (!url) {
                throw new DayPilot.Exception("events.load(): 'url' parameter required");
            }
            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.tasks.list = data;
                    if (calendar._initialized) {
                        calendar.update();
                    }
                }
            };

            var usePost = calendar.tasksLoadMethod && calendar.tasksLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "contentType": "application/json",
                    //"data": { "start": calendar.visibleStart().toString(), "end": calendar.visibleEnd().toString()},
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                var fullUrl = url;
                /*var queryString = "start=" + calendar.visibleStart().toString() + "&end=" + calendar.visibleEnd().toString();
                if (fullUrl.indexOf("?") > -1) {
                    fullUrl += "&" + queryString;
                }
                else {
                    fullUrl += "?" + queryString;
                }*/

                DayPilot.ajax({
                    "method": "GET",
                    "url": fullUrl,
                    "success": onSuccess,
                    "error": onError
                });
            }

        };


        this.visibleStart = function() {
            return scheduler.visibleStart();
        };

        this.visibleEnd = function() {
            return scheduler.visibleEnd();
        };

        // events
        this.onAfterRender = null;
        this.onAfterUpdate = null;
        this.onBeforeRowHeaderRender = null;
        this.onBeforeRowHeaderExport = null;
        this.onBeforeTaskRender = null;
        this.onBeforeTaskExport = null;
        this.onBeforeTimeHeaderRender = null;
        this.onBeforeTimeHeaderExport = null;
        this.onBeforeCellRender = null;
        this.onBeforeCellExport = null;
        this.onBeforeCornerRender = null;
        this.onBeforeCornerExport = null;
        this.onTaskClick = null;
        this.onTaskClicked = null;
        this.onTaskDoubleClick = null;
        this.onTaskDoubleClicked = null;
        this.onTaskRightClick = null;
        this.onTaskRightClicked = null;
        this.onRowCreate = null;
        this.onRowCreated = null;
        this.onRowMove = null;
        this.onRowMoved = null;
        this.onRowMoving = null;
        this.onRowClick = null;
        this.onRowClicked = null;
        this.onRowDoubleClick = null;
        this.onRowDoubleClicked = null;
        this.onRowEdit = null;
        this.onRowEdited = null;
        this.onRowFilter = null;
        this.onRowSelect = null;
        this.onRowSelected = null;
        this.onTaskMove = null;
        this.onTaskMoved = null;
        this.onTaskMoving = null;
        this.onTaskResize = null;
        this.onTaskResized = null;
        this.onTaskResizing = null;
        this.onLinkCreate = null;
        this.onLinkCreated = null;

        this._serverBased = function() {
            if (this.backendUrl) {  // ASP.NET MVC, Java
                return true;
            }
            if (typeof WebForm_DoCallback === 'function' && this.uniqueID) {  // ASP.NET WebForms
                return true;
            }
            return false;
        };

        this._setStartDate = function() {
            if (typeof calendar.startDate === "string") {
                calendar.startDate = new DayPilot.Date(calendar.startDate);
            }

            if (calendar.startDate && calendar.days) {
                return;
            }

            var start = DayPilot.Date.today();
            var end = start.addDays(1);
            var startTicks = null;
            var endTicks = null;


            function checkTasks(tasks) {
                for (var i = 0; i < tasks.length; i++) {
                    var e = tasks[i];
                    start = new DayPilot.Date(e.start);
                    end = new DayPilot.Date(e.end);
                    if (startTicks === null || start.getTime() < startTicks) {
                        startTicks = start.getTime();
                    }
                    if (endTicks === null || end.getTime() > endTicks) {
                        endTicks = end.getTime();
                    }
                    if (e.children && e.children.length > 0) {
                        checkTasks(e.children);
                    }
                }
            }

            checkTasks(calendar.tasks.list);

            if (startTicks && endTicks) {
                start = new DayPilot.Date(startTicks).getDatePart();
                end =  new DayPilot.Date(endTicks).getDatePart().addDays(1);

                scheduler.startDate = calendar.startDate || start;
                scheduler.days = calendar.days || DayPilot.DateUtil.daysDiff(start, end);
            }
            else {
                scheduler.startDate = start;
                scheduler.days = 30;
            }
        };

        this._findStartEnd = function(tasks, startTicks, endTicks) {

        };

        this.commandCallBack = function(command, data) {
            wrap.translate();
            scheduler.commandCallBack(command, data);
        };

        this.message = function(html, delay, foreColor, backColor) {
            scheduler.message(html, delay, foreColor, backColor);
        };

        this.setHeight = function(pixels) {
            scheduler.setHeight(pixels);
        };

        this._isShortInit = function() {
            return !!this.backendUrl;

/*
            // make sure it has a place to ask
            if (this.backendUrl) {
                return !DayPilot.isArray(calendar.tasks.list) || calendar.tasks.list.length == 0;
            }
            else {
                return false;
            }
*/
        };

        this.setScrollY = function(scrollY) {
            scheduler.setScrollY(scrollY);
        };

        this.setScrollX = function(scrollX) {
            scheduler.setScrollX(scrollX);
        };

        this.getScrollY = function() {
            return scheduler.getScrollY();
        };

        this.getScrollX = function() {
            return scheduler.getScrollX();
        };

        this.scrollToRow = function(id) {
            scheduler.scrollToResource(id);
        };


        this.init = function() {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.")
            }
            wrap.translate();
            wrap._loadTasks();
            wrap._loadLinks();
            this._setStartDate();

            scheduler.init();
            this._initialized = true;

            this._postInit();

            return this;

            /*
            if (this._isShortInit()) {
                scheduler.internal.callback('Init');
            }*/
        };

        this._disposed = false;

        this.dispose = function() {
            scheduler.dispose();
            calendar._disposed = true;
        };

        this.update = function(options) {

            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Gantt instance that hasn't been initialized yet.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Gantt instance that has been disposed.");
            }

            calendar._loadOptions(options);

            wrap.translate();
            wrap._loadTasks();
            wrap._loadLinks();
            calendar._setStartDate();
            scheduler.update();
        };

        this.scrollTo = function(target) {
            scheduler.scrollTo(target);
        };

        this.scrollToTask = function(id) {
            scheduler.scrollToResource(id);
        };

        this._tasktools = {};
        var tasktools = this._tasktools;

        tasktools.cache = {};

        tasktools.clearCache = function() {
            tasktools.cache = {};
        };

        tasktools.addToCache = function(data, parent) {
            // cache
            var key = data.id;

            if (!key) {
                return;
            }

            var wrapper = {};
            wrapper.isTaskWrapper = true;
            wrapper.data = data;
            wrapper.parent = parent;

            if (tasktools.cache[key]) {
                throw "Duplicate task id detected";
            }

            tasktools.cache[key] = wrapper;

        };

        tasktools.findInCache = function(id) {
            if (!id) {
                return null;
            }
            return tasktools.cache[id.toString()];
        };

        tasktools.getProperty = function(task, name) {
            if (task.tags && task.tags[name]) {
                return task.tags[name];
            }
            return task[name];
        };

        tasktools.findParentArray = function(res) {
            return tasktools.findInArray(calendar.tasks.list, res);
        };

        tasktools.findInArray = function(array, res) {
            if (DayPilot.indexOf(array, res) !== -1) {
                return array;
            }
            for(var i = 0; i < array.length; i++) {
                var r = array[i];
                if (r.children && r.children.length > 0) {
                    var parent = tasktools.findInArray(r.children, res);
                    if (parent) {
                        return parent;
                    }
                }
            }
            return null;
        };

        this._wrap = {};
        var wrap = this._wrap;

        var coalesce = function(p, val) {
            if (typeof p !== "undefined") {
                return p;
            }
            return val;
        };

        wrap.translate = function() {

            scheduler.internal.gantt = calendar;

            // settings
            // fixed
            scheduler.durationBarMode = "PercentComplete";
            scheduler.timeRangeSelectedHandling = "Disabled";
            scheduler.treeEnabled = true;
            scheduler.rowCreateHtml = "";
            scheduler.rowHeaderColumnsMode = "Legacy";

            // variable
            scheduler.autoRefreshCommand = calendar.autoRefreshCommand;
            scheduler.autoRefreshEnabled = calendar.autoRefreshEnabled;
            scheduler.autoRefreshInterval = calendar.autoRefreshInterval;
            scheduler.autoRefreshMaxCount = calendar.autoRefreshMaxCount;
            scheduler.autoScroll = calendar.autoScroll;
            scheduler.backendUrl = calendar.backendUrl;
            // scheduler.crosshairColor = calendar.crosshairColor;
            // scheduler.crosshairOpacity = calendar.crosshairOpacity;
            scheduler.crosshairType = calendar.crosshairType;
            scheduler.doubleClickTimeout = calendar.doubleClickTimeout;
            scheduler.durationBarVisible = calendar.completeBarVisible;
            scheduler.durationBarHeight = calendar.completeBarHeight;
            scheduler.dynamicEventRendering = calendar.progressiveTaskRendering;
            scheduler.dynamicEventRenderingMargin = calendar.progressiveTaskRenderingMargin;
            scheduler.dynamicEventRenderingCacheSweeping = calendar.progressiveTaskRenderingCacheSweeping;
            scheduler.dynamicEventRenderingCacheSize = calendar.progressiveTaskRenderingCacheSize;
            scheduler.startDate = new DayPilot.Date(calendar.startDate);
            scheduler.days = calendar.days;
            scheduler.cellDuration = calendar.cellDuration;
            scheduler.cellGroupBy = calendar.cellGroupBy;
            scheduler.cellWidth = calendar.cellWidth;
            scheduler.cellWidthSpec = calendar.cellWidthSpec;
            scheduler.cornerHtml = calendar.cornerHtml;
            scheduler.cornerText = calendar.cornerText;
            scheduler.eventHeight = calendar.taskHeight;
            scheduler.eventResizeMargin = calendar.taskResizeMargin;
            scheduler.floatingEvents = calendar.floatingTasks;
            scheduler.floatingTimeHeaders = calendar.floatingTimeHeaders;
            scheduler.headerHeight = calendar.headerHeight;
            scheduler.heightSpec = calendar.heightSpec;
            scheduler.height = calendar.height;
            scheduler.linkBottomMargin = calendar.linkBottomMargin;
            scheduler.linkPointSize = calendar.linkPointSize;
            scheduler.loadingLabelVisible = calendar.loadingLabelVisible;
            scheduler.loadingLabelText = calendar.loadingLabelText;
            scheduler.loadingLabelHtml = calendar.loadingLabelHtml;
            scheduler.locale = calendar.locale;
            scheduler.messageBarPosition = calendar.messageBarPosition;
            scheduler.messageHideAfter = calendar.messageHideAfter;
            //scheduler.milestoneWidth = calendar.milestoneWidth;
            scheduler.rowCreateHandling = calendar.rowCreateHandling;
            scheduler.progressiveRowRendering = calendar.progressiveRowRendering;
            scheduler.progressiveRowRenderingPreload = calendar.progressiveRowRenderingPreload;
            scheduler.scale = calendar.scale;
            scheduler.scrollDelayEvents = calendar.scrollDelayTasks;
            scheduler.scrollDelayCells = calendar.scrollDelayCells;
            scheduler.scrollDelayFloats = calendar.scrollDelayFloats;
            scheduler.scrollX = calendar.scrollX;
            scheduler.scrollY = calendar.scrollY;
            if (calendar.scrollToTaskId) {
                scheduler.scrollToResourceId = calendar.scrollToTaskId;
            }
            scheduler.separators = calendar.separators;
            scheduler.tapAndHoldTimeout = calendar.tapAndHoldTimeout;
            scheduler.eventHtmlLeftMargin = calendar.taskHtmlLeftMargin;
            scheduler.eventHtmlRightMargin = calendar.taskHtmlRightMargin;
            scheduler.eventMovingStartEndEnabled = calendar.taskMovingStartEndEnabled;
            scheduler.eventMovingStartEndFormat = calendar.taskMovingStartEndFormat;
            scheduler.eventResizingStartEndEnabled = calendar.taskResizingStartEndEnabled;
            scheduler.eventResizingStartEndFormat = calendar.taskResizingStartEndFormat;
            scheduler.hideBorderFor100PctHeight = calendar.hideBorderFor100PctHeight;
            scheduler.hideUntilInit = calendar.hideUntilInit;
            scheduler.treeIndent = calendar.treeIndent;
            scheduler.treeAnimation = calendar.treeAnimation;
            scheduler.treeAutoExpand = calendar.treeAutoExpand;
            scheduler.treeImageMarginLeft = calendar.treeImageMarginLeft;
            scheduler.treeImageMarginTop = calendar.treeImageMarginTop;
            scheduler.treeImageMarginRight = calendar.treeImageMarginRight;
            scheduler.treeImageWidth = calendar.treeImageWidth;
            scheduler.treeImageHeight = calendar.treeImageHeight;
            scheduler.timeHeaders = calendar.timeHeaders;
            scheduler.rowHeaderHideIconEnabled = calendar.rowHeaderHideIconEnabled;
            scheduler.rowHeaderColumnsMergeParents = calendar.rowHeaderColumnsMergeParents;
            scheduler.rowHeaderScrolling = calendar.rowHeaderScrolling;
            scheduler.rowHeaderSplitterWidth = calendar.rowHeaderSplitterWidth;
            scheduler.rowHeaderWidth = calendar.rowHeaderWidth;
            scheduler.rowHeaderWidthAutoFit = calendar.rowHeaderWidthAutoFit;
            scheduler.rowMarginBottom = calendar.rowMarginBottom;
            scheduler.rowMinHeight = calendar.rowMinHeight;
            scheduler.selectedRows = calendar.selectedRows;
            scheduler.theme = calendar.theme;
            scheduler.useEventBoxes = calendar.useEventBoxes;
            scheduler.snapToGrid = calendar.snapToGrid;
            scheduler.uniqueID = calendar.uniqueID;
            scheduler.bubble = calendar.bubbleTask;
            scheduler.cellBubble = calendar.bubbleCell;
            scheduler.resourceBubble = calendar.bubbleRow;
            scheduler.contextMenu = calendar.contextMenuTask;
            scheduler.contextMenuResource = calendar.contextMenuRow;
            scheduler.contextMenuLink = calendar.contextMenuLink;
            scheduler.syncResourceTree = calendar.syncTasks;
            scheduler.syncLinks = calendar.syncLinks;
            scheduler.timeline = calendar.timeline;
            scheduler.visible = calendar.visible;
            scheduler.devsb = calendar.devsb;
            scheduler.weekStarts = calendar.weekStarts;
            scheduler.xssProtection = calendar.xssProtection;

            scheduler.eventMoveHandling = calendar.taskMoveHandling;
            scheduler.eventClickHandling = calendar.taskClickHandling;
            scheduler.eventResizeHandling = calendar.taskResizeHandling;
            scheduler.linkCreateHandling = calendar.linkCreateHandling;
            scheduler.eventRightClickHandling = calendar.taskRightClickHandling;
            scheduler.eventDoubleClickHandling = calendar.taskDoubleClickHandling;
            scheduler.rowMoveHandling = calendar.rowMoveHandling;
            scheduler.rowClickHandling = calendar.rowClickHandling;
            scheduler.rowDoubleClickHandling = calendar.rowDoubleClickHandling;
            scheduler.rowEditHandling = calendar.rowEditHandling;
            scheduler.rowSelectHandling = calendar.rowSelectHandling;

            // test
            scheduler.eventVersionsEnabled = calendar.taskVersionsEnabled;
            scheduler.eventVersionHeight = calendar.taskVersionHeight;
            scheduler.eventVersionMargin = calendar.taskVersionMargin;
            scheduler.eventVersionPosition = calendar.taskVersionPosition;

            // temporarily disabled - will require a different mapping
            // scheduler.eventDeleteHandling = calendar.taskDeleteHandling;

            if (DayPilot.isArray(calendar.columns)) {
                scheduler.rowHeaderColumns = [];
                for (var i = 0; i < calendar.columns.length; i++) {
                    var c = calendar.columns[i];
                    var rhc = {};
                    DayPilot.Util.copyProps(c, rhc, ['html', 'text', 'name', 'title', 'width', 'hidden', 'maxAutoWidth']);
                    rhc.display = c.display || c.property;
                    scheduler.rowHeaderColumns.push(rhc);
                }
            }

            // server-based data
            if (calendar._serverBased()) {
                scheduler.timeHeader = calendar.timeHeader;

                scheduler.cellProperties = calendar.cellProperties;
                scheduler.cellConfig = calendar.cellConfig;
            }

            // event mapping

            scheduler.onRowCreate = function(args) {
                args.control = calendar;
                if (typeof calendar.onRowCreate === "function") {
                    calendar.onRowCreate(args);
                }
            };

            scheduler.onRowCreated = function(args) {
                if (typeof calendar.onRowCreated === "function") {
                    calendar.onRowCreated(args);
                }
            };

            scheduler.onAfterRender = function(args) {
                if (typeof calendar.onAfterRender === "function") {
                    calendar.onAfterRender(args);
                }
            };

            scheduler.onAfterUpdate = function(args) {
                if (typeof calendar.onAfterUpdate === "function") {
                    calendar.onAfterUpdate(args);
                }
            };

            scheduler.onRowHeaderResized = function(args) {
                calendar.rowHeaderWidth = scheduler.rowHeaderWidth;
            };

            scheduler.onRowFilter = function(args) {
                if (typeof calendar.onRowFilter !== "function") {
                    return;
                }
                args.task = new DayPilot.Task(args.row.$.row.task, calendar);
                args.control = calendar;

                calendar.onRowFilter(args);
            };

            scheduler.onAjaxError = function(args) {
                if (typeof calendar.onAjaxError === "function") {
                    calendar.onAjaxError(args);
                }
            };

            scheduler.onRowHeaderColumnResized = function(args) {
                var column = args.column;
                var index = DayPilot.indexOf(scheduler.rowHeaderColumns, column);

                for (var i = 0; i < calendar.columns.length; i++) {
                    var rhc = scheduler.rowHeaderColumns[i];
                    var c = calendar.columns[i];
                    c.width = rhc.width;
                }

                if (typeof calendar.onColumnResized === "function") {
                    var cargs = {};
                    cargs.column = calendar.columns[index];
                    calendar.onColumnResized(cargs);
                }

            };

            scheduler.internalUseStandardColumns = DayPilot.isArray(calendar.columns);

            scheduler.onBeforeRowHeaderRender = function(args) {
                args.task = new DayPilot.Task(args.row.$.row.task, calendar);

                var e = args.row.$.row.events[0];
                // var e = args.row.data;
                if (e && calendar.taskGroupMode === "Auto" && e.data.type === "Group") {
                    args.task.data.start = e.data.start;
                    args.task.data.end = e.data.end;
                }

                var columns = [];
                if (DayPilot.isArray(calendar.columns)) {
                    for (var i = 0; i < calendar.columns.length; i++) {
                        var column = calendar.columns[i];
                        var property = column.display || column.property;

                        var colargs = {};
                        colargs.value = scheduler.internal.xssTextHtml(tasktools.getProperty(args.task.data, property));

                        if (args.task.data.row && args.task.data.row.columns && args.task.data.row.columns[i]) {
                            colargs.html = args.task.data.row.columns[i].html;
                        }
                        else {
                            colargs.html = colargs.value;
                        }
                        columns.push(colargs);
                    }
                }

                args.row.columns = columns;

                if (typeof calendar.onBeforeRowHeaderRender === "function") {
                    calendar.onBeforeRowHeaderRender(args);
                }

/*
                if (DayPilot.isArray(calendar.columns)) {
                    for (var i = 0; i < calendar.columns.length; i++) {
                        var html = columns[i].html;
                        if (i === 0) {
                            args.row.html = html;
                        }
                        else {
                            args.row.columns[i - 1].html = html;
                        }
                    }
                }
*/

            };


            scheduler.onBeforeRowHeaderExport = function(args) {
                args.task = new DayPilot.Task(args.row.$.row.task, calendar);

                if (typeof calendar.onBeforeRowHeaderExport === "function") {
                    calendar.onBeforeRowHeaderExport(args);
                }

            };

            scheduler.onBeforeEventExport = function(args) {
                if (typeof calendar.onBeforeTaskExport !== "function") {
                    return;
                }

                args.task = new DayPilot.Task(args.e, calendar);

                calendar.onBeforeTaskExport(args);
            };

            scheduler.onBeforeCellRender = function(args) {
                args.task = calendar.tasks.find(args.cell.resource);

                delete args.cell.resource;
                if (typeof calendar.onBeforeCellRender === "function") {
                    args.control = calendar;
                    calendar.onBeforeCellRender(args);
                }
            };

            scheduler.onBeforeCellExport = function(args) {
                args.task = calendar.tasks.find(args.cell.resource);
                delete args.cell.resource;

                if (typeof calendar.onBeforeCellExport === "function") {
                    args.control = calendar;
                    calendar.onBeforeCellExport(args);
                }

            };

            scheduler.onBeforeCornerRender = function(args) {
                if (typeof calendar.onBeforeCornerRender === "function") {
                    args.control = calendar;
                    calendar.onBeforeCornerRender(args);
                }
            };

            scheduler.onBeforeCornerExport = function(args) {
                if (typeof calendar.onBeforeCornerExport === "function") {
                    args.control = calendar;
                    calendar.onBeforeCornerExport(args);
                }
            };

            scheduler.onBeforeTimeHeaderRender = function(args) {
                if (typeof calendar.onBeforeTimeHeaderRender === "function") {
                    args.control = calendar;
                    calendar.onBeforeTimeHeaderRender(args);
                }
            };

            scheduler.onBeforeTimeHeaderExport = function(args) {
                if (typeof calendar.onBeforeTimeHeaderExport === "function") {
                    args.control = calendar;
                    calendar.onBeforeTimeHeaderExport(args);
                }
            };

            scheduler.onEventClick = function(args) {
                args.task = new DayPilot.Task(args.e, calendar);
                args.control = calendar;
                if (typeof calendar.onTaskClick === "function") {
                    calendar.onTaskClick(args);
                }
            };

            scheduler.onEventClicked = function(args) {
                if (typeof calendar.onTaskClicked === "function") {
                    calendar.onTaskClicked(args);
                }
            };

            scheduler.onEventDelete = function(args) {
                if (typeof calendar.onTaskDelete === "function") {
                    calendar.onTaskDelete(args);
                }
            };

            scheduler.onEventDeleted = function(args) {
                if (typeof calendar.onTaskDeleted === "function") {
                    calendar.onTaskDeleted(args);
                }
            };

            scheduler.onEventDoubleClick = function(args) {
                args.task = new DayPilot.Task(args.e, calendar);
                args.control = calendar;
                if (typeof calendar.onTaskDoubleClick === "function") {
                    calendar.onTaskDoubleClick(args);
                }
            };

            scheduler.onEventDoubleClicked = function(args) {
                if (typeof calendar.onTaskDoubleClicked === "function") {
                    calendar.onTaskDoubleClicked(args);
                }
            };

            scheduler.onEventRightClick = function(args) {
                args.task = new DayPilot.Task(args.e, calendar);
                if (typeof calendar.onTaskRightClick === "function") {
                    calendar.onTaskRightClick(args);
                }
            };

            scheduler.onEventRightClicked = function(args) {
                if (typeof calendar.onTaskRightClicked === "function") {
                    calendar.onTaskRightClicked(args);
                }
            };

            scheduler.onRowMoving = function(args) {
                args._source = args.source;
                args._target = args.target;
                args.source = new DayPilot.Task(args._source.$.row.task, calendar);
                args.target = new DayPilot.Task(args._target.$.row.task, calendar);

                if (typeof calendar.onRowMoving === "function") {
                    calendar.onRowMoving(args);
                }
            };

            scheduler.onRowMove = function(args) {
                args._source = args.source;
                args._target = args.target;
                args.source = new DayPilot.Task(args._source.$.row.task, calendar);
                args.target = new DayPilot.Task(args._target.$.row.task, calendar);
                args.control = calendar;
                if (typeof calendar.onRowMove === "function") {
                    calendar.onRowMove(args);
                }
                args.source = args._source;
                args.target = args._target;
            };

            scheduler.onRowMoved = function(args) {

                var updateNow = calendar.rowMoveHandling === "Update" || calendar.rowMoveHandling === "Notify";

                if (updateNow) {
                    // update parents
                    var source = args._source.$.row.task;
                    var target = args._target.$.row.task;
                    var position = args.position;

                    // *******************

                    if (position === "forbidden") {
                        return;
                    }

                    var sourceGantt = args._source.calendar.internal.gantt;

                    // remove from source
                    var sourceParent = sourceGantt._tasktools.findParentArray(source);
                    if (!sourceParent) {
                        throw "Cannot find source node parent";
                    }
                    var sourceIndex = DayPilot.indexOf(sourceParent, source);
                    sourceParent.splice(sourceIndex, 1);

                    // move to target
                    var targetParent = tasktools.findParentArray(target);
                    if (!targetParent) {
                        throw "Cannot find target node parent";
                    }
                    var targetIndex = DayPilot.indexOf(targetParent, target);

                    switch (position) {
                        case "before":
                            targetParent.splice(targetIndex, 0, source);
                            break;
                        case "after":
                            targetParent.splice(targetIndex + 1, 0, source);
                            break;
                        case "child":
                            if (!target.children) {
                                target.children = [];
                                target.expanded = true;
                            }
                            target.children.push(source);
                            break;
                    }

                    //wrap._loadTasks();
                    calendar._angular.notify();

                    calendar.update();

                    if (sourceGantt !== calendar) {
                        sourceGantt.update();
                    }

                    // *******************
                }

                args.source = new DayPilot.Task(args._source.$.row.task, calendar);
                args.target = new DayPilot.Task(args._target.$.row.task, calendar);

                if (typeof calendar.onRowMoved === "function") {
                    calendar.onRowMoved(args);
                }
            };

            scheduler.onRowClick = function(args) {
                args.task = new DayPilot.Task(args.resource.$.row.task, calendar);
                if (typeof calendar.onRowClick === "function") {
                    calendar.onRowClick(args);
                }
            };

            scheduler.onRowClicked = function(args) {
                if (typeof calendar.onRowClicked === "function") {
                    calendar.onRowClicked(args);
                }
            };

            scheduler.onRowDoubleClick = function(args) {
                args.task = new DayPilot.Task(args.resource.$.row.task, calendar);
                if (typeof calendar.onRowDoubleClick === "function") {
                    calendar.onRowDoubleClick(args);
                }
            };

            scheduler.onRowDoubleClicked = function(args) {
                if (typeof calendar.onRowDoubleClicked === "function") {
                    calendar.onRowDoubleClicked(args);
                }
            };

            scheduler.onRowEdit = function(args) {
                args.task = new DayPilot.Task(args.resource.$.row.task, calendar);
                if (typeof calendar.onRowEdit === "function") {
                    calendar.onRowEdit(args);
                }
            };

            scheduler.onRowEdited = function(args) {
                if (typeof calendar.onRowEdited === "function") {
                    calendar.onRowEdited(args);
                }
            };

            scheduler.onRowSelect = function(args) {
                args.task = new DayPilot.Task(args.row.$.row.task, calendar);
                if (typeof calendar.onRowSelect === "function") {
                    calendar.onRowSelect(args);
                }
            };

            scheduler.onRowSelected = function(args) {
                if (typeof calendar.onRowSelected === "function") {
                    calendar.onRowSelected(args);
                }
            };

            scheduler.onEventMove = function(args) {
                args._e = args.e;
                args.task = new DayPilot.Task(args.e, calendar);
                args.control = calendar;
                //delete args.e;
                //delete args.position;
                //delete args.newResource;
                if (typeof calendar.onTaskMove === "function") {
                    calendar.onTaskMove(args);
                }
            };

            scheduler.onEventMoved = function(args) {

/*
                var updateParent = function(parent) {
                    if (!parent) {
                        return;
                    }

                    var pe = scheduler.events.find(parent.id);
                    var children = wrap.childrenStartEnd(parent);
                    pe.start(children.start);
                    pe.end(children.end);
                    scheduler.events.update(pe);
                    updateParent(pe.data.parent);
                };
*/

                if (calendar.taskGroupMode === "Auto") {
                    var e = args._e;

                    // update source
                    var task = e.data.task;
                    task.start = e.start();
                    task.end = e.end();

                    //updateParent(args.e.data.parent);

                    while (e.data.parent) {
                        var parent = scheduler.events.find(e.data.parent.id);
                        var children = wrap.childrenStartEnd(e.data.parent);
                        parent.start(children.start);
                        parent.end(children.end);
                        scheduler.events.update(parent);
                        e = parent;
                    }

                }

                calendar._angular.notify();

                if (typeof calendar.onTaskMoved === "function") {
                    calendar.onTaskMoved(args);
                }
            };

            scheduler.onEventMoving = function(args) {
                args.task = new DayPilot.Task(args.e, calendar);
                args._e = args.e;

                delete args.position;
                delete args.overlapping;
                delete args.resource;

                if (typeof calendar.onTaskMoving === "function") {
                    calendar.onTaskMoving(args);
                }
            };

            scheduler.onEventResize = function(args) {
                args._e = args.e;
                args.task = new DayPilot.Task(args.e, calendar);
                args.control = calendar;
                if (typeof calendar.onTaskResize === "function") {
                    calendar.onTaskResize(args);
                }
            };

            scheduler.onEventResized = function(args) {
                if (calendar.taskGroupMode === "Auto") {

                    var e = args._e;

                    // update source
                    var task = e.data.task;
                    task.start = e.start();
                    task.end = e.end();

                    while (e.data.parent) {
                        var parent = scheduler.events.find(e.data.parent.id);
                        var children = wrap.childrenStartEnd(e.data.parent);
                        parent.start(children.start);
                        parent.end(children.end);
                        scheduler.events.update(parent);
                        e = parent;
                    }
                }
                calendar._angular.notify();

                if (typeof calendar.onTaskResized === "function") {
                    calendar.onTaskResized(args);
                }
            };

            scheduler.onEventResizing = function(args) {
                args.task = new DayPilot.Task(args.e, calendar);
                args._e = args.e;
                args.control = calendar;

                if (typeof calendar.onTaskResizing === "function") {
                    calendar.onTaskResizing(args);
                }
            };

            scheduler.onLinkCreate = function(args) {
                args.source = calendar.tasks.find(args.from);
                args.target = calendar.tasks.find(args.to);
                args.control = calendar;
                if (typeof calendar.onLinkCreate === "function") {
                    calendar.onLinkCreate(args);
                }
            };

            scheduler.onLinkCreated = function(args) {
                if (typeof calendar.onLinkCreated === "function") {
                    calendar.onLinkCreated(args);
                }
            };

            scheduler.onResourceExpand = function(args) {
                var task = args.resource.$.row.task;
                if (!task.row) {
                    task.row = {};
                }
                task.row.collapsed = false;
            };

            scheduler.onResourceCollapse = function(args) {
                var task = args.resource.$.row.task;
                if (!task.row) {
                    task.row = {};
                }
                task.row.collapsed = true;
            };

        };

        wrap._rowObjectForTaskData = function(data) {
            for (var i = 0; i < scheduler.rowlist.length; i++) {
                var row = scheduler.rowlist[i];
                if (row.task === data) {
                    return scheduler.internal.createRowObject(row);
                }
            }
            return null;
        };

        wrap._loadLinks = function() {
            scheduler.links.list = calendar.links.list ? calendar.links.list : [];
        };

        wrap._loadTasks =  function() {
            scheduler.resources = [];
            scheduler.events.list = [];

            tasktools.clearCache();

            wrap._loadChildren(calendar.tasks.list, scheduler.resources, null);

            if (css.sheet) {
                css.sheet.commit();
                css.sheet = null;
            }
        };

        wrap._doBeforeTaskRender = function(task) {

            var type = task.type || "Task";
            if (task.children && task.children.length) {
                type = "Group";
            }

            /*
            if (typeof calendar.onBeforeTaskRender !== "function") {
                return {
                    "data": task,
                    "type": type
                };
            }
            */

            var data = {};

            // make a copy
            for (var name in task) {
                if (name === "children") {
                    continue;
                }
                data[name] = task[name];
            }

            var args = {};
            args.data = data;
            args.type = type;

            if (!data.box) {
                data.box = {};
            }

            if (typeof data.box.html === "undefined") {
                if (args.type === "Task") {
                    var complete = data.complete || 0;
                    data.box.text = complete + "%";
                }
                else {
                    data.box.text = "";
                }
            }

            if (typeof data.box.htmlRight === "undefined") {
                data.box.htmlRight = scheduler.internal.xssTextHtml(data.text);
            }

            if (typeof calendar.onBeforeTaskRender === "function") {
                calendar.onBeforeTaskRender(args);
            }

            // read-only, override the change
            args.type = type;

            return args;
        };

        var css = {};
        css.keys = {};
        css.sheet = null;

        wrap._getBackColorCss = function(args) {
            if (!args.data.box) {
                return;
            }

            if (args.data.box.cssClass) {
                return;
            }

            if (!args.data.box.backColor) {
                return;
            }

            if (args.type === "Task") {
                return;
            }

            var color = DayPilot.Util.normalizeColor(args.data.box.backColor);
            var key = args.type + "_" + color.replace("#", "");

            var t = calendar.theme;
            var cn = calendar.theme + "_" + key;  // ."+cn+"

            if (!css.keys[key]) {
                css.keys[key] = true;

                if (!css.sheet) {
                    css.sheet = DayPilot.sheet();
                }

                if (args.type === "Group") {
                    css.sheet.add("."+cn+"."+t+"_task_group ."+t+"_event_inner", "position:absolute;top:5px;left:0px;right:0px;bottom:6px;overflow:hidden; background: "+color+"; filter: none; border: 0px none;");
                    css.sheet.add("."+cn+"."+t+"_task_group."+t+"_event:before", "content:''; border-color: transparent transparent transparent "+color+"; border-style: solid; border-width: 6px; position: absolute; bottom: 0px;");
                    css.sheet.add("."+cn+"."+t+"_task_group."+t+"_event:after", "content:''; border-color: transparent "+color+" transparent transparent; border-style: solid; border-width: 6px; position: absolute; bottom: 0px; right: 0px;");
                }
                else if (args.type === "Milestone") {
                    css.sheet.add("."+cn+"."+t+"_task_milestone ."+t+"_event_inner", "position:absolute;top:16%;left:16%;right:16%;bottom:16%; background: "+color+"; border: 0px none; -webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);-ms-transform: rotate(45deg);-o-transform: rotate(45deg); transform: rotate(45deg); filter: none;");
                    css.sheet.add("."+cn+"."+t+"_browser_ie8 ."+t+"_task_milestone ."+t+"_event_inner", "-ms-filter: \"progid:DXImageTransform.Microsoft.Matrix(SizingMethod='auto expand', M11=0.7071067811865476, M12=-0.7071067811865475, M21=0.7071067811865475, M22=0.7071067811865476);\"");
                }
            }

            return cn;

        };

        wrap._loadChildren = function(source, target, parent) {
            if (!DayPilot.isArray(source)) {
                return;
            }
            for (var i = 0; i < source.length; i++) {
                var original = source[i];
                tasktools.addToCache(original, parent);
                var args = wrap._doBeforeTaskRender(original);
                var task = args.data;
                var type = args.type;

                var event = {};
                DayPilot.Util.copyProps(task, event, ['id', 'start', 'end', 'text', 'complete', 'tags', 'versions']);
                DayPilot.Util.copyProps(task.box, event);
                event.parent = parent;
                event.task = original;
                event.resource = task.id;

                event.commitCallback = (function(e) {
                    return function() {
                        e.task.start = e.start;
                        e.task.end = e.end;
                    }
                })(event);

                if (type == "Group") {
                    event.type = "Group";
                    // event.html = "";
                    event.html = (task.box && task.box.html) || "";
                    //event.html = task.html;
                    //event.barHidden = true;

                    var css = wrap._getBackColorCss(args);
                    if (css) {
                        event.cssClass = (event.cssClass || "") + " " + css;
                    }

                    if (calendar.taskGroupMode === "Auto") {
                        var children = wrap.childrenStartEnd(original);
                        event.start = children.start;
                        event.end = children.end;
                        event.resizeDisabled = true;
                        event.moveDisabled = true;
                    }
                }
                else if (type === "Milestone") {
                    event.html = "";
                    // TODO modifying the original object (remove?)
                    original.end = original.start;

                    var css = wrap._getBackColorCss(args);
                    if (css) {
                        event.cssClass = (event.cssClass || "") + " " + css;
                    }

                    task.end = task.start;

                    event.end = task.start;
                    //event.html = task.html;
                    event.barHidden = true;
                    event.resizeDisabled = true;
                    event.type = "Milestone";
                    event.width = calendar.taskHeight;
                    delete event.backColor;
                }
                else if (type === "Task" ){
                    //event.html = task.box.html;
                    doNothing();
                }

                event.moveVDisabled = true;

                event.htmlRight = task.box.htmlRight;
                event.htmlLeft = task.box.htmlLeft;

                scheduler.events.list.push(event);

                var r = {};

                // source
                r.task = original;

                // server-based only
                DayPilot.Util.copyProps(task.row, r);

                r.name = task.text;
                r.id = task.id;
                r.children = [];
                r.expanded = !task.row || !task.row.collapsed;

                if (original.children && original.children.length) {
                    wrap._loadChildren(original.children, r.children, original);
                }

                target.push(r);

            }
        };

        wrap.childrenStartEnd = function(task) {
            if (!task.children || !task.children.length) {
                var start = task.start;
                var end = task.end;
                if (task.type === "Milestone") {
                    end = start;
                }
                return { "start": new DayPilot.Date(start), "end": new DayPilot.Date(end) };
            }
            var start = null;
            var end = null;
            for (var i = 0; i < task.children.length; i++) {
                var children = wrap.childrenStartEnd(task.children[i]);
                if (!start || children.start.getTime() < start.getTime()) {
                    start = children.start;
                }
                if (!end || children.end.getTime() > end.getTime()) {
                    end = children.end;
                }
            }
            return { "start": start, "end": end};
        };

        this.rows = {};

        this.rows.expand = function(levels) {
            scheduler.rows.expand(levels);
        };

        this.rows.expandAll = function() {
            scheduler.rows.expandAll();
        };

        this.rows.filter = function(param) {
            scheduler.rows.filter(param);
        };

        this.rows.selection = {};

        this.rows.selection.add = function(task) {
            var row = scheduler.rows.find(task.data.id);

        };

        this.rows.selection.clear = function() {
            scheduler.rows.selection.clear();
        };

        this.rows.selection.get = function() {
            return scheduler.rows.selection.get().map(function(row) {
                return new DayPilot.Task(row.$.row.task, calendar);
            });
        };

        this.exportAs = function(format, options) {
/*
            if (!calendar._visible()) {
                throw new DayPilot.Exception("DayPilot.Scheduler.exportAs(): The instance must be visible during export.");
            }
*/
            return scheduler.exportAs(format, options);
        };


        this._specialHandling = null;
        this._loadOptions = function(options) {
            if (!options) {
                return;
            }

            var specialHandling = {
                "tasks": {
                    "preInit": function() {
                        var tasks = this.data;
                        if (!tasks) {
                            return;
                        }
                        if (DayPilot.isArray(tasks.list)) {
                            calendar.tasks.list = tasks.list;
                        }
                        else {
                            calendar.tasks.list = tasks;
                        }
                    }
                },
                "links": {
                    "preInit": function() {

                        var links = this.data;
                        if (!links) {
                            return;
                        }
                        if (DayPilot.isArray(links.list)) {
                            calendar.links.list = links.list;
                        }
                        else {
                            calendar.links.list = links;
                        }
                    }
                },
                "scrollTo": {
                    "postInit": function() {
                        if (this.data) {
                            calendar.scrollTo(this.data);
                        }
                    }
                },
                "scrollToTask": {
                    "postInit": function() {
                        if (this.data) {
                            calendar.scrollToTask(this.data);
                        }
                    }
                }
            };
            this._specialHandling = specialHandling;

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    calendar[name] = options[name];
                }
            }

        };

        this._postInit = function() {
            var specialHandling = this._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
        };

        this.internal = {};
        this.internal.initialized =  function() {
            return calendar._initialized;
        };
        // DayPilot.Task
        this.internal.rowObjectForTaskData = wrap._rowObjectForTaskData;
        // Angular 2
        this.internal.loadOptions = calendar._loadOptions;

        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function() {
            if (calendar._angular.scope) {
                calendar._angular.scope["$apply"]();
            }
        };

        this._loadOptions(options);
    };

    // experimental jQuery bindings
    if (typeof jQuery !== 'undefined') {
        (function($) {
            $.fn.daypilotGantt = function(options) {
                var first = null;
                var j = this.each(function() {
                    if (this.daypilot) { // already initialized
                        return;
                    };

                    var daypilot = new DayPilot.Gantt(this.id, options);
                    daypilot.init();

                    this.daypilot = daypilot;

                    if (!first) {
                        first = daypilot;
                    }
                });
                if (this.length === 1) {
                    return first;
                }
                else {
                    return j;
                }
            };
        })(jQuery);
    }

    (function registerAngularModule() {
        var app = DayPilot.am();

        if (!app) {
            return;
        }

        app.directive("daypilotGantt", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element.replaceWith(this["template"].replace("{{id}}", attrs["id"]));

                    return function link(scope, element, attrs) {
                        var calendar = new DayPilot.Gantt(element[0]);
                        calendar._angular.scope = scope;
                        calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Calendar object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }

                            }
                        }


                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        //var events = attrs["events"] || attrs["daypilotEvents"];

                        watch.call(scope, config, function (value, oldVal) {
                            calendar._loadOptions(value);
                            calendar.update();
                        }, true);

                    };
                }
            };
        }]);

    })();

    DayPilot.Gantt.def = {};

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright © 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
	var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Kanban !== 'undefined' && DayPilot.Kanban.def) {
        return;
    }

    // prevent unwanted effects during minification
    var doNothing = function() { };

    DayPilot.Kanban = function(id, options) {
        this.v = '2023.2.5592';
        var This = this;

        this.barWidth = 5;
        this.cardAutoHeight = true;
        this.cardHeight = 60;
        this.cardMarginLeft = 5;
        this.cardMarginRight = 5;
        this.cardMarginBottom = 5;
        this.columnHeaderHeight = 20;
        // this.crosshairColor = "gray";
        this.crosshairType = 'Disabled';
        this.height = 300;
        this.heightSpec = "Auto";
        this.theme = "kanban_default";
        this.cellMarginBottom = 4;
        this.cellMarginTop = 5;
        this.columnWidthSpec = "Auto";
        this.columnWidth = 200;
        this.cornerHtml = null;
        this.contextMenuCard = null;
        this.rowMinHeight = 0;
        this.swimlaneCollapsingEnabled = false;
        this.swimlaneHeaderWidth = 80;
        this.visible = true;

        this.swimlanes = {};
        this.swimlanes.list = [];
        this.columns = {};
        this.columns.list = [];
        this.cards = {};
        this.cards.list = [];

        this.cardDeleteHandling = "Disabled";
        this.cardMoveHandling = "Update";
        this.columnMoveHandling = "Disabled";
        this.swimlaneMoveHandling = "Disabled";
        this.cardRightClickHandling = 'ContextMenu';

        this.onBeforeCellRender = null;
        this.onCardClick = null;
        this.onCardClicked = null;
        this.onCardRightClick = null;
        this.onCardRightClicked = null;
        this.onCardDelete = null;
        this.onCardDeleted = null;
        this.onCardMove = null;
        this.onCardMoved = null;
        //this.onCardMoving = null;
        this.onColumnMove = null;
        this.onColumnMoved = null;
        this.onHeightChanged = null;
        this.onSwimlaneMove = null;
        this.onSwimlaneMoved = null;

        var scheduler = new DayPilot.Scheduler(id);
        this.scheduler = scheduler;

        var wrap = {};

        var swimlaneCollapseIconWidth = 15;
        var swimlaneCollapseIconHeight = 15;

        doNothing();

        var start = new DayPilot.Date("2000-01-01");

        wrap.translate = function() {
            var dp = scheduler;
            dp.startDate = start;
            dp.scale = "Day";
            dp.timeHeaders = [
                { groupBy: "Cell", format: "d" }
            ];
            dp.rowHeaderColumnsMode = "Legacy";

            dp.heightSpec = This.heightSpec;

            dp.cellWidthSpec = This.columnWidthSpec;
            dp.cellWidth = This.columnWidth;
            dp.cellsMarkBusiness = false;
            dp.cornerHtml = This.cornerHtml;
            dp.crosshairType = This.crosshairType;
            dp.dynamicEventRendering = "Disabled";
            dp.floatingEvents = false;
            dp.floatingTimeHeaders = false;
            dp.rowMinHeight = This.rowMinHeight;
            dp.rowMarginTop = This.cellMarginTop;
            dp.rowMarginBottom = This.cellMarginBottom;
            dp.devsb = This.devsb;

            dp.eventMoveToPosition = true;
            dp.headerHeight = This.columnHeaderHeight;
            dp.eventResizeHandling = "Disabled";
            dp.timeRangeSelectedHandling = "Disabled";

            dp.eventHeight = This.cardHeight;
            dp.eventMarginLeft = This.cardMarginLeft;
            dp.eventMarginRight = This.cardMarginRight;
            dp.eventMarginBottom = This.cardMarginBottom;
            dp.eventTextWrappingEnabled = true;
            // dp.cellStacking = true;
            // dp.cellStackingAutoHeight = This.cardAutoHeight;
            dp.durationBarVisible = false;
            dp.theme = This.theme;
            dp.visible = This.visible;
            dp.rowHeaderWidth = This.swimlaneHeaderWidth;

            dp.contextMenu = This.contextMenuCard;


            dp.eventDeleteHandling = This.cardDeleteHandling;
            dp.eventMoveHandling = This.cardMoveHandling;
            dp.rowMoveHandling = DayPilot.list(This.swimlanes.list).isEmpty() ? "Disabled" : This.swimlaneMoveHandling;
            dp.eventRightClickHandling = This.cardRightClickHandling;

            dp.onHeightChanged = This.onHeightChanged;

            dp.internal.enableCellStacking(This.cardAutoHeight);
            dp.internal.cssNames.timeheadercol = "_colheadercell";
            dp.internal.cssNames.timeheadercolInner = "_colheadercell_inner";
            dp.internal.cssNames.resourcedivider = "_rowheaderdivider";
            dp.internal.cssNames.event = "_card";
            dp.internal.cssNames.eventInner = "_card_inner";
            dp.internal.cssNames.eventDelete = "_card_delete";
            dp.internal.cssNames.eventMovingSource = "_card_moving_source";

            if (This.swimlaneCollapsingEnabled) {
                dp.rowHeaderWidthMarginRight = swimlaneCollapseIconWidth + 0;
            }

            dp.onBeforeTimeHeaderRender = function(args) {
                var column = This._findColumn(args.header.start);

                args.header.html = column.name;
                args.header.toolTip = column.toolTip || "";
                args.header.areas = DayPilot.list(column.areas).map(function(src) {
                    var area = [];
                    DayPilot.Util.copyProps(src, area);
                    return area;
                });

                DayPilot.list(args.header.areas).forEach(function(area) {
                    area.target = new DayPilot.KanbanColumn(column, This);
                });

                if (This.columnMoveHandling !== "Disabled") {
                    var css = This.theme + "_columnmove_handle";
                    args.header.areas.push(
                        { "left": 0, "top": 0, "width": 20, "height": 20, "css": css, "mousedown": This._onColumnMouseDown, "action": "None" }
                    );
                }
            };

            dp.onBeforeCellRender = function(args) {

                var wargs = {};
                wargs.cell = {};
                // read-only
                wargs.cell.column = new DayPilot.KanbanColumn(This._findColumn(args.cell.start), This);
                wargs.cell.swimlane = null;

                var swimlane = This._findSwimlane(args.cell.resource);
                if (swimlane) {
                    wargs.cell.swimlane = new DayPilot.Swimlane(swimlane, This);
                }

                // read/write
                wargs.cell.areas = [];
                wargs.cell.cssClass = null;
                wargs.cell.html = null;
                wargs.cell.backImage = null;
                wargs.cell.backRepeat = null;
                wargs.cell.backColor = null;

                if (typeof This.onBeforeCellRender === "function") {
                    This.onBeforeCellRender(wargs);
                    DayPilot.Util.copyProps(wargs.cell, args.cell, ["areas", "cssClass", "html", "backImage", "backRepeat", "backColor"]);
                    DayPilot.list(args.cell.areas).forEach(function(area) {
                        area.target = {
                            "swimlane": wargs.cell.swimlane,
                            "column": wargs.cell.column
                        };
                    })
                }

                var row = dp.rows.find(args.cell.resource);
                var res = dp.resources[row.index];
                if (res.collapsed) {
                    if (!args.cell.cssClass) {
                        args.cell.cssClass = "";
                    }
                    args.cell.cssClass += " " + This.theme + "_collapsed";
                }
            };

            dp.onEventClick = function(args) {
                var wargs = new DayPilot.Args(args);
                wargs.card = new DayPilot.Card(args.e.data.card, This);
                if (typeof This.onCardClick === "function") {
                    This.onCardClick(wargs);
                }
                args.wrapped = wargs;
            };

            dp.onEventClicked = function(args) {
                var wargs = args.wrapped;
                if (typeof This.onCardClicked === "function") {
                    This.onCardClicked(wargs);
                }
            };

            dp.onEventRightClick = function(args) {
                var wargs = new DayPilot.Args(args);
                wargs.card = new DayPilot.Card(args.e.data.card, This);
                if (typeof This.onCardRightClick === "function") {
                    This.onCardRightClick(wargs);
                }
                args.wrapped = wargs;

                if (args.preventDefault.value) {
                    return;
                }

                var e = args.e;
                var card = wargs.card;
                switch (This.cardRightClickHandling) {
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(card);
                        }
                        else {
                            if (This.contextMenuCard) {
                                This.contextMenuCard.show(card);
                            }
                        }
                        args.preventDefault();
                        break;
/*
                    case 'Bubble':
                        if (This.bubble) {
                            This.bubble.showEvent(card);
                        }
                        break;
*/

                }
            };

            dp.onEventRightClicked = function(args) {
                var wargs = args.wrapped;
                if (typeof This.onCardRightClicked === "function") {
                    This.onCardRightClicked(wargs);
                }
            };

            dp.onEventDelete = function(args) {
                var wargs = new DayPilot.Args(args);
                wargs.card = new DayPilot.Card(args.e.data.card, This);
                wargs.control = This;
                if (typeof This.onCardDelete === "function") {
                    This.onCardDelete(wargs);
                }
                args.wrapped = wargs;
            };

            dp.onEventDeleted = function(args) {
                DayPilot.rfa(This.cards.list, args.e.data.card);

                var wargs = args.wrapped;
                if (typeof This.onCardDeleted === "function") {
                    This.onCardDeleted(wargs);
                }
            };

            dp.onEventMove = function(args) {

                if (args.external) {
                    args.e.data.card = {
                        id: args.e.data.id,
                        name: args.e.data.name,
                        text: args.e.data.text,
                        barColor: args.e.data.barColor,
                        barBackColor: args.e.data.barBackColor
                    };
                }

                var wargs = new DayPilot.Args(args);
                wargs.control = This;
                wargs.card = new DayPilot.Card(args.e.data.card, This);
                wargs.column = new DayPilot.KanbanColumn(This._findColumn(args.newStart));
                wargs.position = args.position;
                wargs.external = args.external;
                if (args.newResource !== "*") {
                    wargs.swimlane = new DayPilot.Swimlane(This._findSwimlane(args.newResource), This);
                }
                else {
                    wargs.swimlane = null;
                }

                //console.log("position: " + args.position);

                // target cell
                var events = scheduler.cells.find(args.newStart, args.newResource)[0].events();

                //var previous = events[args.position - 1] ? new DayPilot.Card(events[args.position - 1], This) : null;
                var targetIndex = args.position;

                var previous = null;
                var pi = targetIndex - 1;
                while (events[pi]) {
                    if (events[pi].data !== args.e.data) {
                        previous = new DayPilot.Card(events[pi]);  // create it from DayPilot.Event
                        break;
                    }
                    pi -= 1;
                }

                var next = null;
                var ni = targetIndex;
                while (events[ni]) {
                    if (events[ni].data !== args.e.data) {
                        next = new DayPilot.Card(events[ni]);  // create it from DayPilot.Event
                        break;
                    }
                    ni += 1;
                }

                wargs.previous = previous;
                wargs.next = next;

                if (typeof This.onCardMove === "function") {
                    This.onCardMove(wargs);
                }

                args.wrapped = wargs;

                // the default moving logic disabled, replaced by column update below
                args.preventDefault();

                if (wargs.preventDefault.value) {
                    return;
                }

                switch (This.cardMoveHandling) {
                    case "Update":
                        var newIndex = 0;
                        if (next) {
                            newIndex = next.wrapped.data.sort[0];
                        }
                        else if (previous) {
                            newIndex = previous.wrapped.data.sort[0];
                        }
                        args.e.data.sort = [newIndex, new DayPilot.Date().toString()];

                        DayPilot.rfa(This.cards.list, args.e.data.card);

                        var index = 0;
                        if (next) {
                            index = DayPilot.indexOf(This.cards.list, next.data);
                        }
                        else if (previous) {
                            index = DayPilot.indexOf(This.cards.list, previous.data) + 1;
                        }

                        // update the column
                        var column = This._findColumn(args.newStart);
                        args.e.data.card.column = column.id;

                        // update the swimlane
                        args.e.data.card.swimlane = args.newResource;

                        This.cards.list.splice(index, 0, args.e.data.card);

                        wrap.updateSort();
                        scheduler.internal.deleteDragSource();
                        This.update();
                        break;
                }

                (function moved() {
                    var wargs = args.wrapped;
                    var source = DayPilot.list(This.cards.list).find(function(item) {
                        return args.e.data.card === item;
                    });



                    source.swimlane = wargs.swimlane ? wargs.swimlane.data.id : null;
                    source.column = wargs.column.data.id;

                    if (typeof This.onCardMoved === "function") {
                        This.onCardMoved(wargs);
                    }
                })();

            };

            dp.onBeforeResHeaderRender = function(args) {

                if (!This.swimlaneCollapsingEnabled) {
                    return;
                }

                var noSwimlanes = DayPilot.list(This.swimlanes.list).isEmpty();
                if (noSwimlanes) {
                    return;
                }

                var css = This.theme + "_swimlane_collapse";
                if (args.resource.collapsed) {
                    css = This.theme + "_swimlane_expand";
                }
                args.resource.areas = [
                    {"right":0, "top":0, "height": swimlaneCollapseIconHeight, "width": swimlaneCollapseIconWidth, "action":"JavaScript", "css": css, "js": function() { This._toggleSwimlane(args.resource.index); }}
                ];

            };

            dp.onRowMove = function(args) {
                var wargs = new DayPilot.Args(args);
                wargs.control = This;
                args.wrapped = wargs;
                wargs.swimlane = new DayPilot.Swimlane(args.source.$.row.swimlane);

                var targetIndex = 0;
                switch (args.position) {
                    case "before":
                        targetIndex = args.target.index;
                        break;
                    case "after":
                        targetIndex = args.target.index + 1;
                        break;
                    default:
                        throw "Unexpected target swimlane position: " + args.position;
                        break;
                }
                wargs.position = targetIndex;

                wargs.previous = null;
                var pi = targetIndex - 1;
                while (scheduler.rowlist[pi] && scheduler.rowlist[pi].swimlane !== wargs.swimlane.data) {
                    wargs.previous = new DayPilot.Swimlane(scheduler.rowlist[pi].swimlane);
                    pi -= 1;
                }

                wargs.next = null;
                var ni = targetIndex;
                while (scheduler.rowlist[ni] && scheduler.rowlist[ni].swimlane !== wargs.swimlane.data) {
                    wargs.next = new DayPilot.Swimlane(scheduler.rowlist[ni].swimlane);
                    ni += 1;
                }

                if (typeof This.onSwimlaneMove === "function") {
                    This.onSwimlaneMove(wargs);
                }
            };

            dp.onRowMoved = function(args) {

                var wargs = args.wrapped;

                DayPilot.rfa(This.swimlanes.list, wargs.swimlane.data);

                var index = 0;
                if (wargs.next) {
                    index = DayPilot.indexOf(This.swimlanes.list, wargs.next.data);
                }
                else if (wargs.previous) {
                    index = DayPilot.indexOf(This.swimlanes.list, wargs.previous.data) + 1;
                }

                This.swimlanes.list.splice(index, 0, wargs.swimlane.data);

                if (typeof This.onSwimlaneMoved === "function") {
                    This.onSwimlaneMoved(wargs);
                }
            };

            //dp.treeEnabled = true;
            dp.treePreventParentUsage = true;

        };

        wrap.loadCards = function() {
            // var start = new DayPilot.Date("2000-01-01");
            var headerCss = This.theme + "_card_header";
            var bodyCss = This.theme + "_card_body";

            var now = new DayPilot.Date().toString();

            scheduler.sortDirections = ["asc", "desc"];

            scheduler.events.list = DayPilot.list(This.cards.list).map(function(card, i) {
                var html = card.html || card.text || "";
                var name = card.name || "";

                var data = {};
                data.id = card.id;
                data.text = card.text;
                data.html = "<div class='" + headerCss + "'>" + name + "</div><div class='" + bodyCss + "'>" + html + "</div>";
                data.resource = card.swimlane;
                data.start = start.addDays(DayPilot.list(This.columns.list).findIndex(function(item) {
                    return card.column === item.id;
                }));
                data.end = data.start.addDays(1);
                //data.barColor = card.barColor;
                data.card = card;
                data.height = card.height;
                data.cssClass = card.cssClass;
                data.sort = [i , now];
                data.areas = DayPilot.list(card.areas).map(function(item) {
                    var copy = {};
                    DayPilot.Util.copyProps(item, copy);
                    if (item.js) {
                        copy.js = function(e) { item.js(new DayPilot.Card(e.data.card, This)); };
                    }
                    return copy;
                });
                data.areas.push({"left": 0, "width":5, "top": 0, "bottom":0, "backColor": card.barColor, "cssClass": This.theme + "_card_bar"});

                return data;
            });
        };

        wrap.updateSort = function() {
            var now = new DayPilot.Date().toString();
            DayPilot.list(This.cards.list).forEach(function(item, i) {
                var evdata = wrap.findSchedulerEventData(item);
                if (evdata) {
                    evdata.sort = [i, now];
                }
            });
        };

        wrap.findSchedulerEventData = function(cardData) {
            return DayPilot.list(scheduler.events.list).find(function(evdata) {
                return evdata.card === cardData;
            });
        };

        wrap.loadSwimlanes = function() {
            var collapsedHeight = 20;
            var swimlanes = DayPilot.list(This.swimlanes.list);
            scheduler.resources = swimlanes.map(function(input) {
                var item = {};
                item.name = input.name;
                item.id = input.id;
                item.swimlane = input;

                if (input.collapsed) {
                    item.collapsed = true;
                    item.eventHeight = collapsedHeight;
                    item.hideEvents = true;
                    /*
                    // prevent loading tasks, might not work in the long term
                    item.id = null;
                    */
                }

                return item;
            });

            if (swimlanes.isEmpty()) {
                scheduler.resources = [
                    {name: "", id: "*"}
                ];
            }

        };

        wrap.loadColumns = function() {
            var columns = DayPilot.list(This.columns.list);
            scheduler.days = columns.length;
        };

        var colmoving = {};
        colmoving.active = null;
        colmoving.div = null;

        colmoving.update = function() {
            colmoving.clear();

            var index = colmoving.findPosition();
            colmoving.draw(index);
        };

        colmoving.clear = function() {
            DayPilot.de(colmoving.div);
            colmoving.div = null;
        };

        colmoving.draw = function(index) {
            var left = 0;
            if (index >= scheduler.itline.length) {
                var cell = scheduler.itline[scheduler.itline.length - 1];
                left = cell.left + cell.width - 3;
            }
            else {
                left = scheduler.itline[index].left;
            }

            var div = document.createElement("div");
            div.style.position = "absolute";
            //div.style.backgroundColor = "green";
            div.style.left = left + "px";
            div.style.width = "3px";
            div.style.top = 0;
            div.style.height = scheduler.headerHeight + "px";
            div.className = This.theme + "_columnmove_position";

            colmoving.div = div;

            scheduler.nav.timeHeader.appendChild(div);
        };

        colmoving.findPosition = function() {
            if (This.coords.x < 0) {
                return 0;
            }
            var index = DayPilot.list(scheduler.itline).findIndex(function(item) {
                var left = item.left + scheduler.rowHeaderWidth;
                var width = item.width;
                return This.coords.x < (left + width/2);
            });

            if (index === -1) {
                return scheduler.itline.length;
            }
            return index;
        };

        this._onColumnMouseDown = function(args) {
            colmoving.active = args;
        };

        this._findColumn = function(date) {
            // return This.columns.list[date.getDay() - 1];
            return This.columns.list[DayPilot.DateUtil.daysDiff(start, date)];
        };

        this._findSwimlane = function(id) {
            return DayPilot.list(This.swimlanes.list).find(function(item) {
                return item.id === id;
            });
        };

        this.message = function(html, delay, foreColor, backColor) {
            scheduler.message(html, delay, foreColor, backColor);
        };

        this.show = function() {
            This.visible = true;
            scheduler.show();
        };

        this.hide = function() {
            This.visible = false;
            scheduler.hide();
        };

        this.cards.add = function(card) {
            var data = null;
            if (card && card instanceof DayPilot.Card) {
                data = card.data;
            }
            else {
                data = card;
            }
            if (!card) {
                return;
            }
            This.cards.list.push(data);
            This.update();
        };

        this.cards.remove = function(card) {
            var data = null;
            if (card && card instanceof DayPilot.Card) {
                data = card.data;
            }
            else {
                data = card;
            }
            if (!card) {
                return;
            }
            DayPilot.rfa(This.cards.list, data);
            This.update();
        };

        this.cards.update = function(card) {

            // shortcut implementation
            This.update();
        };

        this.cards.find = function(id) {
            var data = DayPilot.list(This.cards.list).find(function(item) {
                if (id === item.id) {
                    return true;
                }
                return false;
            });
            if (!data) {
                return null;
            }
            return new DayPilot.Card(data, This);
        };

        this._toggleSwimlane = function(i) {
            if (!DayPilot.list(This.swimlanes.list).isEmpty()) {
                This.swimlanes.list[i].collapsed = !This.swimlanes.list[i].collapsed;
            }
            This.update();
        };

        this.init = function() {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.")
            }
            wrap.translate();
            wrap.loadSwimlanes();
            wrap.loadColumns();
            wrap.loadCards();

            scheduler.init();
            This._registerGlobalHandlers();
            this._initialized = true;

            return this;
        };

        this._disposed = false;

        this.dispose = function() {
            scheduler.dispose();
            This._disposed = true;
        };

        this.update = function(options) {
            var calendar = This;
            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Kanban instance that hasn't been initialized yet.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Kanban instance that has been disposed.");
            }

            This._loadOptions(options);

            wrap.translate();
            wrap.loadSwimlanes();
            wrap.loadColumns();
            wrap.loadCards();
            scheduler.update();
        };

        this._registerGlobalHandlers = function() {
            DayPilot.re(document, 'mouseup', This._gMouseUp);
            DayPilot.re(document, 'mousemove', This._gMouseMove);
        };

        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function() {
            if (This._angular.scope) {
                This._angular.scope["$apply"]();
            }
        };

        this._specialHandling = null;
        this._loadOptions = function(options) {

            if (!options) {
                return;
            }

            var specialHandling = {
                "cards": {
                    "preInit": function() {
                        var cards = this.data;
                        if (!cards) {
                            // This.cards.list = [];
                            return;
                        }
                        if (DayPilot.isArray(cards.list)) {
                            This.cards.list = cards.list;
                        }
                        else {
                            This.cards.list = cards;
                        }
                    }
                },
                "columns": {
                    "preInit": function() {

                        var columns = this.data;
                        if (!columns) {
                            // This.columns.list = [];
                            return;
                        }
                        if (DayPilot.isArray(columns.list)) {
                            This.columns.list = columns.list;
                        }
                        else {
                            This.columns.list = columns;
                        }
                    }
                },
                "swimlanes": {
                    "preInit": function() {

                        var swimlanes = this.data;
                        if (!swimlanes) {
                            // This.swimlanes.list = [];
                            return;
                        }
                        if (DayPilot.isArray(swimlanes.list)) {
                            This.swimlanes.list = swimlanes.list;
                        }
                        else {
                            This.swimlanes.list = swimlanes;
                        }
                    }
                }
            };
            this._specialHandling = specialHandling;

/*            This.columns.list = [];
            This.swimlanes.list = [];
            This.cards.list = [];*/

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    This[name] = options[name];
                }
            }

        };

        this._postInit = function() {
            var specialHandling = this._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
        };

        this.internal = {};
        // Angular 2
        this.internal.loadOptions = This._loadOptions;

        this._loadOptions(options);

        this._visible = function() {
            var el = This.nav.top;
            if (!el) {
                return false;
            }
            return el.offsetWidth > 0 && el.offsetHeight > 0;
        };

        this._waitForVisibility = function() {
            var calendar = This;
            var visible = calendar._visible;

            if (!visible() && !calendar._visibilityInterval) {
                //calendar.debug.message("Not visible during init, starting visibilityInterval");
                calendar._visibilityInterval = setInterval(function() {
                    if (visible()) {
                        calendar.update();
                        clearInterval(calendar._visibilityInterval);
                    }
                }, 100);
            }
        };

        this._gMouseMove = function(ev) {
            This.coords = DayPilot.mo3(scheduler.nav.top, ev);

            if (colmoving.active) {
                colmoving.update();
            }
        };

        this._gMouseUp = function(ev) {
            if (!colmoving.active) {
                return;
            }

            var source = colmoving.active.source;
            var target = colmoving.findPosition();

            var column = This._findColumn(source.start);

            var args = new DayPilot.Args();
            args.column = new DayPilot.KanbanColumn(column, This);
            args.position = target;
            args.previous = null;
            args.next = null;

            var previous = null;
            var position = args.position;
            while (position !== 0 && !previous) {
                if (column !== This.columns.list[position - 1]) {
                    previous = This.columns.list[position - 1]
                }
                position -= 1;
            }

            if (previous) {
                args.previous = new DayPilot.KanbanColumn(previous, This);
            }

            var next = null;
            position = args.position;
            while (position < This.columns.list.length - 1 && !next) {
                if (column !== This.columns.list[position]) {
                    next = This.columns.list[position];
                }
                position += 1;
            }

            if (next) {
                args.next = new DayPilot.KanbanColumn(next, This);
            }

            if (typeof This.onColumnMove === "function") {
                This.onColumnMove(args);
            }

            if (!args.preventDefault.value) {

                if (This.columnMoveHandling === "Update") {
                    DayPilot.rfa(This.columns.list, args.column.data);

                    var index = 0;
                    if (args.next) {
                        index = DayPilot.indexOf(This.columns.list, args.next.data);
                    }
                    else if (args.previous) {
                        index = DayPilot.indexOf(This.columns.list, args.previous.data) + 1;
                    }

                    This.columns.list.splice(index, 0, args.column.data);

                    This.update();
                }

                if (typeof This.onColumnMoved === "function") {
                    This.onColumnMove(args);
                }
            }

            colmoving.active = null;
            colmoving.clear();
        };

    };

    DayPilot.Kanban.makeDraggable = function(options) {
        DayPilot.Scheduler.makeDraggable(options);
    };

	DayPilot.Card = function(data, control) {
        if (data instanceof DayPilot.Event) {
            var e = data;
            this.data = e.data.card;
            this.wrapped = data;
        }
        else {
            this.data = data;
        }

        this.control = control;
    };

    DayPilot.KanbanColumn = function(data, control) {
        this.data = data;
        this.control = control;
    };

    DayPilot.Swimlane = function(data, control) {
        this.data = data;
        this.control = control;
    };

    (function registerAngularModule() {
        var app = DayPilot.am();

        if (!app) {
            return;
        }

        app.directive("daypilotKanban", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element.replaceWith(this["template"].replace("{{id}}", attrs["id"]));

                    return function link(scope, element, attrs) {
                        var calendar = new DayPilot.Kanban(element[0]);
                        calendar._angular.scope = scope;
                        calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Calendar object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }
                            }
                        }

                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        //var events = attrs["cards"] || attrs["daypilotCards"];

                        watch.call(scope, config, function (value, oldVal) {
                            calendar._loadOptions(value);
                            calendar.update();
                        }, true);

                    };
                }
            };
        }]);

    })();

    DayPilot.Kanban.def = {};

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
 Use of this software is subject to license terms.
 https://www.daypilot.org/
 */

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Menu !== 'undefined' && DayPilot.Menu.def) {
        return;
    }

    var doNothing = function() {};

    var DayPilotMenu = {};

    DayPilotMenu.mouse = null;
    DayPilotMenu.menu = null;
    DayPilotMenu.handlersRegistered = false;
    DayPilotMenu.hideTimeout = null;
    DayPilotMenu.waitingSubmenu = null;

    DayPilot.Menu = function(items) {
        var menu = this;
        var initiatorAreaDiv = null;

        this.v = '2023.2.5592';
        this.zIndex = 120;  // more than 10,001 used by ModalPopupExtender
        //this.useShadow = true;
        this.cssClassPrefix = "menu_default";
        this.cssOnly = true;
        this.menuTitle = null;
        this.showMenuTitle = false;
        this.hideOnMouseOut = false;
        this.hideAfter = 200;
        this.theme = null;

        this.onShow = null;

        // hiding internal properties for angular
        this._state = function() {};
        //this._state.ref = null; // ref object, used for position

        if (items && DayPilot.isArray(items)) {
            this.items = items;
        }

        // angular change detection
        this.toJSON = function() {
            return null;
        };

        this.show = function(e, options) {
            options = options || {};

            var value = null;
            if (!e) {
                value = null;
            }
            else if (typeof e.id === 'string' || typeof e.id === 'number') {
                value = e.id;
            }
            else if (typeof e.id === 'function') {
                value = e.id();
            }
            else if (typeof e.value === 'function') {
                value = e.value();
            }

            if (typeof(DayPilot.Bubble) !== 'undefined') { // hide any bubble if active
                DayPilot.Bubble.hideActive();
            }

            if (!options.submenu) {
                DayPilotMenu.menuClean();
            }

            // clear old data
            this._state.submenu = null;

            if (DayPilotMenu.mouse === null) { // not possible to execute before mouse move (TODO)
                return;
            }

            if (!menu.cssOnly) {
                menu.cssOnly = true;
            }

            var source = null;
            if (e && e.isRow && e.$.row.task) {
                source = new DayPilot.Task(e.$.row.task, e.calendar);
                source.menuType = "resource";
            }
            else if (e && e.isEvent && e.data.task) {
                source = new DayPilot.Task(e, e.calendar);
            }
            else {
                source = e;
            }

            if (typeof menu.onShow === "function") {
                var args = {};
                args.source = source;
                args.menu = menu;
                args.preventDefault = function () {
                    args.preventDefault.value = true;
                };
                menu.onShow(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "0px";
            div.style.left = "0px";
            div.style.display = 'none';
            div.style.overflow = 'hidden';
            div.style.zIndex = this.zIndex + 1;
            div.className = this.applyCssClass('main');
            div.onclick = function(ev) {
                ev.cancelBubble = true;
                this.parentNode.removeChild(this);
            };

            if (this.hideOnMouseOut) {
                div.onmousemove = function(ev) {
                    clearTimeout(DayPilotMenu.hideTimeout);
                };
                div.onmouseleave = function(ev) {
                    menu.delayedHide({"hideParent": true});
                };
            }

            if (!this.items || this.items.length === 0) {
                throw "No menu items defined.";
            }

            if (this.showMenuTitle) {
                var title = document.createElement("div");
                title.innerHTML = this.menuTitle;
                title.className = this.applyCssClass("title");
                div.appendChild(title);
            }

            for (var i = 0; i < this.items.length; i++) {
                var mi = this.items[i];
                var item = document.createElement("div");
                DayPilot.Util.addClass(item, this.applyCssClass("item"));
                if (mi.items) {
                    DayPilot.Util.addClass(item, this.applyCssClass("item_haschildren"));
                    DayPilot.Util.addClass(div, this.applyCssClass(("withchildren")));
                }
                //item.style.position = 'relative';

                if (typeof mi === 'undefined') {
                    continue;
                }

                if (mi.hidden) {
                    continue;
                }


                if (mi.text === '-') {
                    var separator = document.createElement("div");
                    separator.addEventListener("click", function(ev) {
                        ev.stopPropagation();
                    });

                    item.appendChild(separator);
                }
                else {
                    var link = document.createElement("a");
                    link.style.position = 'relative';
                    link.style.display = "block";

                    if (mi.cssClass) {
                        DayPilot.Util.addClass(link, mi.cssClass);
                    }

                    if (mi.disabled) {
                        DayPilot.Util.addClass(link, menu.applyCssClass("item_disabled"));
                    }
                    else {
                        if (mi.onclick || mi.onClick) {
                            link.item = mi;
                            link.onclick = (function(mi, link) {
                                return function (e) {
                                    if (typeof mi.onClick === "function") {
                                        var args = {};
                                        args.item = mi;
                                        args.source = link.source;
                                        args.originalEvent = e;
                                        args.preventDefault = function () {
                                            args.preventDefault.value = true;
                                        };
                                        mi.onClick(args);
                                        if (args.preventDefault.value) {
                                            return;
                                        }
                                    }
                                    if (mi.onclick) {
                                        mi.onclick.call(link, e);
                                    }
                                };
                            })(mi, link);

                            var assignTouchEnd = function(mi, link) {
                                return function(e) {
                                    e.stopPropagation();
                                    e.preventDefault();

                                    var cleanup = function() {
                                        window.setTimeout(function() {
                                            link.source.calendar.internal.touch.active = false;
                                        }, 500);
                                    };

                                    if (typeof mi.onClick === "function") {
                                        var args = {};
                                        args.item = mi;
                                        args.source = link.source;
                                        args.originalEvent = e;
                                        args.preventDefault = function() {
                                            args.preventDefault.value = true;
                                        };
                                        mi.onClick(args);
                                        if (args.preventDefault.value) {
                                            cleanup();
                                            return;
                                        }
                                    }

                                    if (mi.onclick) {
                                        mi.onclick.call(link, e);
                                    }

                                    DayPilotMenu.menuClean();
                                    cleanup();
                                };
                            };

                            DayPilot.reNonPassive(link, "touchstart", function(ev) {
                                ev.stopPropagation();
                                ev.preventDefault();

                                link.source.calendar.internal.touch.active = true;
                            });
                            DayPilot.reNonPassive(link, "touchend", assignTouchEnd(mi, link));

                            // link.ontouchend = assignTouchEnd(mi, link);
                        }


                        if (mi.items && !mi.disabled) {
                            var assign = function(mi, link) {
                                return function(ev) {
                                    ev.preventDefault();
                                    ev.stopPropagation();
                                    menu._showSubmenu(mi, link);
                                };
                            };
                            link.ontouchend = assign(mi, link);
                        }

                        if (mi.onclick) {
                            doNothing();
                        }
                        else if (mi.href) {
                            link.href = mi.href.replace(/\x7B0\x7D/gim, value); // for NavigateUrl actions, only for backwards compatibility
                            if (mi.target) {
                                link.setAttribute("target", mi.target);
                            }
                        }
                        else if (mi.command) {
                            var assign = function(mi, link) {
                                return function(e) {
                                    var source = link.source;
                                    var item = mi;
                                    item.action = item.action ? item.action : 'CallBack';
                                    var cal = source.calendar || source.root;

                                    if (source instanceof DayPilot.Link) {
                                        cal.internal.linkMenuClick(item.command, source, item.action);
                                        return;
                                    }
                                    else if (source instanceof DayPilot.Selection) {
                                        cal.internal.timeRangeMenuClick(item.command, source, item.action);
                                        return;
                                    }
                                    else if (source instanceof DayPilot.Event) {
                                        cal.internal.eventMenuClick(item.command, source, item.action);
                                        return;
                                    }
                                    else if (source instanceof DayPilot.Selection) {
                                        cal.internal.timeRangeMenuClick(item.command, source, item.action);
                                        return;
                                    }
                                    else if (source instanceof DayPilot.Task) {
                                        if (source.menuType === "resource") {
                                            cal.internal.resourceHeaderMenuClick(item.command, link.menuSource, item.action);
                                        }
                                        else {
                                            cal.internal.eventMenuClick(item.command, link.menuSource, item.action);
                                        }
                                        return;
                                    }
                                    else {
                                        switch (source.menuType) {  // TODO legacy, remove
                                            case 'resource':
                                                cal.internal.resourceHeaderMenuClick(item.command, source, item.action);
                                                return;
                                            case 'selection':  // fully replaced
                                                cal.internal.timeRangeMenuClick(item.command, source, item.action);
                                                return;
                                            default:  //  fully replaced
                                                cal.internal.eventMenuClick(item.command, source, item.action);
                                                return;
                                        }
                                    }

                                    e.preventDefault();
                                };
                            };
                            link.onclick = assign(mi, link);
                            link.ontouchend = assign(mi, link);
                        }

                    }


                    if (mi.items) {
                        link.addEventListener("click", function(ev) {
                            ev.stopPropagation();
                        });
                    }

                    link.source = source;
                    link.menuSource = e;

                    var span = document.createElement("span");
                    span.className = menu.applyCssClass("item_text");
                    span.innerHTML = DayPilot.Util.escapeTextHtml(mi.text, mi.html);
                    link.appendChild(span);

                    if (mi.image) {
                        var image = document.createElement("img");
                        image.src = mi.image;
                        image.style.position = 'absolute';
                        image.style.top = '0px';
                        image.style.left = '0px';

                        link.appendChild(image);
                    }

                    if (mi.icon) {
                        var icon = document.createElement("span");
                        icon.className = menu.applyCssClass("item_icon");

                        var iel = document.createElement("i");
                        iel.className = mi.icon;
                        icon.appendChild(iel);

                        link.appendChild(icon);
                    }

                    if (mi.symbol) {
                        var ns = "http://www.w3.org/2000/svg";
                        var svg = document.createElementNS(ns,"svg");
                        svg.setAttribute("width", "100%");
                        svg.setAttribute("height", "100%");
                        var use = document.createElementNS(ns,"use");
                        use.setAttribute("href", mi.symbol);
                        svg.appendChild(use);

                        var svgWrap = document.createElement("span");
                        svgWrap.className = menu.applyCssClass("item_symbol");
                        svgWrap.style.position = "absolute";
                        svgWrap.style.top = "0px";
                        svgWrap.style.left = "0px";
                        svgWrap.appendChild(svg);

                        link.appendChild(svgWrap);
                    }

                    var assignOnMouseOver = function(mi, link) {
                        return function() {
                            var source = link.source;
                            var item = mi;

                            var ws = DayPilotMenu.waitingSubmenu;
                            if (ws) {
                                if (ws.parent === item) {
                                    return;
                                }
                                else {
                                    clearTimeout(ws.timeout);
                                    DayPilotMenu.waitingSubmenu = null;
                                }
                            }

                            if (mi.disabled) {
                                return;
                            }

                            DayPilotMenu.waitingSubmenu = {};
                            DayPilotMenu.waitingSubmenu.parent = item;
                            DayPilotMenu.waitingSubmenu.timeout = setTimeout(function() {

                                DayPilotMenu.waitingSubmenu = null;

                                menu._showSubmenu(item, link);

                            }, 300);
                        };
                    };

                    link.onmouseover = assignOnMouseOver(mi, link);

                    item.appendChild(link);
                }

                div.appendChild(item);

            }

            var delayedDismiss = function(e) {
                window.setTimeout(function() {
                    DayPilotMenu.menuClean();
                    DayPilot.MenuBar.deactivate();
                }, 100);
            };

            div.onclick = delayedDismiss;
            div.ontouchend = delayedDismiss;

            div.onmousedown = function(e) {
                e = e || window.event;
                e.cancelBubble = true;
                if (e.stopPropagation)
                    e.stopPropagation();
            };
            div.oncontextmenu = function() {
                return false;
            };

            document.body.appendChild(div);
            menu._state.visible = true;
            menu._state.source = e;

            div.style.display = '';
            var height = div.offsetHeight;
            var width = div.offsetWidth;
            div.style.display = 'none';

            // don't show the menu outside of the visible window
            var windowHeight = document.documentElement.clientHeight;
            // required for ipad with zoom instead of document.documentElement.clientWidth
            var windowWidth = window.innerWidth;

            var windowMargin = (typeof options.windowMargin == "number") ? options.windowMargin : 5;

            (function showInitiator() {
                var initiator = options.initiator;
                // initiator = options.initiator;
                if (!initiator) {
                    return;
                }
                var div = initiator.div;
                var e = initiator.e;
                var area = initiator.area;

                var v = area.visibility || area.v || "Visible";
                var a = initiator.a;
                if (v !== "Visible") {
                    // make sure the source area is visible
                    a = DayPilot.Areas.createArea(div, e, area);
                    div.appendChild(a);
                    // will be used to remove it on hide
                    initiatorAreaDiv = a;
                }

                if (a) {
                    var abs = DayPilot.abs(a);
                    options.x = abs.x;
                    options.y = abs.y + abs.h + 2;
                }

            })();


            (function adjustPosition() {

                // don't show it exactly under the cursor
                var x = (typeof options.x === "number") ? options.x : DayPilotMenu.mouse.x + 1;
                var y = (typeof options.y === "number") ? options.y : DayPilotMenu.mouse.y + 1;

                var topOffset = document.body.scrollTop || document.documentElement.scrollTop;
                var leftOffset = document.body.scrollLeft || document.documentElement.scrollLeft;

                if (y - topOffset > windowHeight - height && windowHeight !== 0) {
                    var offsetY = y - topOffset - (windowHeight - height) + windowMargin;
                    div.style.top = (y - offsetY) + 'px';
                }
                else {
                    div.style.top = y + 'px';
                }

                if (options.align === "right") {
                    x -= width;
                }

                if (x - leftOffset > windowWidth - width && windowWidth !== 0) {
                    var offsetX = x - leftOffset - (windowWidth - width) + windowMargin;
                    div.style.left = (x - offsetX) + 'px';
                }
                else {
                    div.style.left = x + 'px';
                }
/*
                if (DayPilotMenu.mouse.clientY > windowHeight - height && windowHeight !== 0) {
                    var offsetY = DayPilotMenu.mouse.clientY - (windowHeight - height) + 5;
                    div.style.top = (y - offsetY) + 'px';
                }
                else {
                    div.style.top = y + 'px';
                }

                if (DayPilotMenu.mouse.clientX > windowWidth - width && windowWidth !== 0) {
                    var offsetX = DayPilotMenu.mouse.clientX - (windowWidth - width) + 5;
                    div.style.left = (x - offsetX) + 'px';
                }
                else {
                    div.style.left = x + 'px';
                }
*/
            })();

            if (options.parentLink) {

                var parent = options.parentLink;

                var verticalOffset = parseInt(new DayPilot.StyleReader(div).get("border-top-width"));

                var pos = DayPilot.abs(options.parentLink.parentNode);
                var x = pos.x + parent.offsetWidth;
                var y = pos.y - verticalOffset;

                if (x + width > windowWidth) {
                    x = Math.max(0, pos.x - width);
                }

                var docScrollTop = document.body.scrollTop + document.documentElement.scrollTop;
                if (y + height - docScrollTop > windowHeight) {
                    y = Math.max(0, windowHeight - height + docScrollTop);
                }

                div.style.left = x + "px";
                div.style.top = y + "px";

            }
            div.style.display = '';

            this.addShadow(div);
            this._state.div = div;

            if (!options.submenu) {
                DayPilot.Menu.active = this;
            }

            //this._initiator = null;

        };

        this._showSubmenu = function(item, link) {
            var mi = item;
            var source = link.source;

            if (menu._state.submenu && menu._state.submenu.item === item) {  // already visible
                return;
            }

            if (menu._state.submenu && menu._state.submenu.item !== item) {  // hide submenus of other items
                DayPilot.Util.removeClass(menu._state.submenu.link.parentNode, menu.applyCssClass("item_haschildren_active"));
                menu._state.submenu.menu.hide();
                menu._state.submenu = null;
            }

            if (!item.items) {  // no submenu for this item
                return;
            }

            var options = menu.cloneOptions();
            options.items = item.items;

            menu._state.submenu = {};
            menu._state.submenu.menu = new DayPilot.Menu(options);
            menu._state.submenu.menu._parentMenu = menu;
            menu._state.submenu.menu.show(source, {"submenu": true, "parentLink": link, "parentItem": mi});
            menu._state.submenu.item = item;
            menu._state.submenu.link = link;
            DayPilot.Util.addClass(link.parentNode, menu.applyCssClass("item_haschildren_active"));

        };

        this.applyCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            var sep = (this.cssOnly ? "_" : "");
            if (prefix) {
                return prefix + sep + part;
            }
            else {
                return "";
            }
        };

        this.cloneOptions = function() {
            return DayPilot.Util.copyProps(options, {}, ["cssClassPrefix", "theme", "hideAfter", "hideOnMouseOut", "zIndex"]);
        };

        this.hide = function(props) {
            props = props || {};

            if (this._state.submenu) {
                this._state.submenu.menu.hide();
            }

            var ws = DayPilotMenu.waitingSubmenu;
            if (ws) {
                DayPilotMenu.waitingSubmenu = null;
                clearTimeout(ws.timeout);
            }

            this.removeShadow();
            if (this._state.div && this._state.div.parentNode === document.body) {
                document.body.removeChild(this._state.div);
            }

/*
            if (this._initiator) {
                DayPilot.de(this._initiator);
                this._initiator = null;
            }
*/

            if (initiatorAreaDiv) {
                DayPilot.de(initiatorAreaDiv);
                initiatorAreaDiv = null;
            }

            menu._state.visible = false;
            menu._state.source = null;

            if (menu._parentMenu && props.hideParent) {
                menu._parentMenu.hide(props);
            }

            if (DayPilot.Menu.active === menu) {
                DayPilot.Menu.active = null;
            }

            if (typeof this.onHide === "function") {
                var args = {};
                this.onHide(args);
            }

        };

        this.delayedHide = function(props) {
            DayPilotMenu.hideTimeout = setTimeout(function() {
                menu.hide(props);
            }, menu.hideAfter);
        };

        this.cancelHideTimeout = function() {
            clearTimeout(DayPilotMenu.hideTimeout);
        };

        // detects the mouse position, use when creating menu right before opening (.show)
        this.init = function(ev) {
            DayPilotMenu.mouseMove(ev);
            return this;
        };

        // disabled
        this.addShadow = function(object) {};

        // disabled
        this.removeShadow = function() {
        /*    if (!this._state.shadows) {
                return;
            }

            for (var i = 0; i < this._state.shadows.length; i++) {
                document.body.removeChild(this._state.shadows[i]);
            }
            this._state.shadows = [];*/
        };


        var options = DayPilot.isArray(items) ? null : items;
        if (options) {
            for (var name in options) {
                this[name] = options[name];
            }
        }

    };

    DayPilot.MenuBar = function(id, options) {
        var menubar = this;

        options = options || {};

        this.items = [];
        this.theme = "menubar_default";
        this.windowMargin = 0;

        this.nav = {};
        this.elements = {};
        this.elements.items = DayPilot.list();

        this._active = null;
        this._initialized = false;

        for (var name in options) {
            this[name] = options[name];
        }

        this._cssClass = function(cl) {
            return this.theme + "_" + cl;
        };

        this._show = function() {
            this.nav.top = document.getElementById(id);

            var top = this.nav.top;
            top.className = this._cssClass("main");

            DayPilot.list(menubar.items).forEach(function(item) {
                var div = document.createElement("span");
                div.innerHTML = DayPilot.Util.escapeTextHtml(item.text, item.html);
                div.className = menubar._cssClass("item");
                if (item.cssClass) {
                    div.classList.add(item.cssClass);
                }
                div.data = item;
                div.onclick = function(e) {
                    if (menubar.active && menubar.active.item === item) {
                        menubar._hideActive();
                    }
                    else if (item.children) {
                        menubar._activate(div);
                        return;
                    }

                    if (typeof item.onClick === "function") {
                        var args = {};
                        args.item = item;
                        args.originalEvent = e;
                        item.onClick(args);
                    }
                };
                div.onmousedown = function(ev) {
                    ev.stopPropagation();
                };
                div.onmouseover = function() {
                    if (menubar.active && menubar.active.item !== item) {
                        menubar._activate(div);
                    }
                };

                top.appendChild(div);
                menubar.elements.items.push(div);
            });
        };

        this._hideActive = function() {
            var activeCss = menubar._cssClass("item_active");
            menubar.elements.items.forEach(function(div) {
                DayPilot.Util.removeClass(div, activeCss);
            });

            if (menubar.active && menubar.active.menu) {
                menubar.active.menu.hide();
            }
            menubar.active = null;
        };

        this._isActive = function(div) {
            if (!menubar.active) {
                return false;
            }
            return menubar.active.item === div.data;
        };

        this._activate = function(div) {
            if (menubar._isActive(div)) {
                return;
            }

            menubar._hideActive();

            var item = div.data;
            var a = menubar.active = {};
            a.item = item;
            a.div = div;

            var activeCss = menubar._cssClass("item_active");
            DayPilot.Util.addClass(div, activeCss);

            var abs = DayPilot.abs(div);

            if (item.children) {
                a.menu = new DayPilot.Menu({"items": item.children});
                // a.menu.show(null, { "x": abs.x + abs.w, "y": abs.y + abs.h, "align": item.align, "windowMargin": menubar.windowMargin});
                var x = abs.x;
                if (item.align === "right") {
                    x += abs.w;
                }
                a.menu.show(null, { "x": x, "y": abs.y + abs.h, "align": item.align, "windowMargin": menubar.windowMargin});
            }

            DayPilot.MenuBar.active = menubar;
        };

        this.init = function() {
            this._show();
            this._initialized = true;
            return this;
        };

        this.dispose = function() {
            if (!this._initialized) {
                return;
            }
            this.nav.top.innerHTML = "";
            this.elements.items = [];
        };

    };

    DayPilot.MenuBar.deactivate = function() {
        if (DayPilot.MenuBar.active) {
            DayPilot.MenuBar.active._hideActive();
            DayPilot.MenuBar.active = null;
        }
    };

    DayPilotMenu.menuClean = function() {
        if (typeof(DayPilot.Menu.active) === 'undefined')
            return;

        if (DayPilot.Menu.active) {
            DayPilot.Menu.active.hide();
            DayPilot.Menu.active = null;
        }

    };

    DayPilotMenu.mouseDown = function(ev) {
        if (typeof(DayPilotMenu) === 'undefined') {
            return;
        }
        DayPilotMenu.menuClean();

        DayPilot.MenuBar.deactivate();
    };

    DayPilotMenu.mouseMove = function(ev) {
        if (typeof(DayPilotMenu) === 'undefined') {
            return;
        }
        DayPilotMenu.mouse = DayPilotMenu.mousePosition(ev);
    };

    DayPilotMenu.touchMove = function(ev) {
        if (typeof(DayPilotMenu) === 'undefined') {
            return;
        }
        DayPilotMenu.mouse = DayPilotMenu.touchPosition(ev);
    };

    DayPilotMenu.touchStart = function(ev) {
        if (typeof(DayPilotMenu) === 'undefined') {
            return;
        }
        //DayPilotMenu.menuClean();
        DayPilotMenu.mouse = DayPilotMenu.touchPosition(ev);
    };

    DayPilotMenu.touchEnd = function(ev) {
        // do not call menuClean() here, it doesn't work with eventTapAndHoldHandling="ContextMenu"
        // DayPilotMenu.menuClean();
    };

    DayPilotMenu.touchPosition = function(ev) {
        if (!ev || !ev.touches) {
            return null;
        }
        var touch = ev.touches[0];
        var mouse = {};
        mouse.x = touch.pageX;
        mouse.y = touch.pageY;
        // mouse.clientX = touch.clientX;
        // mouse.clientY = touch.clientY;
        return mouse;
    };

    DayPilotMenu.mousePosition = function(e) {
        return DayPilot.mo3(null, e);
    };

    DayPilot.Menu.touchPosition = function(ev) {
        if (ev.touches) {
            DayPilotMenu.mouse = DayPilotMenu.touchPosition(ev);
        }
    };
    // publish the API

    DayPilot.Menu.hide = function(options) {
        options = options || {};

        if (options.calendar) {
            var active = DayPilot.Menu.active;
            if (active) {
                var source = active._state.source;
                if (source && source.calendar === options.calendar) {
                    DayPilotMenu.menuClean();
                }
            }
        }
        else {
            DayPilotMenu.menuClean();
        }
    };

    // (backwards compatibility)
    //DayPilot.MonthVisible.dragStart = DayPilotMonth.dragStart;
    /*
    DayPilot.MenuVisible.Menu = DayPilotMenu.Menu;
    */

    // current
    //DayPilot.Menu = DayPilotMenu.Menu;
    if (!DayPilotMenu.handlersRegistered) {
        DayPilot.re(document, 'mousemove', DayPilotMenu.mouseMove);
        DayPilot.re(document, 'mousedown', DayPilotMenu.mouseDown);
        DayPilot.re(document, 'touchmove', DayPilotMenu.touchMove);
        DayPilot.re(document, 'touchstart', DayPilotMenu.touchStart);
        DayPilot.re(document, 'touchend', DayPilotMenu.touchEnd);
        DayPilotMenu.handlersRegistered = true;
    }

    DayPilot.Menu.def = {};

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }


})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/

   3.15.0
*/

if (typeof(DayPilot) === 'undefined') {
    DayPilot = {};
}

(function(DayPilot) {
    

    // modal.js  -> 1435

    if (DayPilot.ModalStatic) {
        return;
    }

    DayPilot.ModalStatic = {};

    DayPilot.ModalStatic.list = [];

    // hide the last one
    DayPilot.ModalStatic.hide = function() {
        if (this.list.length > 0) {
            var last = this.list.pop();
            if (last) {
                last.hide();
            }
        }
    };

    DayPilot.ModalStatic.remove = function(modal) {
        var list = DayPilot.ModalStatic.list;
        for (var i = 0; i < list.length; i++) {
            if (list[i] === modal) {
                list.splice(i, 1);
                return;
            }
        }
    };

    DayPilot.ModalStatic.close = function(result) {
        DayPilot.ModalStatic.result(result);
        DayPilot.ModalStatic.hide();
    };

    DayPilot.ModalStatic.result = function(r) {
        var list = DayPilot.ModalStatic.list;
        if (list.length > 0) {
            list[list.length - 1].result = r;
        }
    };

    DayPilot.ModalStatic.displayed = function(modal) {
        var list = DayPilot.ModalStatic.list;
        for (var i = 0; i < list.length; i++) {
            if (list[i] === modal) {
                return true;
            }
        }
        return false;
    };

    DayPilot.ModalStatic.stretch = function() {
        if (this.list.length > 0) {
            var last = this.list[this.list.length - 1];
            if (last) {
                last.stretch();
            }
        }
    };

    DayPilot.ModalStatic.last = function() {
        var list = DayPilot.ModalStatic.list;
        if (list.length > 0) {
            return list[list.length - 1];
        }
        return null;
    };

    var Sheet = function() {
        var style = document.createElement("style");
        style.setAttribute("type", "text/css");
        if (!style.styleSheet) {   // ie
            style.appendChild(document.createTextNode(""));
        }

        var h = document.head || document.getElementsByTagName('head')[0];
        h.appendChild(style);

        var oldStyle = !! style.styleSheet; // old ie

        var sheet = {};
        sheet.rules = [];
        sheet.commit = function() {
            try {
                if (oldStyle) {
                    style.styleSheet.cssText = this.rules.join("\n");
                }
            }
            catch (e) {
                //alert("Error registering the built-in stylesheet (IE stylesheet limit reached). Stylesheet count: " + document.styleSheets.length);
            }
        };

        sheet.add = function(selector, rules, index) {
            if (oldStyle) {
                this.rules.push(selector + "{" + rules + "\u007d");
                return;
            }
            if(style.sheet.insertRule) {  // normal browsers, ie9+
                if (typeof index === "undefined") {
                    index = style.sheet.cssRules.length;
                }
                style.sheet.insertRule(selector + "{" + rules + "\u007d", index);
            }
            else if (style.sheet.addRule) {
                style.sheet.addRule(selector, rules, index);
            }
            else {
                throw "No CSS registration method found";
            }
        };
        sheet.print = function() {
            var rules = style.sheet.cssRules;
            var all = [];

            for (var i = 0; i < rules.length; i++) {
                all.push(rules[i].cssText);
            }
            return all.join("\n");
        };
        return sheet;
    };

    var iconCalendar = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB3aWR0aD0iMTAiCiAgIGhlaWdodD0iMTUiCj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDUpIj4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojY2NjY2NjO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjM4MDM3MzM2O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDE5MjgiCiAgICAgICB3aWR0aD0iOS45MTUzMDYxIgogICAgICAgaGVpZ2h0PSIxMS4zNjkzNyIKICAgICAgIHg9IjAuMTE3MTg3NSIKICAgICAgIHk9Ii0zLjAwOTk5NTciCiAgICAgICByeT0iMS4zMTE4NTA1IiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNjY2NjY2M7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNTk4MTQwMTI7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0MTkzMCIKICAgICAgIHdpZHRoPSIxLjUzNDQxMzYiCiAgICAgICBoZWlnaHQ9IjIuMjE5ODI1IgogICAgICAgeD0iMi4xNTU4NDgzIgogICAgICAgeT0iLTQuMzkzNzAwMSIKICAgICAgIHJ5PSIwLjY3MTc4OTE3IiAvPgogICAgPHJlY3QKICAgICAgIHJ5PSIwLjI5NjAxNDciCiAgICAgICB5PSItMS4xNjU4NDY2IgogICAgICAgeD0iMS41MjM5NTA2IgogICAgICAgaGVpZ2h0PSIxLjgyOTkwOTEiCiAgICAgICB3aWR0aD0iMS44MzQyMjUxIgogICAgICAgaWQ9InJlY3QxOTQ4IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS40MjE4OTE5MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgPHJlY3QKICAgICAgIHJ5PSIwLjY3MTc4OTE3IgogICAgICAgeT0iLTQuMzkzNzAwMSIKICAgICAgIHg9IjYuNDUyNzIzNSIKICAgICAgIGhlaWdodD0iMi4yMTk4MjUiCiAgICAgICB3aWR0aD0iMS41MzQ0MTM2IgogICAgICAgaWQ9InJlY3QyMDAzIgogICAgICAgc3R5bGU9ImZpbGw6I2NjY2NjYztmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS41OTgxNDAxMjtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDIxODkxOTM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0MjAwNSIKICAgICAgIHdpZHRoPSIxLjgzNDIyNTEiCiAgICAgICBoZWlnaHQ9IjEuODI5OTA5MSIKICAgICAgIHg9IjQuMjE5MjYzMSIKICAgICAgIHk9Ii0xLjE2NTg0NjYiCiAgICAgICByeT0iMC4yOTYwMTQ3IiAvPgogICAgPHJlY3QKICAgICAgIHJ5PSIwLjI5NjAxNDciCiAgICAgICB5PSItMS4xNjU4NDY2IgogICAgICAgeD0iNi45OTI3MDA2IgogICAgICAgaGVpZ2h0PSIxLjgyOTkwOTEiCiAgICAgICB3aWR0aD0iMS44MzQyMjUxIgogICAgICAgaWQ9InJlY3QyMDA3IgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS40MjE4OTE5MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDIxODkxOTM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0MjAxMyIKICAgICAgIHdpZHRoPSIxLjgzNDIyNTEiCiAgICAgICBoZWlnaHQ9IjEuODI5OTA5MSIKICAgICAgIHg9IjEuNTIzOTUwNiIKICAgICAgIHk9IjEuODAyOTAzNCIKICAgICAgIHJ5PSIwLjI5NjAxNDciIC8+CiAgICA8cmVjdAogICAgICAgcnk9IjAuMjk2MDE0NyIKICAgICAgIHk9IjEuODAyOTAzNCIKICAgICAgIHg9IjQuMjE5MjYzMSIKICAgICAgIGhlaWdodD0iMS44Mjk5MDkxIgogICAgICAgd2lkdGg9IjEuODM0MjI1MSIKICAgICAgIGlkPSJyZWN0MjAxNSIKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNDIxODkxOTM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjQyMTg5MTkzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDIwMTciCiAgICAgICB3aWR0aD0iMS44MzQyMjUxIgogICAgICAgaGVpZ2h0PSIxLjgyOTkwOTEiCiAgICAgICB4PSI2Ljk5MjcwMDYiCiAgICAgICB5PSIxLjgwMjkwMzQiCiAgICAgICByeT0iMC4yOTYwMTQ3IiAvPgogICAgPHJlY3QKICAgICAgIHJ5PSIwLjI5NjAxNDciCiAgICAgICB5PSI0LjczMjU5MDciCiAgICAgICB4PSIxLjU2MzAxMzEiCiAgICAgICBoZWlnaHQ9IjEuODI5OTA5MSIKICAgICAgIHdpZHRoPSIxLjgzNDIyNTEiCiAgICAgICBpZD0icmVjdDIwMTkiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjQyMTg5MTkzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS40MjE4OTE5MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InJlY3QyMDIxIgogICAgICAgd2lkdGg9IjEuODM0MjI1MSIKICAgICAgIGhlaWdodD0iMS44Mjk5MDkxIgogICAgICAgeD0iNC4yNTgzMjU2IgogICAgICAgeT0iNC43MzI1OTA3IgogICAgICAgcnk9IjAuMjk2MDE0NyIgLz4KICAgIDxyZWN0CiAgICAgICByeT0iMC4yOTYwMTQ3IgogICAgICAgeT0iNC43MzI1OTA3IgogICAgICAgeD0iNy4wMzE3NjMxIgogICAgICAgaGVpZ2h0PSIxLjgyOTkwOTEiCiAgICAgICB3aWR0aD0iMS44MzQyMjUxIgogICAgICAgaWQ9InJlY3QyMDIzIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS40MjE4OTE5MztzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiAvPgogIDwvZz4KPC9zdmc+Cg==";
    var iconExpand = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB3aWR0aD0iMTAiCiAgIGhlaWdodD0iMTUiCj4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDUpIj4KICAgIDxwYXRoCiAgICAgICBpZD0icGF0aDMxNzMiCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojOTk5OTk5O3N0cm9rZS13aWR0aDoxLjg1MTk2ODUzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZSIKICAgICAgIGQ9Ik0gMC45NTQxNDgzOCwwLjY4MTYwMzEgNS4wMzkwNjI1LDUuNDExNTM4NiA5LjEyMzk3NjYsMC42ODE2MDMxIgogICAgICAgIC8+CiAgPC9nPgo8L3N2Zz4K";

    var sheet = new Sheet();
    sheet.add(".modal_default_main", "border: 10px solid #ccc; max-width: 90%;");
    sheet.add(".modal_default_main:focus", "outline: none;");
    sheet.add(".modal_default_content", "padding: 10px 0px;");
    sheet.add(".modal_default_inner", "padding: 20px;");
    sheet.add(".modal_default_input", "padding: 10px 0px;");
    sheet.add(".modal_default_buttons", "margin-top: 10px;");
    sheet.add(".modal_default_buttons", "padding: 10px 0px;");
    sheet.add(".modal_default_form_item", "padding: 10px 0px; position: relative;");
    sheet.add(".modal_default_form_item_level1", "border-left: 2px solid #ccc; margin-left: 10px; padding-left: 20px;");
    sheet.add(".modal_default_form_item.modal_default_form_title", "font-size: 1.5rem; font-weight: bold;");
    sheet.add(".modal_default_form_item input[type=text]", "width: 100%; box-sizing: border-box;");
    sheet.add(".modal_default_form_item textarea", "width: 100%; height: 200px; box-sizing: border-box;");
    sheet.add(".modal_default_form_item input[type=select]", "width: 100%; box-sizing: border-box;");
    sheet.add(".modal_default_form_item label", "display: block;");
    sheet.add(".modal_default_form_item select", "width: 100%; box-sizing: border-box;");
    sheet.add(".modal_default_form_item_label", "margin: 2px 0px;");
    sheet.add(".modal_default_form_item_image img", "max-width: 100%; height: auto;");

    sheet.add(".modal_default_form_item_invalid", "");
    sheet.add(".modal_default_form_item_invalid_message", "position: absolute; right: 0px; top: 9px; background-color: red; color: #ffffff; padding: 2px; border-radius: 2px;");

    sheet.add(".modal_default_background", "opacity: 0.5; background-color: #000;");
    sheet.add(".modal_default_ok", "padding: 3px; width: 80px;");
    sheet.add(".modal_default_cancel", "padding: 3px; width: 80px;");

    sheet.add(".modal_default_form_item_date", "position: relative;");
    sheet.add(".modal_default_form_item_date:after", "content: ''; position: absolute; right: 7px; top: 50%; margin-top: 3px; width: 10px; height: 15px; background-image:url(" + iconCalendar + ")");

    if (navigator.userAgent.indexOf("Edge") !== -1) {
        sheet.add(".modal_default_form_item_date input::-ms-clear", "display: none;");
    }

    sheet.add(".modal_default_form_item_scrollable_scroll", "width: 100%; height: 200px; box-sizing: border-box; border: 1px solid #ccc; overflow-y: auto;");
    sheet.add(".modal_default_form_item_scrollable_scroll_content", "padding: 5px;");

    sheet.add(".modal_default_form_item_searchable", "position: relative;");
    sheet.add(".modal_default_form_item_searchable_icon", "");
    sheet.add(".modal_default_form_item_searchable_icon:after", "content:''; position: absolute; right: 5px; top: 50%; margin-top: -8px; width: 10px; height: 15px; background-image:url(" + iconExpand + ");");
    sheet.add(".modal_default_form_item_searchable_list", "box-sizing: border-box; border: 1px solid #999; max-height: 150px; overflow-y: auto;");
    sheet.add(".modal_default_form_item_searchable_list_item", "background: white; padding: 2px; cursor: default;");
    sheet.add(".modal_default_form_item_searchable_list_item_highlight", "background: #ccc;");

    sheet.add(".modal_default_form_item_time", "position: relative;");
    sheet.add(".modal_default_form_item_time_icon", "");
    sheet.add(".modal_default_form_item_time_icon:after", "content:''; position: absolute; right: 5px; top: 50%; margin-top: -8px; width: 10px; height: 15px; background-image:url(" + iconExpand + ");");
    sheet.add(".modal_default_form_item_time_list", "box-sizing: border-box; border: 1px solid #999; max-height: 150px; overflow-y: auto;");
    sheet.add(".modal_default_form_item_time_list_item", "background: white; padding: 2px; cursor: default;");
    sheet.add(".modal_default_form_item_time_list_item_highlight", "background: #ccc;");

    sheet.add(".modal_default_form_item_datetime_parent", "display: flex;");
    sheet.add(".modal_default_form_item_datetime .modal_default_form_item_time_main", "margin-left: 5px;");
    sheet.add(".modal_default_form_item_datetime input[type='text'].modal_default_input_date ", "");

    sheet.add(".modal_default_form_item_tabular_main", "margin-top: 10px;");
    sheet.add(".modal_default_form_item_tabular_table", "display: table; width: 100%; xbackground-color: #fff; border-collapse: collapse;");
    sheet.add(".modal_default_form_item_tabular_tbody", "display: table-row-group;");
    sheet.add(".modal_default_form_item_tabular_row", "display: table-row;");
    sheet.add(".modal_default_form_item_tabular_row.modal_default_form_item_tabular_header", "");  // used to be bold
    sheet.add(".modal_default_form_item_tabular_cell.modal_default_form_item_tabular_rowaction", "padding: 0px; width: 23px;");  // _delete: width + marginLeft
    sheet.add(".modal_default_form_item_tabular_cell", "display: table-cell; border: 0px; padding: 2px 2px 2px 0px; cursor: default; vertical-align: bottom;");
    sheet.add(".modal_default_form_item_tabular_header .modal_default_form_item_tabular_cell", "padding-left: 0px; padding-bottom: 0px;");
    sheet.add(".modal_default_form_item_tabular_table input[type=text], .modal_default_form_item_tabular_table input[type=number]", "width:100%; box-sizing: border-box;");
    sheet.add(".modal_default_form_item_tabular_table select", "width:100%; height:100%; box-sizing: border-box;");
    sheet.add(".modal_default_form_item_tabular_plus", "display: inline-block; background-color: #ccc; color: white; width: 20px; height: 20px; border-radius: 10px; box-sizing: border-box; position: relative; margin-left: 3px; margin-top: 3px; cursor: pointer;");
    sheet.add(".modal_default_form_item_tabular_plus:after", "content: ''; position: absolute; left: 5px; top: 5px; width: 10px; height: 10px;   background-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTSA1LjAgMC41IEwgNS4wIDkuNSBNIDAuNSA1LjAgTCA5LjUgNS4wJyBzdHlsZT0nZmlsbDpub25lO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpidXR0JyAvPjwvc3ZnPg==\")");
    sheet.add(".modal_default_form_item_tabular_delete", "display: inline-block; background-color: #ccc; color: white; width: 20px; height: 20px; border-radius: 10px; box-sizing: border-box; position: relative; margin-left: 3px; margin-top: 3px; cursor: pointer;");
    sheet.add(".modal_default_form_item_tabular_delete:after", "content: ''; position: absolute; left: 5px; top: 5px; width: 10px; height: 10px;   background-image: url(\"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0nMTAnIGhlaWdodD0nMTAnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+PHBhdGggZD0nTSAwLjUgMC41IEwgOS41IDkuNSBNIDAuNSA5LjUgTCA5LjUgMC41JyBzdHlsZT0nZmlsbDpub25lO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbGluZWNhcDpidXR0JyAvPjwvc3ZnPg==\")");
    sheet.add(".modal_default_form_item_tabular_disabled .modal_default_form_item_tabular_plus", "display: none;");
    sheet.add(".modal_default_form_item_tabular_plus_max.modal_default_form_item_tabular_plus", "display: none;");
    sheet.add(".modal_default_form_item_tabular_disabled .modal_default_form_item_tabular_delete", "visibility: hidden;");
    sheet.add(".modal_default_form_item_tabular_empty", "height: 1px; margin: 5px 23px 5px 0px; background-color: #ccc;");
    sheet.add(".modal_default_form_item_tabular_spacer .modal_default_form_item_tabular_cell", "padding: 0px;");

    sheet.add(".modal_min_main", "border: 1px solid #ccc; max-width: 90%;");
    sheet.add(".modal_min_background", "opacity: 0.5; background-color: #000;");
    sheet.add(".modal_min_ok", "padding: 3px 10px;");
    sheet.add(".modal_min_cancel", "padding: 3px 10px;");


    sheet.add(".navigator_modal_main", "border-left: 1px solid #c0c0c0;border-right: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;background-color: white;color: #000000; box-sizing: content-box;");
    sheet.add(".navigator_modal_main *, .navigator_modal_main *:before, .navigator_modal_main *:after", "box-sizing: content-box;");
    sheet.add(".navigator_modal_month", "font-size: 11px;");
    sheet.add(".navigator_modal_day", "color: black;");
    sheet.add(".navigator_modal_weekend", "background-color: #f0f0f0;");
    sheet.add(".navigator_modal_dayheader", "color: black;");
    sheet.add(".navigator_modal_line", "border-bottom: 1px solid #c0c0c0;");
    sheet.add(".navigator_modal_dayother", "color: gray;");
    sheet.add(".navigator_modal_todaybox", "border: 1px solid red;");
    sheet.add(".navigator_modal_title, .navigator_modal_titleleft, .navigator_modal_titleright", 'border-top: 1px solid #c0c0c0;border-bottom: 1px solid #c0c0c0;color: #333;background: #f3f3f3;');
    sheet.add(".navigator_modal_busy", "font-weight: bold;");
    sheet.add(".navigator_modal_cell", "text-align: center;");
    sheet.add(".navigator_modal_select .navigator_modal_cell_box", "background-color: #FFE794; opacity: 0.5;");
    sheet.add(".navigator_modal_title", "text-align: center;");
    sheet.add(".navigator_modal_titleleft, .navigator_modal_titleright", "text-align: center;");
    sheet.add(".navigator_modal_dayheader", "text-align: center;");
    sheet.add(".navigator_modal_weeknumber", "text-align: center;");
    sheet.add(".navigator_modal_cell_text", "cursor: pointer;");

    sheet.commit();

    //var isIE = (navigator && navigator.userAgent && navigator.userAgent.indexOf("MSIE") !== -1);

    DayPilot.Modal = function(options) {

        // default values
        this.autoFocus = true;
        this.focus = null; // field to be focused - field id as string or {id, value}
        this.autoStretch = true;  // height will be increased automatically to avoid scrollbar, until this.maxHeight is reached
        this.autoStretchFirstLoadOnly = false;
        this.className = null;
        this.theme = "modal_default";
        this.disposeOnClose = true;
        this.dragDrop = true;
        this.loadingHtml = null;
        this.maxHeight = null; // if not set, it will stretch until the bottom space is equal to this.top
        this.scrollWithPage = true;  // modal window will scroll with the page
        this.useIframe = true; // only for showHtml()
        this.zIndex = 99999;

        this.left = null;  // will be centered if null
        this.width = 600;
        this.top = 20;
        this.height = 200;  // see also autoStretch
        this.locale = null; // used for DayPilot.Modal.form() items with "date" type

        // event handler
        this.closed = null;
        this.onClose = null;
        this.onClosed = null;
        this.onShow = null;

        // internal
        var This = this;
        this.id = '_' + new Date().getTime() + 'n' + (Math.random() * 10);
        this._registered = false;

        // drag&drop
        this._start = null;
        this._coords = null;

        this.showHtml = function(html) {

            if (DayPilot.ModalStatic.displayed(this)) {
                throw "This modal dialog is already displayed.";
            }

            if (!this.div) {
                this._create();
            }
            this._update();

            if (this.useIframe) {
                var delayed = function(p, innerHTML) {
                    return function() {
                        p.setInnerHTML(p.id + "iframe", innerHTML);
                    };
                };

                window.setTimeout(delayed(this, html), 0);
            }
            else {
                if (html.nodeType) {
                    this.div.appendChild(html);
                }
                else {
                    this.div.innerHTML = html;
                }
            }

            this._update();
            this._register();
            this._doShow();

        };

        this.showUrl = function(url) {

            if (DayPilot.ModalStatic.displayed(this)) {
                throw "This modal dialog is already displayed.";
            }

            //this.useIframe = true; // forced

            if (this.useIframe) {
                if (!this.div) {
                    this._create();
                }

                var loadingHtml = this.loadingHtml;
                if (loadingHtml) {
                    this.iframe.src = "about:blank";
                    this.setInnerHTML(this.id + "iframe", loadingHtml);
                }

                this.re(this.iframe, "load", this._onIframeLoad);

                this.iframe.src = url;
                //this.iframe.contentWindow.modal = This;

                this._update();
                this._register();
                this._doShow();
            }
            else {
                This._ajax({
                    "url": url,
                    "success": function(args) {
                        var html = args.request.responseText;
                        This.showHtml(html);
                    },
                    "error": function(args) {
                        This.showHtml("Error loading the modal dialog");
                    }
                });
            }

        };

        this._doShow = function() {
            if (typeof This.onShow === "function") {
                var args = {};
                args.root = This._body();
                args.modal = This;
                This.onShow(args);
            }
        };

        this._body = function() {
            return This.iframe ? This.iframe.contentWindow.document : This.div;
        };

        this._ajax = function(object) {
            var req = new XMLHttpRequest();
            if (!req) {
                return;
            }

            var method = object.method || "GET";
            var success = object.success || function() {};
            var error = object.error || function() {};
            var data = object.data;
            var url = object.url;

            req.open(method, url, true);
            req.setRequestHeader('Content-type', 'text/plain');
            req.onreadystatechange = function() {
                if (req.readyState !== 4)
                    return;
                if (req.status !== 200 && req.status !== 304) {
                    if (error) {
                        var args = {};
                        args.request = req;
                        error(args);
                    }
                    else {
                        if (window.console) { console.log('HTTP error ' + req.status); }
                    }
                    return;
                }
                var args = {};
                args.request = req;
                success(args);
            };
            if (req.readyState === 4) {
                return;
            }
            if (typeof data === 'object') {
                data = JSON.stringify(data);
            }
            req.send(data);
        };

        this._update = function() {

            delete this.result;

            var win = window;
            var doc = document;

            var scrollY = win.pageYOffset ? win.pageYOffset : ((doc.documentElement && doc.documentElement.scrollTop) ? doc.documentElement.scrollTop : doc.body.scrollTop);

            var height = function() {
                return This._windowRect().y;
            };

            //this.hideDiv.style.height = height() + "px";
            if (this.theme) {
                this.hideDiv.className = this.theme + "_background";
            }
            if (this.zIndex) {
                this.hideDiv.style.zIndex = this.zIndex;
            }
            this.hideDiv.style.display = '';

            window.setTimeout(function() {
                if (This.hideDiv) {
                    This.hideDiv.onclick = function() {
                        This.hide({"backgroundClick": true});
                    };
                }
            }, 500);

            if (this.theme) {
                this.div.className = this.theme + "_main";
            }
            else {
                this.div.className = "";
            }

            if (this.className) {
                this.div.className += " " + this.className;
            }
            if (this.left) {
                this.div.style.left = this.left + "px";
            }
            else {
                this.div.style.marginLeft = '-' + Math.floor(this.width / 2) + "px";  // '-45%'
            }
            this.div.style.position = 'absolute';
            this.div.style.boxSizing = "content-box";
            this.div.style.top = (scrollY + this.top) + 'px';
            this.div.style.width = this.width + 'px';  // '90%'
            if (this.zIndex) {
                this.div.style.zIndex = this.zIndex;
            }

            if (this.height) {
                if (this.useIframe || !this.autoStretch) {
                    this.div.style.height = this.height + 'px';
                }
                else {
                    this.div.style.height = '';
                }
            }
            if (this.useIframe && this.height) {
                this.iframe.style.height = (this.height) + 'px';
            }

            this.div.style.display = '';

            this._updateHorizontal();

            // make sure it's there just once
            DayPilot.ModalStatic.remove(this);
            DayPilot.ModalStatic.list.push(this);

            /*
            if (this.iframe) {
            this.iframe.onload = null;
            }
            */
        };

        this._onIframeLoad = function() {
            This.iframe.contentWindow.modal = This;
            if (This.autoStretch) {
                This.stretch();
            }
        };

        this.stretch = function() {
            var height = function() {
                return This._windowRect().y;
            };

            var width = function() {
                return This._windowRect().x;
            };


            if (this.useIframe) {
                // width first
                var maxWidth = width() - 40;  // fixed 20px margin
                for (var w = this.width; w < maxWidth && this._hasHorizontalScrollbar(); w += 10) {
                    //this.iframe.style.width = (w) + 'px';
                    this.div.style.width = w + 'px';
                    this.div.style.marginLeft = '-' + Math.floor(w / 2) + "px";  //
                }

                // height
                var maxHeight = this.maxHeight || height() - 2 * this.top;
                for (var h = this.height; h < maxHeight && this._hasVerticalScrollbar(); h += 10) {
                    this.iframe.style.height = (h) + 'px';
                    this.div.style.height = h + 'px';
                }

                if (this.autoStretchFirstLoadOnly) {
                    this.ue(this.iframe, "load", this._onIframeLoad);
                }
            }
            else {
                this.div.style.height = '';
            }


        };

        this._hasHorizontalScrollbar = function() {
            var document = this.iframe.contentWindow.document;
            var root = document.compatMode === 'BackCompat' ? document.body : document.documentElement;

            var scrollWidth = root.scrollWidth;
            var children = document.body.children;
            for (var i = 0; i < children.length; i++) {
                var bottom = children[i].offsetLeft + children[i].offsetWidth;
                scrollWidth = Math.max(scrollWidth, bottom);
            }

            var isHorizontalScrollbar = scrollWidth > root.clientWidth;
            return isHorizontalScrollbar;

        };

        this._hasVerticalScrollbar = function() {
            var document = this.iframe.contentWindow.document;
            var root = document.compatMode === 'BackCompat' ? document.body : document.documentElement;

            var scrollHeight = root.scrollHeight;
            var children = document.body.children;
            for (var i = 0; i < children.length; i++) {
                var bottom = children[i].offsetTop + children[i].offsetHeight;
                scrollHeight = Math.max(scrollHeight, bottom);
            }

            var isVerticalScrollbar =  scrollHeight > root.clientHeight;
            //var isHorizontalScrollbar = root.scrollWidth > root.clientWidth;
            return isVerticalScrollbar;
        };

        this._windowRect = function() {
            var doc = document;

            if (doc.compatMode === "CSS1Compat" && doc.documentElement && doc.documentElement.clientWidth) {
                var x = doc.documentElement.clientWidth;
                var y = doc.documentElement.clientHeight;
                return { x: x, y: y };
            }
            else {
                var x = doc.body.clientWidth;
                var y = doc.body.clientHeight;
                return { x: x, y: y };
            }
        };

        this._register = function() {
            if (this._registered) {
                return;
            }
            this.re(window, 'resize', this._onWindowResize);
            this.re(window, 'scroll', this._onWindowScroll);

            if (this.dragDrop) {
                this.re(document, 'mousemove', this._onMouseMove);
                this.re(document, 'mouseup', this._onMouseUp);
            }
            this._registered = true;
        };

        this._unregister = function() {
            this.ue(window, 'resize', this._onWindowResize);
            this.ue(window, 'scroll', this._onWindowScroll);
            if (this.dragDrop) {
                this.ue(document, 'mousemove', this._onMouseMove);
                this.ue(document, 'mouseup', this._onMouseUp);
            }
            this._registered = false;
        };

        this._onDragStart = function(e) {
            if (e.target !== This.div) {
                return;
            }
            e.preventDefault();
            This.div.style.cursor = "move";
            This._maskIframe();
            This._coords = This.mc(e || window.event);
            This._start = { x: This.div.offsetLeft, y: This.div.offsetTop };

        };

        this._onMouseMove = function(e) {
            if (!This._coords) {
                return;
            }

            var e = e || window.event;
            var now = This.mc(e);

            var x = now.x - This._coords.x;
            var y = now.y - This._coords.y;

            //This.iframe.style.display = 'none';
            This.div.style.marginLeft = '0px';
            This.div.style.top = (This._start.y + y) + "px";
            This.div.style.left = (This._start.x + x) + "px";

        };

        this._onMouseUp = function(e) {
            // no drag&drop
            if (!This._coords) {
                return;
            }
            //This.iframe.style.display = '';
            This._unmaskIframe();
            This.div.style.cursor = null;

            This._coords = null;
        };

        this._maskIframe = function() {
            if (!this.useIframe) {
                return;
            }

            var opacity = 80;

            var mask = document.createElement("div");
            mask.style.backgroundColor = "#ffffff";
            mask.style.filter = "alpha(opacity=" + opacity + ")";
            mask.style.opacity = "0." + opacity;
            mask.style.width = "100%";
            mask.style.height = this.height + "px";
            mask.style.position = "absolute";
            mask.style.left = '0px';
            mask.style.top = '0px';

            this.div.appendChild(mask);
            this.mask = mask;
        };

        this._unmaskIframe = function() {
            if (!this.useIframe) {
                return;
            }

            this.div.removeChild(this.mask);
            this.mask = null;
        };

        this._onWindowResize = function() {
            This._updateTop();
            This._updateHorizontal();
        };

        this._onWindowScroll = function() {
            This._updateTop();
        };

        this._updateHorizontal = function() {
            if (This.left) {
                return;
            }

            if (!This.div) {
                return;
            }

            var width = This.div.offsetWidth;
            This.div.style.marginLeft = '-' + Math.floor(width / 2) + "px";  // '-45%'
        };

        this._updateTop = function() {
            if (!This.hideDiv) {
                return;
            }
            if (!This.div) {
                return;
            }
            if (This.hideDiv.style.display === 'none') {
                return;
            }
            if (This.div.style.display === 'none') {
                return;
            }

            var scrollY = This._parent.scrollY();


            //This.hideDiv.style.height = height() + "px";
            if (!This.scrollWithPage) {
                This.div.style.top = (scrollY + This.top) + 'px';
            }
        };

        this._parent = {};
        this._parent.container = function() {
            return This.container || document.body;
        };
        this._parent.scrollY = function() {
            var c = This._parent.container();
            if (c === document.body) {
                return window.pageYOffset ? window.pageYOffset : ((document.documentElement && document.documentElement.scrollTop) ? document.documentElement.scrollTop : document.body.scrollTop);
            }
            else {
                return c.scrollTop;
            }
        };

        // already available in common.js but this file should be standalone
        this.re = function(el, ev, func) {
            if (el.addEventListener) {
                el.addEventListener(ev, func, false);
            } else if (el.attachEvent) {
                el.attachEvent("on" + ev, func);
            }
        };

        // unregister event
        this.ue = function(el, ev, func) {
            if (el.removeEventListener) {
                el.removeEventListener(ev, func, false);
            } else if (el.detachEvent) {
                el.detachEvent("on" + ev, func);
            }
        };

        // mouse coords
        this.mc = function(ev) {
            if (ev.pageX || ev.pageY) {
                return { x: ev.pageX, y: ev.pageY };
            }
            return {
                x: ev.clientX + document.documentElement.scrollLeft,
                y: ev.clientY + document.documentElement.scrollTop
            };
        };

        // absolute element position on page
        this.abs = function(element) {
            var r = {
                x: element.offsetLeft,
                y: element.offsetTop
            };

            while (element.offsetParent) {
                element = element.offsetParent;
                r.x += element.offsetLeft;
                r.y += element.offsetTop;
            }

            return r;
        };

        this._create = function() {

            var container = This._parent.container();
            var isRoot = container === document.body;
            var position = isRoot ? "fixed" : "absolute";

            var hide = document.createElement("div");
            hide.id = this.id + "hide";
            hide.style.position = position;
            hide.style.left = "0px";
            hide.style.top = "0px";
            hide.style.right = "0px";
            hide.style.bottom = "0px";
            hide.oncontextmenu = function() { return false; };
            hide.onmousedown = function() { return false; };  // prevent selecting

            container.appendChild(hide);

            var div = document.createElement("div");
            div.id = this.id + 'popup';
            div.style.position = position;
            div.style.left = '50%';
            div.style.top = '0px';
            div.style.backgroundColor = 'white';
            div.style.width = "50px";
            div.style.height = "50px";
            if (this.dragDrop) {
                div.onmousedown = this._onDragStart;
            }
            div.addEventListener("keydown", function(e) {
                // prevent interaaction with the document using keyboard
                e.stopPropagation();
            });

            var defaultHeight = 50;

            var iframe = null;
            if (this.useIframe) {
                iframe = document.createElement("iframe");
                iframe.id = this.id + "iframe";
                iframe.name = this.id + "iframe";
                iframe.frameBorder = '0';
                iframe.style.width = '100%';
                iframe.style.height = defaultHeight + 'px';
                div.appendChild(iframe);
            }

            container.appendChild(div);

            this.div = div;
            this.iframe = iframe;
            this.hideDiv = hide;
        };

        this.setInnerHTML = function(id, innerHTML) {
            var frame = window.frames[id];

            var doc = frame.contentWindow || frame.document || frame.contentDocument;
            if (doc.document) {
                doc = doc.document;
            }

            if (doc.body == null) {       // null in IE
                doc.write("<body></body>");
            }

            if (innerHTML.nodeType) {
                doc.body.appendChild(innerHTML);
            }
            else {
                doc.body.innerHTML = innerHTML;
            }

            if (This.autoStretch) {
                if (!This.autoStretchFirstLoadOnly || !This._stretched) {
                    This.stretch();
                    This._stretched = true;
                }
            }
        };

        this.close = function(result) {
            this.result = result;
            this.hide();
        };

        this.closeSerialized = function() {
            var ref = This._body();
            var fields = ref.querySelectorAll("input, textarea, select");
            var result = {};
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                var name = field.name;
                if (!name) {
                    continue;
                }
                var value = field.value;
                /*if (field.picker) {
                    value = field.picker.date ? field.picker.date.toString() : null;
                }
                else*/ /*if (field.table) {
                    value = field.table.save();
                }
                else*/ /*if (field.searchable) {
                    value = field.searchable.selected && field.searchable.selected.id;
                }
                else *//*if (field.tagName === "SELECT") {
                    var option = field.options[field.selectedIndex];
                    if (option && typeof option._originalValue !== "undefined") {
                        value = option._originalValue;
                    }
                }
                else*/ /*if (field.type === "radio") {
                    if (!field.checked) {
                        continue;
                    }
                    value = field._originalValue;
                }
                else*/ /*if (field.type === "checkbox") {
                    value = field.checked;
                }*/
                result[name] = value;
            }
            This.close(result);
        };

        this.hide = function(options) {

            options = options || {};

            var args = {};
            args.backgroundClick = !!options.backgroundClick;
            args.result = this.result;
            args.canceled = typeof this.result === "undefined";
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof this.onClose === "function") {
                this.onClose(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            if (this.div) {
                this.div.style.display = 'none';
                this.hideDiv.style.display = 'none';
                if (!this.useIframe) {
                    this.div.innerHTML = null;
                }
            }

            // return focus to the main window (Firefox)
            window.focus();

            //DayPilot.ModalStatic = null;
            DayPilot.ModalStatic.remove(this);

            if (typeof this.onClosed === "function") {
                this.onClosed(args);
            }
            else if (this.closed) {
                this.closed();
            }

            delete this.result;

            if (this.disposeOnClose) {

                This._unregister();

                This._de(This.div);
                This._de(This.hideDiv);

                This.div = null;
                This.hideDiv = null;
                This.iframe = null;
            }
        };

        this._de = function(e) {
            if (!e) {
                return;
            }
            e.parentNode && e.parentNode.removeChild(e);
        };

        this._applyOptions = function() {
            if (!options) {
                return;
            }

            for (var name in options) {
                this[name] = options[name];
            }
        };

        this._applyOptions();

    };

    DayPilot.Modal.alert = function(message, options) {
        options = options || {};
        options.height = options.height || 40;
        options.useIframe = false;

        var okText = options.okText || "OK";
        var cancelText = options.cancelText || "Cancel";

        return DayPilot.getPromise(function(success, failure) {
            options.onClosed = function(args) {
                success(args);
                /*
                if (typeof args.result === "undefined") {
                    failure(args);
                }
                else {

                }*/
            };

            var modal = new DayPilot.Modal(options);

            var div = document.createElement("div");
            div.className = modal.theme + "_inner";
            // div.style.padding = "10px";

            var text = document.createElement("div");
            text.className = modal.theme + "_content";
            text.innerHTML = message;

            var buttons =  document.createElement("div");
            buttons.className = modal.theme + "_buttons";
            // buttons.style.margin = "10px 0px";

            var buttonOK = document.createElement("button");
            buttonOK.innerText = okText;
            buttonOK.className = modal.theme + "_ok";
            buttonOK.onclick = function(e) {
                DayPilot.ModalStatic.close("OK");
            };

            buttons.appendChild(buttonOK);

            div.appendChild(text);
            div.appendChild(buttons);

            //var buttons = "<div style='margin: 10px 0px'><button onclick='parent.DayPilot.ModalStatic.close();' autofocus>OK</button></div>";

            modal.showHtml(div);

            if (modal.autoFocus) {
                buttonOK.focus();
            }
        });

    };

    DayPilot.Modal.confirm = function(message, options) {
        options = options || {};
        options.height = options.height || 40;
        options.useIframe = false;

        var okText = options.okText || "OK";
        var cancelText = options.cancelText || "Cancel";

        return DayPilot.getPromise(function(success, failure) {
            options.onClosed = function(args) {
                success(args);
            };

            var modal = new DayPilot.Modal(options);

            var div = document.createElement("div");
            div.className = modal.theme + "_inner";
            // div.style.padding = "10px";

            var text = document.createElement("div");
            text.className = modal.theme + "_content";
            text.innerHTML = message;

            var buttons =  document.createElement("div");
            buttons.className = modal.theme + "_buttons";
            // buttons.style.margin = "10px 0px";

            var buttonOK = document.createElement("button");
            buttonOK.innerText = okText;
            buttonOK.className = modal.theme + "_ok";
            buttonOK.onclick = function(e) {
                DayPilot.ModalStatic.close("OK");
            };

            var space = document.createTextNode(" ");

            var buttonCancel = document.createElement("button");
            buttonCancel.innerText = cancelText;
            buttonCancel.className = modal.theme + "_cancel";
            buttonCancel.onclick = function(e) {
                DayPilot.ModalStatic.close();
            };

            buttons.appendChild(buttonOK);
            buttons.appendChild(space);
            buttons.appendChild(buttonCancel);

            div.appendChild(text);
            div.appendChild(buttons);

            modal.showHtml(div);

            if (modal.autoFocus) {
                buttonOK.focus();
            }

        });
    };


    DayPilot.Modal.prompt = function(message, defaultValue, options) {
        if (typeof defaultValue === "object") {
            options = defaultValue;
            defaultValue = "";
        }

        options = options || {};
        options.height = options.height || 40;
        options.useIframe = false;

        var okText = options.okText || "OK";
        var cancelText = options.cancelText || "Cancel";

        var inputText = defaultValue || "";

        return DayPilot.getPromise(function(success, failure) {
            options.onClosed = function(args) {
                success(args);
            };

            var modal = new DayPilot.Modal(options);

            var div = document.createElement("div");
            div.className = modal.theme + "_inner";

            var text = document.createElement("div");
            text.className = modal.theme + "_content";
            text.innerHTML = message;

            var inputs = document.createElement("div");
            inputs.className = modal.theme + "_input";
            //inputs.style.margin = "10px 0px";

            var input = document.createElement("input");
            input.value = inputText;
            input.style.width = "100%";
            input.onkeydown = function(e) {
                var letcontinue = false;
                switch (e.keyCode) {
                    case 13:
                        modal.close(this.value);
                        break;
                    case 27:
                        modal.close();
                        break;
                    default:
                        letcontinue = true;
                        break;
                }
                if (!letcontinue) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            inputs.appendChild(input);

            var buttons =  document.createElement("div");
            buttons.className = modal.theme + "_buttons";
            //buttons.style.margin = "10px 0px";

            var buttonOK = document.createElement("button");
            buttonOK.innerText = okText;
            buttonOK.className = modal.theme + "_ok";
            buttonOK.onclick = function(e) {
                modal.close(input.value);
            };

            var space = document.createTextNode(" ");

            var buttonCancel = document.createElement("button");
            buttonCancel.innerText = cancelText;
            buttonCancel.className = modal.theme + "_cancel";
            buttonCancel.onclick = function(e) {
                modal.close();
            };

            buttons.appendChild(buttonOK);
            buttons.appendChild(space);
            buttons.appendChild(buttonCancel);


            div.appendChild(text);
            div.appendChild(inputs);
            div.appendChild(buttons);

            modal.showHtml(div);

            if (modal.autoFocus) {
                input.focus();
            }

        });
    };

    var isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };

    function setPathValue(target, path, value) {
        var iodot = path.indexOf(".");
        if (iodot === -1) {
            if (path !== "__proto__" && path !== "constructor") {
                target[path] = value;
            }
            return;
        }
        var segment = path.substring(0, iodot);
        if (segment === "__proto__" || segment === "constructor") {
            return;
        }
        var remainder = path.substring(iodot + 1);
        var child = target[segment];
        if (typeof child !== "object" || child === null) {
            target[segment] = {};
            child = target[segment];
        }
        setPathValue(child, remainder, value);
    }

    // form = array of items
    // data = object with properties
    // options = standard modal properties
    // DayPilot.Modal.form([]);  // form only - new data
    // DayPilot.Modal.form({});  // data only - automatic form
    //
    DayPilot.Modal.form = function(form, data, options) {
        if (arguments.length === 1) {
            var arg = form;
            var isa = isArray(arg);

            if (isa) {
                data = {};
            }
            else if (typeof arg === "object") {
                data = form;
                form = [];
                for (var name in data) {
                    var item = {};
                    item.name = name;
                    item.id = name;
                    form.push(item);
                }
            }
            else {
                throw "Invalid DayPilot.Modal.form() parameter";
            }

        }

        // make a copy
        var opts = {};
        for (var name in options) {
            opts[name] = options[name];
        }

        // options = options || {};
        opts.height = opts.height || 40;
        opts.useIframe = false;

        /*        if (typeof opts.autoFocus === "undefined") {
                    opts.autoFocus = false;
                }*/

        var okText = opts.okText || "OK";
        var cancelText = opts.cancelText || "Cancel";

        // var message = opts.message || "";

        return DayPilot.getPromise(function(success, failure) {
            opts.onClosed = function(args) {

                if (args.result) {
                    // deep copy
                    var mergedResult = JSON.parse(JSON.stringify(data));

                    // unflatten
                    for (var name in args.result) {
                        setPathValue(mergedResult, name, args.result[name]);
                    }
                    args.result = mergedResult;
                }

                success(args);
            };

            var modal = new DayPilot.Modal(opts);

            var div = document.createElement("div");
            div.className = modal.theme + "_inner";

            var inputs = document.createElement("div");
            inputs.className = modal.theme + "_input";

            var f = new Form({
                theme: modal.theme,
                form: form,
                data: data,
                zIndex: modal.zIndex,
                locale: modal.locale,
                plugins: modal.plugins,
                onKey: function(args) {
                    switch (args.key) {
                        case "Enter":
                            // modal.closeSerialized();
                            // modal.close(f.serialize());
                            if (f.validate()) {
                                modal.close(f.serialize());
                            }
                            break;
                        case "Escape":
                            modal.close();
                            break;
                    }
                },
                onChange: function(args) {
                    if (typeof modal.onChange === "function") {
                        modal.onChange(args);
                    }
                }
            });
            var el = f.create();

            inputs.append(el);

            var buttons =  document.createElement("div");
            buttons.className = modal.theme + "_buttons";

            var buttonOK = document.createElement("button");
            buttonOK.innerText = okText;
            buttonOK.className = modal.theme + "_ok";

            if (opts.okDisabled) {
                buttonOK.disabled = true;
            }
            buttonOK.onclick = function(e) {
                if (f.validate()) {
                    modal.close(f.serialize());
                }
                // modal.closeSerialized();
            };

            var space = document.createTextNode(" ");

            var buttonCancel = document.createElement("button");
            buttonCancel.innerText = cancelText;
            buttonCancel.className = modal.theme + "_cancel";
            buttonCancel.onclick = function(e) {
                modal.close();
            };
            buttonCancel.onmousedown = function(e) {
                f.canceling = true;
            };

            buttons.appendChild(buttonOK);
            buttons.appendChild(space);
            buttons.appendChild(buttonCancel);


            // div.appendChild(text);
            div.appendChild(inputs);
            div.appendChild(buttons);

            modal.showHtml(div);

            modal.div.setAttribute("tabindex", "-1");
            modal.div.addEventListener("keydown", function(e) {
                switch (e.keyCode) {
                    case 27:
                        modal.close();
                        break;
                    case 13:
                        if (f.validate()) {
                            modal.close(f.serialize());
                        }
                        // modal.closeSerialized();
                        break;
                }
            });

            if (modal.focus) {
                var toBeFocused = null;
                if (typeof modal.focus === "object") {
                    var id = modal.focus.id;
                    var value = modal.focus.value;
                    toBeFocused = f.findViewById(id, value);
                }
                else if (typeof modal.focus === "string") {
                    toBeFocused = f.findViewById(modal.focus)
                }
                if (toBeFocused) {
                    toBeFocused.focus();
                }
            }
            else {
                var first = f.firstFocusable();
                if (modal.autoFocus && first) {
                    first.focus();
                }
                else {
                    modal.div.focus();
                }
            }

        });
    };

    DayPilot.Modal.close = function(result) {
        var opener = DayPilot.Modal.opener();
        if (!opener) {
            return;
        }
        opener.close(result);
    };

    DayPilot.Modal.stretch = function(result) {
        var opener = DayPilot.Modal.opener();
        if (!opener) {
            throw "Unable to find the opener DayPilot.Modal instance.";
        }
        opener.stretch();
    };

    DayPilot.Modal.closeSerialized = function() {
        var last = DayPilot.Modal.opener() || DayPilot.ModalStatic.last();
        if (last) {
            last.closeSerialized();
        }
    };

    DayPilot.Modal.opener = function() {
        if (typeof DayPilot !== "undefined" && typeof DayPilot.ModalStatic !== "undefined" && DayPilot.ModalStatic.list.length > 0) {
            return DayPilot.ModalStatic.list[DayPilot.ModalStatic.list.length - 1];
        }
        return parent && parent.DayPilot && parent.DayPilot.ModalStatic && parent.DayPilot.ModalStatic.list[parent.DayPilot.ModalStatic.list.length - 1];
    };

    DayPilot.Modal.Experimental = {};
    DayPilot.Modal.Experimental.Form = Form;

    if (typeof DayPilot.getPromise === "undefined") {
        DayPilot.getPromise = function(f) {
            if (typeof Promise !== 'undefined') {
                return new Promise(f);
            }

            DayPilot.Promise = function(f) {
                var p = this;

                this.then = function(onFulfilled, onRejected) {
                    onFulfilled = onFulfilled || function() {};
                    onRejected = onRejected || function() {};
                    f(onFulfilled, onRejected);
                    return DayPilot.getPromise(f);
                };

                this['catch'] = function(onRejected) {
                    p.then(null, onRejected);
                    return DayPilot.getPromise(f);
                };
            };

            return new DayPilot.Promise(f);

        };
    }

    // end of modal.js

    // form.js
    var Form = function (options) {

        // properties
        this.form = [];
        this.data = {};
        this.theme = "form_default";
        this.zIndex = 99999;
        this.locale = "en-us";
        this.plugins = {};

        // events
        this.onKey = null;

        // state
        this._rows = [];
        this._newRows = null;
        this.canceling = false;

        this._validationTimeouts = [];

        // view
        this._views = [];
        this._div = null;

        options = options || {};

        for (var name in options) {
            this[name] = options[name];
        }
    };

    Form.prototype.create = function () {
        this.load();
        this.render();

        return this._div;
    };

    Form.prototype.render = function () {
        var form = this;
        this._div = document.createElement("div");
        this._rows.forEach(function (row) {
            form.createView(row);
        });
        this.applyState();
    };

    Form.prototype.createView = function (row) {
        var theme = this.theme;
        var form = this;

        var div = document.createElement("div");
        div.className = theme + "_form_item " + theme + "_form_item_level" + row.level;
        if (!row.interactive && row.type === "title") {
            /*
                  if (row.type === "title") {
                    div.className += " " + theme + "_form_title";
                  }
            */
            div.className += " " + theme + "_form_title";
        }
        else {
            div.className += " " + theme + "_form_item_" + row.type;
        }
        if (row.data.cssClass) {
            div.className += " " + row.data.cssClass;
        }

        if (!row.isValue) {
            var label = document.createElement("div");
            label.className = theme + "_form_item_label";
            label.innerText = row.text;
            div.appendChild(label);
        }

        var interactive = this.createInteractive(row);
        interactive.onInput = function(options) {
            options = options || {};
            form._validateInteractive(interactive, {
                "debounce": !options.immediate
            });
            if (typeof form.onChange === "function") {
                var args = {};
                args.result = form.serialize();
                form.onChange(args);
            }
        };
        interactive.onBlur = function() {
            if (!form.canceling) {
                form._validateInteractive(interactive);
            }
        };
        interactive.apply(row);
        interactive._div = div;
        interactive.row = row;

        if (interactive.element) {
            div.appendChild(interactive.element);
        }

        this._views.push(interactive);

        this._div.appendChild(div);

    };

    Form.prototype.validate = function() {
        var form = this;
        var valid = true;
        this._views.forEach(function(interactive) {
            var iv = form._validateInteractive(interactive);
            valid = valid && iv;
        });
        return valid;
    };

    Form.prototype._validateInteractive = function(interactive, options) {
        options = options || {};
        var debounce = options.debounce;
        var silent = options.silent;


        var row = interactive.row;
        var valid = true;

        var onValidate = typeof row.data.onValidate === "function" ? row.data.onValidate : null;
        var validate = typeof  row.data.validate === "function" ? row.data.validate : null;  // legacy

        var validateHandler = onValidate || validate;

        if (validateHandler) {

            var args = {};
            args.valid = true;
            args.value = interactive.save()[row.field];
            args.message = "Error";
            args.values = this.serialize();  // legacy
            args.result = this.serialize();

            validateHandler(args);

            var cssClassInvalid = this.theme + "_form_item_invalid";
            var cssClassMessage = this.theme + "_form_item_invalid_message";
            if (args.valid) {
                clearTimeout(this._validationTimeouts[row.field]);

                if (interactive._errorMsg) {
                    interactive._errorMsg.remove();
                    interactive._errorMsg = null;
                }
                interactive._div.classList.remove(cssClassInvalid);
            }
            else {

                function showInvalid() {
                    if (interactive._errorMsg) {
                        interactive._errorMsg.remove();
                        interactive._errorMsg = null;
                    }

                    interactive._div.classList.add(cssClassInvalid);
                    var msg = document.createElement("div");
                    msg.classList.add(cssClassMessage);
                    msg.innerText = args.message;

                    interactive._errorMsg = msg;

                    interactive._div.appendChild(msg);
                }

                if (!silent) {
                    if (debounce) {

                        var debounceDelay = 1000;

                        clearTimeout(this._validationTimeouts[row.field]);

                        this._validationTimeouts[row.field] = setTimeout(function() {
                            showInvalid();
                        }, debounceDelay);
                    }
                    else {
                        showInvalid();
                    }

                }

            }
            valid = args.valid;
        }
        return valid;
    };

    Form.prototype.load = function () {
        // transform this.form + this.data into state (_rows)
        var t = this;
        this.form.forEach(function (item) {
            t.processFormItem(item, 0);
        });

        var flat;
        // sanity check (especially for circular references)
        try {
            var stringified = JSON.stringify(this.data);
            var rebuilt = JSON.parse(stringified);
            flat = flatten(rebuilt);
        }
        catch (e) {
            throw new Error("The 'data' object is not serializable (it may contain circular dependencies): " + e);
        }

        // set values
        for (var name in flat) {
            this.setValue(name, flat[name]);
        }

        // set state depending on values
        // this.updateDependentState();
    };

    Form.prototype.setValue = function (name, value) {
        this._rows.forEach(function (row) {
            row.applyValue(name, value);
        });
    };

    Form.prototype.updateDependentState = function () {
        var form = this;
        var enabled = [true];

        var source = this._newRows ? this._newRows : this._rows;

        source.forEach(function (row) {

            var updatedRow = form.updateState(row, {
                enabled: enabled[row.level] && !row.data.disabled
            });

            if (updatedRow.isValue) {
                enabled[updatedRow.level + 1] = updatedRow.enabled && updatedRow.checked;
            }
        });
    };

    Form.prototype.processFormItem = function (item, level) {
        var form = this;
        var type = this.getFieldType(item);

        var rows = [];

        if (type === "radio") {

            if (item.name) {
                var row = new RowModel();
                row.field = item.id;
                row.data = item;
                row.level = level;
                row.type = "label";
                row.interactive = false;
                row.text = item.name;
                form._rows.push(row);
                rows.push(row);
            }

            item.options.forEach(function (option) {
                var row = new RowModel();
                row.field = item.id;
                row.data = option;
                row.level = level;
                row.type = type;
                row.isValue = true;
                row.text = option.name;
                row.resolved = option.id;
                form._rows.push(row);
                rows.push(row);

                if (option.children) {
                    option.children.forEach(function (child) {
                        var childRows = form.processFormItem(child, level + 1);
                        rows = rows.concat(childRows);
                    })
                }
            });
        }
        else if (type === "title") {
            var row = new RowModel();
            row.field = item.id;
            row.data = item;
            row.level = level;
            row.type = type;
            row.interactive = false;
            row.text = item.name;
            form._rows.push(row);
            rows.push(row);
        }
        else if (type === "image") {
            var row = new RowModel();
            row.isValue = true;
            row.field = item.id;
            row.data = item;
            row.level = level;
            row.type = type;
            row.interactive = false;
            row.text = null;
            form._rows.push(row);
            rows.push(row);
        }
        else if (type === "html") {
            var row = new RowModel();
            row.isValue = true;
            row.field = item.id;
            row.data = item;
            row.level = level;
            row.type = type;
            row.interactive = false;
            row.text = null;
            form._rows.push(row);
            rows.push(row);
        }
        else if (type === "scrollable") {
            var row = new RowModel();
            row.isValue = true;
            row.field = item.id;
            row.data = item;
            row.level = level;
            row.type = type;
            row.interactive = false;
            row.text = null;
            form._rows.push(row);
            rows.push(row);
        }
        else {
            var row = new RowModel();
            row.field = item.id;
            row.data = item;
            row.level = level;
            row.type = type;
            row.text = item.name;
            row.children = [];
            form._rows.push(row);
            rows.push(row);
        }

        if (type === "checkbox") {
            row.isValue = true;
            row.resolved = true;

            if (item.children) {
                item.children.forEach(function (child) {
                    var childRows = form.processFormItem(child, level + 1);
                    rows = rows.concat(childRows);
                })
            }
        }

        return rows;

    };

    Form.prototype.doOnKey = function (key) {
        if (typeof this.onKey === "function") {
            var args = {
                key: key
            };
            this.onKey(args);
        }
    };

    Form.prototype.createInteractive = function (row) {
        var form = this;
        var views = {
            "label": function () {
                return new Interactive();
            },
            "title": function () {
                return new Interactive();
            },
            "image": function() {
                var interactive = new Interactive();

                var image = document.createElement("img");
                image.src = row.data.image;

                interactive.element = image;

                return interactive;
            },
            "html": function() {
                var interactive = new Interactive();

                var div = document.createElement("div");
                if (typeof row.data.text === "string") {
                    div.innerText = row.data.text;
                }
                else if (typeof row.data.html === "string") {
                    div.innerHTML = row.data.html;
                }

                interactive.element = div;

                return interactive;
            },
            "scrollable": function() {
                var interactive = new Interactive();

                var scroll = document.createElement("div");
                scroll.className = form.theme + "_form_item_scrollable_scroll";

                if (row.data.height) {
                    scroll.style.height = row.data.height + "px";
                }

                var div = document.createElement("div");
                div.className = form.theme + "_form_item_scrollable_scroll_content";
                if (typeof row.data.text === "string") {
                    div.innerText = row.data.text;
                }
                else if (typeof row.data.html === "string") {
                    div.innerHTML = row.data.html;
                }

                scroll.appendChild(div);

                interactive.element = scroll;

                return interactive;
            },
            "text": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;

                    var input = interactive.element;
                    input.value = row.value;
                    input.disabled = !row.enabled;
                };

                var input = document.createElement("input");
                input.name = row.field;
                input.type = "text";
                input.autocomplete = "off";
                input.onkeydown = function (e) {
                    var letcontinue = false;
                    switch (e.keyCode) {
                        case 13:
                            form.doOnKey("Enter");
                            break;
                        case 27:
                            form.doOnKey("Escape");
                            break;
                        default:
                            letcontinue = true;
                            break;
                    }
                    if (!letcontinue) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };

                input.oninput = function(e) {
                    interactive.onInput();
                };
                input.onblur = function(e) {
                    interactive.onBlur();
                }

                interactive.element = input;
                interactive.canFocus = function() {
                    return !interactive.element.disabled;
                };
                interactive.focus = function () {
                    interactive.element.focus();
                    interactive.element.setSelectionRange(0, interactive.element.value.length);
                };
                interactive.save = function() {
                    var result = {};
                    result[row.field] = input.value;
                    return result;
                };

                return interactive;
            },
            "textarea": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;

                    var input = interactive.element;
                    input.value = row.value;
                    input.disabled = !row.enabled;
                };

                var textarea = document.createElement("textarea");
                textarea.name = row.field;
                if (row.data.height) {
                    textarea.style.height = row.data.height + "px";
                }
                // input.type = "text";
                textarea.onkeydown = function (e) {
                    var letcontinue = false;
                    switch (e.keyCode) {
                        case 13:
                            // form.doOnKey("Enter");
                            if (e.ctrlKey || e.metaKey) {
                                form.doOnKey("Enter");
                            }
                            letcontinue = false;
                            break;
                        case 27:
                            form.doOnKey("Escape");
                            break;
                        default:
                            letcontinue = true;
                            break;
                    }
                    if (!letcontinue) {
                        // e.preventDefault();
                        e.stopPropagation();
                    }
                };

                textarea.oninput = function(e) {
                    interactive.onInput();
                };
                textarea.onblur = function(e) {
                    interactive.onBlur();
                }

                interactive.element = textarea;
                interactive.canFocus = function() {
                    return !interactive.element.disabled;
                };
                interactive.focus = function () {
                    interactive.element.focus();
                    interactive.element.setSelectionRange(0, 0);
                };
                interactive.save = function() {
                    var result = {};
                    result[row.field] = textarea.value;
                    return result;
                };

                return interactive;
            },
            "date": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var input = interactive.element;
                    var picker = interactive.picker;

                    if (row.data.dateFormat) {
                        picker.pattern = row.data.dateFormat;
                    }
                    var locale = row.data.locale || form.locale;
                    if (locale) {
                        picker.locale = locale;
                    }

                    input.disabled = !row.enabled;

                    picker.date = new DayPilot.Date(row.value);
                    var formatted = new DayPilot.Date(row.value).toString(row.data.dateFormat || picker.pattern, picker.locale);
                    input.value = formatted;
                };

                var input = document.createElement("input");
                input.name = row.field;

                var picker = new DayPilot.DatePicker({
                    target: input,
                    theme: "navigator_modal",
                    zIndex: form.zIndex + 1,
                    resetTarget: false,
                    targetAlignment: "left",
                    onTimeRangeSelect: function(args) {
                        interactive.onInput({"immediate": true});
                    }
                });

                // required for serialization - to get the normalized value
                input.picker = picker;
                input.className = form.theme + "_input_date";
                input.type = "text";
                input.onkeydown = function (e) {
                    var letcontinue = false;
                    switch (e.keyCode) {
                        case 13:  // enter
                            if (picker.visible) {
                                picker.close();
                            } else {
                                form.doOnKey("Enter");
                            }
                            break;
                        case 27: // escape
                            if (picker.visible) {
                                picker.close();
                            } else {
                                form.doOnKey("Escape");
                            }
                            break;
                        case 9:  // tab
                            picker.close();
                            letcontinue = true;
                            break;
                        default:
                            letcontinue = true;
                            break;
                    }
                    if (!letcontinue) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };

                input.onfocus = function () {
                    picker.show();
                };

                input.onclick = function () {
                    picker.show();
                };

                /*
                        input.onblur = function () {
                          // input.picker.close();
                        };
                */

                input.oninput = function(e) {
                    interactive.onInput();
                };
                input.onblur = function(e) {
                    interactive.onBlur();
                }

                interactive.element = input;
                interactive.picker = picker;
                interactive.canFocus = function() {
                    return !interactive.element.disabled;
                };
                interactive.focus = function () {
                    interactive.element.focus();
                };
                interactive.save = function() {
                    var value = picker.date ? picker.date.toString() : null;
                    var result = {};
                    result[row.field] = value;
                    return result;
                };
                return interactive;
            },
            "time": function () {
                return form._createInteractiveTime(row);
            },
            "datetime": function() {
                return form._createInteractiveDateTime(row);
            },
            "select": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var select = interactive.element;

                    select.value = row.value;
                    select.disabled = !row.enabled;
                };

                var select = document.createElement("select");
                select.name = row.field;

                if (row.data.options && row.data.options.forEach) {
                    row.data.options.forEach(function (i) {
                        var option = document.createElement("option");
                        option.innerText = i.name || i.id;
                        option.value = i.id;
                        option._originalValue = i.id;
                        select.appendChild(option);
                    });
                }

                select.onchange = function(e) {
                    interactive.onInput({"immediate": true});
                };
                select.onblur = function(e) {
                    interactive.onBlur();
                };

                interactive.element = select;
                interactive.canFocus = function() {
                    return !interactive.element.disabled;
                };
                interactive.focus = function () {
                    interactive.element.focus();
                };
                interactive.save = function() {
                    var value = null;
                    var option = select.options[select.selectedIndex];
                    if (option && typeof option._originalValue !== "undefined") {
                        value = option._originalValue;
                    }
                    var result = {};
                    result[row.field] = value;
                    return result;
                };

                return interactive;

            },
            "searchable": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var searchable = interactive.searchable;

                    searchable.disabled = !row.enabled;
                    searchable.select(row.value);
                };

                var searchable = new Searchable({
                    data: row.data.options || [],
                    name: row.field,
                    theme: form.theme + "_form_item_searchable",
                    listZIndex: form.zIndex + 1,
                    // disabled: !row.enabled
                    onSelect: function(args) {
                        if (args.ui) {
                            interactive.onInput({"immediate": true});
                        }
                    }
                });

                var element = searchable.create();

                interactive.element = element;
                interactive.searchable = searchable;
                interactive.canFocus = function() {
                    return !interactive.searchable.disabled;
                };
                interactive.focus = function () {
                    interactive.searchable.focus();
                };
                interactive.save = function() {
                    var value = searchable.selected && searchable.selected.id;
                    var result = {};
                    result[row.field] = value;
                    return result;
                };

                return interactive;
            },
            "radio": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var radio = interactive.radio;

                    radio.checked = row.checked;
                    radio.disabled = !row.enabled;
                };

                var label = document.createElement("label");

                var radio = document.createElement("input");
                radio.type = "radio";
                radio.name = row.field;
                radio._originalValue = row.resolved;

                radio.onchange = function (ev) {
                    // activation only

                    var row = interactive.row;
                    form.findRowsByField(row.field).forEach(function (row) {
                        form.updateState(row, {
                            checked: false
                        });
                    });
                    form.updateState(row, {
                        checked: true
                    });

                    form.applyState();

                    interactive.onInput({"immediate": true});
                };

                radio.onblur = function(e) {
                    interactive.onBlur();
                };

                label.appendChild(radio);

                var text = document.createTextNode(row.text);
                label.append(text);

                interactive.element = label;
                interactive.radio = radio;
                interactive.canFocus = function() {
                    return false;
                };
                interactive.focus = function () {
                    interactive.radio.focus();
                }
                interactive.save = function() {
                    if (!radio.checked) {
                        return {};
                    }
                    var value = radio._originalValue;
                    var result = {};
                    result[row.field] = value;
                    return result;
                };

                return interactive;
            },
            "checkbox": function () {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var checkbox = interactive.checkbox;

                    checkbox.checked = row.checked;
                    checkbox.disabled = !row.enabled;
                };

                var label = document.createElement("label");

                var checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.name = row.field;
                checkbox._originalValue = row.resolved;

                checkbox.onchange = function (ev) {
                    var row = interactive.row;
                    form.updateState(row, {
                        checked: this.checked
                    });
                    form.applyState();

                    interactive.onInput({"immediate": true});
                };

                checkbox.onblur = function(e) {
                    interactive.onBlur();
                };

                label.appendChild(checkbox);

                var text = document.createTextNode(row.text);
                label.append(text);

                interactive.element = label;
                interactive.checkbox = checkbox;
                interactive.canFocus = function() {
                    return false;
                };
                interactive.focus = function () {
                    interactive.checkbox.focus();
                }
                interactive.save = function() {
                    var value = checkbox.checked;
                    var result = {};
                    result[row.field] = value;
                    return result;
                };

                return interactive;
            },
            "table": function() {
                var interactive = new Interactive();
                interactive.apply = function (row) {
                    interactive.row = row;
                    var table = interactive.table;

                    table.disabled = !row.enabled;
                    table.load(row.value || []);

                    /*
                              if (row.value) {
                                table.load(row.value);
                              }
                    */
                };

                var table = new Table({
                    name: row.field,
                    // form: row.data.columns,
                    form: form,
                    theme: form.theme + "_form_item_tabular",
                    item: row.data,
                    onInput: function(args) {
                        interactive.onInput();
                    }
                });

                var element = table.create();

                interactive.element = element;
                interactive.table = table;
                interactive.canFocus = function() {
                    // return !interactive.table.disabled;
                    return false;
                };
                interactive.focus = function () {
                    interactive.table.focus();
                };
                interactive.save = function() {
                    var value = table.save();
                    var result = {};
                    result[row.field] = value;
                    return result;
                };

                return interactive;
            }
        };
        if (form.plugins && form.plugins[row.type]) {
            return form.plugins[row.type](row);
        }
        return views[row.type]();
    };

    Form.prototype._createInteractiveTime = function(row) {
        var form = this;
        var interactive = new Interactive();
        interactive.apply = function (row) {
            interactive.row = row;
            var searchable = interactive.searchable;

            searchable.disabled = !row.enabled;
            searchable.select(row.value);
        };

        var data = [];

        var interval = row.data.timeInterval || 15;  // allowed values: 1, 5, 10, 15, 20, 30, 60
        var allowedIntervals = [1, 5, 10, 15, 20, 30, 60];
        if (!allowedIntervals.includes(interval)) {
            interval = 15;
        }
        var perHour = 60 / interval;

        var localeStr = row.data.locale || form.locale;
        var locale = DayPilot.Locale.find(localeStr) || DayPilot.Locale.US;

        var date = DayPilot.Date.today();

        for (var i = 0; i < 24*perHour; i++) {
            var time = date.addMinutes(interval*i);
            var item = {};
            item.name = time.toString(row.data.timeFormat || locale.timePattern, locale);
            item.id = time.toString("HH:mm");
            data.push(item);
        }

        var searchable = new Searchable({
            data: data,
            name: row.field,
            theme: form.theme + "_form_item_time",
            listZIndex: form.zIndex + 1,
            strategy: "startsWith",
            // disabled: !row.enabled
            onSelect: function(args) {
                if (args.ui) {
                    interactive.onInput({"immediate": true});
                }
            }
        });

        var element = searchable.create();

        interactive.element = element;
        interactive.searchable = searchable;
        interactive.canFocus = function() {
            return !interactive.searchable.disabled;
        };
        interactive.focus = function () {
            interactive.searchable.focus();
        };
        interactive.save = function() {
            var value = searchable.selected && searchable.selected.id;
            var result = {};
            result[row.field] = value;
            return result;
        };

        return interactive;

    };

    Form.prototype._createInteractiveDateTime = function(row) {
        var form = this;
        var interactive = new Interactive();
        interactive.apply = function (row) {
            interactive.row = row;
            var searchable = interactive.searchable;

            searchable.disabled = !row.enabled;

            var timePart = new DayPilot.Date(row.value).toString("HH:mm");

            searchable.select(timePart);

            var input = interactive.dateInput;
            var picker = interactive.picker;

            if (row.data.dateFormat) {
                picker.pattern = row.data.dateFormat;
            }
            var localeStr = row.data.locale || form.locale;
            if (localeStr) {
                var locale = DayPilot.Locale.find(localeStr) || DayPilot.Locale.US;
                picker.locale = localeStr;
                picker.pattern = locale.datePattern;
            }

            input.disabled = !row.enabled;

            picker.date = new DayPilot.Date(row.value);
            var formatted = new DayPilot.Date(row.value).toString(row.data.dateFormat || picker.pattern, picker.locale);
            input.value = formatted;

        };

        var dateElement = (function createDatePicker() {
            var input = document.createElement("input");
            input.name = row.field;

            var picker = new DayPilot.DatePicker({
                target: input,
                theme: "navigator_modal",
                zIndex: form.zIndex + 1,
                resetTarget: false,
                targetAlignment: "left",
                onTimeRangeSelect: function(args) {
                    interactive.onInput({"immediate": true});
                }
            });

            // required for serialization - to get the normalized value
            input.picker = picker;
            input.className = form.theme + "_input_date";
            input.type = "text";
            input.onkeydown = function (e) {
                var letcontinue = false;
                switch (e.keyCode) {
                    case 13:  // enter
                        if (picker.visible) {
                            picker.close();
                        } else {
                            form.doOnKey("Enter");
                        }
                        break;
                    case 27: // escape
                        if (picker.visible) {
                            picker.close();
                        } else {
                            form.doOnKey("Escape");
                        }
                        break;
                    case 9:  // tab
                        picker.close();
                        letcontinue = true;
                        break;
                    default:
                        letcontinue = true;
                        break;
                }
                if (!letcontinue) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            input.onfocus = function () {
                picker.show();
            };

            input.onclick = function () {
                picker.show();
            };

            input.oninput = function(e) {
                interactive.onInput();
            };
            input.onblur = function(e) {
                interactive.onBlur();
            }

            interactive.dateInput = input;
            interactive.picker = picker;

            return input;
        })();


        var timeElement = (function createTimePicker() {
            var data = [];

            var interval = row.data.timeInterval || 15;  // allowed values: 1, 5, 10, 15, 20, 30, 60
            var allowedIntervals = [1, 5, 10, 15, 20, 30, 60];
            if (!allowedIntervals.includes(interval)) {
                interval = 15;
            }
            var perHour = 60 / interval;

            var localeStr = row.data.locale || form.locale;
            var locale = DayPilot.Locale.find(localeStr) || DayPilot.Locale.US;

            var date = DayPilot.Date.today();

            for (var i = 0; i < 24*perHour; i++) {
                var time = date.addMinutes(interval*i);
                var item = {};
                item.name = time.toString(row.data.timeFormat || locale.timePattern, locale);
                item.id = time.toString("HH:mm");
                data.push(item);
            }

            var searchable = new Searchable({
                data: data,
                name: row.field,
                theme: form.theme + "_form_item_time",
                listZIndex: form.zIndex + 1,
                strategy: "startsWith",
                // disabled: !row.enabled
                onSelect: function(args) {
                    if (args.ui) {
                        interactive.onInput({"immediate": true});
                    }
                }
            });

            interactive.searchable = searchable;
            return searchable.create();

        })();


        var element = document.createElement("div");
        element.className = form.theme + "_form_item_datetime_parent";
        element.appendChild(dateElement);
        element.appendChild(timeElement);

        interactive.element = element;
        interactive.canFocus = function() {
            return !interactive.searchable.disabled;
        };
        interactive.focus = function () {
            interactive.dateInput.focus();
        };
        interactive.save = function() {
            var timeValue = interactive.searchable.selected && interactive.searchable.selected.id;
            var dateValue = interactive.picker.date ? interactive.picker.date.toString() : null;

            var date = new DayPilot.Date(dateValue).getDatePart();
            var value = DayPilot.Date.parse(date.toString("yyyy-dd-MM ") + timeValue, "yyyy-dd-MM HH:mm");

            var result = {};
            result[row.field] = value;
            return result;

        };

        return interactive;

    };

    Form.prototype.findRowsByField = function (field) {
        return this._rows.filter(function (row) {
            return row.field === field;
        });
    };

    // ooptional value param applies to radio which can have multiple views, one for each value
    Form.prototype.findViewById = function (id, value) {
        return this._views.find(function (v) {
            if (v.row.field === id) {
                if (v.row.type === "radio") {
                    return v.row.resolved === value;
                } else {
                    return true;
                }
            }
            return false;
        });
    };

    Form.prototype.firstFocusable = function () {
        return this._views.find(function (v) {
            return v.canFocus && v.canFocus();
        });
    };

    Form.prototype.updateState = function (row, props) {
        var source = this._newRows ? this._newRows : this._rows;
        var index = source.indexOf(row);
        this._newRows = source.map(function (srow) {
            if (srow !== row) {
                return srow;
            }
            // our row
            if (row.propsEqual(props)) {
                return row;
            }
            var cloned = row.clone();
            for (var name in props) {
                cloned[name] = props[name];
            }
            return cloned;
        });
        return this._newRows[index];
    };

    // dirty row received, a member of _newRows
    Form.prototype.updateInteractive = function (row) {
        var index = this._newRows.indexOf(row);
        this._views[index].apply(row);
    };

    Form.prototype.applyState = function () {
        var form = this;

        this.updateDependentState();

        if (!this._newRows) {
            return;
        }

        var dirtyRows = this._newRows.filter(function (row, i) {
            return form._rows[i] !== row;
        });

        dirtyRows.forEach(function (row) {
            form.updateInteractive(row);
        });

        this._rows = this._newRows;

        this._newRows = null;
    };

    Form.prototype.getFieldType = function (item) {

        var known = ["text", "date", "select", "searchable", "radio", "checkbox", "table", "title", "image", "html", "textarea", "scrollable", "time", "datetime"];
        if (known.indexOf(item.type) !== -1) {
            return item.type;
        }

        if (item.type && this.plugins && this.plugins[item.type]) {
            return item.type;
        }

        if (item.image) {
            return "image";
        }

        if (item.html || item.text) {
            return "html";
        }

        if (!item.id) {
            return "title";
        }

        if (item.options) {
            return "searchable";
        }

        if (item.dateFormat) {
            return "date";
        }

        if (item.columns) {
            return "table";
        }

        return "text";
    };

    Form.prototype.serialize = function() {
        var result = {};

        this._views.forEach(function(interactive) {
            var out = interactive.save();
            for (var name in out) {
                result[name] = out[name];
            }
        });

        return result;
    };

    var RowModel = function () {
        this.id = this.guid();
        this.field = null;
        this.data = null;
        this.type = null;
        this.level = 0;
        this.enabled = true;
        this.value = null;
        this.text = null;

        this.interactive = true;

        this.isValue = false;
        this.checked = false;
        this.resolved = null;  // value resolves to
    };

    RowModel.prototype.clone = function () {
        var rm = new RowModel();
        for (var name in this) {
            if (name === "id") {
                continue;
            }
            rm[name] = this[name];
        }
        return rm;
    };

    RowModel.prototype.propsEqual = function (props) {
        for (var name in props) {
            if (this[name] !== props[name]) {
                return false;
            }
        }
        return true;
    };

    RowModel.prototype.guid = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };
        return ("" + S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
    };

    RowModel.prototype.applyValue = function (name, value) {
        if (this.field !== name) {
            return;
        }
        this.value = value;
        if (this.isValue && value === this.resolved) {
            this.checked = true;
        }
    };

    var Interactive = function () {
        // this.row = row;
        this.element = null;

        // only used for autofocus
        this.canFocus = function() {
            return false;
        };
        this.apply = function (row) {
        };
        this.focus = function () {
        };
        this.save = function() {
            return {};
        }
    };

    function flatten(object, result, prefix) {
        result = result || {};
        prefix = prefix || "";
        for (var name in object) {
            var src = object[name];
            if (typeof src === "object") {
                if (Object.prototype.toString.call(src) === '[object Array]') {
                    result[prefix + name] = src;
                }
                else if (src && src.toJSON) {
                    result[prefix + name] = src.toJSON();
                }
                else {
                    flatten(src, result, prefix + name + ".");
                }
            }
            else {
                result[prefix + name] = src;
            }
        }
        return result;
    }

    // end of form.js

    // searchable.js
    var Searchable = function(options) {

        // properties
        this.data = [];
        this.name = null;
        this.theme = "searchable_default";
        this._disabled = false;
        this.listZIndex = 100000;


        // events
        this.onSelect = null;

        // state
        this._selected = null;
        this._highlighted = null;
        this._collapsed = false;
        // this._focused = false;
        // this._filter = null;

        // view
        this._input = null;
        this._list = null;
        this._options = [];
        this._hidden = null;

        options = options || {};

        var t = this;

        var specialHandling = {
            "selected": {
                post: function(val) {
                    if (typeof val === "object" && val.id) {
                        t._selected = val;
                    }
                    else if (typeof val === "string" || typeof val === "number") {
                        t.select(val);
                    }
                }
            }
        };

        Object.defineProperty(this, "selected", {
            get: function() {
                return this._selected;
            },
        });

        Object.defineProperty(this, "disabled", {
            get: function() {
                return this._disabled;
            },
            set: function(val) {
                this._disabled = val;
                if (this._input) {
                    this._input.disabled = val;
                    if (val) {
                        // verify
                        this._cancel();
                    }
                }
            }
        });

        for (var name in options) {
            if (!specialHandling[name]) {
                this[name] = options[name];
            }
        }

        for (var name in options) {
            if (specialHandling[name]) {
                specialHandling[name].post(options[name]);
            }
        }

    };

    Searchable.prototype.select = function(id) {
        this._selected = this.data.find(function(item) { return item.id === id });
        this._doOnSelect(false);
        return this;
    };


    Searchable.prototype.create = function() {
        var component = this;
        var t = this;

        var div = document.createElement("div");
        div.className = this.theme + "_main";
        div.style.position = "relative";

        var icon = document.createElement("div");
        icon.className = this.theme + "_icon";
        icon.style.position = "absolute";
        icon.style.right = "0";
        icon.style.top = "0";
        icon.style.bottom = "0";
        icon.style.width = "20px";
        icon.addEventListener("mousedown", function(ev) {
            ev.preventDefault();
            if (component._collapsed) {
                component.focus();
                expand();
            }
            else {
                cancel();
                collapse();
            }
        });

        var list = document.createElement("div");
        list.className = this.theme + "_list";
        list.style.display = "none";
        list.style.position = "absolute";
        list.style.zIndex = this.listZIndex;

        var hidden = document.createElement("input");
        hidden.type = "hidden";
        hidden.name = this.name;
        hidden.searchable = t;
        this._hidden = hidden;

        var input = document.createElement("input");
        input.type = "text";
        input.className = this.theme + "_input";
        input.disabled = this._disabled;
        input.addEventListener("click", function(ev) {
            // console.log("click");
            expand();
        });
        input.addEventListener("focus", function(ev) {
            // do not call expand() here, the readonly status has to stay
            // input.value = "";
            // console.log("focus");
            filter("all");
        });
        input.addEventListener("input", function(ev) {
            filter();
        });
        input.addEventListener("blur", function(ev) {
            input.removeAttribute("readonly");
            cancel();
        });

        input.addEventListener("keydown", function(ev) {
            if (component._collapsed) {
                if (ev.key === "Enter") {
                    return;
                }
                if (ev.key === "Esc" || ev.key === "Escape") {
                    return;
                }
                expand();
            }

            if (ev.key === "ArrowDown") {
                var index = t._options.indexOf(t._highlighted);
                if (index + 1 < t._options.length) {
                    t._highlighted = t._options[index + 1];
                }
                updateHiglight();
            } else if (ev.key === "ArrowUp") {
                var index = t._options.indexOf(t._highlighted);
                if (index - 1 >= 0) {
                    t._highlighted = t._options[index - 1];
                }
                updateHiglight();
            } else if (ev.key === "Enter") {
                if (component._highlighted) {
                    ev.stopPropagation();
                    selectOption(component._highlighted);
                }
                else {
                    ev.stopPropagation();
                    // t._cancel();
                    cancel();
                    collapse();
                }
            } else if (ev.key === "Esc" || ev.key === "Escape") {
                ev.stopPropagation();
                cancel();
                collapse();
            }
        });
        this._input = input;
        this._list = list;

        if (!this._selected) {
            this._selected = this.data[0];
            if (this._selected) {
                input.value = this._selected.name;
            }
        }

        function filter(strategy) {
            // component._collapsed = false;

            var defaultStrategy = component.strategy;
            if (component.strategy !== "includes" && component.strategy !== "startsWith") {
                defaultStrategy = "includes";
            }

            strategy = strategy || defaultStrategy || "includes";

            list.style.display = "";
            list.style.top = input.offsetHeight + "px";
            list.style.left = "0px";
            list.style.width = input.offsetWidth + "px";
            list.innerHTML = "";

            // allow scrollbar access
            list.addEventListener("mousedown", function(ev) {
                ev.preventDefault();
            });

            component._highlighted = null;

            component._options = [];

            var first = null;

            component.data.forEach(function(item) {

                var name = item.name || item.id;

                if (strategy === "includes") {
                    if (name.toLowerCase().indexOf(input.value.toLowerCase()) === -1) {
                        return;
                    }
                }
                else if (strategy === "startsWith") {
                    if (name.toLowerCase().indexOf(input.value.toLowerCase()) !== 0) {
                        return;
                    }
                }
                else if (strategy === "all") {
                    // don't skip
                }


                var option = document.createElement("div");
                option.className = component.theme + "_list_item";
                option.innerText = name;

                option.item = item;

                if (item === component._selected) {
                    component._highlighted = option;
                }
                if (!first) {
                    first = option;
                }

                // "mousedown" goes before blur, "click" goes after
                option.addEventListener("mousedown", function(ev) {
                    selectOption(option);
                    ev.preventDefault();
                });

                option.addEventListener("mousemove", function(ev) {
                    if (component._highlighted === option) {
                        return;
                    }
                    component._highlighted = option;
                    updateHiglight({dontScroll: true});
                });

                list.appendChild(option);

                component._options.push(option);
            });

            if (!component._highlighted) {
                component._highlighted = first;
            }
            updateHiglight();
        }

        function updateHiglight(options) {
            options = options || {};
            var scrollIntoView = !options.dontScroll;

            // redo, avoid selectors
            var previous = document.querySelectorAll("." + component.theme + "_list_item_highlight");
            previous.forEach(function(p) {
                p.className = p.className.replace(component.theme + "_list_item_highlight", "");
            });

            if (component._highlighted) {
                component._highlighted.className += " " + component.theme + "_list_item_highlight";

                if (scrollIntoView && !isScrolledIntoView(component._highlighted, list)) {
                    component._highlighted.scrollIntoView();
                }
            }
        }

        function isScrolledIntoView(target, viewport) {
            var tRect = target.getBoundingClientRect();
            var vRect = viewport.getBoundingClientRect();
            return tRect.top >= vRect.top && tRect.bottom <= vRect.bottom;
        }

        function selectOption(option) {
            var item = option.item;

            // input.value = option.innerText;
            component._selected = item;
            component._doOnSelect(true);
            hide();
            collapse();
        }

        function cancel() {
            component._cancel();
        }

        function hide() {
            component._hide();
        }

        function collapse() {
            component._collapsed = true;
            input.setAttribute("readonly", "readonly");
            input.focus();
        }

        function expand() {
            component._collapsed = false;
            input.removeAttribute("readonly");
            // input.value = "";
            input.select();
            filter("all");
        }

        div.appendChild(input);
        div.appendChild(icon);
        div.appendChild(hidden);
        div.appendChild(list);
        return div;
    };

    Searchable.prototype._cancel = function() {
        this._hide();
        if (!this._selected) {
            this._input.value = "";
            // not sure about this:
            this._doOnSelect(true);
        } else {
            this._input.value = this._selected.name;
        }
        // collapse();
    }

    Searchable.prototype.focus = function() {
        // this._input.focus();

        this._collapsed = true;
        this._input.setAttribute("readonly", "readonly");
        this._input.focus();
        this._cancel();
    };

    Searchable.prototype._hide = function() {
        this._list.style.display = "none";
    };

    Searchable.prototype._doOnSelect = function(byUser) {
        this._hidden.value = this.selected ? this.selected.id : null;
        if (this._selected) {
            this._input.value = this._selected.name;
        }
        else {
            this._input.value = "";
        }

        if (typeof this.onSelect === "function") {
            var args = {
                control: this,
                ui: byUser
            };
            this.onSelect(args);
        }
    };

    // end of searchable.js

    // table.js
    var Table = function(options) {

        this.form = null; // Form instance
        this.item = null; // table def from form
        this.data = null;
        this.name = null;
        this.theme = "edit_table_default";
        this.onInput = null;

        this.nav = {};

        this._activeEdit = null;
        this._rows = [];

        options = options || {};

        for (var name in options) {
            this[name] = options[name];
        }

    };

    Table.prototype.create = function() {
        var table = this;

        var div = document.createElement("div");
        div.className = this.theme + "_main";
        div.style.position = "relative";

        var hidden = document.createElement("input");
        hidden.type = "hidden";
        hidden.name = table.name;
        hidden.table = this;
        div.appendChild(hidden);

        var tableElement = document.createElement("div");
        tableElement.className = this.theme + "_table";
        var header = this._createHeader();
        tableElement.appendChild(header);

        var spacerRow = table._createRowState({});
        spacerRow.spacer = true;
        var spacer = this._renderRow(spacerRow);
        // spacer.style.visibility = "hidden";
        spacer.classList.add(table.theme + "_spacer");
        tableElement.appendChild(spacer);

        var body = document.createElement("div");
        body.className = table.theme + "_tbody";
        tableElement.appendChild(body);

        div.appendChild(tableElement);

        var after = document.createElement("div");
        div.appendChild(after);

        this.nav.body = body;
        this.nav.table = tableElement;
        this.nav.main = div;
        this.nav.after = after;

        var add = document.createElement("div");
        var plus = document.createElement("span");
        plus.className = this.theme + "_plus";

        plus.addEventListener("click", function(ev) {
            if (table.disabled) {
                return;
            }

            var generate = table.item.onNewRow;
            var value = {};
            if (typeof generate === "function") {
                var args = {};
                args.result = table.form.serialize();
                args.value = {};
                generate(args);
                value = args.value;
            }

            var row = table._createRowState(value);
            table._rows.push(row);
            table._render();
            table._doOnInput();
        });

        this.nav.plus = plus;

        add.appendChild(plus);
        div.appendChild(add);

        return div;
    };

    Table.prototype._createHeader = function() {
        var table = this;
        var row = document.createElement("div");
        row.classList.add(this.theme + "_row");
        row.classList.add(this.theme + "_header");
        this.item.columns.forEach(function(item) {
            var cell = document.createElement("div");
            cell.classList.add(table.theme + "_cell");
            cell.innerText = item.name;
            row.appendChild(cell);
        });
        return row;
    };

    Table.prototype._maxRowsReached = function() {
        var max = this.item.max || 0;
        if (max && this._rows.length >= max) {
            return true;
        }
        return false;
    };

    Table.prototype.save = function() {
        var table = this;
        var data = [];

        table._rows.forEach(function(row) {
            var item = {};
            row.cells.forEach(function(cell) {
                item[cell.id] = cell.value;
            });
            data.push(item);
        });

        return data;
    };

    Table.prototype.load = function(data) {
        var table = this;

        var isArray = Object.prototype.toString.call(data) === '[object Array]';
        if (!isArray) {
            throw new Error("Array expected");
        }

        this.data = data;

        this._createState();
        this._render();
    };

    Table.prototype._updateCss = function() {
        if (this.disabled) {
            this.nav.main.classList.add(this.theme + "_disabled");
        }
        else {
            this.nav.main.classList.remove(this.theme + "_disabled");
        }

        var maxReached = this._maxRowsReached();
        if (maxReached) {
            this.nav.plus.classList.add(this.theme + "_plus_max");
        }
        else {
            this.nav.plus.classList.remove(this.theme + "_plus_max");
        }
    };

    Table.prototype._createState = function() {
        var table = this;
        this._rows = [];
        this.data.forEach(function(dataRow) {
            var row = table._createRowState(dataRow);
            table._rows.push(row);
        });
    };

    Table.prototype._removeRow = function(row) {
        var table = this;

        var index = table._rows.indexOf(row);
        table._rows.splice(index, 1);
    };

    Table.prototype._createRowState = function(dataRow) {
        var table = this;

        var row = {};
        row.data = dataRow;
        row.cells = [];

        table.item.columns.forEach(function(formItem) {
            var id = formItem.id;
            var value = dataRow[id];

            var type = table._formItemType(formItem);
            if (typeof value === "undefined") {
                if (type === "text") {
                    value = "";
                }
                else if (type === "number") {
                    value = 0;
                }
                else if (type === "select") {
                    var options = formItem.options;
                    value = options && options[0].id;
                }
            }

            var cell = {};
            cell.id = id;
            cell.value = value;
            cell.type = type;
            cell.data = formItem;
            row.cells.push(cell);
        });

        return row;
    };

    Table.prototype._formItemType = function(formItem) {
        var type = formItem.type;
        if (!type) {
            if (formItem.options) {
                type = "select";
            }
            else {
                type = "text";
            }
        }
        return type;
    };

    Table.prototype._render = function() {

        var table = this;
        this.nav.body.innerHTML = "";
        this.nav.after.innerHTML = "";

        this._rows.forEach(function(row) {
            var el = table._renderRow(row);
            table.nav.body.appendChild(el);
        });

        if (this._rows.length === 0) {
            var el = table._renderEmpty();
            table.nav.after.appendChild(el);
        }

        this._updateCss();
    };

    Table.prototype._renderEmpty = function() {
        var div = document.createElement("div");
        div.className = this.theme + "_empty";

        return div;
    };

    Table.prototype._renderRow = function(row) {
        var table = this;
        var el = document.createElement("div");
        el.className = table.theme + "_row";

        row.cells.forEach(function(cell) {

            var cellEl = document.createElement("div");
            cellEl.className = table.theme + "_cell";
            var interactive = table._renderCell(cell);

            if (row.spacer) {
                var wrap = document.createElement("div");
                wrap.style.height = "0px";
                wrap.style.overflow = "hidden";
                wrap.appendChild(interactive);

                cellEl.appendChild(wrap);
            }
            else {
                cellEl.appendChild(interactive);

            }

            el.appendChild(cellEl);
        });

        var cell = document.createElement("div");
        cell.classList.add(table.theme + "_cell");
        cell.classList.add(table.theme + "_rowaction");

        var span = document.createElement("span");
        span.className = this.theme + "_delete";

        span.addEventListener("click", function(ev) {
            if (table.disabled) {
                return;
            }
            table._removeRow(row);
            table._render();
            table._doOnInput();
        });

        if (!row.spacer) {
            cell.appendChild(span);
        }


        el.appendChild(cell);

        return el;
    };

    Table.prototype._doOnInput = function() {
        var table = this;
        if (typeof table.onInput === "function") {
            var args = {}
            table.onInput(args);
        }
    };

    Table.prototype._renderCell = function(cell) {
        var table = this;
        var type = cell.type;
        if (type === "text" || type === "number") {
            var input = document.createElement("input");
            input.type = type;
            if (table.disabled) {
                input.disabled = true;
            }
            if (cell.value) {
                input.value = cell.value;
            }
            input.addEventListener("keyup", function(ev) {
                if (type === "number") {
                    cell.value = Number(this.value);
                }
                else {
                    cell.value = this.value;
                }
                table._doOnInput();
            });
            return input;
        }
        else if (type === "select") {
            var select = document.createElement("select");
            if (table.disabled) {
                select.disabled = true;
            }

            cell.data.options.forEach(function(item) {
                var option = document.createElement("option");
                option.innerText = item.name;
                option.value = item.id;
                option._originalValue = item.id;

                select.appendChild(option);

                if (cell.value === item.id) {
                    option.setAttribute("selected", true);
                }
            });

            select.addEventListener("change", function(ev) {
                var option = select.options[select.selectedIndex];
                if (option && typeof option._originalValue !== "undefined") {
                    cell.value = option._originalValue;
                }
                table._doOnInput();
            });

            return select;
        }

        throw new Error("Unsupported item type: " + type);
    };

    Table.prototype.focus = function() {
    };

    // end of table.js

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
	var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    var doNothing = function() { };

    if (typeof DayPilot.Month !== 'undefined' && DayPilot.Month.def) {
        return;
    }

    var DayPilotMonth = {};

    DayPilot.Month = function(id, options) {
        this.v = '2023.2.5592';

        this.nav = {};

        var calendar = this;

        this.id = id;
        this.isMonth = true;
        this.api = 2;
        this._initialized = false;

        this.hideUntilInit = true;

        this.startDate = new DayPilot.Date(); // today
        this.width = null; // default width is auto
        if (typeof DayPilot.Bubble === "function") { this.bubble = new DayPilot.Bubble(); } else { this.bubble = null; }
        this.cssClassPrefix = "month_default";
        this.cellHeight = 100; // default cell height is 100 pixels (it's a minCellHeight, it will be extended if needed)
        this.cellMarginBottom = 0;
        this.allowMultiSelect = true;
        this.autoRefreshCommand = 'refresh';
        this.autoRefreshEnabled = false;
        this.autoRefreshInterval = 60;
        this.autoRefreshMaxCount = 20;
        this.doubleClickTimeout = 300;
        this.eventEndSpec = "DateTime";
        this.eventTextWrappingEnabled = false;
        this.headerHeight = 30;
        this.heightSpec = "Auto";
        this.weekStarts = "Auto";
        this.eventBarVisible = true;
        this.eventHeight = 25;
        this.cellHeaderHeight = 24;
        this.clientState = {};

        this.afterRender = function() { };
        this.cssOnly = true;
        this.eventsLoadMethod = "GET";
        this.initEventEnabled = false;
        this.lineSpace = 1;
        this.loadingLabelVisible = true;
        this.loadingLabelText = "Loading...";
        this.loadingLabelHtml = null;
        this.locale = "en-us";
        this.maxEvents = "All";
        this.messageHideAfter = 5000;
        this.notifyCommit = 'Immediate'; // or 'Queue'
        this.visible = true;

        this.eventMoveToPosition = false;

        this.eventStartTime = false;
        this.eventEndTime = false;
        this.eventStartEndWidth = 45;

        this.showWeekend = true;
        this.cellMode = false;
        this.shadowType = "Fill";
        this.tapAndHoldTimeout = 300;
        this.timeFormat = "Auto";
        this.viewType = 'Month';
        this.weeks = 1;
        this.xssProtection = "Enabled"; // "Disabled"

        this.cellHeaderClickHandling = "Enabled";
        this.eventClickHandling = 'Enabled';
        this.eventDeleteHandling = "Disabled";
        this.eventDoubleClickHandling = 'Disabled';
        this.eventMoveHandling = 'Update';
        this.eventResizeHandling = 'Update';
        this.eventRightClickHandling = 'ContextMenu';
        this.eventSelectHandling = 'Update';
        this.headerClickHandling = "Enabled";
        this.timeRangeSelectedHandling = 'Enabled';
        this.timeRangeDoubleClickHandling = 'Disabled';

        this.onEventFilter = null;
        this.onBeforeEventRender = null;
        this.onBeforeCellRender = null;
        this.onBeforeHeaderRender = null;

        this.onBeforeEventDomAdd = null;
        this.onBeforeEventDomRemove = null;

        this.onBeforeEventExport = null;
        this.onBeforeCellExport = null;
        this.onBeforeHeaderExport = null;

        this.onCellHeaderClick = null;
        this.onCellHeaderClicked = null;

        this.backendUrl = null;
        this.cellEvents = [];

        this.elements = {};
        this.elements.events = [];

        this._cache = {};
        this._cache.events = {}; // register DayPilotMonth.Event objects here, key is the data event, reset during drawevents

        this.events = {};

        this._autoRefreshCount = 0;

        this.members = {};
        this.members.ignore = [
            "internal",
            "nav",
            "debug",
            "temp",
            "elements",
            "members",
            "cellProperties"
        ];

        this._productCode = 'javasc';

        this._updateView = function(result, context) {

            var result = JSON.parse(result);

            if (result.BubbleGuid) {
                var guid = result.BubbleGuid;
                var bubble = this.bubbles[guid];
                delete this.bubbles[guid];

                calendar._loadingStop();
                if (typeof result.Result.BubbleHTML !== 'undefined') {
                    bubble.updateView(result.Result.BubbleHTML, bubble);
                }
                return;
            }

            if (result.CallBackRedirect) {
                document.location.href = result.CallBackRedirect;
                return;
            }

            if (typeof result.ClientState !== 'undefined') {
                calendar.clientState = result.ClientState;
            }

            if (result.UpdateType === "None") {

                calendar._fireAfterRenderDetached(result.CallBackData, true);

                if (result.Message) {
                    calendar.message(result.Message);
                }
                calendar._loadingStop();
                return;
            }

            // config
            if (result.VsUpdate) {
                var vsph = document.createElement("input");
                vsph.type = 'hidden';
                vsph.name = calendar.id + "_vsupdate";
                vsph.id = vsph.name;
                vsph.value = result.VsUpdate;
                calendar._vsph.innerHTML = '';
                calendar._vsph.appendChild(vsph);
            }

            calendar.events.list = result.Events;

            if (typeof result.TagFields !== 'undefined') {
                calendar.tagFields = result.TagFields;
            }

            if (typeof result.SortDirections !== 'undefined') {
                calendar.sortDirections = result.SortDirections;
            }

            if (result.UpdateType === "Full") {
                // generated
                calendar.cellProperties = result.CellProperties;
                calendar.headerProperties = result.HeaderProperties;

                // properties
                calendar.startDate = result.StartDate;
                if (typeof result.ShowWeekend !== 'undefined') { calendar.showWeekend = result.ShowWeekend; } // number, can be 0
                //calendar.showWeekend = result.ShowWeekend ? result.ShowWeekend : calendar.showWeekend;
                // calendar.headerBackColor = result.HeaderBackColor ? result.HeaderBackColor : calendar.headerBackColor;
                // calendar.backColor = result.BackColor ? result.BackColor : calendar.backColor;
                // calendar.nonBusinessBackColor = result.NonBusinessBackColor ? result.NonBusinessBackColor : calendar.nonBusinessBackColor;
                calendar.locale = result.Locale ? result.Locale : calendar.locale;
                calendar.timeFormat = result.TimeFormat ? result.TimeFormat : calendar.timeFormat;
                if (typeof result.WeekStarts !== 'undefined') { calendar.weekStarts = result.WeekStarts; } // number, can be 0

                calendar.hashes = result.Hashes;
            }

            calendar.multiselect.clear(true);
            calendar.multiselect.initList = result.SelectedEvents;

            calendar._deleteEvents();
            calendar._prepareRows();
            calendar._loadEvents();

            if (result.UpdateType === "Full") {
                calendar._clearTable();
                calendar._drawTable();
            }
            calendar._updateHeight();

            calendar._show();

            calendar._drawEvents();

            calendar._fireAfterRenderDetached(result.CallBackData, true);

            calendar._startAutoRefresh();

            if (result.Message) {
                calendar.message(result.Message);
            }

            calendar._loadingStop();

        };

        this._fireAfterRenderDetached = function(data, isCallBack) {
            var afterRenderDelayed = function(data, isc) {
                return function() {
                    if (calendar._api2()) {
                        if (typeof calendar.onAfterRender === 'function') {
                            var args = {};
                            args.isCallBack = isc;
                            args.data = data;

                            calendar.onAfterRender(args);
                        }
                    }
                    else {
                        if (calendar.afterRender) {
                            calendar.afterRender(data, isc);
                        }
                    }
                };
/*
                return function() {
                    if (calendar.afterRender) {
                        calendar.afterRender(data, isc);
                    }
                };*/
            };

            window.setTimeout(afterRenderDelayed(data, isCallBack), 0);
        };

        this._api2 = function() {
            return calendar.api === 2;
        };

        this._xssTextHtml = function(text, html) {

            if (calendar._resolved._xssProtectionEnabled()) {
                return DayPilot.Util.escapeTextHtml(text, html);
            }

            if (!DayPilot.Util.isNullOrUndefined(html)) {
                return html;
            }
            if (DayPilot.Util.isNullOrUndefined(text)) {
                return "";
            }
            return text;
        };

        this._prefixCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            if (prefix) {
                return prefix + part;
            }
            else {
                return "";
            }
        };

        this._loadEvents = function() {

            if (!this.events.list) {
                return;
            }

            if (typeof this.onBeforeEventRender === 'function') {
                var length = this.events.list.length;
                for (var i = 0; i < length; i++) {
                    this._doBeforeEventRender(i);
                }
            }

            if (this.cellMode) {
                this._loadEventsCells();
            }
            else {
                this._loadEventsRows();
            }

        };

        this._loadingStart = function(immediately) {

            var delay = immediately ? 0 : 100;
            if (calendar.loadingTimeout) {
                window.clearTimeout(calendar.loadingTimeout);
            }

            calendar.loadingTimeout = window.setTimeout(function() {
                if (calendar.loadingLabelVisible && calendar.nav.loading) {
                    calendar.nav.loading.style.top = (resolved.headerHeight() + 5) + "px";
                    calendar.nav.loading.innerHTML = calendar._xssTextHtml(this.loadingLabelText, this.loadingLabelHtml);
                    calendar.nav.loading.style.display = '';
                }
            }, delay);
        };

        this._loadingStop = function() {

            if (this.loadingTimeout) {
                window.clearTimeout(this.loadingTimeout);
            }

            if (calendar.nav.loading) {
                this.nav.loading.style.display = 'none';
            }
        };


        this._loadEventsRows = function() {

            if (!this.events.list) {
                return;
            }

            // prepare rows and columns
            for (var x = 0; x < this.events.list.length; x++) {
                var e = this.events.list[x];

                if (typeof e !== "object") {
                    throw new DayPilot.Exception("Event data item must be an object");
                }
                if (!e.start) {
                    throw new DayPilot.Exception("Event data item must specify 'start' property");
                }

                var cache = null;
                if (typeof calendar.onBeforeEventRender === 'function') {
                    //var index = DayPilot.indexOf(calendar.events.list, e);
                    cache = calendar._cache.events[x];
                }

                if (cache) {
                    if (cache.hidden) {
                        continue;
                    }
                }
                else if (e.hidden) {
                    continue;
                }

                var start = new DayPilot.Date(e.start);
                var end = new DayPilot.Date(e.end);

                end = calendar._adjustEndIn(end);

                if (start.getTime() > end.getTime()) { // skip invalid events, zero duration allowed
                    continue;
                }
                for (var i = 0; i < this.rows.length; i++) {
                    var row = this.rows[i];
                    if (row.belongsHere(start, end)) {
                        var ep = new DayPilot.Event(e, calendar);

                        if (typeof calendar.onEventFilter === "function" && calendar.events._filterParams) {
                            var args = {};
                            args.filter = calendar.events._filterParams;
                            args.visible = true;
                            args.e = ep;

                            calendar.onEventFilter(args);

                            if (!args.visible) {
                                break;
                            }
                        }

                        row.events.push(ep);

                        if (typeof this.onBeforeEventRender === 'function') {
                            ep.cache = this._cache.events[x];
                        }
                    }
                }
            }

            // arrange events into lines
            for (var ri = 0; ri < this.rows.length; ri++) {
                var row = this.rows[ri];
                row.events.sort(this._eventComparerCustom);

                for (var ei = 0; ei < this.rows[ri].events.length; ei++) {
                    var ev = row.events[ei];
                    var colStart = row.getStartColumn(ev);
                    var colWidth = row.getWidth(ev);
                    //var line = row.putIntoLine(ev, colStart, colWidth, ri);
                    row.putIntoLine(ev, colStart, colWidth, ri);
                }
            }

        };

        this._loadEventsCells = function() {
            this.cellEvents = [];
            for (var x = 0; x < this._getColCount(); x++) {
                this.cellEvents[x] = [];

                for (var y = 0; y < this.rows.length; y++) {
                    var cell = {};
                    var d = this.firstDate.addDays(y * 7 + x);

                    cell.start = d;
                    cell.end = d.addDays(1);
                    cell.events = [];

                    this.cellEvents[x][y] = cell;
                }
            }

            // prepare rows and columns
            for (var i = 0; i < this.events.list.length; i++) {
                var e = this.events.list[i];

                if (typeof e !== "object") {
                    throw new DayPilot.Exception("Event data item must be an object");
                }
                if (!e.start) {
                    throw new DayPilot.Exception("Event data item must specify 'start' property");
                }

                var cache = null;
                if (typeof calendar.onBeforeEventRender === 'function') {
                    //var index = DayPilot.indexOf(calendar.events.list, e);
                    cache = calendar._cache.events[i];
                }

                if (cache) {
                    if (cache.hidden) {
                        continue;
                    }
                }
                else if (e.hidden) {
                    continue;
                }

                var start = new DayPilot.Date(e.start);
                var end = new DayPilot.Date(e.start); // we ignore the end date in cellMode

                end = calendar._adjustEndIn(end);

                if (start.getTime() > end.getTime()) { // skip invalid events, zero duration allowed
                    continue;
                }

                for (var x = 0; x < this._getColCount(); x++) {
                    for (var y = 0; y < this.rows.length; y++) {
                        var cell = this.cellEvents[x][y];
                        if (start.getTime() >= cell.start.getTime() && start.getTime() < cell.end.getTime()) {
                            var ep = new DayPilot.Event(e, calendar);

                            if (typeof calendar.onEventFilter === "function" && calendar.events._filterParams) {
                                var args = {};
                                args.filter = calendar.events._filterParams;
                                args.visible = true;
                                args.e = ep;

                                calendar.onEventFilter(args);

                                if (!args.visible) {
                                    continue;
                                }
                            }

                            cell.events.push(ep);

                            if (typeof this.onBeforeEventRender === 'function') {
                                ep.cache = this._cache.events[i];
                            }
                        }
                    }
                }
            }

            for (var x = 0; x < this._getColCount(); x++) {
                for (var y = 0; y < this.rows.length; y++) {
                    var cell = this.cellEvents[x][y];
                    cell.events.sort(this._eventComparerCustom);
                }
            }
        };

        this._deleteEvents = function() {
            for (var i = 0; i < this.elements.events.length; i++) {
                var div = this.elements.events[i];

/*
                if (typeof calendar.onDomRemoveEvent === "function") {
                    var domArgs = div.domArgs;
                    div.domArgs = null;
                    calendar.onDomRemoveEvent(domArgs);
                }
*/

                (function domRemove() {
                    var domArgs = div.domArgs;
                    div.domArgs = null;

                    // legacy, to be removed
                    if (typeof calendar.onDomRemoveEvent === "function") {
                        calendar.onDomRemoveEvent(domArgs);
                    }
                    if (domArgs && typeof calendar.onBeforeEventDomRemove === "function") {
                        calendar.onBeforeEventDomRemove(domArgs);
                    }

                    if (domArgs && typeof calendar.onBeforeEventDomAdd === "function" && calendar._react.reactDOM) {
                        var target = domArgs && domArgs._targetElement;
                        if (target) {
                            var isReact = DayPilot.Util.isReactComponent(domArgs.element);
                            if (isReact) {
                                if (!calendar._react.reactDOM) {
                                    throw new DayPilot.Exception("Can't reach ReactDOM");
                                }
                                calendar._react._unmount(target);
                            }
                        }
                    }

                })();

                div.event = null;
                div.click = null;
                div.parentNode.removeChild(div);
            }

            this.elements.events = [];

        };

        this._drawEvents = function() {
            this._cache.events = {};  // reset DayPilotMonth.Event object cache

            if (this.cellMode) {
                this._drawEventsCells();
            }
            else {
                this._drawEventsRows();
            }

            this.multiselect.redraw();

        };

        this._drawEventsCells = function() {
            this.elements.events = [];

            if (this.cellEvents.length === 0) {
                return;
            }

            for (var x = 0; x < this._getColCount(); x++) {
                for (var y = 0; y < this.rows.length; y++) {
                    var cell = this.cellEvents[x][y];
                    var div = this.cells[x][y];

                    for (var i = 0; i < cell.events.length; i++) {

                        var ep = cell.events[i];

                        //var eventPart = {};
                        //eventPart.event = cell.events[i];
                        ep.part.colStart = x;
                        ep.part.colWidth = 1;
                        ep.part.row = y;
                        ep.part.line = i;
                        ep.part.startsHere = true;
                        ep.part.endsHere = true;

                        this._drawEvent(ep);

                    }
                }
            }

        };

        this._drawEventsRows = function() {
            this.elements.events = [];

            var max = typeof calendar.maxEvents === "number" ? calendar.maxEvents: 1000;

            // draw events
            for (var ri = 0; ri < this.rows.length; ri++) {
                var row = this.rows[ri];

                for (var li = 0; li < row.lines.length; li++) {
                    var line = row.lines[li];

                    if (li >= max) {
                        continue;
                    }

                    for (var pi = 0; pi < line.length; pi++) {
                        this._drawEvent(line[pi]);
                    }
                }
            }

        };

        this._eventComparer = function(a, b) {
            if (!a || !b || !a.start || !b.start) {
                return 0; // no sorting, invalid arguments
            }

            var byStart = a.start().ticks - b.start().ticks;
            if (byStart !== 0) {
                return byStart;
            }

            var byEnd = b.end().ticks - a.end().ticks; // desc
            return byEnd;
        };

        this._eventComparerCustom = function(a, b) {
            if (!a || !b) {
                //calendar.debug("no sorting, invalid arguments");
                return 0; // no sorting, invalid arguments
            }

            if (!a.data || !b.data || !a.data.sort || !b.data.sort || a.data.sort.length === 0 || b.data.sort.length === 0) { // no custom sorting, using default sorting (start asc, end asc);
                return calendar._eventComparer(a, b);
            }

            var result = 0;
            var i = 0;
            while (result === 0 && typeof a.data.sort[i] !== "undefined" && typeof b.data.sort[i] !== "undefined") {
                if (a.data.sort[i] === b.data.sort[i]) {
                    result = 0;
                }
                else if (typeof a.data.sort[i] === "number" && typeof b.data.sort[i] === "number") {
                    result = a.data.sort[i] - b.data.sort[i];
                }
                else {
                    result = calendar._stringComparer(a.data.sort[i], b.data.sort[i], calendar.sortDirections[i]);
                }
                i++;
            }

            return result;
        };

        this._stringComparer = function(a, b, direction) {
            var asc = (direction !== "desc");
            var aFirst = asc ? -1 : 1;
            var bFirst = -aFirst;

            if (a === null && b === null) {
                return 0;
            }
            // nulls first
            if (b === null) { // b is smaller
                return bFirst;
            }
            if (a === null) {
                return aFirst;
            }

            //return asc ? a.localeCompare(a, b) : -a.localeCompare(a, b);

            var ar = [];
            ar[0] = a;
            ar[1] = b;

            ar.sort();

            return a === ar[0] ? aFirst : bFirst;
        };

        this._drawShadow = function(x, y, line, width, offset, e) {

            if (!offset) {
                offset = 0;
            }


            var disabled = (function checkDisabled() {
                for (var i = 0; i < width; i++) {
                    var pos = x + 7*y + i - offset;
                    if (pos < 0) {
                        continue;
                    }

                    var cx = pos % 7;
                    var cy = Math.floor(pos / 7);

                    var maxRow = calendar.rows.length - 1;
                    if (cy > maxRow) {
                        continue;
                    }

                    var disabled = calendar.cells[cx][cy].props.disabled;
                    if (disabled) {
                        return true;
                    }
                }
            })();

            var remains = width;

            this.shadow = {};
            this.shadow.list = [];
            this.shadow.start = { x: x, y: y };
            this.shadow.width = width;
            this.shadow.disabled = disabled;

            if (this.eventMoveToPosition) {
                remains = 1;
                this.shadow.position = line;
            }

            // something before the first day
            var hidden = y * 7 + x - offset;
            if (hidden < 0) {
                remains += hidden;
                x = 0;
                y = 0;
            }

            var remainingOffset = offset;
            while (remainingOffset >= 7) {
                y--;
                remainingOffset -= 7;
            }
            if (remainingOffset > x) {
                var plus = 7 - this._getColCount();
                if (remainingOffset > (x + plus)) {
                    y--;
                    x = x + 7 - remainingOffset;
                }
                else {
                    remains = remains - remainingOffset + x;
                    x = 0;
                }
            }
            else {
                x -= remainingOffset;
            }

            if (y < 0) {
                y = 0;
                x = 0;
            }

            var cursor = null;
            if (DayPilotMonth.resizingEvent) {
                cursor = 'w-resize';
            }
            else if (DayPilotMonth.movingEvent) {
                cursor = "move";
            }

            this.nav.top.style.cursor = cursor;

            while (remains > 0 && y < this.rows.length) {
                var drawNow = Math.min(this._getColCount() - x, remains);
                var row = this.rows[y];

                /*
                if (!row) {
                return;
                }
                */

                var top = this._getRowTop(y);
                var height = row.getHeight();

                if (this.eventMoveToPosition) {
                    top = this._getEventTop(y, line);
                    height = 2;
                }

                var shadow = document.createElement("div");
                shadow.setAttribute("unselectable", "on");
                shadow.style.position = 'absolute';
                shadow.style.left = (this._getCellWidth() * x) + '%';
                shadow.style.width = (this._getCellWidth() * drawNow) + '%';
                shadow.style.top = (top) + 'px';
                shadow.style.height = (height) + 'px';
                shadow.style.cursor = cursor;

                var inside = document.createElement("div");
                inside.setAttribute("unselectable", "on");
                shadow.appendChild(inside);

                shadow.className = this._prefixCssClass("_shadow");
                inside.className = this._prefixCssClass("_shadow_inner");

                if (disabled) {
                    DayPilot.Util.addClass(shadow, this._prefixCssClass("_shadow_forbidden"));
                }

                var ref = this.nav.events;

                ref.appendChild(shadow);
                this.shadow.list.push(shadow);

                remains -= (drawNow + 7 - this._getColCount());
                x = 0;
                y++;
            }

        };

        this._clearShadow = function() {
            if (this.shadow) {
                var ref = this.nav.events;
                DayPilot.de(this.shadow.list);
                /*
                for (var i = 0; i < this.shadow.list.length; i++) {
                    ref.removeChild(this.shadow.list[i]);
                }*/
                this.shadow = null;
                this.nav.top.style.cursor = '';
            }

        };

        this._getEventTop = function(row, line) {
            //var top = this.headerHeight;
            var top = 0;
            for (var i = 0; i < row; i++) {
                top += this.rows[i].getHeight();
            }
            top += this.cellHeaderHeight; // space on top
            top += line * resolved.lineHeight();
            return top;
        };

        this._getDateFromCell = function(x, y) {
            return this.firstDate.addDays(y * 7 + x);
        };

        this._doBeforeEventRender = function(i) {
            var cache = this._cache.events;
            var data = this.events.list[i];
            var evc = {};

            // make a copy
            for (var name in data) {
                evc[name] = data[name];
            }

            if (typeof this.onBeforeEventRender === 'function') {
                var args = {};
                args.e = evc;
                args.data = evc;
                this.onBeforeEventRender(args);
            }

            cache[i] = evc;

        };

        this._drawEvent = function(ep) { // row, startCol, widthCols, text
            var cellMode = this.cellMode;

            //var ev = ep.data;
            var row = ep.part.row;
            var line = ep.part.line;
            var colStart = ep.part.colStart;
            var colWidth = ep.part.colWidth;

            var cache = ep.cache || ep.data;

            var left = cellMode ? 0 : this._getCellWidth() * (colStart);
            var width = cellMode ? 100 : this._getCellWidth() * (colWidth);
            var top = cellMode ? line * resolved.lineHeight() : this._getEventTop(row, line);

            var div = document.createElement("div");
            div.setAttribute("unselectable", "on");
            div.style.height = resolved.eventHeight() + 'px';

            div.style.position = "relative";
            div.style.overflow = "hidden";
            div.className = this._prefixCssClass("_event");

            if (cache.cssClass) {
                DayPilot.Util.addClass(div, cache.cssClass);
            }

            div.event = ep;

            if (cellMode) {
                div.style.marginRight = "2px";
                div.style.marginBottom = "2px";
                //e.style.position = 'relative';
            }
            else {
                div.style.width = width + '%';
                div.style.position = 'absolute';
                div.style.left = left + '%';
                div.style.top = top + 'px'; // plus space on top
            }

            if (this.showToolTip && cache.toolTip && !this.bubble) {
                div.title = cache.toolTip;
            }

            if (!calendar.eventTextWrappingEnabled) {
                div.style.whiteSpace = "nowrap";
            }

            div.onclick = this._onEventClick;
            div.ondblclick = this._onEventDoubleClick;
            div.oncontextmenu = this._onEventContextMenu;
            div.onmousedown = this._onEventMouseDown;
            div.onmousemove = this._onEventMouseMove;
            div.onmouseout = this._onEventMouseOut;

            DayPilot.reNonPassive(div, "touchstart", touch.onEventTouchStart);
            DayPilot.rePassive(div, "touchmove", touch.onEventTouchMove);
            DayPilot.rePassive(div, "touchend", touch.onEventTouchEnd);

            if (!ep.part.startsHere) {
                DayPilot.Util.addClass(div, this._prefixCssClass("_event_continueleft"));
            }
            if (!ep.part.endsHere) {
                DayPilot.Util.addClass(div, this._prefixCssClass("_event_continueright"));
            }

            var inner = document.createElement("div");
            inner.setAttribute("unselectable", "on");
            inner.className = this._prefixCssClass("_event_inner");
            if (cache.fontColor) {
                inner.style.color = cache.fontColor;
            }
            if (cache.borderColor) {
                if (cache.borderColor === "darker" && cache.backColor) {
                    inner.style.borderColor = DayPilot.ColorUtil.darker(cache.backColor, 2);
                }
                else {
                    inner.style.borderColor = cache.borderColor;
                }
            }

            if (cache.backColor) {
                inner.style.background = cache.backColor;
            }

            if (cache.backImage) {
                inner.style.backgroundImage = "url(" + cache.backImage + ")";
                if (cache.backRepeat) {
                    inner.style.backgroundRepeat = cache.backRepeat;
                }
            }

            div.appendChild(inner);

            if (ep.client.barVisible()) {

                var bar = document.createElement("div");
                bar.setAttribute("unselectable", "on");
                bar.className = this._prefixCssClass("_event_bar");
                bar.style.position = "absolute";

                var barInner = document.createElement("div");
                barInner.setAttribute("unselectable", "on");
                barInner.className = this._prefixCssClass("_event_bar_inner");
                barInner.style.top = "0%";
                barInner.style.height = "100%";

                if (cache.barColor) {
                    barInner.style.backgroundColor = cache.barColor;
                }

                bar.appendChild(barInner);
                div.appendChild(bar);
            }

            var locale = this._resolved.locale();
            var startEndWidth = calendar.eventStartEndWidth;
            if (this.eventStartTime || cache.htmlStart) {
                //var text = DayPilot.DateUtil.hours(ep.start(), resolved.timeFormat() === 'Clock12Hours');
                var left = 5;
                if (calendar.eventBarVisible) {
                    left += 5;
                }
                var text = (calendar._resolved.timeFormat() === 'Clock12Hours') ? ep.start().toString("h tt", locale) : ep.start().toString("H", locale);
                var area = {
                    "left": left,
                    "top":2,
                    "width": startEndWidth,
                    "bottom": 2,
                    "v": "Visible",
                    "html": cache.htmlStart || text,
                    "css": calendar._prefixCssClass("_event_timeleft")
                };
                var a = DayPilot.Areas.createArea(div, ep, area);
                div.appendChild(a);
                inner.style.paddingLeft = startEndWidth + "px";
            }

            if (this.eventEndTime || cache.htmlEnd) {
                //var text = DayPilot.DateUtil.hours(ep.end(), resolved.timeFormat() === 'Clock12Hours');
                var text = (calendar._resolved.timeFormat() === 'Clock12Hours') ? ep.end().toString("h tt", locale) : ep.end().toString("H", locale);
                var area = {
                    "right": 5,
                    "top": 2,
                    "width": startEndWidth,
                    "bottom": 2,
                    "v": "Visible",
                    "html": cache.htmlEnd || text,
                    "css": calendar._prefixCssClass("_event_timeright")
                };
                var a = DayPilot.Areas.createArea(div, ep, area);
                div.appendChild(a);
                inner.style.paddingRight = startEndWidth + "px";
            }

            if (cache.areas) {
                var areas = cache.areas;
                for (var i = 0; i < areas.length; i++) {
                    var area = areas[i];
                    if (!DayPilot.Areas.isVisible(area)) {
                        continue;
                    }
                    var a = DayPilot.Areas.createArea(div, ep, area);
                    div.appendChild(a);
                }
            }

            (function domAdd() {
                var args = {};
                args.e = ep;
                args.control = calendar;
                args.element = null;

                div.domArgs = args;

                // legacy, to be removed
                if (typeof calendar.onDomAddEvent === "function") {
                    calendar.onDomAddEvent(args);
                }

                if (typeof calendar.onBeforeEventDomAdd === "function") {
                    calendar.onBeforeEventDomAdd(args);
                }

                if (args.element) {
                    var target = inner;
                    if (target) {
                        args._targetElement = target;

                        var isReactComponent = DayPilot.Util.isReactComponent(args.element);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }
                else {
                    inner.innerHTML = ep.client.innerHTML();
                }

            })();

            this.elements.events.push(div);

            if (cellMode) {
                this.cells[colStart][row].body.appendChild(div);
            }
            else {
                this.nav.events.appendChild(div);
            }

            if (calendar.multiselect._shouldBeSelected(div.event)) {
                calendar.multiselect.add(div.event, true);
            }

            var div = div;

            if (calendar._api2()) {
                if (typeof calendar.onAfterEventRender === 'function') {
                    var args = {};
                    args.e = div.event;
                    args.div = div;

                    calendar.onAfterEventRender(args);
                }
            }
            else {
                if (calendar.afterEventRender) {
                    calendar.afterEventRender(div.event, div);
                }
            }

            /*
            if (calendar.afterEventRender) {
                calendar.afterEventRender(e.event, e);
            }*/

        };

        this._onEventClick = function(ev) {
            if (touch.start) {
                return;
            }

            calendar._eventClickDispatch(this, ev);
        };

        this._onEventDoubleClick = function(ev) {
            ev.stopPropagation();
            calendar._eventDoubleClickDispatch(this, ev);
        };

        this._onEventMouseMove = function(ev) {
            var e = this;
            var ep = e.event;

            if (typeof (DayPilotMonth) === 'undefined') {
                return;
            }

            if (DayPilotMonth.movingEvent || DayPilotMonth.resizingEvent) {
                return;
            }

            // position
            var offset = DayPilot.mo3(e, ev);
            if (!offset) {
                return;
            }

            (function() {
                var div = e;
                if (!div.active) {
                    //var e = e.event;
                    var areas = [];

                    var data = ep.cache || ep.data;

                    if (calendar.eventDeleteHandling !== "Disabled" && !data.deleteDisabled) {
                        areas.push({"action":"JavaScript","v":"Hover","w":17,"h":17,"top": 2,"right":2, "css": calendar._prefixCssClass("_event_delete"),"js":function(e) { calendar._eventDeleteDispatch(e); } });
                    }

                    var list = div.event.cache ? div.event.cache.areas : div.event.data.areas;
                    if (list && list.length > 0) {
                        areas = areas.concat(list);
                    }
                    DayPilot.Areas.showAreas(div, div.event, null, areas);
                }
            })();

            //DayPilot.Areas.showAreas(e, e.event);

            calendar._findEventDivs(e.event).forEach(function(div) {
                DayPilot.Util.addClass(div, calendar._prefixCssClass("_event_hover"));
            });

            var resizeMargin = 6;

            if (!calendar.cellMode && offset.x <= resizeMargin && ep.client.resizeEnabled()) {
                if (ep.part.startsHere) {
                    e.style.cursor = "w-resize";
                    e.dpBorder = 'left';
                }
                else {
                    e.style.cursor = 'not-allowed';
                }
            }
            else if (!calendar.cellMode && e.clientWidth - offset.x <= resizeMargin && ep.client.resizeEnabled()) {
                if (ep.part.endsHere) {
                    e.style.cursor = "e-resize";
                    e.dpBorder = 'right';
                }
                else {
                    e.style.cursor = 'not-allowed';
                }
            }
            else if (ep.client.clickEnabled()) {
                e.style.cursor = "pointer";
            }
            else {
                e.style.cursor = 'default';
            }

            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble && calendar.eventHoverHandling !== 'Disabled') {
                //if (this.style.cursor == 'default' || this.style.cursor == 'pointer') {
                if (!DayPilotMonth.movingEvent && !DayPilotMonth.resizingEvent) {
                    var notMoved = this._lastOffset && offset.x === this._lastOffset.x && offset.y === this._lastOffset.y;
                    if (!notMoved) {
                        this._lastOffset = offset;
                        calendar.bubble.showEvent(e.event);
                    }
                    //calendar.bubble.showEvent(e.event);
                }
                else {
                    DayPilot.Bubble.hideActive();
                }
            }

        };

        this._onEventMouseOut  = function(ev) {
            var e = this;

            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble) {
                calendar.bubble.hideOnMouseOut();
            }
            e.style.cursor = '';

            calendar._findEventDivs(e.event).forEach(function(div) {
                DayPilot.Util.removeClass(div, calendar._prefixCssClass("_event_hover"));
            });

            DayPilot.Areas.hideAreas(e, ev);

        };

        this._onEventContextMenu  = function() {
            var e = this;
            calendar._eventRightClickDispatch(e.event);
            return false;
        };

        this._onEventMouseDown = function(ev) {
            if (touch.start) {
                return;
            }

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
                DayPilot.Bubble.cancelShowing();
            }

            var e = this;
            var ep = e.event;
            var row = ep.part.row;
            var colStart = ep.part.colStart;
            var line = ep.part.line;
            var colWidth = ep.part.colWidth;

            ev = ev || window.event;
            var button = DayPilot.Util.mouseButton(ev);

            ev.cancelBubble = true;
            if (ev.stopPropagation) {
                ev.stopPropagation();
            }

            if (button.left) {
                if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble) {
                    DayPilot.Bubble.hideActive();
                }

                DayPilotMonth.movingEvent = null;
                if (this.style.cursor === 'w-resize' || this.style.cursor === 'e-resize') {
                    var resizing = {};
                    resizing.start = {};
                    resizing.start.x = colStart;
                    resizing.start.y = row;
                    resizing.event = e.event;
                    resizing.width = DayPilot.DateUtil.daysSpan(resizing.event.start(), resizing.event.end()) + 1;
                    resizing.direction = this.style.cursor;
                    DayPilotMonth.resizingEvent = resizing;
                }
                else if (this.style.cursor === 'move' || ep.client.moveEnabled()) {
                    calendar._clearShadow();

                    var coords = DayPilot.mo3(calendar.nav.events, ev);
                    if (!coords) {
                        return;
                    }

                    //coords.y -= this.parentNode.parentNode.scrollTop;

                    var cell = calendar._getCellBelowPoint(coords.x, coords.y);
                    if (!cell) {
                        return;
                    }

                    var hidden = DayPilot.DateUtil.daysDiff(ep.start(), calendar.rows[row].start);
                    var offset = (cell.y * 7 + cell.x) - (row * 7 + colStart);
                    if (hidden) {
                        offset += hidden;
                    }

                    var moving = {};
                    moving.start = {};
                    moving.start.x = colStart;
                    moving.start.y = row;
                    moving.start.line = line;
                    moving.offset = calendar.eventMoveToPosition ? 0 : offset;
                    moving.colWidth = colWidth;
                    moving.event = e.event;
                    moving.coords = coords;
                    DayPilotMonth.movingEvent = moving;
                }
            }
        };

        this.temp = {};
        this.temp.getPosition = function() {
            if (!calendar.coords) {
                return null;
            }
            var cell = calendar._getCellBelowPoint(calendar.coords.x, calendar.coords.y);
            if (!cell) {
                return null;
            }

            var d = new DayPilot.Date(calendar._getDateFromCell(cell.x, cell.y));
            var cell = {};
            cell.start = d;
            cell.end = d.addDays(1);
            return cell;
        };

        this._touch = {};
        var touch = calendar._touch;

        touch.active = false;
        touch.start = false;

        touch.timeouts = [];

        touch.onEventTouchStart = function(ev) {
            // iOS
            if (touch.active || touch.start) {
                return;
            }

            touch.clearTimeouts();

            touch.start = true;
            touch.active = false;

            var div = this;

            var e = div.event;

            if (e.client.moveEnabled()) {
                var holdfor = calendar.tapAndHoldTimeout;
                touch.timeouts.push(window.setTimeout(function() {
                    touch.active = true;
                    touch.start = false;

                    var coords = touch.relativeCoords(ev);
                    touch.startMoving(div, coords);

                    ev.preventDefault();

                }, holdfor));
            }

            // prevent onMainTouchStart
            ev.stopPropagation();

        };

        touch.onEventTouchMove = function(ev) {
            touch.clearTimeouts();
            touch.start = false;
        };

        touch.onEventTouchEnd = function(ev) {
            touch.clearTimeouts();

            // quick tap
            if (touch.start) {
                calendar._eventClickSingle(this, ev);
            }

            window.setTimeout(function() {
                touch.start = false;
                touch.active = false;
            }, 500);
        };

        touch.onMainTouchStart = function(ev) {
            // prevent after-alert firing on iOS
            if (touch.active || touch.start) {
                return;
            }

            touch.clearTimeouts();

            touch.start = true;
            touch.active = false;

            var holdfor = calendar.tapAndHoldTimeout;
            touch.timeouts.push( window.setTimeout(function() {
                touch.active = true;
                touch.start = false;

                ev.preventDefault();

                var coords = touch.relativeCoords(ev);
                touch.startRange(coords);
            }, holdfor));

        };

        touch.onMainTouchMove = function(ev) {
            touch.clearTimeouts();

            touch.start = false;

            if (touch.active) {
                ev.preventDefault();

                var coords = touch.relativeCoords(ev);

                if (touch.moving) {
                    //ev.preventDefault();
                    touch.updateMoving(coords);
                    return;
                }

                if (touch.range) {
                    touch.updateRange(coords);
                }
            }
        };

        touch.onMainTouchEnd = function(ev) {
            touch.clearTimeouts();

            if (touch.active) {
                if (touch.moving) {
                    //alert("touchend, moving");
                    var src = touch.moving;

                    // load ref
                    //var calendar = DayPilotMonth.movingEvent.event.calendar;
                    var e = touch.moving.event;
                    var start = calendar.shadow.start;
                    var position = calendar.shadow.position;
                    var offset = touch.moving.offset;

                    // cleanup
                    calendar._clearShadow();
                    touch.moving = null;

                    // fire the event
                    calendar._eventMoveDispatch(e, start.x, start.y, offset, ev, position);

                }

                if (touch.range) {
                    var sel = touch.range;
                    //var calendar = sel.root;

                    var start = new DayPilot.Date(calendar._getDateFromCell(sel.from.x, sel.from.y));
                    var end = start.addDays(sel.width);
                    touch.range = null;
                    calendar._timeRangeSelectedDispatch(start, end);
                }
            }

            window.setTimeout(function() {
                touch.start = false;
                touch.active = false;
            }, 500);

        };

        touch.clearTimeouts = function() {
            for (var i = 0; i < touch.timeouts.length; i++) {
                clearTimeout(touch.timeouts[i]);
            }
            touch.timeouts = [];
        };

        touch.relativeCoords = function(ev) {
            var ref = calendar.nav.events;

            var t = ev.touches ? ev.touches[0] : ev;

            var x = t.pageX;
            var y = t.pageY;
            // var coords  = { x: x, y: y};

            var abs = DayPilot.abs(ref);
            var coords = {x: x - abs.x, y: y - abs.y, toString: function() { return "x: " + this.x + ", y:" + this.y; } };
            return coords;
        };


        touch.startMoving = function(div, coords) {
            calendar._clearShadow();

            var ep = div.event;

            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            if (!cell) {
                return;
            }

            var hidden = DayPilot.DateUtil.daysDiff(ep.start(), calendar.rows[ep.part.row].start);
            var offset = (cell.y * 7 + cell.x) - (ep.part.row * 7 + ep.part.colStart);
            if (hidden) {
                offset += hidden;
            }

            var moving = {};
            moving.start = {};
            moving.start.x = ep.part.colStart;
            moving.start.y = ep.part.row;
            moving.start.line = ep.part.line;
            moving.offset = calendar.eventMoveToPosition ? 0 : offset;
            moving.colWidth = ep.part.colWidth;
            moving.event = ep;
            moving.coords = coords;
            touch.moving = moving;

            touch.updateMoving(coords);
        };

        touch.updateMoving = function(coords) {
            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            if (!cell) {
                return;
            }

            var linepos = calendar._linePos(cell);

            calendar._clearShadow();

            var event = touch.moving.event;
            var offset = touch.moving.offset;
            var width = calendar.cellMode ? 1 : DayPilot.DateUtil.daysSpan(event.start(), event.end()) + 1;

            if (width < 1) {
                width = 1;
            }
            calendar._drawShadow(cell.x, cell.y, linepos, width, offset, event);

        };

        touch.startRange = function(coords) {
            //touch.range = { "root": calendar, "x": x, "y": y, "from": { x: x, y: y }, "width": 1 };

            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            if (!cell) {
                return;
            }

            calendar._clearShadow();

            var range = {};
            range.start = {};
            range.start.x = cell.x;
            range.start.y = cell.y;
            range.x = cell.x; // not necessary
            range.y = cell.y; // not necessary
            range.width = 1;

            touch.range = range;
            touch.updateRange(coords);

        };

        touch.updateRange = function(coords) {
            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            if (!cell) {
                return;
            }

            calendar._clearShadow();

            var start = touch.range.start;
            var startIndex = start.y * 7 + start.x;
            var cellIndex = cell.y * 7 + cell.x;

            var width = Math.abs(cellIndex - startIndex) + 1;

            if (width < 1) {
                width = 1;
            }

            var shadowStart = startIndex < cellIndex ? start : cell;

            touch.range.width = width;
            touch.range.from = { x: shadowStart.x, y: shadowStart.y };

            calendar._drawShadow(shadowStart.x, shadowStart.y, 0, width, 0, null);

        };

        // overridable
        this.isWeekend = function(date) {
            var sunday = 0;
            var saturday = 6;

            if (date.dayOfWeek() === sunday) {
                return true;
            }
            if (date.dayOfWeek() === saturday) {
                return true;
            }
            return false;
        };

        // returns DayPilot.Date object
        this._lastVisibleDayOfMonth = function() {
            var last = this.startDate.lastDayOfMonth();

            if (this.showWeekend) {
                return last;
            }

            while (this.isWeekend(last)) {
                last = last.addDays(-1);
            }
            return last;
        };

        this._prepareRows = function() {

            if (typeof this.startDate === 'string') {
                this.startDate = new DayPilot.Date(this.startDate);
            }
            if (this.viewType === 'Month') {
                this.startDate = this.startDate.firstDayOfMonth();
            }
            else {
                this.startDate = this.startDate.getDatePart();
            }


            this.firstDate = this.startDate.firstDayOfWeek(resolved.weekStarts());
            if (!this.showWeekend) {
                var previousMonth = this.startDate.addMonths(-1).getMonth();

                var lastBeforeWeekend = new DayPilot.Date(this.firstDate).addDays(6);
                while (this.isWeekend(lastBeforeWeekend)) {
                    lastBeforeWeekend = lastBeforeWeekend.addDays(-1);
                }

                if (lastBeforeWeekend.getMonth() === previousMonth) {
                    this.firstDate = this.firstDate.addDays(7);
                }
            }

            var firstDayOfMonth = this.startDate;

            var rowCount;

            if (this.viewType === 'Month') {
                var lastVisibleDayOfMonth = this._lastVisibleDayOfMonth();
                var count = DayPilot.DateUtil.daysDiff(this.firstDate, lastVisibleDayOfMonth) + 1;
                rowCount = Math.ceil(count / 7);
            }
            else {
                rowCount = this.weeks;
            }

            this.days = rowCount * 7;

            this.rows = [];
            for (var x = 0; x < rowCount; x++) {
                var r = {};
                r.start = this.firstDate.addDays(x * 7);  // start point
                r.end = r.start.addDays(this._getColCount()); // end point
                r.events = []; // collection of events
                r.lines = []; // collection of lines
                r.index = x; // row index
                r.minHeight = this.cellHeight; // default, can be extended during events loading
                r.calendar = this;

           /*     r.belongsHere = function(ev) {
                    if (ev.end().getTime() === ev.start().getTime() && ev.start().getTime() === this.start.getTime()) {
                        return true;
                    }
                    return !(ev.end().getTime() <= this.start.getTime() || ev.start().getTime() >= this.end.getTime());
                };*/

                r.belongsHere = function(start, end) {
                    if (end.getTime() === start.getTime() && start.getTime() === this.start.getTime()) {
                        return true;
                    }
                    return !(end.getTime() <= this.start.getTime() || start.getTime() >= this.end.getTime());
                };

                r.getPartStart = function(ep) {
                    return DayPilot.DateUtil.max(this.start, ep.start());
                };

                r.getPartEnd = function(ep) {
                    return DayPilot.DateUtil.min(this.end, ep.rawend());
                };

                r.getStartColumn = function(ep) {
                    var partStart = this.getPartStart(ep);
                    return DayPilot.DateUtil.daysDiff(this.start, partStart);
                };

                r.getWidth = function(ep) {
                    return DayPilot.DateUtil.daysSpan(this.getPartStart(ep), this.getPartEnd(ep)) + 1;
                };

                r.putIntoLine = function(ep, colStart, colWidth, row) {
                    var thisRow = this;

                    for (var i = 0; i < this.lines.length; i++) {
                        var line = this.lines[i];
                        if (line.isFree(colStart, colWidth)) {
                            line.addEvent(ep, colStart, colWidth, row, i);
                            return i;
                        }
                    }

                    var line = [];
                    line.isFree = function(colStart, colWidth) {
                        var free = true;

                        for (var i = 0; i < this.length; i++) {
                            var ep = this[i];
                            if (!(colStart + colWidth - 1 < ep.part.colStart || colStart > ep.part.colStart + ep.part.colWidth - 1)) {
                                free = false;
                            }
                        }

                        return free;
                    };

                    line.addEvent = function(ep, colStart, colWidth, row, index) {
                        //var eventPart = {};
                        //eventPart.event = ev;
                        ep.part.colStart = colStart;
                        ep.part.colWidth = colWidth;
                        ep.part.row = row;
                        ep.part.line = index;
                        ep.part.startsHere = thisRow.start.getTime() <= ep.start().getTime();
                        //if (confirm('r.start: ' + thisRow.start + ' ev.Start: ' + ev.Start)) thisRow = null;
                        ep.part.endsHere = thisRow.end.getTime() >= ep.end().getTime();

                        this.push(ep);
                    };

                    line.addEvent(ep, colStart, colWidth, row, this.lines.length);

                    this.lines.push(line);

                    return this.lines.length - 1;
                };

                r.getStart = function() {
                    var start = 0;
                    for (var i = 0; i < calendar.rows.length && i < this.index; i++) {
                        start += calendar.rows[i].getHeight();
                    }
                };

                r.getHeight = function() {
                    var max = typeof calendar.maxEvents === "number" ? calendar.maxEvents : 1000;
                    var lines = Math.min(max, this.lines.length);
                    return Math.max(lines * resolved.lineHeight() + calendar.cellHeaderHeight + calendar.cellMarginBottom, this.calendar.cellHeight);
                };

                this.rows.push(r);
            }

            this._endDate = this.firstDate.addDays(rowCount * 7);
        };

        this._getHeight = function() {
            switch (this.heightSpec) {
                case "Auto":
                    var height = resolved.headerHeight();
                    for (var i = 0; i < this.rows.length; i++) {
                        height += this.rows[i].getHeight();
                    }
                    return height;
                case "Fixed":
                    return this.height;
            }
        };

        this._getWidth = function(start, end) {
            var diff = (end.y * 7 + end.x) - (start.y * 7 + start.x);
            return diff + 1;
        };

/*
        this._getMinCoords = function(first, second) {
            if ((first.y * 7 + first.x) < (second.y * 7 + second.x)) {
                return first;
            }
            else {
                return second;
            }
        };
*/

        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function() {
            if (calendar._angular.scope) {
                calendar._angular.scope["$apply"]();
            }
        };

        this.debug = new DayPilot.Debug(this);

        this._drawTop = function() {
            var relative = this.nav.top;
            this.nav.top.dp = this;
            //this.nav.top = relative;
            relative.setAttribute("unselectable", "on");
            relative.style.MozUserSelect = 'none';
            relative.style.KhtmlUserSelect = 'none';
            relative.style.WebkitUserSelect = 'none';

            relative.style.WebkitTapHighlightColor = "rgba(0,0,0,0)";
            relative.style.WebkitTouchCallout = "none";

            relative.style.position = 'relative';
            if (this.width) {
                relative.style.width = this.width;
            }
            // not setting height now, will be set using _updateHeight() later
            //relative.style.height = this._getHeight() + 'px';
            relative.onselectstart = function(e) { return false; }; // prevent text cursor in Chrome during drag&drop
            relative.className = this._prefixCssClass("_main");

            if (this.hideUntilInit) {
                relative.style.visibility = 'hidden';
            }

            if (!this.visible) {
                relative.style.display = "none";
            }

            relative.onmousemove = this._onMainMouseMove;

            DayPilot.reNonPassive(relative, "touchstart", touch.onMainTouchStart);
            DayPilot.reNonPassive(relative, "touchmove", touch.onMainTouchMove);
            DayPilot.rePassive(relative, "touchend", touch.onMainTouchEnd);


            this._vsph = document.createElement("div");
            this._vsph.style.display = 'none';

            this.nav.top.appendChild(this._vsph);

            var table = document.createElement("div");
            //table.setAttribute("data-id", "header");
            table.style.position = "relative";
            table.style.height = resolved.headerHeight() + "px";
            //table.style.marginRight = "20px";
            table.oncontextmenu = function() { return false; };
            this.nav.top.appendChild(table);
            this.nav.header = table;

            var scrollable = document.createElement("div");
            scrollable.style.zoom = "1";  // ie7, makes DayPilot.sw working

            var cells = document.createElement("div");
            cells.style.position = "relative";
            cells.ondblclick = calendar._onCellDoubleClick;
            scrollable.appendChild(cells);

            this.nav.loading = document.createElement("div");
            this.nav.loading.style.position = 'absolute';
            this.nav.loading.style.top = '0px';
            this.nav.loading.style.left = (5) + "px";
            this.nav.loading.className = calendar._prefixCssClass("_loading");
            this.nav.loading.innerHTML = calendar._xssTextHtml(this.loadingLabelText, this.loadingLabelHtml);
            this.nav.loading.style.display = 'none';

            this.nav.top.appendChild(scrollable);
            this.nav.top.appendChild(this.nav.loading);

            this.nav.scrollable = scrollable;
            this.nav.events = cells;

        };

        this._onMainMouseMove = function(ev) {

            ev.insideMainD = true;
            if (window.event && window.event.srcElement) {
                window.event.srcElement.inside = true;
            }

            calendar.coords = DayPilot.mo3(calendar.nav.events, ev);
            var coords = calendar.coords;
            if (!coords) {
                return;
            }

            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            if (!cell) {
                return;
            }

            if (DayPilotMonth.resizingEvent) {
                calendar._clearShadow();
                var resizing = DayPilotMonth.resizingEvent;

                var original = resizing.start;
                var width, start;

                if (resizing.direction === 'w-resize') {
                    start = cell;

                    var endDate = resizing.event.rawend();
                    if (endDate.getDatePart().getTime() === endDate.getTime()) {
                        endDate = endDate.addDays(-1);
                    }

                    var end = calendar._getCellFromDate(endDate);
                    width = calendar._getWidth(cell, end);
                }
                else {
                    start = calendar._getCellFromDate(resizing.event.start());
                    width = calendar._getWidth(start, cell);
                }

                if (width < 1) {
                    width = 1;
                }

                calendar._drawShadow(start.x, start.y, 0, width);

            }
            else if (DayPilotMonth.movingEvent) {

                // calendar.debug.message("mousemove/moving start coords: " + DayPilotMonth.movingEvent.coords.x + " " + DayPilotMonth.movingEvent.coords.y);
                // calendar.debug.message("mousemove/current coords: " + coords.x + " " + coords.y);

                // not actually moved, Chrome bug
                if (coords.x === DayPilotMonth.movingEvent.coords.x && coords.y === DayPilotMonth.movingEvent.coords.y) {
                    return;
                }

                var linepos = calendar._linePos(cell);

                calendar._clearShadow();

                var event = DayPilotMonth.movingEvent.event;
                var offset = DayPilotMonth.movingEvent.offset;
                var width = calendar.cellMode ? 1 : DayPilot.DateUtil.daysSpan(event.start(), event.rawend()) + 1;

                if (width < 1) {
                    width = 1;
                }
                calendar._drawShadow(cell.x, cell.y, linepos, width, offset, event);
            }
            else if (DayPilotMonth.timeRangeSelecting) {
                DayPilotMonth.cancelCellClick = true;

                calendar._clearShadow();

                var start = DayPilotMonth.timeRangeSelecting;

                var startIndex = start.y * 7 + start.x;
                var cellIndex = cell.y * 7 + cell.x;

                var width = Math.abs(cellIndex - startIndex) + 1;

                if (width < 1) {
                    width = 1;
                }

                var shadowStart = startIndex < cellIndex ? start : cell;

                DayPilotMonth.timeRangeSelecting.from = { x: shadowStart.x, y: shadowStart.y };
                DayPilotMonth.timeRangeSelecting.width = width;
                DayPilotMonth.timeRangeSelecting.moved = true;

                calendar._drawShadow(shadowStart.x, shadowStart.y, 0, width, 0, null);

            }

            if (DayPilotMonth.drag) {

                // drag detected
                if (DayPilotMonth.gShadow) {
                    document.body.removeChild(DayPilotMonth.gShadow);
                }
                DayPilotMonth.gShadow = null;

                if (!DayPilotMonth.movingEvent) {

                    var now = DayPilot.Date.today();

                    var ev = {
                        'id': DayPilotMonth.drag.id,
                        'start': now,
                        'end': now.addSeconds(DayPilotMonth.drag.duration),
                        'text': DayPilotMonth.drag.text
                    };

                    var data = DayPilotMonth.drag.data;
                    if (data) {
                        var skip = ['duration', 'element', 'remove', 'id', 'text'];
                        for (var name in data) {
                            if (DayPilot.contains(skip, name)) {
                                continue;
                            }
                            ev[name] = data[name];
                        }
                    }

                    var event = new DayPilot.Event(ev, calendar);
                    //event.calendar = calendar;
                    //event.root = calendar;
                    event.external = true;

                    var me = DayPilotMonth.movingEvent = {};
                    me.event = event;
                    me.coords = coords;
                    me.position = 0;
                    me.offset = 0;
                    me.external = true;
                    me.removeElement = DayPilotMonth.drag.element;

                }

                ev.cancelBubble = true;
            }

        };

        // cell is result of _getCellBelowPoint
        this._linePos = function(cell) {
            var y = cell.relativeY;
            var row = calendar.rows[cell.y];
            //var linesCount = row.lines.length;
            var top = calendar.cellHeaderHeight;
            var lh = resolved.lineHeight();
            var max = row.lines.length;

            for (var i = 0; i < row.lines.length; i++) {
                var line = row.lines[i];
                if (line.isFree(cell.x, 1)) {
                    max = i;
                    break;
                }
            }

            var pos = Math.floor((y - top + lh / 2) / lh);  // rounded position
            var pos = Math.min(max, pos);  // no more than max
            var pos = Math.max(0, pos);  // no less then 0

            return pos;
        };

        this.message = function(text, opt) {
            if (text === null) {
                return;
            }

            if (!calendar._initialized) {
                return;
            }

            var options = {};
            var delay;
            if (typeof arguments[1] === "object") {
                options = arguments[1];
                delay = options.delay;
            }
            else {
                delay = opt;
            }

            var html = "";
            if (options.rawHtml) {
                html = text;
            }
            else {
                html = DayPilot.Util.escapeHtml(text);
            }

            delay = delay || this.messageHideAfter || 2000;

            // var opacity = 0.8;

            var top = resolved.headerHeight();

            var div;

            if (!this.nav.message) {
                div = document.createElement("div");
                div.setAttribute("unselectable", "on");
                div.style.position = "absolute";
                div.style.right = "0px";
                div.style.left = "0px";
                div.style.top = top + "px";
                div.style.display = 'none';

                div.onmousemove = function() {
                    if (div.messageTimeout && !div.status) {
                        clearTimeout(div.messageTimeout);
                    }
                };

                div.onmouseout = function() {
                    if (calendar.nav.message.style.display !== 'none') {
                        div.messageTimeout = setTimeout(calendar._hideMessage, 500);
                    }
                };

                var inner = document.createElement("div");
                inner.setAttribute("unselectable", "on");
                inner.onclick = function() {
                    calendar.nav.message.style.display = 'none';
                };
                inner.className = this._prefixCssClass("_message");
                div.appendChild(inner);

                var close = document.createElement("div");
                close.setAttribute("unselectable", "on");
                close.style.position = "absolute";
                close.className = this._prefixCssClass("_message_close");
                close.onclick = function() { calendar.nav.message.style.display = 'none'; };
                div.appendChild(close);

                this.nav.top.appendChild(div);
                this.nav.message = div;

            }
            else {
                div = calendar.nav.message;
            }

            var showNow = function() {
                // calendar.nav.message.style.opacity = opacity;

                if (!calendar.nav.message) {  // UpdatePanel refresh
                    return;
                }

                var inner = calendar.nav.message.firstChild;
                inner.className = calendar._prefixCssClass("_message"); // clear any custom css that may have been set

                if (options.cssClass) {
                    DayPilot.Util.addClass(inner, options.cssClass);
                }

                inner.innerHTML = html;

                var end = function() { div.messageTimeout = setTimeout(calendar._hideMessage, delay); };
                DayPilot.fade(calendar.nav.message, 0.2, end);
            };

            // make sure not timeout is active
            clearTimeout(div.messageTimeout);

            // another message was visible
            if (this.nav.message.style.display !== 'none') {
                DayPilot.fade(calendar.nav.message, -0.2, showNow);
            }
            else {
                showNow();
            }

        };

        this.message.show = function(html) {
            calendar.message(html);
        };

        this.message.hide = function() {
            calendar._hideMessage();
        };

        this._hideMessage = function() {
            var end = function() { calendar.nav.message.style.display = 'none'; };
            DayPilot.fade(calendar.nav.message, -0.2, end);
        };

        this._onResize = function(ev) {
            if (calendar.heightSpec === "Parent100Pct") {
                calendar._updateHeight();
            }
        };

        this._updateHeight = function() {
            var scrollable = this.nav.scrollable;
            if (this.heightSpec === "Parent100Pct" || this.heightSpec === 'Fixed') {
                //cells.style.height = (this._getHeight() - this.headerHeight) + "px";
                scrollable.style.top = this.headerHeight + "px";
                scrollable.style.bottom = "0px";
                scrollable.style.left = "0px";
                scrollable.style.right = "0px";
                scrollable.style.overflow = "auto";
                scrollable.style.position = "absolute";
            }
            else {
                scrollable.style.position = "relative";
            }

            if (this.heightSpec === 'Parent100Pct') {
                this.nav.top.style.height = "100%";
                var height = this.nav.top.clientHeight;
                //this.nav.scrollable.style.height = (height - resolved.headerHeight()) + "px";
            }
            else {
                this.nav.top.style.height = this._getHeight() + 'px';
            }

            for (var x = 0; x < this.cells.length; x++) {
                for (var y = 0; y < this.cells[x].length; y++) {
                //for (var y = 0; y < this.rows.length; y++) {
                    this.cells[x][y].style.top = this._getRowTop(y) + 'px';
                    this.cells[x][y].style.height = this.rows[y].getHeight() + 'px';
                }
            }

            this._updateScrollbarWidth();
        };

        // x, y are relative
        this._getCellBelowPoint = function(x, y) {
            x = Math.max(0, x);
            var columnWidth = Math.floor(this.nav.top.clientWidth / this._getColCount());
            var column = Math.min(Math.floor(x / columnWidth), this._getColCount() - 1);

            var row = null;

            //var height = resolved.headerHeight();
            var relativeY = 0;

            /*
            if (y < height) {
                return null;
            }

            var baseHeight = height; // coords are alway relative to nav.events
            */
           var height = 0;
           var baseHeight = 0;

            for (var i = 0; i < this.rows.length; i++) {
                height += this.rows[i].getHeight();
                if (y < height) {
                    relativeY = y - baseHeight;
                    row = i;
                    break;
                }
                baseHeight = height;
            }

            if (row === null) {
                row = this.rows.length - 1; // might be a pixel below the last line
            }

            var cell = {};
            cell.x = column;
            cell.y = row;
            cell.relativeY = relativeY;

            return cell;
        };

        this._getCellFromDate = function(date) {
            var width = DayPilot.DateUtil.daysDiff(this.firstDate, date);
            var cell = { x: 0, y: 0 };
            while (width >= 7) {
                cell.y++;
                width -= 7;
            }
            cell.x = width;
            return cell;
        };

        this._updateScrollbarWidth = function() {
            var width = DayPilot.sw(this.nav.scrollable);
            this.nav.header.style.marginRight = width + "px";
        };

        var child = null;

        this._drawTable = function() {

/*
            if (this.heightSpec === 'Parent100Pct') {
                this.nav.top.style.height = "100%";
            }
*/
            var table = this.nav.header;
            var cells = this.nav.events;
            var colCount = calendar._getColCount();

            this.cells = [];

            for (var x = 0; x < colCount; x++) {
                var isLastX = x === colCount - 1;

                this.cells[x] = [];
                var headerProperties = this.headerProperties ? this.headerProperties[x] : null;

                var dayIndex = x + resolved.weekStarts();
                if (dayIndex > 6) {
                    dayIndex -= 7;
                }

                if (!headerProperties) {
                    var headerProperties = {};
                    headerProperties.html = resolved.locale().dayNames[dayIndex];
                }

                if (typeof calendar.onBeforeHeaderRender === 'function') {
                    var args = {};
                    args.header = {};
                    args.header.dayOfWeek = dayIndex;
                    //args.header.html = html;

                    var proplist = ['html', 'backColor', 'cssClass'];
                    DayPilot.Util.copyProps(headerProperties, args.header, proplist);
                    calendar.onBeforeHeaderRender(args);
                    DayPilot.Util.copyProps(args.header, headerProperties, proplist);
                }

                var header = document.createElement("div");
                header.setAttribute("unselectable", "on");
                header.style.position = 'absolute';

                header.style.left = (this._getCellWidth() * x) + '%';
                if (isLastX) {
                    header.style.right = "0px";
                }
                else {
                    header.style.width = (this._getCellWidth()) + '%';
                }

                header.style.top = '0px';
                header.style.height = (resolved.headerHeight()) + 'px';

                (function(x) {
                    header.onclick = function() { calendar._headerClickDispatch(x); };
                })(dayIndex);

                var inner = document.createElement("div");
                inner.setAttribute("unselectable", "on");
                inner.className = this._prefixCssClass("_header_inner");
                inner.innerHTML = headerProperties.html;

                header.appendChild(inner);

                header.className = this._prefixCssClass("_header");
                if (headerProperties) {
                    if (headerProperties.cssClass) {
                        DayPilot.Util.addClass(header, headerProperties.cssClass);
                    }
                    if (headerProperties.backColor) {
                        inner.style.background = headerProperties.backColor;
                    }
                }

                table.appendChild(header);

                for (var y = 0; y < this.rows.length; y++) {
                    this._drawCell(x, y, cells);
                }

            }

            if (!DayPilot.contains(this.nav.top.childNodes, child) && DayPilot.Util.isNullOrUndefined("K5woOes")) {
                var div = document.createElement("div");
                div.style.position = 'absolute';
                div.style.padding = '2px';
                div.style.top = '0px';
                div.style.left = '0px';
                div.style.backgroundColor = "#FF6600";
                div.style.color = "white";
                div.innerHTML = "\u0044\u0045\u004D\u004F";
                child = div;
                this.nav.top.appendChild(div);
            }

            //this._updateScrollbarWidth();

        };

        this._clearTable = function() {

            // clear event handlers
            for (var x = 0; x < this.cells.length; x++) {
                for (var y = 0; y < this.cells[x].length; y++) {
                    this.cells[x][y].onclick = null;

                    (function domRemove() {
                        var div = calendar.cells[x][y];
                        var domArgs = div.domArgs;
                        div.domArgs = null;

                        if (domArgs && typeof calendar.onBeforeCellDomRemove === "function") {
                            calendar.onBeforeCellDomRemove(domArgs);
                        }

                        if (domArgs && typeof calendar.onBeforeCellDomAdd === "function" && calendar._react.reactDOM) {
                            var target = domArgs && domArgs._targetElement;
                            if (target) {
                                var isReact = DayPilot.Util.isReactComponent(domArgs.element);
                                if (isReact) {
                                    if (!calendar._react.reactDOM) {
                                        throw new DayPilot.Exception("Can't reach ReactDOM");
                                    }
                                    calendar._react._unmount(target);
                                }
                            }
                        }

                    })();

                }
            }

            this.nav.header.innerHTML = '';
            //this.nav.scrollable.innerHTML = '';
            this.nav.events.innerHTML = '';

        };

        this._drawCell = function(x, y, table) {

            var row = this.rows[y];
            var d = this.firstDate.addDays(y * 7 + x);
            var cellProperties = this.cellProperties ? this.cellProperties[y * this._getColCount() + x] : null;
            var colCount = calendar._getColCount();
            var isLastX = x === colCount - 1;

            var headerHtml = null;
            if (cellProperties) {
                headerHtml = cellProperties["headerHtml"];
            }
            else {
                var date = d.getDay();
                if (date === 1) {
                    headerHtml = resolved.locale().monthNames[d.getMonth()] + ' ' + date;
                }
                else {
                    headerHtml = date + "";
                }
            }

            if (!cellProperties) {
                var cellProperties = {};
                cellProperties.business = !calendar.isWeekend(d);
                cellProperties.headerHtml = headerHtml;
                cellProperties.disabled = false;

                cellProperties.backColor = null;
                cellProperties.backImage = null;
                cellProperties.backRepeat = null;
                cellProperties.areas = null;
                cellProperties.headerBackColor = null;
                cellProperties.cssClass = null;
                cellProperties.html = null;
            }

            if (typeof calendar.onBeforeCellRender === 'function') {

                var args = {};
                args.cell = {};
                args.cell.start = d;
                args.cell.end = args.cell.start.addDays(1);

                args.cell.properties = cellProperties;

                args.cell.events = function() {
                    return calendar.events.forRange(args.cell.start, args.cell.end);
                };

                calendar.onBeforeCellRender(args);
                DayPilot.Util.copyProps(args.cell, cellProperties, ['areas', 'backColor', 'backImage', 'backRepeat', 'business', 'disabled', 'headerHtml', 'headerBackColor', 'cssClass', 'html']);
            }

            var left = this._getCellWidth() * x;
            var width = this._getCellWidth();

            var cell = document.createElement("div");
            cell.setAttribute("unselectable", "on");
            cell.style.position = 'absolute';
            cell.style.cursor = 'default';
            cell.style.left = (left) + '%';
            if (!isLastX) {
                cell.style.width = (width) + '%';
            }
            else {
                cell.style.right = "0px";
            }

            cell.style.top = (this._getRowTop(y)) + 'px';
            cell.style.height = (row.getHeight()) + 'px';

            // TODO wrap in an object
            cell.d = d;
            cell.x = x;
            cell.y = y;
            cell.props = cellProperties;

            var previousMonth = this.startDate.addMonths(-1).getMonth();
            var nextMonth = this.startDate.addMonths(1).getMonth();

            var thisMonth = this.startDate.getMonth();

            var inner = document.createElement("div");
            inner.setAttribute("unselectable", "on");
            cell.appendChild(inner);
            inner.className = this._prefixCssClass("_cell_inner");

            inner.className = this._prefixCssClass("_cell_inner");
            if (d.getMonth() === thisMonth) {
                cell.className = this._prefixCssClass("_cell");
            }
            else if (d.getMonth() === previousMonth) {
                cell.className = this._prefixCssClass("_cell") + " " + this._prefixCssClass("_previous");
            }
            else if (d.getMonth() === nextMonth) {
                cell.className = this._prefixCssClass("_cell") + " " + this._prefixCssClass("_next");
            }
            else {
                doNothing();
            }

            if (cellProperties) {
                if (cellProperties["cssClass"]) {
                    DayPilot.Util.addClass(cell, cellProperties.cssClass);
                }

                if (cellProperties["business"]) {
                    DayPilot.Util.addClass(cell, this._prefixCssClass("_cell_business"));
                }

                if (cellProperties["backColor"]) {
                    inner.style.backgroundColor = cellProperties["backColor"];
                }

                if (cellProperties["backImage"]) {
                    inner.style.backgroundImage = "url('" + cellProperties["backImage"] + "')";
                }
                if (cellProperties["backRepeat"]) {
                    inner.style.backgroundRepeat = cellProperties["backRepeat"];
                }
            }

            cell.onmousedown = this._onCellMouseDown;
            cell.onmousemove = this._onCellMouseMove;
            cell.onmouseout = this._onCellMouseOut;
            cell.oncontextmenu = this._onCellContextMenu;
            cell.onclick = this._onCellClick;
            cell.ondblclick = this._onCellDoubleClick;

            var day = document.createElement("div");
            day.setAttribute("unselectable", "on");
            day.style.height = this.cellHeaderHeight + "px";

            if (cellProperties && cellProperties["headerBackColor"]) {
                day.style.background = cellProperties["headerBackColor"];
            }
            day.className = this._prefixCssClass("_cell_header");
            day.innerHTML = cellProperties.headerHtml;

            day.onclick = function(ev) {

                if (calendar.cellHeaderClickHandling !== "Enabled") {
                    return;
                }

                ev.stopPropagation();

                var args = {};
                args.control = calendar;
                args.start = d;
                args.end = d.addDays(1);
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onCellHeaderClick === "function") {
                    calendar.onCellHeaderClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                if (typeof calendar.onCellHeaderClicked === "function") {
                    calendar.onCellHeaderClicked(args);
                }

            };

            inner.appendChild(day);

            if (cellProperties && cellProperties["html"]) {
                var html = document.createElement("div");
                html.setAttribute("unselectable", "on");
                html.style.height = (row.getHeight() - this.cellHeaderHeight) + 'px';
                html.style.overflow = 'hidden';
                html.innerHTML = cellProperties["html"];
                inner.appendChild(html);
            }

            if (this.cellMode) {
                var scrolling = document.createElement("div");
                scrolling.setAttribute("unselectable", "on");
                scrolling.style.height = (this.cellHeight - this.cellHeaderHeight) + "px";
                scrolling.style.overflow = 'auto';
                scrolling.style.position = 'relative';

                var inside = document.createElement('div');
                inside.setAttribute("unselectable", "on");
                inside.style.paddingTop = "1px";
                inside.style.paddingBottom = "1px";

                scrolling.appendChild(inside);
                inner.appendChild(scrolling);

                cell.body = inside;
                cell.scrolling = scrolling;
            }

            if (cell.props) {
                var areas = cell.props.areas || [];
                for (var i = 0; i < areas.length; i++) {
                    var area = areas[i];
                    if (!DayPilot.Areas.isVisible(area)) {
                        continue;
                    }
                    var a = DayPilot.Areas.createArea(cell, cell.props, area);
                    cell.appendChild(a);
                }
            }

            (function domAdd() {

                if (typeof calendar.onBeforeCellDomAdd !== "function" && typeof calendar.onBeforeCellDomRemove !== "function") {
                    return;
                }

                var args = {};
                args.control = calendar;
                args.cell = {};
                args.cell.start = d;
                args.cell.end = args.cell.start.addDays(1);
                args.cell.events = function() {
                    return calendar.events.forRange(args.cell.start, args.cell.end);
                };
                args.element = null;
                // args.target = "Cell";

                cell.domArgs = args;

                if (typeof calendar.onBeforeCellDomAdd === "function") {
                    calendar.onBeforeCellDomAdd(args);
                }

                if (args.element) {
                    target = inner;
/*
                    switch (args.target && args.target.toLowerCase()) {
                        case "text":
                            target = inner;
                            break;
                        case "cell":
                            target = inner;
                            break;
                    }
*/
                    if (target) {
                        args._targetElement = target;

                        var isReactComponent = DayPilot.Util.isReactComponent(args.element);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }
            })();

            this.cells[x][y] = cell;

            table.appendChild(cell);

            if (typeof calendar.onAfterCellRender === "function") {
                args.cell.div = cell;
                args.cell.divHeader = day;
                calendar.onAfterCellRender(args);
            }
        };

        this._onCellMouseMove = function() {
            var c = this;
            if (c.props) {
                DayPilot.Areas.showAreas(c, c.props);
            }
        };

        this._onCellMouseOut = function(ev) {
            var c = this;
            if (c.props) {
                DayPilot.Areas.hideAreas(c, ev);
            }
        };

        this._onCellContextMenu = function() {
            var d = this.d;

            var go = function(d) {
                var start = new DayPilot.Date(d);
                var end = start.addDays(1);

                var selection = new DayPilot.Selection(start, end, null, calendar);
                if (calendar.contextMenuSelection) {
                    calendar.contextMenuSelection.show(selection);
                }
            };

            go(d);

            return false;

        };

        this._onCellDoubleClick = function() {
            // var d = this.d;

            var coords = calendar.coords;
            var cell = calendar._getCellBelowPoint(coords.x, coords.y);
            var d = calendar._getDateFromCell(cell.x, cell.y);

            if (calendar.timeouts) {
                for (var toid in calendar.timeouts) {
                    window.clearTimeout(calendar.timeouts[toid]);
                }
                calendar.timeouts = null;
            }

            if (calendar.timeRangeDoubleClickHandling !== 'Disabled') {
                var start = new DayPilot.Date(d);
                var end = start.addDays(1);
                calendar._timeRangeDoubleClickDispatch(start, end);
            }
        };

        this._onCellClick = function() {

            if (DayPilotMonth.cancelCellClick) {
                return;
            }

            var d = this.d;

            var props = this.props;

            if (props.disabled) {
                return;
            }

            var single = function(d) {
                var start = new DayPilot.Date(d);
                var end = start.addDays(1);
                calendar._timeRangeSelectedDispatch(start, end);
            };

            if (calendar.timeRangeSelectedHandling !== 'Disabled' && calendar.timeRangeDoubleClickHandling === 'Disabled') {
                single(d);
                return;
            }

            if (!calendar.timeouts) {
                calendar.timeouts = [];
            }

            var clickDelayed = function(d) {
                return function() {
                    single(d);
                };
            };

            calendar.timeouts.push(window.setTimeout(clickDelayed(d), calendar.doubleClickTimeout));

        };

        this._onCellMouseDown = function(e) {
            var cell = this;
            var x = cell.x;
            var y = cell.y;

            DayPilotMonth.cancelCellClick = false;

            if (cell.scrolling) {
                var offset = DayPilot.mo3(cell.scrolling, e);
                var sw = DayPilot.sw(cell.scrolling);
                var width = cell.scrolling.offsetWidth;
                if (offset.x > width - sw) {  // clicking on the vertical scrollbar
                    return;
                }
            }

            if (calendar.timeRangeSelectedHandling !== 'Disabled') {
                calendar._clearShadow();
                DayPilotMonth.timeRangeSelecting = { "root": calendar, "x": x, "y": y, "from": { x: x, y: y }, "width": 1 };
            }

            calendar._drawShadow(x, y, 0, 1);

        };

        this._getColCount = function() {
            if (this.showWeekend) {
                return 7;
            }
            else {
                return 5;
            }
        };

        this._getCellWidth = function() {
            if (this.showWeekend) {
                return 14.285;
            }
            else {
                return 20;
            }
        };

/*        this._getCellBackColor = function(d) {
            if (d.getUTCDay() === 6 || d.getUTCDay() === 0) {
                return this.nonBusinessBackColor;
            }
            return this.backColor;
        };*/

        this._getRowTop = function(index) {
            //var top = this.headerHeight;
            var top = 0;
            for (var i = 0; i < index; i++) {
                top += this.rows[i].getHeight();
            }
            return top;
        };

        this.clearSelection = function() {
            this._clearShadow();
        };

/*
        this._postBack = function(prefix) {
            var args = [];
            for (var i = 1; i < arguments.length; i++) {
                args.push(arguments[i]);
            }

            __doPostBack(calendar.uniqueID, prefix + DayPilot.ea(args));
        };
*/
        this._postBack2 = function(action, data, parameters) {
            var envelope = {};
            envelope.action = action;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);
            __doPostBack(calendar.uniqueID, commandstring);
        };

        this._callBack2 = function(action, parameters, data, type) {

            if (!this._serverBased()) {
                calendar.debug.message("Callback invoked without the server-side backend specified. Callback canceled.", "warning");
                return;
            }

            if (typeof type === 'undefined') {
                type = "CallBack";
            }

            calendar._loadingStart();

            var envelope = {};

            envelope.action = action;
            envelope.type = type;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);

            if (this.backendUrl) {
                DayPilot.request(this.backendUrl, this._callBackResponse, commandstring, this._ajaxError);
            }
            else if (typeof WebForm_DoCallback === 'function') {
                WebForm_DoCallback(this.uniqueID, commandstring, this._updateView, null, this.callbackError, true);
            }
        };

        this._serverBased = function() {
            return (calendar._productCode !== "javasc" && calendar._productCode.indexOf("DCODE") === -1) || calendar.devsb;
        };


        this._isAspnetWebForms = function() {
            if (typeof WebForm_DoCallback === 'function' && this.uniqueID) {
                return true;
            }
            return false;
        };

        this._ajaxError = function(req) {
            if (typeof calendar.onAjaxError === 'function') {
                var args = {};
                args.request = req;
                calendar.onAjaxError(args);
            }
            else if (typeof calendar.ajaxError === 'function') { // backwards compatibility
                calendar.ajaxError(req);
            }
        };

        this._callBackResponse = function(response) {
            calendar._updateView(response.responseText);
        };

        this._getCallBackHeader = function() {
            var h = {};
            h.v = this.v;
            h.control = "dpm";
            h.id = this.id;
            h.visibleStart = new DayPilot.Date(this.firstDate);
            h.visibleEnd = h.visibleStart.addDays(this.days);

            h.clientState = this.clientState;
            //h.cssOnly = calendar.cssOnly;
            h.cssClassPrefix = calendar.cssClassPrefix;

            h.startDate = calendar.startDate;
            h.showWeekend = this.showWeekend;
            // h.headerBackColor = this.headerBackColor;
            // h.backColor = this.backColor;
            // h.nonBusinessBackColor = this.nonBusinessBackColor;
            h.locale = this.locale;
            h.timeFormat = this.timeFormat;
            h.weekStarts = this.weekStarts;
            h.viewType = this.viewType;
            h.weeks = this.weeks;

            h.selected = calendar.multiselect.events();

            h.hashes = calendar.hashes;

            return h;
        };

        this.visibleStart = function() {
            return new DayPilot.Date(this.firstDate);
        };

        this.visibleEnd = function() {
            return calendar.visibleStart().addDays(calendar.days);
        };

        this._invokeEvent = function(type, action, params, data) {

            if (type === 'PostBack') {
                calendar.postBack2(action, params, data);
            }
            else if (type === 'CallBack') {
                calendar._callBack2(action, params, data, "CallBack");
            }
            else if (type === 'Immediate') {
                calendar._callBack2(action, params, data, "Notify");
            }
            else if (type === 'Queue') {
                calendar.queue.add(new DayPilot.Action(this, action, params, data));
            }
            else if (type === 'Notify') {
                if (resolved.notifyType() === 'Notify') {
                    calendar._callBack2(action, params, data, "Notify");
                }
                else {
                    calendar.queue.add(new DayPilot.Action(calendar, action, params, data));
                }
            }
            else {
                throw "Invalid event invocation type";
            }
        };
        /*
        this.queue = {};
        this.queue.list = [];
        this.queue.list.ignoreToJSON = true;

        this.queue.add = function(action) {
            if (!action) {
                return;
            }
            if (action.isAction) {
                calendar.queue.list.push(action);
            }
            else {
                throw "DayPilot.Action object required for queue.add()";
            }
        };

        this.queue.notify = function(data) {
            var params = {};
            params.actions = calendar.queue.list;
            calendar._callBack2('Notify', params, data, "Notify");

            calendar.queue.list = [];
        };

        this.queue.clear = function() {
            calendar.queue.list = [];
        };

        this.queue.pop = function() {
            return calendar.queue.list.pop();
        };
*/
        this._bubbleCallBack = function(args, bubble) {
            var guid = calendar._recordBubbleCall(bubble);

            var params = {};
            params.args = args;
            params.guid = guid;

            calendar._callBack2("Bubble", params);
        };

        this._recordBubbleCall = function(bubble) {
            var guid = DayPilot.guid();
            if (!this.bubbles) {
                this.bubbles = [];
            }

            this.bubbles[guid] = bubble;
            return guid;
        };


        this.eventClickPostBack = function(e, data) {
            this._postBack2("EventClick", data, e);
        };
        this.eventClickCallBack = function(e, data) {
            this._callBack2('EventClick', e, data);
        };

        this._eventClickDispatch = function(div, e) {

            DayPilotMonth.movingEvent = null;
            DayPilotMonth.resizingEvent = null;

            //var div = this;

            var e = e || window.event;
            var ctrlKey = e.ctrlKey;
            var metaKey = e.metaKey;

            e.cancelBubble = true;
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            if (calendar.eventDoubleClickHandling === 'Disabled') {
                calendar._eventClickSingle(div, e);
                return;
            }

            if (!calendar.timeouts) {
                calendar.timeouts = [];
            }
            else {
                for (var toid in calendar.timeouts) {
                    window.clearTimeout(calendar.timeouts[toid]);
                }
                calendar.timeouts = [];
            }

            var eventClickDelayed = function(div, e) {
                return function() {
                    calendar._eventClickSingle(div, e);
                };
            };

            calendar.timeouts.push(window.setTimeout(eventClickDelayed(div, e), calendar.doubleClickTimeout));

        };


        this._eventClickSingle = function(div, ev) {

            var e = div.event;
            if (!e.client.clickEnabled()) {
                return;
            }

            var ctrlKey = ev.ctrlKey;
            var metaKey = ev.metaKey;

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;
                args.div = div;
                args.originalEvent = ev;
                args.meta = ev.metaKey;
                args.ctrl = ev.ctrlKey;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventClick === 'function') {
                    calendar.onEventClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ctrlKey, metaKey);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventClicked === 'function') {
                    calendar.onEventClicked(args);
                }

            }
            else {
                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventClick(e);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ctrlKey, metaKey);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

            }

/*
            switch (calendar.eventClickHandling) {
                case 'PostBack':
                    calendar.eventClickPostBack(e);
                    break;
                case 'CallBack':
                    calendar.eventClickCallBack(e);
                    break;
                case 'JavaScript':
                    calendar.onEventClick(e);
                    break;
                case 'Select':
                    calendar._eventSelect(div, e, ctrlKey);
                    break;
                case 'ContextMenu':
                    var menu = e.client.contextMenu();
                    if (menu) {
                        menu.show(e);
                    }
                    else {
                        if (calendar.contextMenu) {
                            calendar.contextMenu.show(e);
                        }
                    }
                    break;
                case 'Bubble':
                    if (calendar.bubble) {
                        calendar.bubble.showEvent(e);
                    }
                    break;
            }
            */
        };

        this._eventDeleteDispatch = function(e) {

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventDelete === 'function') {
                    calendar.onEventDelete(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventDeleteHandling) {
                    case 'PostBack':
                        calendar.eventDeletePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDeleteCallBack(e);
                        break;
                    case 'Update':
                        calendar.events.remove(e);
                        break;
                }

                if (typeof calendar.onEventDeleted === 'function') {
                    calendar.onEventDeleted(args);
                }
            }
            else {
                switch (calendar.eventDeleteHandling) {
                    case 'PostBack':
                        calendar.eventDeletePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDeleteCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDelete(e);
                        break;
                }
            }

        };

        this.eventDeletePostBack = function(e, data) {
            this._postBack2('EventDelete', e, data);
        };
        this.eventDeleteCallBack = function(e, data) {
            this._callBack2('EventDelete', e, data);
        };

        this.eventDoubleClickPostBack = function(e, data) {
            this._postBack2('EventDoubleClick', data, e);
        };
        this.eventDoubleClickCallBack = function(e, data) {
            this._callBack2('EventDoubleClick', e, data);
        };

        this._eventDoubleClickDispatch = function(div, ev) {

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            if (calendar.timeouts) {
                for (var toid in calendar.timeouts) {
                    window.clearTimeout(calendar.timeouts[toid]);
                }
                calendar.timeouts = null;
            }

            var ev = ev || window.event;
            var e = div.event;

            if (!e.client.doubleClickEnabled()) {
                return;
            }

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventDoubleClick === 'function') {
                    calendar.onEventDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ev.ctrlKey, ev.metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventDoubleClicked === 'function') {
                    calendar.onEventDoubleClicked(args);
                }

            }
            else {
                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDoubleClick(e);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ev.ctrlKey, ev.metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

            }

        };

        this._eventSelect = function(div, e, ctrlKey, metaKey) {
            calendar._eventSelectDispatch(div, e, ctrlKey, metaKey);
        };

        this.eventSelectPostBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._postBack2('EventSelect', data, params);
        };
        this.eventSelectCallBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._callBack2('EventSelect', params, data);
        };

        this._eventSelectDispatch = function(div, e, ctrlKey, metaKey) {

            var m = calendar.multiselect;

            var allowDeselect = false;
            var isSelected = m.isSelected(e);
            var ctrlOrMeta = ctrlKey || metaKey;
            if (!ctrlOrMeta && isSelected && !allowDeselect && m.list.length === 1) {
                return;
            }

            if (calendar._api2()) {

                m.previous = m.events();

                var args = {};
                args.e = e;
                args.selected = m.isSelected(e);
                args.ctrl = ctrlKey;
                args.meta = metaKey;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventSelect === 'function') {
                    calendar.onEventSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'Update':
                        m._toggleDiv(div, ctrlKey);
                        break;
                }

                if (typeof calendar.onEventSelected === 'function') {
                    args.change = m.isSelected(e) ? "selected" : "deselected";
                    args.selected = m.isSelected(e);
                    calendar.onEventSelected(args);
                }

            }
            else {
                m.previous = m.events();
                m._toggleDiv(div, ctrlKey);
                var change = m.isSelected(e) ? "selected" : "deselected";

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'JavaScript':
                        calendar.onEventSelect(e, change);
                        break;
                }
            }


/*
            switch (calendar.eventSelectHandling) {
                case 'PostBack':
                    calendar.eventSelectPostBack(e, change);
                    break;
                case 'CallBack':
                    __theFormPostData = "";
                    __theFormPostCollection = [];
                    if (WebForm_InitCallback) {
                        WebForm_InitCallback();
                    }
                    calendar.eventSelectCallBack(e, change);
                    break;
                case 'JavaScript':
                    calendar.onEventSelect(e, change);
                    break;
            }
            */
        };


        this.eventRightClickPostBack = function(e, data) {
            this._postBack2("EventRightClick", data, e);
        };
        this.eventRightClickCallBack = function(e, data) {
            this._callBack2('EventRightClick', e, data);
        };

        this._eventRightClickDispatch = function(e) {

            this.event = e;

            if (!e.client.rightClickEnabled()) {
                return false;
            }

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventRightClick === 'function') {
                    calendar.onEventRightClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventRightClicked === 'function') {
                    calendar.onEventRightClicked(args);
                }

            }
            else {
                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventRightClick(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }
            }

            return false;
        };

        this.eventMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.e = e;
            params.command = command;

            this._postBack2('EventMenuClick', data, params);
        };
        this.eventMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.e = e;
            params.command = command;

            this._callBack2('EventMenuClick', params, data);
        };

        this._eventMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.eventMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.eventMenuClickCallBack(e, command);
                    break;
            }
        };

        this.eventMovePostBack = function(e, newStart, newEnd, data, position) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            params.position = position;

            this._postBack2('EventMove', data, params);

        };
        this.eventMoveCallBack = function(e, newStart, newEnd, data, position) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            params.position = position;
            //params.newColumn = newColumn;

            this._callBack2('EventMove', params, data);
        };

        this._eventMoveDispatch = function(e, x, y, offset, ev, position, external) {

            var startOffset = e.start().getTimePart();

            var endDate = e.rawend().getDatePart();
            if (endDate.getTime() !== e.rawend().getTime()) {
                endDate = endDate.addDays(1);
            }
            var endOffset = DayPilot.DateUtil.diff(e.rawend(), endDate);

            var boxStart = this._getDateFromCell(x, y);
            boxStart = boxStart.addDays(-offset);
            var width = DayPilot.DateUtil.daysSpan(e.start(), e.rawend()) + 1;

            var boxEnd = boxStart.addDays(width);

            var newStart = boxStart.addTime(startOffset);
            var newEnd = boxEnd.addTime(endOffset);

            newEnd = calendar._adjustEndOut(newEnd);

            if (calendar._api2()) {
                // API v2
                var args = {};

                args.e = e;
                args.control = calendar;
                args.newStart = newStart;
                args.newEnd = newEnd;
                args.position = position;
                args.ctrl = false;
                args.external = external;
                if (ev) {
                    args.ctrl = ev.ctrlKey;
                }
                args.shift = false;
                if (ev) {
                    args.shift = ev.shiftKey;
                }
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventMove === 'function') {
                    calendar.onEventMove(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventMoveHandling) {
                    case 'PostBack':
                        calendar.eventMovePostBack(e, newStart, newEnd, null, position);
                        break;
                    case 'CallBack':
                        calendar.eventMoveCallBack(e, newStart, newEnd, null, position);
                        break;
                    case 'Notify':
                        calendar.eventMoveNotify(e, newStart, newEnd, null, position);
                        break;
                    case 'Update':
                        if (args.external) {
                            e.start(newStart);
                            e.end(newEnd);
                            e.commit();
                            calendar.events.add(e);
                        }
                        else {
                            e.start(newStart);
                            e.end(newEnd);
                            calendar.events.update(e);
                        }
                        calendar._deleteDragSource();
                        break;
                }

                if (typeof calendar.onEventMoved === 'function') {
                    calendar.onEventMoved(args);
                }
            }
            else {
                switch (calendar.eventMoveHandling) {
                    case 'PostBack':
                        calendar.eventMovePostBack(e, newStart, newEnd, null, position);
                        break;
                    case 'CallBack':
                        calendar.eventMoveCallBack(e, newStart, newEnd, null, position);
                        break;
                    case 'JavaScript':
                        calendar.onEventMove(e, newStart, newEnd, ev.ctrlKey, ev.shiftKey, position);
                        break;
                    case 'Notify':
                        calendar.eventMoveNotify(e, newStart, newEnd, null, position);
                        break;
                }
            }


/*
            switch (calendar.eventMoveHandling) {
                case 'PostBack':
                    calendar.eventMovePostBack(e, newStart, newEnd, null, position);
                    break;
                case 'CallBack':
                    calendar.eventMoveCallBack(e, newStart, newEnd, null, position);
                    break;
                case 'JavaScript':
                    calendar.onEventMove(e, newStart, newEnd, ev.ctrlKey, ev.shiftKey, position);
                    break;
                case 'Notify':
                    calendar.eventMoveNotify(e, newStart, newEnd, null, position);
                    break;

            }
*/
        };

        this.eventMoveNotify = function(e, newStart, newEnd, data, line) {

            var old = new DayPilot.Event(e.copy(), this);

            e.start(newStart);
            e.end(newEnd);
            //e.resource(newResource);
            e.commit();

            calendar.update();

            this._invokeEventMove("Notify", old, newStart, newEnd, data, line);

        };

        this._invokeEventMove = function(type, e, newStart, newEnd, data, line) {
            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;
            //params.newResource = newResource;
            params.position = line;

            this._invokeEvent(type, "EventMove", params, data);
        };

        this.eventResizePostBack = function(e, newStart, newEnd, data) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._postBack2('EventResize', data, params);
        };

        this.eventResizeCallBack = function(e, newStart, newEnd, data) {
            if (!newStart)
                throw 'newStart is null';
            if (!newEnd)
                throw 'newEnd is null';

            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._callBack2('EventResize', params, data);
        };

        this._eventResizeDispatch = function(e, start, width) {
            var startOffset = e.start().getTimePart();

            var endDate = e.rawend().getDatePart();
            if (endDate != e.rawend()) {
                endDate = endDate.addDays(1);
            }
            var endOffset = DayPilot.DateUtil.diff(e.rawend(), endDate);

            var boxStart = this._getDateFromCell(start.x, start.y);
            var boxEnd = boxStart.addDays(width);

            var newStart = boxStart.addTime(startOffset);
            var newEnd = boxEnd.addTime(endOffset);

            newEnd = calendar._adjustEndOut(newEnd);

            if (calendar._api2()) {
                // API v2
                var args = {};

                args.e = e;
                args.control = calendar;
                args.newStart = newStart;
                args.newEnd = newEnd;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventResize === 'function') {
                    calendar.onEventResize(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventResizeHandling) {
                    case 'PostBack':
                        calendar.eventResizePostBack(e, newStart, newEnd);
                        break;
                    case 'CallBack':
                        calendar.eventResizeCallBack(e, newStart, newEnd);
                        break;
                    case 'Notify':
                        calendar.eventResizeNotify(e, newStart, newEnd);
                        break;
                    case 'Update':
                        e.start(newStart);
                        e.end(newEnd);
                        calendar.events.update(e);
                        break;
                }

                if (typeof calendar.onEventResized === 'function') {
                    calendar.onEventResized(args);
                }
            }
            else {
               switch (calendar.eventResizeHandling) {
                    case 'PostBack':
                        calendar.eventResizePostBack(e, newStart, newEnd);
                        break;
                    case 'CallBack':
                        calendar.eventResizeCallBack(e, newStart, newEnd);
                        break;
                    case 'JavaScript':
                        calendar.onEventResize(e, newStart, newEnd);
                        break;
                    case 'Notify':
                        calendar.eventResizeNotify(e, newStart, newEnd);
                        break;

                }
            }

/*
            switch (calendar.eventResizeHandling) {
                case 'PostBack':
                    calendar.eventResizePostBack(e, newStart, newEnd);
                    break;
                case 'CallBack':
                    calendar.eventResizeCallBack(e, newStart, newEnd);
                    break;
                case 'JavaScript':
                    calendar.onEventResize(e, newStart, newEnd);
                    break;
                case 'Notify':
                    calendar.eventResizeNotify(e, newStart, newEnd);
                    break;
            }
            */
        };

        this.eventResizeNotify = function(e, newStart, newEnd, data) {

            var old = new DayPilot.Event(e.copy(), this);

            e.start(newStart);
            e.end(newEnd);
            e.commit();

            calendar.update();

            this._invokeEventResize("Notify", old, newStart, newEnd, data);

        };

        this._invokeEventResize = function(type, e, newStart, newEnd, data) {
            var params = {};
            params.e = e;
            params.newStart = newStart;
            params.newEnd = newEnd;

            this._invokeEvent(type, "EventResize", params, data);
        };


        this.timeRangeSelectedPostBack = function(start, end, data) {
            var range = {};
            range.start = start;
            range.end = end;

            this._postBack2('TimeRangeSelected', data, range);
        };
        this.timeRangeSelectedCallBack = function(start, end, data) {

            var range = {};
            range.start = start;
            range.end = end;

            this._callBack2('TimeRangeSelected', range, data);
        };

        this._timeRangeSelectedDispatch = function(start, end) {

            end = calendar._adjustEndOut(end);

            if (calendar._api2()) {

                var args = {};
                args.start = start;
                args.end = end;
                args.control = calendar;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeRangeSelect === 'function') {
                    calendar.onTimeRangeSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                // now perform the default builtin action
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end);
                        calendar.clearSelection();
                        break;
                    case 'CallBack':
                        calendar.timeRangeSelectedCallBack(start, end);
                        calendar.clearSelection();
                        break;
                }

                if (typeof calendar.onTimeRangeSelected === 'function') {
                    calendar.onTimeRangeSelected(args);
                }

            }
            else {
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end);
                        calendar.clearSelection();
                        break;
                    case 'CallBack':
                        calendar.timeRangeSelectedCallBack(start, end);
                        calendar.clearSelection();
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeSelected(start, end);
                        break;
                }
            }

            /*
            switch (calendar.timeRangeSelectedHandling) {
                case 'PostBack':
                    calendar.timeRangeSelectedPostBack(start, end);
                    calendar.clearSelection();
                    break;
                case 'CallBack':
                    calendar.timeRangeSelectedCallBack(start, end);
                    calendar.clearSelection();
                    break;
                case 'JavaScript':
                    calendar.onTimeRangeSelected(start, end);
                    break;
            }
            */
        };

        this.timeRangeMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.selection = e;
            params.command = command;

            this._postBack2("TimeRangeMenuClick", data, params);

        };
        this.timeRangeMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.selection = e;
            params.command = command;

            this._callBack2("TimeRangeMenuClick", params, data);
        };

        this._timeRangeMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.timeRangeMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.timeRangeMenuClickCallBack(e, command);
                    break;
            }
        };

        this.headerClickPostBack = function(c, data) {
            this._postBack2('HeaderClick', data, c);
        };
        this.headerClickCallBack = function(c, data) {
            this._callBack2('HeaderClick', c, data);
        };

        this._headerClickDispatch = function(x) {

            var data = this.data;
            var c = { day: x };
            // check if allowed

            if (calendar._api2()) {

                var args = {};
                args.header = {};
                args.header.dayOfWeek = x;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onHeaderClick === 'function') {
                    calendar.onHeaderClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.headerClickHandling) {
                    case 'PostBack':
                        calendar.headerClickPostBack(c);
                        break;
                    case 'CallBack':
                        calendar.headerClickCallBack(c);
                        break;
                }

                if (typeof calendar.onHeaderClicked === 'function') {
                    calendar.onHeaderClicked(args);
                }
            }
            else {
                switch (calendar.headerClickHandling) {
                    case 'PostBack':
                        calendar.headerClickPostBack(c);
                        break;
                    case 'CallBack':
                        calendar.headerClickCallBack(c);
                        break;
                    case 'JavaScript':
                        calendar.onHeaderClick(c);
                        break;
                }
            }

        };

        this.timeRangeDoubleClickPostBack = function(start, end, data) {
            var range = {};
            range.start = start;
            range.end = end;
            //range.resource = column;

            this._postBack2('TimeRangeDoubleClick', data, range);
        };
        this.timeRangeDoubleClickCallBack = function(start, end, data) {

            var range = {};
            range.start = start;
            range.end = end;
            //range.resource = column;

            this._callBack2('TimeRangeDoubleClick', range, data);
        };

        this._timeRangeDoubleClickDispatch = function(start, end) {
            if (calendar._api2()) {

                var args = {};
                args.start = start;
                args.end = end;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeRangeDoubleClick === 'function') {
                    calendar.onTimeRangeDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end);
                        break;
                }

                if (typeof calendar.onTimeRangeDoubleClicked === 'function') {
                    calendar.onTimeRangeDoubleClicked(args);
                }
            }
            else {
                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end);
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeDoubleClick(start, end);
                        break;
                }
            }

            /*
            switch (calendar.timeRangeDoubleClickHandling) {
                case 'PostBack':
                    calendar.timeRangeDoubleClickPostBack(start, end);
                    break;
                case 'CallBack':
                    calendar.timeRangeDoubleClickCallBack(start, end);
                    break;
                case 'JavaScript':
                    calendar.onTimeRangeDoubleClick(start, end);
                    break;
            }
            */
        };

        this.commandCallBack = function(command, data) {
            this._stopAutoRefresh();

            var params = {};
            params.command = command;

            this._callBack2('Command', params, data);
        };

        this.commandPostBack = function(command, data) {
            this._stopAutoRefresh();

            var params = {};
            params.command = command;

            this._postBack2('Command', params, data);
        };

        this._findEventDiv = function(e) {
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (div.event === e || div.event.data === e.data) {
                    return div;
                }
            }
            return null;
        };

        this._findEventDivs = function(e) {
            var result = {};
            result.list = [];
            result.forEach = function(m) {
                if (!m) { return; }
                for (var i = 0; i < this.list.length; i++) {
                    m(this.list[i]);
                }
            };

            for (var i = 0; i < this.elements.events.length; i++) {
                var div = this.elements.events[i];
                if (div.event.data === e.data) {
                    result.list.push(div);
                }
            }
            return result;

        };

        this._getDimensionsFromCss = function(className) {
            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.className = this._prefixCssClass(className);

            document.body.appendChild(div);
            var height = div.offsetHeight;
            var width = div.offsetWidth;
            document.body.removeChild(div);

            var result = {};
            result.height = height;
            result.width = width;
            return result;
        };


        this._resolved = {};
        var resolved = this._resolved;

        resolved._xssProtectionEnabled = function() {
            return calendar.xssProtection !== "Disabled";
        };

        resolved.clearCache = function() {
            delete calendar._cache.eventHeight;
            delete calendar._cache.headerHeight;
        };

        resolved.lineHeight = function() {
            return resolved.eventHeight() + calendar.lineSpace;
        };

        resolved.rounded = function() {
            return calendar.eventCorners === "Rounded";
        };

        resolved.loadFromServer = function() {
            return !!calendar.backendUrl;

/*            // make sure it has a place to ask
            if (calendar.backendUrl) {
                return (typeof calendar.events.list === 'undefined') || (!calendar.events.list);
            }
            else {
                return false;
            }*/
        };

        resolved.locale = function() {
            return DayPilot.Locale.find(calendar.locale);
        };

        resolved.getWeekStart = function() {
            if (calendar.showWeekend) {
                return calendar.weekStarts;
            }
            else {
                return 1; // Monday
            }
        };

        resolved.weekStarts = function() {
            if (!calendar.showWeekend) {
                return 1;  // Monday
            }
            if (calendar.weekStarts === 'Auto') {
                var locale = resolved.locale();
                if (locale) {
                    return locale.weekStarts;
                }
                else {
                    return 0; // Sunday
                }
            }
            else {
                return calendar.weekStarts;
            }
        };


        resolved.notifyType = function() {
            var type;
            if (calendar.notifyCommit === 'Immediate') {
                type = "Notify";
            }
            else if (calendar.notifyCommit === 'Queue') {
                type = "Queue";
            }
            else {
                throw "Invalid notifyCommit value: " + calendar.notifyCommit;
            }

            return type;
        };

        resolved.eventHeight = function() {
            if (calendar._cache.eventHeight) {
                return calendar._cache.eventHeight;
            }
            var height = calendar._getDimensionsFromCss("_event_height").height;
            if (!height) {
                height = calendar.eventHeight;
            }
            calendar._cache.eventHeight = height;
            return height;
        };

        resolved.headerHeight = function() {
            if (calendar._cache.headerHeight) {
                return calendar._cache.headerHeight;
            }
            var height = calendar._getDimensionsFromCss("_header_height").height;
            if (!height) {
                height = calendar.headerHeight;
            }
            calendar._cache.headerHeight = height;
            return height;
        };

        resolved.timeFormat = function() {
            if (calendar.timeFormat !== 'Auto') {
                return calendar.timeFormat;
            }
            return resolved.locale().timeFormat;
        };

        this._visible = function() {
            var el = calendar.nav.top;
            if (!el) {
                return false;
            }
            return el.offsetWidth > 0 && el.offsetHeight > 0;
        };

        // export
        this.exportAs = function(format, options) {
            if (!calendar._visible()) {
                throw new DayPilot.Exception("DayPilot.Month.exportAs(): The instance must be visible during export.");
            }
            var board = img.generate(format, options);
            return new DayPilot.Export(board);
        };

        this._img = {};
        var img = this._img;

        img._options = null;
        img._mode = null;

        // ff, ch, ie 9+
        img.generate = function(format, options) {

            /*

            Supported options:
            area: "viewport" | "full" | "range"
            scale: number
            quality: number (JPEG only)
            dateFrom: DayPilot.Date | string (range only)
            dateTo: DayPilot.Date | string (range only)
            width: number
             */

            if (typeof format === "object") {
                options = format;
                format = null;
            }

            var options = options || {};
            var format = format || options.format || "svg";
            var scale = options.scale || 1;

            if (format === "config") {
                return;
            }

            // backwards compatibility
            if (format.toLowerCase() === "jpg") {
                format = "jpeg";
            }

            var mode = options.area || "viewport";
            img._options = options;
            img._mode = mode;

            // make sure event positions are calculated
            /*img.getRows().forEach(function(row) {
             calendar._updateEventPositionsInRow(row);
             });*/

            var width = img.getWidth();
            var height = img.getHeight();

            var board;
            switch (format.toLowerCase()) {
                case "svg":
                    board = new DayPilot.Svg(width, height);
                    break;
                case "png":
                    board = new DayPilot.Canvas(width, height, "image/png", scale);
                    break;
                case "jpeg":
                    board = new DayPilot.Canvas(width, height, "image/jpeg", scale, options.quality);
                    break;
                default:
                    throw "Export format not supported: " + format;
            }

            var rectangles = img.getRectangles();

            // main
            var backColor = new DayPilot.StyleReader(calendar.nav.top).get("background-color");
            var borderColor = new DayPilot.StyleReader(calendar.nav.top).get("border-top-color");
            //var cornerBackground = new DayPilot.StyleReader(calendar.nav.corner.firstChild).get("background-color");

            // day header
            var header = calendar.nav.header.firstChild.firstChild;
            var headerBackColor = new DayPilot.StyleReader(header).get("background-color");
            var headerFont = new DayPilot.StyleReader(header).getFont();
            var headerColor = new DayPilot.StyleReader(header).get("color");

            // cells
            var cell = calendar.cells[0][0].firstChild;
            var cellBackColor = new DayPilot.StyleReader(cell).get("background-color");
            var cellBorderColor = new DayPilot.StyleReader(cell).get("border-right-color");

            var cellWidth = rectangles.grid.w * calendar._getCellWidth() / 100;

            // events
            /*var eventDiv = calendar.elements.events[0].firstChild;
            var eventBackColor = new DayPilot.StyleReader(eventDiv).get("background-color");
            eventBackColor = DayPilot.Util.isTransparentColor(eventBackColor) ? "white" : eventBackColor;
            var eventBorderColor = new DayPilot.StyleReader(eventDiv).get("border-right-color");
            var eventFont = new DayPilot.StyleReader(eventDiv).getFont();
            var eventColor = new DayPilot.StyleReader(eventDiv).get("color");
            var eventPaddingTop = new DayPilot.StyleReader(eventDiv).getPx("padding-top");
            var eventPaddingLeft = new DayPilot.StyleReader(eventDiv).getPx("padding-left");
            var eventPaddingRight = new DayPilot.StyleReader(eventDiv).getPx("padding-right");
            var eventPaddingBottom = new DayPilot.StyleReader(eventDiv).getPx("padding-bottom");*/

            var left = 0;

            // background
            board.fillRect(rectangles.main, "white");
            board.fillRect(rectangles.main, backColor);

            // day headers
            DayPilot.list.for(calendar._getColCount()).forEach(function(x) {
                var headerProperties = calendar.headerProperties ? calendar.headerProperties[x] : null;

                var dayIndex = x + resolved.weekStarts();
                if (dayIndex > 6) {
                    dayIndex -= 7;
                }

                if (!headerProperties) {
                    var headerProperties = {};
                    headerProperties.html = resolved.locale().dayNames[dayIndex];
                }

                var top = 0;
                var width = cellWidth;
                var height = resolved.headerHeight();
                var text = headerProperties.html;

                var rect = {"x": left, "y": top, "w": width + 1, "h": height + 1};
                var rectText = DayPilot.Util.copyProps(rect);
                //rectText.w -= 4;


                var args = {};
                args.header = {};
                args.header.dayOfWeek = dayIndex;
                args.backColor = headerBackColor;
                args.text = text;
                args.horizontalAlignment = "center";
                args.verticalAlignment = "center";
                args.fontSize = headerFont.size;
                args.fontFamily = headerFont.family;
                args.fontStyle = headerFont.style;
                args.fontColor = headerColor;

                if (typeof calendar.onBeforeHeaderExport === "function") {
                    calendar.onBeforeHeaderExport(args);
                }

                var font = {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle};

                board.fillRect(rect, args.backColor);
                board.rect(rect, borderColor);
                board.text(rectText, args.text, font, args.fontColor, args.horizontalAlignment, 0, args.verticalAlignment);

                left += width;

            });

            // cells
            var top = rectangles.grid.y;
            img._getRows().forEach(function(row) {
                var height = row.getHeight();
                var left = 0;
                var y = calendar.rows.indexOf(row);
                DayPilot.list.for(calendar._getColCount()).forEach(function(x) {
                    var cell = calendar.cells[x][y];
                    var props = cell.props;

                    var width = cellWidth;
                    var backColor = new DayPilot.StyleReader(calendar.cells[x][y].firstChild).get("background-color");

                    var cellHeaderDiv = calendar.cells[x][y].firstChild.firstChild;
                    var cellHeaderFont = new DayPilot.StyleReader(cellHeaderDiv).getFont();
                    var cellHeaderColor = new DayPilot.StyleReader(cellHeaderDiv).get("color");
                    var cellHeaderBackColor = new DayPilot.StyleReader(cellHeaderDiv).get("background-color");

                    var d = calendar.firstDate.addDays(y * 7 + x);

                    var args = {};
                    args.cell = {};
                    args.cell.start = d;
                    args.cell.end = d.addDays(1);
                    args.backColor = backColor;
                    args.text = props.headerHtml;
                    args.horizontalAlignment = "right";

                    if (typeof calendar.onBeforeCellExport === "function") {
                        calendar.onBeforeCellExport(args);
                    }

                    // cell
                    var rectCell = {"x": left, "y": top, "w": width + 1, "h": height + 1};
                    board.fillRect(rectCell, args.backColor);
                    board.rect(rectCell, cellBorderColor);

                    // header
                    var rectHeader = {"x": left, "y": top, "w": width - 2, "h": calendar.cellHeaderHeight};
                    // var rectText = DayPilot.Util.copyProps(rectHeader);
                    // rectText.w -= 4;
                    board.fillRect(rectCell, cellHeaderBackColor);
                    board.text(rectHeader, args.text, cellHeaderFont, cellHeaderColor, args.horizontalAlignment);

                    // body
                    left += width;
                });

                top += height;
            });

            // events
            // var top = rectangles.grid.y;;
            var rowTop = 0;
            img._getRows().forEach(function(row) {
                var height = row.getHeight();
                DayPilot.list(row.lines).forEach(function(line) {
                    DayPilot.list(line).forEach(function(ep) {

                        var cache = ep.cache || ep.data;

                        // detection
                        var eventDiv = img._fakeEvent();
                        eventDiv.className += " " + cache.cssClass;
                        var eventInnerDiv = eventDiv.firstChild;
                        var barDiv = eventDiv.querySelector("." + calendar._prefixCssClass("_event_bar"));

                        var eventBorderColor = new DayPilot.StyleReader(eventInnerDiv).get("border-right-color");
                        var eventFont = new DayPilot.StyleReader(eventInnerDiv).getFont();
                        var eventColor = new DayPilot.StyleReader(eventInnerDiv).get("color");
                        var eventBackColor = new DayPilot.StyleReader(eventInnerDiv).getBackColor();
                        var eventBarColor = new DayPilot.StyleReader(barDiv.firstChild).getBackColor();
                        var eventBarWidth = new DayPilot.StyleReader(barDiv.firstChild).getPx("width");
                        var eventPadding = {};
                        eventPadding.left = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-left");
                        eventPadding.right = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-right");
                        eventPadding.top = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-top");
                        eventPadding.bottom = new DayPilot.StyleReader(eventInnerDiv).getPx("padding-bottom");

                        var barColor  = cache.barColor || eventBarColor;

                        DayPilot.de(eventDiv);
                        // END detection

                        var backColor = cache.backColor || eventBackColor;

                        var args = {};
                        args.e = ep;
                        args.text = ep.text ? ep.text() : ep.client.html();
                        args.fontSize = eventFont.size;
                        args.fontFamily = eventFont.family;
                        args.fontStyle = eventFont.style;
                        args.fontColor = cache.fontColor || eventColor;
                        args.backColor = cache.backColor || backColor;
                        args.borderColor = cache.borderColor || eventBorderColor;
                        args.horizontalAlignment = "left";
                        args.barWidth = eventBarWidth;
                        args.barColor = cache.barColor || eventBarColor;

                        if (typeof calendar.onBeforeEventExport === "function") {
                            calendar.onBeforeEventExport(args);
                        }

                        var left = cellWidth * ep.part.colStart ;
                        var width = cellWidth * ep.part.colWidth;
                        // var top = calendar._getEventTop(ep.part.row, ep.part.line) + rectangles.grid.y + 2;
                        var top = rowTop + calendar.cellHeaderHeight + ep.part.line * resolved.lineHeight() + rectangles.grid.y + 2;
                        var height = resolved.eventHeight();

                        var padding = 2;
                        var rect = {"x": left + padding, "y": top, "w": width + 1 - 2*padding, "h": height};

                        var rectInner = DayPilot.Util.copyProps(rect);

/*
                        if (ep.client.barVisible()) {
                            rectInner.x += eventBarWidth;
                            rectInner.w -= eventBarWidth;
                        }
*/

                        var rectText = DayPilot.Util.copyProps(rectInner);
                        rectText.x += eventPadding.left;
                        rectText.w -= eventPadding.left + eventPadding.right;
                        rectText.y += eventPadding.top;
                        rectText.h -= eventPadding.top + eventPadding.bottom;

                        board.fillRect(rect, args.backColor);

                        if (ep.client.barVisible()) {
                            // var rectBar = {"x": rect.x, "y": rect.y, "w": args.barWidth, "h": rect.h};
                            var rectBarInner = {"x": rect.x, "y": rect.y, "w": args.barWidth, "h": rect.h};

                            // board.fillRect(rectBar, args.barBackColor);
                            board.fillRect(rectBarInner, args.barColor);
                        }

                        board.text(rectText, args.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle}, args.fontColor, args.horizontalAlignment);
                        board.rect(rect, args.borderColor);


                    });
                });

                rowTop += height;
            });

            // frame
            board.rect(rectangles.main, borderColor);
            board.line(rectangles.grid.x, 0, rectangles.grid.x, rectangles.main.h, borderColor);
            board.line(0, rectangles.grid.y, rectangles.main.w, rectangles.grid.y, borderColor);

            return board;

        };

        img._fakeEvent = function() {
            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_event");

            var inner = document.createElement("div");
            inner.className = calendar._prefixCssClass("_event_inner");
            div.appendChild(inner);

            var bar = document.createElement("div");
            bar.className = calendar._prefixCssClass("_event_bar");
            var barInner = document.createElement("div");
            barInner.className = calendar._prefixCssClass("_event_bar_inner");
            bar.appendChild(barInner);
            div.appendChild(bar);

            var wrapper = calendar.nav.events;
            wrapper.appendChild(div);

            return div;
        };

        img._fakeCell = function() {
            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_cell");

            var inner = document.createElement("div");
            inner.className = calendar._prefixCssClass("_cell_inner");
            div.appendChild(inner);

            var wrapper = calendar.nav.events;
            wrapper.appendChild(div);

            return div;
        };

        img.getWidth = function() {
            var mode = img._mode;

            var clientWidth = Math.floor(calendar.nav.top.clientWidth/calendar._getColCount()) * calendar._getColCount();

            switch (mode) {
                case "viewport":
                case "full":
                case "range":
                    if (typeof img._options.width === "number") {
                        return img._options.width;
                    }
                    return clientWidth;
                default:
                    throw "Unsupported export mode: " + mode;
            }
        };

        img.getHeight = function() {
            var mode = img._mode;

            switch (mode) {
                case "viewport":
                case "full":
                    return calendar.nav.top.clientHeight;
                case "range":
                    var height = resolved.headerHeight();
                    img._getRows().forEach(function(row) {
                        height += row.getHeight();
                    });
                    return height;
                default:
                    throw "Unsupported export mode: " + mode;
            }
        };

        img._getRows = function() {
            var start = new DayPilot.Date(img._options.dateFrom || calendar.visibleStart());
            var end = new DayPilot.Date(img._options.dateTo || calendar.visibleEnd());

            var filtered = calendar.rows.filter(function(row) {
                if (img._mode === "range") {
                    return DayPilot.Util.overlaps(row.start, row.end, start, end);
                }
                return true;
            });
            return filtered;
        };

        img.getRectangles = function() {
            var headerHeight = resolved.headerHeight();

            var rectangles = {};
            rectangles.main = {"x": 0, "y": 0, "w": img.getWidth(), "h": img.getHeight()};
            rectangles.grid = {"x": 0, "y": headerHeight, "w": img.getWidth(), "h": img.getHeight() - headerHeight};

            return rectangles;
        };

        // internal methods for handling event selection
        this.multiselect = {};

        this.multiselect.initList = [];
        this.multiselect.list = [];
        this.multiselect.divs = [];
        this.multiselect.previous = [];

        this.multiselect._serialize = function() {
            var m = calendar.multiselect;
            return JSON.stringify(m.events());
        };

        this.multiselect.events = function() {
            var m = calendar.multiselect;
            var events = [];
            events.ignoreToJSON = true;
            for (var i = 0; i < m.list.length; i++) {
                events.push(m.list[i]);
            }
            return events;
        };

        this.multiselect._updateHidden = function() {
            // update the hidden field, not implemented
        };

        this.multiselect._toggleDiv = function(div, ctrl) {
            var m = calendar.multiselect;
            if (m.isSelected(div.event)) {
                if (calendar.allowMultiSelect) {
                    if (ctrl) {
                        m.remove(div.event, true);
                    }
                    else {
                        var count = m.list.length;
                        m.clear(true);
                        if (count > 1) {
                            m.add(div.event, true);
                        }

                    }
                }
                else { // clear all
                    m.clear(true);
                }
            }
            else {
                if (calendar.allowMultiSelect) {
                    if (ctrl) {
                        m.add(div.event, true);
                    }
                    else {
                        m.clear(true);
                        m.add(div.event, true);
                    }
                }
                else {
                    m.clear(true);
                    m.add(div.event, true);
                }
            }
            m.redraw();
            m._updateHidden();
        };

        // compare event with the init select list
        this.multiselect._shouldBeSelected = function(ev) {
            var m = calendar.multiselect;
            return m._isInList(ev, m.initList);
        };

        this.multiselect._alert = function() {
            var m = calendar.multiselect;
            var list = [];
            for (var i = 0; i < m.list.length; i++) {
                var event = m.list[i];
                list.push(event.value());
            }
            alert(list.join("\n"));
        };

        this.multiselect.add = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            if (m._indexOf(ev) === -1) {
                m.list.push(ev);
            }
            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.remove = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            var i = m._indexOf(ev);
            if (i !== -1) {
                m.list.splice(i, 1);
            }
        };

        this.multiselect.clear = function(dontRedraw) {
            var m = calendar.multiselect;
            m.list = [];

            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.redraw = function() {
            //alert('redrawing');
            //calendar.debug("redrawing");
            var m = calendar.multiselect;
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (m.isSelected(div.event)) {
                    m._divSelect(div);
                }
                else {
                    m._divDeselect(div);
                }
            }
        };

        this.multiselect._divSelect = function(div) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            var div = m._findContentDiv(div);
            DayPilot.Util.addClass(div, cn);
            m.divs.push(div);
        };

        this.multiselect._findContentDiv = function(div) {
            return div;
        };

        this.multiselect._divDeselectAll = function() {
            var m = calendar.multiselect;
            for (var i = 0; i < m.divs.length; i++) {
                var div = m.divs[i];
                m._divDeselect(div, true);
            }
            m.divs = [];
        };

        this.multiselect._divDeselect = function(div, dontRemoveFromCache) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            var c = m._findContentDiv(div);
            if (c && c.className && c.className.indexOf(cn) !== -1) {
                c.className = c.className.replace(cn, "");
            }

            if (dontRemoveFromCache) {
                return;
            }
            var i = DayPilot.indexOf(m.divs, div);
            if (i !== -1) {
                m.divs.splice(i, 1);
            }

        };

        this.multiselect.isSelected = function(ev) {
            //return calendar.multiselect.indexOf(ev) != -1;
            return calendar.multiselect._isInList(ev, calendar.multiselect.list);
        };

        this.multiselect._indexOf = function(ev) {
            var data = ev.data;
            for (var i = 0; i < calendar.multiselect.list.length; i++) {
                var item = calendar.multiselect.list[i];
                if (calendar._isSameEvent(item.data, data)) {
                    return i;
                }
            }
            return -1;
        };

        this.multiselect._isInList = function(e, list) {
            if (!list) {
                return false;
            }
            for (var i = 0; i < list.length; i++) {
                var ei = list[i];
                if (calendar._isSameEvent(e, ei)) {
                    return true;
                }
            }

            return false;
        };

        this._isSameEvent = function(data1, data2) {
            return DayPilot.Util.isSameEvent(data1, data2);
        };

        this.events.forRange = function(start, end) {
            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);

            return DayPilot.list(calendar.events.list).filter(function(item) {
                var estart = new DayPilot.Date(item.start);
                var eend = new DayPilot.Date(item.end);

                var startPointOnly = estart === eend && estart === start;
                return startPointOnly || DayPilot.Util.overlaps(start, end, estart, eend);
            }).map(function(item) {
                return new DayPilot.Event(item, calendar);
            });
        };

        this.events.find = function(id) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }

            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].id === id) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        this.events.findRecurrent = function(masterId, time) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }
            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].recurrentMasterId === masterId && calendar.events.list[i].start.getTime() === time.getTime()) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        this.events.update = function(e, data) {
            var params = {};
            params.oldEvent = new DayPilot.Event(e.copy(), calendar);
            params.newEvent = new DayPilot.Event(e.temp(), calendar);

            var action = new DayPilot.Action(calendar, "EventUpdate", params, data);

            e.commit();

            if (calendar._initialized) {
                calendar.update();
            }

            calendar._angular.notify();

            return action;
        };


        this.events.remove = function(e, data) {

            var params = {};
            params.e = new DayPilot.Event(e.data, calendar);

            var action = new DayPilot.Action(calendar, "EventRemove", params, data);

            var index = DayPilot.indexOf(calendar.events.list, e.data);
            calendar.events.list.splice(index, 1);

            if (calendar._initialized) {
                calendar.update();
            }

            calendar._angular.notify();

            return action;
        };

        this.events.add = function(e, data) {

            if (!(e instanceof DayPilot.Event)) {
                e = new DayPilot.Event(e);
            }

            e.calendar = calendar;

            if (!calendar.events.list) {
                calendar.events.list = [];
            }

            calendar.events.list.push(e.data);

            var params = {};
            params.e = e;

            var action = new DayPilot.Action(calendar, "EventAdd", params, data);

            if (calendar._initialized) {
                calendar.update();
            }

            calendar._angular.notify();

            return action;

        };

        this.events.filter = function(args) {
            calendar.events._filterParams = args;
            calendar._update();
        };

        this.events.load = function(url, success, error) {
            var onError = function (args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function (args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function () {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.events.list = data;
                    if (calendar._initialized) {
                        calendar.update();
                    }
                }
            };

            var usePost = calendar.eventsLoadMethod && calendar.eventsLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "data": {"start": calendar.visibleStart().toString(), "end": calendar.visibleEnd().toString()},
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                var fullUrl = url;
                var queryString = "start=" + calendar.visibleStart().toString() + "&end=" + calendar.visibleEnd().toString();
                if (fullUrl.indexOf("?") > -1) {
                    fullUrl += "&" + queryString;
                }
                else {
                    fullUrl += "?" + queryString;
                }

                DayPilot.ajax({
                    "method": "GET",
                    "url": fullUrl,
                    "success": onSuccess,
                    "error": onError
                });
            }
        };

        this._react = {};
        this._react.reactDOM = null;
        this._react.react = null;
        this._react._render = function(component, target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                if (!root) {
                    root = rd.createRoot(target);
                    target._root = root;
                }
                root.render(component);
            }
            else {
                rd.render(component, target);
            }

        };
        this._react._unmount = function(target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                setTimeout(function() {
                    root.unmount();
                }, 0);
            }
            else {
                rd.unmountComponentAtNode(target);
            }
        };

        this.queue = {};
        this.queue.list = [];
        this.queue.list.ignoreToJSON = true;

        this.queue.add = function(action) {
            if (!action) {
                return;
            }
            if (action.isAction) {
                calendar.queue.list.push(action);
            }
            else {
                throw "DayPilot.Action object required for queue.add()";
            }
        };

        this.queue.notify = function(data) {
            var params = {};
            params.actions = calendar.queue.list;
            calendar._callBack2('Notify', params, data, "Notify");

            calendar.queue.list = [];
        };


        this.queue.clear = function() {
            calendar.queue.list = [];
        };

        this.queue.pop = function() {
            return calendar.queue.list.pop();
        };

        this._adjustEndOut = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            if (date.getDatePart().ticks === date.ticks) {
                return date.addDays(-1);
            }
            return date.getDatePart();
        };

        this._adjustEndIn = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            return date.getDatePart().addDays(1);
        };

        this._adjustEndNormalize = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            return date.getDatePart();
        };

        // interval defined in seconds, minimum 30 seconds
        this._startAutoRefresh = function(forceEnabled) {

            if (forceEnabled) {
                this.autoRefreshEnabled = true;
            }

            if (!this.autoRefreshEnabled) {
                return;
            }

            if (this._autoRefreshCount >= this.autoRefreshMaxCount) {
                return;
            }

            //this.autoRefreshCount = 0; // reset
            this._stopAutoRefresh();

            var interval = this.autoRefreshInterval;
            if (!interval || interval < 10) {
                throw "The minimum autoRefreshInterval is 10 seconds";
            }

            //this.autoRefresh = interval * 1000;
            this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
        };

        this._stopAutoRefresh = function() {
            if (this.autoRefreshTimeout) {
                window.clearTimeout(this.autoRefreshTimeout);
            }
        };

        this._doRefresh = function() {
            if (!DayPilotMonth.eventResizing && !DayPilotMonth.eventMoving && !DayPilotMonth.timeRangeSelecting) {
                var skip = false;
                if (typeof this.onAutoRefresh === 'function') {
                    var args = {};
                    args.i = this._autoRefreshCount;
                    args.preventDefault = function() {
                        this.preventDefault.value = true;
                    };

                    calendar.onAutoRefresh(args);
                    if (args.preventDefault.value) {
                        skip = true;
                    }
                }
                if (!skip && this._serverBased()) {
                    this.commandCallBack(this.autoRefreshCommand);
                }
                this._autoRefreshCount++;

                /*
                this.autoRefreshCount++;
                this.commandCallBack(this.autoRefreshCommand);
                */
            }
            if (this._autoRefreshCount < this.autoRefreshMaxCount) {
                this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
            }
        };

        this._update = function(args) {
            if (!this.cells) {  // not initialized yet
                return;
            }

            var args = args || {};
            var full = !args.eventsOnly;

            if (!calendar.cssOnly) {
                calendar.cssOnly = true;
            }

            calendar._deleteEvents();
            calendar._prepareRows();
            calendar._loadEvents();

            if (full) {
                //calendar._updateHeight();
                calendar._resolved.clearCache();
                calendar._clearTable();
                calendar._drawTable();
            }
            calendar._updateHeight();
            calendar._show();
            calendar._drawEvents();

            if (this.visible) {
                this.show();
            }
            else {
                this.hide();
            }

        };

        this.update = function(options) {

            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Month instance that hasn't been initialized yet.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Month instance that has been disposed.");
            }

            this._loadOptions(options);
            this._update();
        };

        this.dispose = function() {
            //var start = new Date();

            var c = calendar;
            if (!c.nav.top) {
                return;
            }

            c._stopAutoRefresh();
            c._deleteEvents();

            c.nav.top.removeAttribute("style");
            c.nav.top.removeAttribute("class");
            c.nav.top.innerHTML = '';
            c.nav.top.dp = null;

            c.nav.top.onmousemove = null;

            DayPilot.ue(c.nav.top, "touchstart", touch.onMainTouchStart);
            DayPilot.ue(c.nav.top, "touchmove", touch.onMainTouchMove);
            DayPilot.ue(c.nav.top, "touchend", touch.onMainTouchEnd);

            c.nav.top = null;

            DayPilot.ue(window, "resize", c._onResize);

            DayPilotMonth.unregister(c);

            if (typeof DayPilot.Bubble !== "undefined") {
                DayPilot.Bubble.cancelShowing();
                DayPilot.Bubble.hide({"calendar": c});
            }

            if (typeof DayPilot.Menu !== "undefined") {
                DayPilot.Menu.hide({"calendar": c});
            }
        };

        this._registerGlobalHandlers = function() {
            if (!DayPilotMonth.globalHandlers) {
                DayPilotMonth.globalHandlers = true;
                DayPilot.re(document, 'mousemove', DayPilotMonth.gMouseMove);
                DayPilot.re(document, 'mouseup', DayPilotMonth.gMouseUp);

                DayPilot.reNonPassive(document, "touchmove", DayPilotMonth.gMouseMove);
            }
            DayPilot.re(window, "resize", this._onResize);
        };

        this._out = function() {
            doNothing();
        };

        this._deleteDragSource = function() {
            if (calendar.todo) {
                if (calendar.todo.del) {
                    var del = calendar.todo.del;
                    del.parentNode.removeChild(del);
                    calendar.todo.del = null;
                }
            }
        };

        this._versionCheck = function() {

            // check licensing restrictions

            switch (calendar._productCode) {
                case "aspnet":
                    if (!this._isAspnetWebForms()) {
                        throw new DayPilot.Exception("ASP.NET WebForms environment required. https://doc.daypilot.org/common/asp-net-webforms-required/");
                    }
                    break;
                case "netmvc":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-asp-net-mvc/");
                    }
                    break;
                case "javaxx":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-java/");
                    }
                    break;
            }
        };

        this._show = function() {
            if (this.nav.top.style.visibility === 'hidden') {
                this.nav.top.style.visibility = 'visible';
            }
        };

        this.show = function() {
            calendar.visible = true;
            calendar.nav.top.style.display = '';
        };

        this.hide = function() {
            calendar.visible = false;
            calendar.nav.top.style.display = 'none';
        };

        this._loadTop = function() {
            if (this.id && this.id.tagName) {
                this.nav.top = this.id;
            }
            else if (typeof this.id === "string") {
                this.nav.top = document.getElementById(this.id);
                if (!this.nav.top) {
                    throw "DayPilot.Month: The placeholder element not found: '" + id + "'.";
                }
            }
            else {
                throw "DayPilot.Month() constructor requires the target element or its ID as a parameter";
            }
            this.nav.limit;
        };


        this._initShort = function() {

            this._loadTop();
            this._prepareRows();
            this._drawTop();
            this._drawTable();
            this._updateHeight();
            this._registerGlobalHandlers();
            this._startAutoRefresh();
            this._callBack2('Init'); // load events

            DayPilotMonth.register(this);
        };

        this.init = function() {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.")
            }

            this._loadTop();

            if (this.nav.top.dp) {
                if (this.nav.top.dp === calendar) {
                    return calendar;
                }
                if (this._isAspnetWebForms()) { // updatepanel
                    return calendar;
                }
                throw new DayPilot.Exception("The target placeholder was already initialized by another DayPilot component instance.");
            }

            this._versionCheck();

            var loadFromServer = resolved.loadFromServer();

            if (!calendar.cssOnly) {
                calendar.cssOnly = true;
                window.console && window.console.log && window.console.log("DayPilot: cssOnly = false mode is not supported since DayPilot Pro 8.0.");
            }

            if (loadFromServer) {
                this._initShort();
                this._initialized = true;
                return this;
            }

            this._prepareRows();
            this._loadEvents();
            this._drawTop();
            this._drawTable();
            this._show();
            this._drawEvents();
            this._updateHeight();

            this._registerGlobalHandlers();

            if (this.messageHTML) {
                window.setTimeout(function() { calendar.message(calendar.messageHTML); }, 0);
            }

            this._fireAfterRenderDetached(null, false);

            if (calendar.initEventEnabled) {
                setTimeout(function() {
                    calendar._callBack2("Init");
                });
            }


            this._startAutoRefresh();
            DayPilotMonth.register(this);

            this._initialized = true;
            this._postInit();

            return this;
        };

        this._specialHandling = null;
        this._loadOptions = function(options) {
            if (!options) {
                return;
            }
            var specialHandling = {
                "events": {
                    "preInit": function() {
                        var events = this.data;
                        if (!events) {
                            return;
                        }
                        if (DayPilot.isArray(events.list)) {
                            calendar.events.list = events.list;
                        }
                        else {
                            calendar.events.list = events;
                        }
                    }
                }
            };
            this._specialHandling = specialHandling;

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    calendar[name] = options[name];
                }
            }

        };

        this._postInit = function() {
            var specialHandling = this._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
        };


        // communication between components
        this.internal = {};
        // ASP.NET
        this.internal.initialized = function() {
            return calendar._initialized;
        };
        // DayPilot.Action
        this.internal.invokeEvent = this._invokeEvent;
        // DayPilot.Menu
        this.internal.eventMenuClick = this._eventMenuClick;
        this.internal.timeRangeMenuClick = this._timeRangeMenuClick;
        // DayPilot.Bubble
        this.internal.bubbleCallBack = this._bubbleCallBack;
        this.internal.findEventDiv = this._findEventDiv;

        // common/DayPilot.Event
        this.internal.adjustEndIn = this._adjustEndIn;
        this.internal.xssTextHtml = calendar._xssTextHtml;

        // areas
        this.internal.touch = calendar._touch;

        // React
        this.internal.enableReact = function (react, reactDOM) {
            calendar._react.react = react;
            calendar._react.reactDOM = reactDOM;
        };
        this.internal.reactRefs = function() {
            return DayPilot.Util.copyProps(calendar._react, {}, ["react", "reactDOM"]);
        };

        // Angular
        this.internal.loadOptions = calendar._loadOptions;

        this.Init = this.init;

        // API compatibility (common)
        Object.defineProperty(this, 'durationBarVisible', { get: function() { return calendar.eventBarVisible; } });

        this._loadOptions(options);
    };


    /*
     * options: {
     *      element: dom element,
     *      duration: duration in minutes,
     *      text: event text,
     *      id: id,
     *      keepElement: whether to keep the original element
     * }
     */
    DayPilot.Month.makeDraggable = function(options) {
        var element = options.element;
        var removeElement = options.keepElement ? null : element;
        var duration = options.duration || 1;

        if (navigator.msPointerEnabled) {
            element.style.msTouchAction = "none";
            element.style.touchAction = "none";
        }

        var mousedown = function(ev) {

            startDragging();

            var element = (ev.target || ev.srcElement);
            if(element.tagName) {
                var tagname = element.tagName.toLowerCase();
                if(tagname === "textarea" || tagname === "select" || tagname === "input") {
                    return false;
                }
            }
            ev.preventDefault && ev.preventDefault();
            return false;

        };

        var touchstart = function(ev) {

            if (DayPilot.Util.isMouseEvent(ev)) {
                return;
            }

            var holdfor = 0;

            window.setTimeout(function() {
                startDragging();

                DayPilotMonth.gMouseMove(ev);

                ev.preventDefault();
            }, holdfor);

            ev.preventDefault();
        };

        function startDragging() {
            // TODO create drag.event = new DayPilot.Event() here
            // TODO merge with DayPilot.Scheduler.startDragging()

            var ds = options.duration || 60;

            if (ds instanceof DayPilot.Duration) {
                ds = ds.totalSeconds();
            }

            var drag = DayPilotMonth.drag = {};
            drag.element = removeElement;
            drag.id = options.id;
            drag.duration = ds;
            drag.text = options.text || "";
            drag.data = options;
            drag.shadowType = "Fill";
        }

        //element.addEventListener(DayPilot.touch.start, touchstart, false);
        DayPilot.us(element);  // make it unselectable
        DayPilot.re(element, "mousedown", mousedown);
        DayPilot.re(element, DayPilot.touch.start, touchstart);

        element.cancelDraggable = function() {
            DayPilot.ue(element, "mousedown", mousedown);
            DayPilot.ue(element, DayPilot.touch.start, touchstart);
            delete element.cancelDraggable;
        };

    };

    DayPilotMonth.createGShadow = function() {

        var shadow = document.createElement('div');
        shadow.setAttribute('unselectable', 'on');
        shadow.style.position = 'absolute';
        shadow.style.width = '100px';
        shadow.style.height = '20px';
        shadow.style.border = '2px dotted #666666';
        shadow.style.zIndex = 101;
        shadow.style.pointerEvents = "none";

        shadow.style.backgroundColor = "#aaaaaa";
        shadow.style.opacity = 0.5;
        shadow.style.filter = "alpha(opacity=50)";
        shadow.style.border = '2px solid #aaaaaa';

        document.body.appendChild(shadow);

        return shadow;
    };


    DayPilotMonth.gMouseMove = function(ev) {

        if (typeof (DayPilotMonth) === 'undefined') {
            return;
        }

        // quick and dirty inside detection
        // hack, but faster than recursing through the parents
        if (ev.insideMainD) {  // FF
            return;
        }
        else if (ev.srcElement) {  // IE
            if (ev.srcElement.inside) {
                return;
            }
        }

        var mousePos = DayPilot.mc(ev);

        if (DayPilotMonth.drag) {

            document.body.style.cursor = 'move';
            if (!DayPilotMonth.gShadow) {
                DayPilotMonth.gShadow = DayPilotMonth.createGShadow();
            }


            var shadow = DayPilotMonth.gShadow;
            shadow.style.left = mousePos.x + 'px';
            shadow.style.top = mousePos.y + 'px';

            // is this necessary?
            DayPilotMonth.movingEvent = null;

            DayPilot.de(DayPilotMonth.movingShadow);
            DayPilotMonth.movingShadow = null;

        }

        for (var i = 0; i < DayPilotMonth.registered.length; i++) {
            if (DayPilotMonth.registered[i]._out) {
                DayPilotMonth.registered[i]._out();
            }
        }

    };


    DayPilotMonth.register = function(calendar) {
        if (!DayPilotMonth.registered) {
            DayPilotMonth.registered = [];
        }
        for (var i = 0; i < DayPilotMonth.registered.length; i++) {
            if (DayPilotMonth.registered[i] === calendar) {
                return;
            }
        }
        DayPilotMonth.registered.push(calendar);

    };

    DayPilotMonth.unregister = function(calendar) {
        var a = DayPilotMonth.registered;
        if (a) {
            var i = DayPilot.indexOf(a, calendar);
            if (i !== -1) {
                a.splice(i, 1);
            }
            if (a.length === 0) {
                a = null;
            }
        }

        if (!a) {
            DayPilot.ue(document, 'mouseup', DayPilotMonth.gMouseUp);
            DayPilotMonth.globalHandlers = false;
        }
    };


    DayPilotMonth.gMouseUp = function(ev) {

        cleanGlobalShadow();

        if (DayPilotMonth.movingEvent) {
            var src = DayPilotMonth.movingEvent;
            DayPilotMonth.movingEvent = null;

            if (!src.event || !src.event.calendar || !src.event.calendar.shadow || !src.event.calendar.shadow.start) {
                return;
            }

            // load ref
            var calendar = src.event.calendar;
            var e = src.event;
            var start = calendar.shadow.start;
            var position = calendar.shadow.position;
            var offset = src.offset;
            var external = src.external;


            var removeElement = src.removeElement;
            if (removeElement) {
                if (!calendar.todo) {
                    calendar.todo = {};
                }
                calendar.todo.del = removeElement;
            }

            var disabled = calendar.shadow.disabled;

            // cleanup
            calendar._clearShadow();
            //DayPilotMonth.movingEvent = null;

            var ev = ev || window.event;

            // fire the event
            if (!disabled) {
                calendar._eventMoveDispatch(e, start.x, start.y, offset, ev, position, external);
            }

            ev.cancelBubble = true;
            if (ev.stopPropagation) {
                ev.stopPropagation();
            }
            return false;
        }
        else if (DayPilotMonth.resizingEvent) {
            var src = DayPilotMonth.resizingEvent;
            DayPilotMonth.resizingEvent = null;

            if (!src.event || !src.event.calendar || !src.event.calendar.shadow || !src.event.calendar.shadow.start) {
                return;
            }

            // load ref
            var calendar = src.event.calendar;

            var e = src.event;
            var start = calendar.shadow.start;
            var width = calendar.shadow.width;

            var disabled = calendar.shadow.disabled;

            // cleanup
            calendar._clearShadow();

            // fire the event
            if (!disabled) {
                calendar._eventResizeDispatch(e, start, width);
            }

            ev.cancelBubble = true;
            return false;
        }
        else if (DayPilotMonth.timeRangeSelecting) {
            //DayPilotMonth.cancelCellClick = true;

            // required for shadow displayed on mousedown (prevents oncellclick)
            // var triggerWhenNotMoved = true;
            if (DayPilotMonth.timeRangeSelecting.moved) {
                var sel = DayPilotMonth.timeRangeSelecting;
                var calendar = sel.root;

                var start = new DayPilot.Date(calendar._getDateFromCell(sel.from.x, sel.from.y));
                var end = start.addDays(sel.width);
                if (!calendar.shadow.disabled) {
                    calendar._timeRangeSelectedDispatch(start, end);
                }
                else {
                    calendar.clearSelection();
                }

            }
            else {
                var sel = DayPilotMonth.timeRangeSelecting;
                var calendar = sel.root;
                var cell = calendar.cells[sel.from.x][sel.from.y];
                calendar._onCellClick.apply(cell);
            }
            DayPilotMonth.timeRangeSelecting = null;
        }

        function cleanGlobalShadow() {
            // clean up external drag helpers
            if (DayPilotMonth.drag) {
                DayPilotMonth.drag = null;

                document.body.style.cursor = '';
            }

            if (DayPilotMonth.gShadow) {
                document.body.removeChild(DayPilotMonth.gShadow);
                DayPilotMonth.gShadow = null;
            }
        }

    };

    // experimental jQuery bindings
    if (typeof jQuery !== 'undefined') {
        (function($) {
            $.fn.daypilotMonth = function(options) {
                var first = null;
                var j = this.each(function() {
                    if (this.daypilot) { // already initialized
                        return;
                    };

                    var daypilot = new DayPilot.Month(this.id, options);
                    daypilot.init();
                    this.daypilot = daypilot;
                    /*
                    for (var name in options) {
                        daypilot[name] = options[name];
                    }*/
                    if (!first) {
                        first = daypilot;
                    }
                });
                if (this.length === 1) {
                    return first;
                }
                else {
                    return j;
                }
            };
        })(jQuery);
    }

    (function registerAngularModule() {

        var app = DayPilot.am();

        if (!app) {
            return;
        }

        app.directive("daypilotMonth", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element.replaceWith(this["template"].replace("{{id}}", attrs["id"]));

                    return function link(scope, element, attrs) {
                        var calendar = new DayPilot.Month(element[0]);
                        calendar._angular.scope = scope;
                        calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Calendar object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }

                            }
                        }

                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        var events = attrs["events"] || attrs["daypilotEvents"];

                        watch.call(scope, config, function (value, oldVal) {
                            for (var name in value) {
                                calendar[name] = value[name];
                            }
                            calendar.update();
                        }, true);

                        watch.call(scope, events, function(value) {
                            calendar.events.list = value;
                            calendar._update({"eventsOnly": true});
                        }, true);

                    };
                }
            };
        }]);
    })();

    DayPilot.Month.def = {};

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Navigator !== 'undefined' && DayPilot.Navigator.def) {
        return;
    }

    var DayPilotNavigator = {};
    DayPilot.Navigator = function(id, options) {
        this.v = '2023.2.5592';
        var calendar = this;
        this.id = id;
        this.api = 2;
        this.isNavigator = true;

        this.autoFocusOnClick = true;
        this.weekStarts = 'Auto'; // 0 = Sunday, 1 = Monday, ... 'Auto' = according to locale
        this.selectMode = 'day'; // day/week/month/none
        this.titleHeight = 30;
        this.dayHeaderHeight = 30;
        this.bound = null;
        this.cellWidth = 30;
        this.cellHeight = 30;
        this.cssOnly = true;
        this.cssClassPrefix = "navigator_default";
        this.freeHandSelectionEnabled = false;
        this.selectionStart = new DayPilot.Date().getDatePart();  // today
        this.selectionEnd = null;
        this.selectionDay = null;
        this.showMonths = 1;
        this.skipMonths = 1;
        this.command = "navigate";
        this.year = new DayPilot.Date().getYear();
        this.month = new DayPilot.Date().getMonth() + 1;
        this.showWeekNumbers = false;
        this.weekNumberAlgorithm = 'Auto';
        this.rowsPerMonth = 'Six';  // Six, Auto
        this.orientation = "Vertical";
        this.locale = "en-us";
        this.rtl = false;
        this.visible = true;

        this.timeRangeSelectedHandling = "Bind";
        this.visibleRangeChangedHandling = "Enabled";

        this.onVisibleRangeChange = null;
        this.onVisibleRangeChanged = null;
        this.onTimeRangeSelect = null;
        this.onTimeRangeSelected = null;

        this.nav = {};

        this._cache = {};

        this._prepare = function() {

            this.root.dp = this;

            if (this.cssOnly) {
                this.root.className = this._prefixCssClass('_main');
            }
            else {
                this.root.className = this._prefixCssClass('main');
            }

            if (this.orientation === "Horizontal") {
                this.root.style.width = this.showMonths * (resolved.cellWidth() * 7 + this._weekNumberWidth()) + 'px';
                this.root.style.height = (this.cellHeight*6 + this.titleHeight + this.dayHeaderHeight) + 'px';
            }
            else {
                this.root.style.width = (resolved.cellWidth() * 7 + this._weekNumberWidth()) + 'px';
            }
            //this.root.style.height = (this.showMonths*(this.cellHeight*6 + this.titleHeight + this.dayHeaderHeight)) + 'px';

            if (this.rtl) {
                this.root.style.direction = "rtl";
            }

            this.root.style.position = "relative";

            if (!this.visible) {
                this.root.style.display = "none";
            }

            var vsph = document.createElement("input");
            vsph.type = 'hidden';
            vsph.name = calendar.id + "_state";
            vsph.id = vsph.name;
            //vsph.value = result.VsUpdate;
            this.root.appendChild(vsph);
            this.state = vsph;

            if (!this.startDate) {
                this.startDate = DayPilot.Date.fromYearMonthDay(this.year, this.month);
            }
            else { // make sure it's the first day
                this.startDate = new DayPilot.Date(this.startDate).firstDayOfMonth();
            }

            this.calendars = [];
            this.selected = [];
            this.months = [];
            /*
            var bound = eval(this.bound);
            if (bound && typeof (bound.listener) == 'function') {
            bound.listener(this);
            }*/
        };

        this._api2 = function() {
            return calendar.api === 2;
        };

        this._clearTable = function() {
            // TODO do something smarter here
            this.root.innerHTML = '';
        };

        this._prefixCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            if (prefix) {
                return prefix + part;
            }
            else {
                return "";
            }
        };

        this._addClass = function(object, name) {
            var fullName = this.cssOnly ? this._prefixCssClass("_" + name) : this._prefixCssClass(name);
            DayPilot.Util.addClass(object, fullName);
        };

        this._removeClass = function(object, name) {
            var fullName = this.cssOnly ? this._prefixCssClass("_" + name) : this._prefixCssClass(name);
            DayPilot.Util.removeClass(object, fullName);
        };

        this._drawTable = function(j, showLinks) {
            var month = {};
            month.cells = [];
            month.days = [];
            month.weeks = [];

            var startDate = this.startDate.addMonths(j);

            var showBefore = showLinks.before;
            var showAfter = showLinks.after;

            var firstOfMonth = startDate.firstDayOfMonth();
            var first = firstOfMonth.firstDayOfWeek(resolved.weekStarts());

            var last = firstOfMonth.addMonths(1);
            var days = DayPilot.DateUtil.daysDiff(first, last);

            var rowCount = (this.rowsPerMonth === "Auto") ? Math.ceil(days / 7) : 6;
            month.rowCount = rowCount;
            var today = (new DayPilot.Date()).getDatePart();

            var width = resolved.cellWidth() * 7 + this._weekNumberWidth();
            month.width = width;
            var height = this.cellHeight * rowCount + this.titleHeight + this.dayHeaderHeight;
            month.height = height;

            var main = document.createElement("div");
            main.style.width = (width) + 'px';
            main.style.height = (height) + 'px';


            if (this.orientation === "Horizontal") {
                main.style.position = "absolute";
                main.style.left = (width * j) + "px";
                main.style.top = "0px";

                month.top = 0;
                month.left = width * j;
            }
            else {
                main.style.position = 'relative';

                var above = j > 0 ? calendar.months[j - 1].top + calendar.months[j - 1].height : 0;
                month.top = above;

                month.left = 0;
            }
            if (this.cssOnly) {
                main.className = this._prefixCssClass('_month');
            }
            else {
                main.className = this._prefixCssClass('month');
            }

            main.style.cursor = 'default';
            main.style.MozUserSelect = 'none';
            main.style.KhtmlUserSelect = 'none';
            main.style.WebkitUserSelect = 'none';

            main.month = month;

            this.root.appendChild(main);

            var totalHeaderHeight = this.titleHeight + this.dayHeaderHeight;

            // title left
            var tl = document.createElement("div");
            tl.style.position = 'absolute';
            tl.style.left = '0px';
            tl.style.right = '0px';  // rtl
            tl.style.top = '0px';
            tl.style.width = resolved.cellWidth() + 'px';
            tl.style.height = this.titleHeight + 'px';
            tl.style.lineHeight = this.titleHeight + 'px';
            //tl.style.textAlign = 'left';
            tl.setAttribute("unselectable", "on");
            if (this.cssOnly) {
                tl.className = this._prefixCssClass('_titleleft');
            }
            else {
                tl.className = this._prefixCssClass('titleleft');
            }
            if (showLinks.left) {
                tl.style.cursor = 'pointer';
                tl.innerHTML = "<span>&lt;</span>";
                tl.onclick = this._clickLeft;
            }
            main.appendChild(tl);
            this.tl = tl;

            // title center
            var ti = document.createElement("div");
            ti.style.position = 'absolute';
            ti.style.left = resolved.cellWidth() + 'px';
            ti.style.top = '0px';
            ti.style.width = (resolved.cellWidth() * 5 + this._weekNumberWidth()) + 'px';
            ti.style.height = this.titleHeight + 'px';
            ti.style.lineHeight = this.titleHeight + 'px';
            //ti.style.textAlign = 'center';
            ti.setAttribute("unselectable", "on");
            if (this.cssOnly) {
                ti.className = this._prefixCssClass('_title');
            }
            else {
                ti.className = this._prefixCssClass('title');
            }
            ti.innerHTML = resolved.locale().monthNames[startDate.getMonth()] + ' ' + startDate.getYear();
            main.appendChild(ti);
            this.ti = ti;

            // title right
            var tr = document.createElement("div");
            tr.style.position = 'absolute';
            tr.style.left = (resolved.cellWidth() * 6 + this._weekNumberWidth()) + 'px';
            tr.style.right = (resolved.cellWidth() * 6 + this._weekNumberWidth()) + 'px';  // rtl
            tr.style.top = '0px';
            tr.style.width = resolved.cellWidth() + 'px';
            tr.style.height = this.titleHeight + 'px';
            tr.style.lineHeight = this.titleHeight + 'px';
            //tr.style.textAlign = 'right';
            tr.setAttribute("unselectable", "on");
            if (this.cssOnly) {
                tr.className = this._prefixCssClass('_titleright');
            }
            else {
                tr.className = this._prefixCssClass('titleright');
            }
            if (showLinks.right) {
                tr.style.cursor = 'pointer';
                tr.innerHTML = "<span>&gt;</span>";
                tr.onclick = this._clickRight;
            }
            main.appendChild(tr);
            this.tr = tr;


            var xOffset = this._weekNumberWidth();
            if (this.showWeekNumbers) {
                for (var y = 0; y < rowCount; y++) {
                    var day = first.addDays(y * 7);
                    var weekNumber = null;
                    switch (this.weekNumberAlgorithm) {
                        case "Auto":
                            weekNumber = (resolved.weekStarts() === 1) ? day.weekNumberISO() : day.weekNumber();
                            break;
                        case "US":
                            weekNumber = day.weekNumber();
                            break;
                        case "ISO8601":
                            weekNumber = day.weekNumberISO();
                            break;
                        default:
                            throw "Unknown weekNumberAlgorithm value.";
                    }

                    var dh = document.createElement("div");
                    dh.style.position = 'absolute';
                    dh.style.left = (0) + 'px';
                    dh.style.right = (0) + 'px';
                    dh.style.top = (y * this.cellHeight + totalHeaderHeight) + 'px';
                    dh.style.width = resolved.cellWidth() + 'px';
                    dh.style.height = this.cellHeight + 'px';
                    dh.style.lineHeight = this.cellHeight + 'px';
                    //dh.style.textAlign = 'right';
                    dh.setAttribute("unselectable", "on");
                    if (this.cssOnly) {
                        dh.className = this._prefixCssClass('_weeknumber');
                    }
                    else {
                        dh.className = this._prefixCssClass('weeknumber');
                    }
                    //dh.innerHTML = "<span style='margin-right: 2px'>" + weekNumber + "</span>";
                    dh.innerHTML = "<span>" + weekNumber + "</span>";
                    main.appendChild(dh);
                    month.weeks.push(dh);
                }
            }


            for (var x = 0; x < 7; x++) {
                month.cells[x] = [];

                // day header
                var dh = document.createElement("div");
                dh.style.position = 'absolute';
                dh.style.left = (x * resolved.cellWidth() + xOffset) + 'px';
                dh.style.right = (x * resolved.cellWidth() + xOffset) + 'px';  // rtl
                dh.style.top = this.titleHeight + 'px';
                dh.style.width = resolved.cellWidth() + 'px';
                dh.style.height = this.dayHeaderHeight + 'px';
                dh.style.lineHeight = this.dayHeaderHeight + 'px';
                //dh.style.textAlign = 'right';
                dh.setAttribute("unselectable", "on");
                if (this.cssOnly) {
                    dh.className = this._prefixCssClass('_dayheader');
                }
                else {
                    dh.className = this._prefixCssClass('dayheader');
                }
                dh.innerHTML = "<span>" + this._getDayName(x) + "</span>";
                main.appendChild(dh);
                month.days.push(dh);

                for (var y = 0; y < rowCount; y++) {
                    var day = first.addDays(y * 7 + x);

                    var isSelected = this._isSelected(day) && this._selectModeLowerCase() !== 'none';
                    var isCurrentMonth = day.firstDayOfMonth() === startDate;
                    var isPrevMonth = day < startDate;
                    var isNextMonth = day >= startDate.addMonths(1);

                    if (this._selectModeLowerCase() === "month") {
                        isSelected = isSelected && isCurrentMonth;
                    }
                    else if (this._selectModeLowerCase() === "day") {
                        isSelected = isSelected && (isCurrentMonth || (showBefore && isPrevMonth) || (showAfter && isNextMonth));
                    }
                    else if (this._selectModeLowerCase() === "week") {
                        //var sd = this.selectionDay || this.selectionStart;
                        var isSelectionCurrentMonth = day.firstDayOfMonth() === startDate;
                        isSelected = isSelected && (isSelectionCurrentMonth || (showBefore && isPrevMonth) || (showAfter && isNextMonth));
                    }

                    var dc = document.createElement("div");
                    month.cells[x][y] = dc;

                    var cellPos = calendar._cellRelativeCoords(x, y);
                    var left = cellPos.x;
                    var top = cellPos.y;

                    dc.day = day;
                    dc.x = x;
                    dc.y = y;
                    dc.left = left;
                    dc.top = top;
                    dc.isCurrentMonth = isCurrentMonth;
                    dc.isNextMonth = isNextMonth;
                    dc.isPrevMonth = isPrevMonth;
                    dc.showBefore = showBefore;
                    dc.showAfter = showAfter;

                    if (this.cssOnly) {
                        dc.className = this._prefixCssClass((isCurrentMonth ? '_day' : '_dayother'));
                    }
                    else {
                        dc.className = this._prefixCssClass((isCurrentMonth ? 'day' : 'dayother'));
                    }
                    calendar._addClass(dc, "cell");
                    if (day.getTime() === today.getTime() && isCurrentMonth) {
                        this._addClass(dc, 'today');
                    }
                    if (day.dayOfWeek() === 0 || day.dayOfWeek() === 6) {
                        this._addClass(dc, 'weekend');
                    }

                    dc.style.position = 'absolute';
                    dc.style.left = (left) + 'px';
                    dc.style.right = (left) + 'px';  // rtl
                    dc.style.top = (top) + 'px';
                    dc.style.width = resolved.cellWidth() + 'px';
                    dc.style.height = this.cellHeight + 'px';
                    dc.style.lineHeight = this.cellHeight + 'px'; // vertical alignment
                    //dc.style.textAlign = 'right';
                    //dc.style.border = '1px solid white';

                    var inner = document.createElement("div");
                    inner.style.position = 'absolute';
                    if (this.cssOnly) {
                        inner.className = (day.getTime() === today.getTime() && isCurrentMonth) ? this._prefixCssClass('_todaybox') : this._prefixCssClass('_daybox');
                    }
                    else {
                        inner.className = (day.getTime() === today.getTime() && isCurrentMonth) ? this._prefixCssClass('todaybox') : this._prefixCssClass('daybox');
                    }
                    calendar._addClass(inner, "cell_box");
                    //inner.style.boxSizing = "border-box";
                    inner.style.left = '0px';
                    inner.style.top = '0px';
                    inner.style.right = '0px';
                    inner.style.bottom = '0px';
                    //inner.style.width = (this.cellWidth - 2) + 'px';
                    //inner.style.height = (this.cellHeight - 2) + 'px';
                    dc.appendChild(inner);

                    /*
                    if (isCurrentMonth) {
                    dc.style.cursor = 'pointer';
                    }
                    */

                    var cell = null;
                    if (this.cells && this.cells[day.toStringSortable()]) {
                        cell = this.cells[day.toStringSortable()];
                    }

                    if (typeof calendar.onBeforeCellRender === "function") {
                        var args = {};
                        args.cell = cell || {};
                        args.cell.day = day;
                        args.cell.isCurrentMonth = isCurrentMonth;
                        args.cell.isToday = day.getTime() === today.getTime() && isCurrentMonth;
                        args.cell.isWeekend = day.dayOfWeek() === 0 || day.dayOfWeek() === 6;
                        if (cell) {
                            args.cell.html = cell.html || day.getDay();
                            args.cell.cssClass = cell.css;
                        }
                        else {
                            args.cell.html = day.getDay();
                            args.cell.cssClass = null;
                        }

                        calendar.onBeforeCellRender(args);

                        cell = args.cell;
                    }

                    if (cell) {
                        DayPilot.Util.addClass(dc, cell.cssClass || cell.css);
                    }

                    //var span = null;
                    if (isCurrentMonth || (showBefore && isPrevMonth) || (showAfter && isNextMonth)) {
                        var text = document.createElement("div");
                        text.innerHTML = day.getDay();
                        text.style.position = "absolute";
                        text.style.left = '0px';
                        text.style.top = '0px';
                        text.style.right = '0px';
                        text.style.bottom = '0px';
                        calendar._addClass(text, "cell_text");

                        // dc.style.cursor = 'pointer';
                        dc.isClickable = true;

                        if (cell && cell.html) {
                            text.innerHTML = cell.html;
                        }

                        dc.appendChild(text);
                    }


                    dc.setAttribute("unselectable", "on");

                    dc.onclick = this._cellClick;

                    main.appendChild(dc);

                    if (isSelected) {
                        calendar._cellSelect(main, x, y);
                        this.selected.push(dc);
                    }

                }
            }

            var line = document.createElement("div");
            line.style.position = 'absolute';
            line.style.left = '0px';
            line.style.top = (totalHeaderHeight - 2) + 'px';
            line.style.width = (resolved.cellWidth() * 7 + this._weekNumberWidth()) + 'px';
            line.style.height = '1px';
            line.style.fontSize = '1px';
            line.style.lineHeight = '1px';
            if (this.cssOnly) {
                line.className = this._prefixCssClass("_line");
            }
            else {
                line.className = this._prefixCssClass("line");
            }
            //line.style.borderBottom = '1px solid black';

            main.appendChild(line);
            this.months.push(month);
        };

        this._cellRelativeCoords = function(x, y) {
            var totalHeaderHeight = this.titleHeight + this.dayHeaderHeight;
            var xOffset = this._weekNumberWidth();
            var left = x * resolved.cellWidth() + xOffset;
            var top = y * this.cellHeight + totalHeaderHeight;

            return {
                "x": left,
                "y": top
            };

        };

        this._cellSelect = function(main, x, y) {
            var div = main.month.cells[x][y];

            calendar._addClass(div, 'select');

            /*
            if (div.selectDiv) {
                return;
            }

            var xOffset = this._weekNumberWidth();
            var totalHeaderHeight = this.titleHeight + this.dayHeaderHeight;

            // overlay select
            var od = document.createElement("div");
            od.style.position = 'absolute';
            od.style.left = (x * this.cellWidth + xOffset) + 'px';
            od.style.top = (y * this.cellHeight + totalHeaderHeight) + 'px';
            od.style.width = this.cellWidth + 'px';
            od.style.height = this.cellHeight + 'px';
            od.className = calendar._prefixCssClass("_selected_overlay");

            div.selectDiv = od;

            main.appendChild(od);
            */
        };

        this._cellUnselect = function(main, x, y) {
            var div = main.month.cells[x][y];

            calendar._removeClass(div, 'select');

            /*
            DayPilot.de(div.selectDiv);
            div.selectDiv = null;
            */
        };

        this._weekNumberWidth = function() {
            if (this.showWeekNumbers) {
                return resolved.cellWidth();
            }
            return 0;
        };

        this._updateFreeBusy = function() {
            if (!this.items) {
                return;
            }

            for (var j = 0; j < this.showMonths; j++) {
                for (var x = 0; x < 7; x++) {
                    for (var y = 0; y < 6; y++) {
                        var cell = this.months[j].cells[x][y];
                        if (!cell) {
                            continue;
                        }
                        if (this.items[cell.day.toStringSortable()] === 1) {
                            this._addClass(cell, 'busy');
                            this._removeClass(cell, 'free');
                        }
                        else {
                            this._removeClass(cell, 'busy');
                            this._addClass(cell, 'free');
                        }
                    }
                }
            }
        };


        this._saveState = function() {
            var s = {};
            s.startDate = calendar.startDate;
            s.selectionStart = calendar.selectionStart;
            s.selectionEnd = calendar.selectionEnd.addDays(1);
            calendar.state.value = JSON.stringify(s);
        };

        this._selectModeLowerCase = function() {
            var selectMode = this.selectMode || "";
            return selectMode.toLowerCase();
        };

        this._adjustSelection = function() {

            var input = this.selectionDay || this.selectionStart;  // selectionDay is preferred
            if (!input) {
                input = DayPilot.Date.today();
            }
            input = new DayPilot.Date(input);  // make sure it's DayPilot.Date

            // ignores selectionEnd
            // uses selectMode
            switch (this._selectModeLowerCase()) {
                case 'day':
                    this.selectionStart = input;
                    this.selectionDay = input;
                    this.selectionEnd = input;
                    break;
                case 'week':
                    this.selectionDay = input;
                    this.selectionStart = input.firstDayOfWeek(resolved.weekStarts());
                    this.selectionEnd = this.selectionStart.addDays(6);
                    break;
                case 'month':
                    this.selectionDay = input;
                    this.selectionStart = input.firstDayOfMonth();
                    this.selectionEnd = this.selectionStart.lastDayOfMonth();
                    break;
                case 'none':
                    this.selectionEnd = input;
                    break;
                default:
                    throw "Unknown selectMode value.";
            }

        };

        this._postponedSelect = null;

        // options.dontFocus, options.dontNotify
        this.select = function(a1, a2, a3) {

            var a2IsDate = a2 && (a2 instanceof DayPilot.Date || typeof a2 === "string");
            var a2IsOptions = (a2 && typeof a2 === "object") || typeof a2 === "boolean";

            var date1 = a1;
            var date2 = a2IsDate ? a2 : null;
            var options = a2IsOptions ? a2 : a3;

            if (!this._initialized) {
                this._postponedSelect = {
                    "date1": date1,
                    "date2": date2,
                    "options": options
                };
                return;
            }

            var focus = true;
            var notify = true;  // fire the timeRangeSelected event

            if (options && typeof options === "object") {
                if (options.dontFocus) {
                    focus = false;
                }
                if (options.dontNotify) {
                    notify = false;
                }
            }
            else if (typeof options === "boolean") {
                focus = !options;
            }

            var originalStart = this.selectionStart;
            var originalEnd = this.selectionEnd;

            this.selectionStart = new DayPilot.Date(date1).getDatePart();
            this.selectionDay = this.selectionStart;

            var startChanged = false;
            if (focus) {

                var newStart = this.startDate;
                if (this.selectionStart < this._activeStart() || this.selectionStart >= this._activeEnd()) {
                    newStart = this.selectionStart.firstDayOfMonth();
                }

                if (newStart.toStringSortable() !== this.startDate.toStringSortable()) {
                    startChanged = true;
                }

                this.startDate = newStart;
            }

            if (date2 && calendar.freeHandSelectionEnabled) {
                calendar.selectionEnd = new DayPilot.Date(date2);
            }
            else {
                this._adjustSelection();
            }

            // redraw
            this._clearTable();
            this._prepare();
            this._drawMonths();
            this._updateFreeBusy();
            this._saveState();

            if (notify && (!originalStart.equals(this.selectionStart) || !originalEnd.equals(this.selectionEnd))) {
                //alert('time range');
                this._timeRangeSelectedDispatch();
            }

            if (startChanged) {
                //alert('visible range');
                this._visibleRangeChangedDispatch();
            }
        };

        this.update = function(options) {

            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Navigator instance that hasn't been initialized yet.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Navigator instance that has been disposed.");
            }

            calendar._clearCache();
            calendar._loadOptions(options);
            calendar._update();
        };

        this._update = function () {
            if (!calendar.cssOnly) {
                calendar.cssOnly = true;
            }

            // redraw
            this._clearTable();
            this._prepare();
            this._adjustSelection();
            this._drawMonths();
            this._loadEvents();
            this._updateFreeBusy();
            this._saveState();

            if (this.visible) {
                this.show();
            }
            else {
                this.hide();
            }
        };

        this._clearCache = function()  {
            calendar._cache = {};
        };

        this._specialHandling = null;
        this._loadOptions = function(options) {
            if (!options) {
                return;
            }
            var specialHandling = {
                "events": {
                    "preInit": function() {
                        var events = this.data;
                        if (!events) {
                            return;
                        }
                        if (DayPilot.isArray(events.list)) {
                            calendar.events.list = events.list;
                        }
                        else {
                            calendar.events.list = events;
                        }
                    }
                }
            };
            this._specialHandling = specialHandling;

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    calendar[name] = options[name];
                }
            }

        };

        this._postInit = function() {
            var specialHandling = this._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
        };


        this._callBack2 = function(action, data, parameters) {
            var envelope = {};
            envelope.action = action;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);

            var context = null;
            if (this.backendUrl) {
                DayPilot.request(this.backendUrl, this._callBackResponse, commandstring, this._ajaxError);
            }
            else {
                WebForm_DoCallback(this.uniqueID, commandstring, this._updateView, context, this.callbackError, true);
            }

        };

        this._ajaxError = function(req) {
            if (typeof calendar.onAjaxError === 'function') {
                var args = {};
                args.request = req;
                calendar.onAjaxError(args);
            }
            else if (typeof calendar.ajaxError === 'function') { // backwards compatibility
                calendar.ajaxError(req);
            }
        };

        this._callBackResponse = function(response) {
            calendar._updateView(response.responseText);
        };

        this._postBack2 = function(action, data, parameters) {
            var envelope = {};
            envelope.action = action;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);
            __doPostBack(calendar.uniqueID, commandstring);
        };

        this._getCallBackHeader = function() {
            var h = {};
            h.v = this.v;
            h.startDate = this.startDate;
            h.selectionStart = this.selectionStart;
            h.showMonths = this.showMonths;
            return h;
        };

        this._listen = function(action, data) {
            if (action === 'refresh') {
                this._visibleRangeChangedDispatch();
            }
        };

        this._getDayName = function(i) {
            var x = i + resolved.weekStarts();
            if (x > 6) {
                x -= 7;
            }
            return resolved.locale().dayNamesShort[x];

        };

        this._isSelected = function(date) {
            if (this.selectionStart === null || this.selectionEnd === null) {
                return false;
            }

            if (this.selectionStart.getTime() <= date.getTime() && date.getTime() <= this.selectionEnd.getTime()) {
                return true;
            }

            return false;
        };

        this._getMonthFromCoords = function(coords) {
            var month = 0;
            //debugger;
            for (var i = 0; i < calendar.months.length; i++) {
                var m = calendar.months[i];
                if (!m) {
                    return null;
                }
                if (coords.x < m.left || m.width < coords.x ) {
                    return null;
                }

                var height = calendar.months[i].height;
                if (m.top <= coords.y && coords.y < m.top + m.height) {
                    return i;
                }
            }
            return null;

        };

        this._getPosition = function(ev) {

            var coords = DayPilot.mo3(calendar.nav.top, ev);

            var monthIndex = calendar._getMonthFromCoords(coords);
            if (monthIndex === null) {
                return null;
            }
            var month = calendar.months[monthIndex];

            var totalHeaderHeight = this.titleHeight + this.dayHeaderHeight;
            if (month.top <= coords.y && coords.y < month.top + totalHeaderHeight) {
                return {
                    "month": monthIndex,
                    "x": 0,
                    "y": 0,
                    "coords": coords,
                    "header": true
                };
            }

            for (var x = 0; x < month.cells.length; x++) {
                for (var y = 0; y < month.cells[x].length; y++) {
                    var cell = month.cells[x][y];
                    var top = cell.top + month.top;
                    var left = cell.left + month.left;
                    if (left <= coords.x && coords.x < left + calendar.cellWidth) {
                        if (top <= coords.y && coords.y < top + calendar.cellHeight) {
                            return {
                                "month": monthIndex,
                                "x": x,
                                "y": y,
                                "coords": coords
                            };
                        }
                    }
                }
            }

            return null;
        };

        this._onTopMouseDown = function(ev) {
            var freeHandSelection = calendar.freeHandSelectionEnabled;
            if (!freeHandSelection) {
                return;
            }
            var start = calendar._getPosition(ev);
            if (start && !start.header) {
                ps.start = start;
            }
            var cell = calendar.months[start.month].cells[start.x][start.y];

            ev.preventDefault();

        };

        this._onTopMouseMove = function(ev) {
            if (!ps.start) {
                return;
            }
            var end = calendar._getPosition(ev);
            if (ps.end) {
                ps.end = end;
            }
            else if (end) {
                var requiredDistance = 3;
                var distance = DayPilot.distance(ps.start.coords, end.coords);

                if (distance > requiredDistance) {
                    ps.end = end;
                }
            }

            if (ps.end) {
                ps.clear();
                ps.draw();
            }
            //ps.end = end;
        };

        this._preselection = {};
        var ps = this._preselection;
        ps.start = null;

        ps.drawCell = function(pos) {
            var month = calendar.months[pos.month];

            var cellPos = calendar._cellRelativeCoords(pos.x, pos.y);

            var top = month.top + cellPos.y;
            var left = month.left + cellPos.x;

            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.left = left + "px";
            div.style.top = top + "px";
            div.style.height = calendar.cellHeight + "px";
            div.style.width = calendar.cellWidth + "px";
            div.style.backgroundColor = "#ccc";
            div.style.opacity = 0.5;
            div.style.cursor = "default";

            calendar.nav.preselection.appendChild(div);
            ps.cells.push(div);
        };

        ps.clear = function() {
            if (!ps.cells) {
                return;
            }

            for(var i = 0; i < ps.cells.length; i++) {
                calendar.nav.preselection.removeChild(ps.cells[i]);
            }
            ps.cells = [];
        };

        ps.draw = function() {
            var ordered = ps.ordered();

            var position = new Position(ordered.start);
            var end = ordered.end;

            if (!end) {
                return;
            }

            if (end === ps.end && end.header) {
                if (end.month > 0) {
                    end.month -= 1;
                    var month = calendar.months[end.month];
                    end.x = 6;
                    end.y = month.rowCount - 1;
                }
            }

            ps.cells = [];

            while (!position.is(end)) {
                ps.drawCell(position);
                var next = new Position(position).next();
                if (!next) {
                    return;
                }
                position.month = next.month;
                position.x = next.x;
                position.y = next.y;
            }

            // the last one
            ps.drawCell(position);

        };

        ps.ordered = function() {
            //var position = new Position(start);
            var start = ps.start;
            var end = ps.end;

            var result = {};
            if (!end || new Position(start).before(end)) {
                result.start = start;
                result.end = end;
            }
            else {
                result.start = end;
                result.end = start;
            }
            return result;
        };

        var Position = function(month, x, y) {

            if (month instanceof Position) {
                return month;
            }
            if (typeof month === "object") {
                var ref = month;
                this.month = ref.month;
                this.x = ref.x;
                this.y = ref.y;
            }
            else {
                this.month = month;
                this.x = x;
                this.y = y;
            }
            this.is = function(ref) {
                return this.month === ref.month && this.x === ref.x && this.y === ref.y;
            };

            this.next = function() {
                var start = this;
                if (start.x < 6) {
                    return {
                        "month": start.month,
                        "x": start.x + 1,
                        "y": start.y
                    };
                }
                var month = calendar.months[start.month];
                if (start.y < month.rowCount - 1) {
                    return {
                        "month": start.month,
                        "x": 0,
                        "y": start.y + 1
                    };
                }
                if (start.month < calendar.months.length - 1) {
                    return {
                        "month": start.month + 1,
                        "x": 0,
                        "y": 0
                    };
                }
                return null;
            };

            this.visible = function() {
                var cell = this.cell();
                if (cell.isCurrentMonth) {
                    return true;
                }
                if (cell.isPrevMonth && cell.showBefore) {
                    return true;
                }
                if (cell.isNextMonth && cell.showAfter) {
                    return true;
                }
                return false;
            };

            this.nextVisible = function() {
                var pos = this;
                while (!pos.visible()) {
                    var next = pos.next();
                    if (!next) {
                        return null;
                    }
                    pos = new Position(next);
                }
                return pos;
            };

            this.previous = function() {
                var start = this;
                if (start.x > 0) {
                    return {
                        "month": start.month,
                        "x": start.x - 1,
                        "y": start.y
                    };
                }
                var month = calendar.months[start.month];
                if (start.y > 0) {
                    return {
                        "month": start.month,
                        "x": 6,
                        "y": start.y - 1
                    };
                }
                if (start.month > 0) {
                    var m = calendar.months[start.month - 1];
                    return {
                        "month": start.month - 1,
                        "x": 6,
                        "y": m.rowCount - 1
                    };
                }
                return null;

            };

            this.previousVisible = function() {
                var pos = this;
                while (!pos.visible()) {
                    var previous = pos.previous();
                    if (!previous) {
                        return null;
                    }
                    pos = new Position(previous);
                }
                return pos;
            };

            this.cell = function() {
                return calendar.months[this.month].cells[this.x][this.y];
            };

            this.date = function() {
                return this.cell().day;
            };

            this.before = function(ref) {
                var thisDate = this.date();
                var refDate = new Position(ref).date();
                return thisDate < refDate;
            };
        };


        this._cellClick = function(ev) {
            var main = this.parentNode;
            var month = this.parentNode.month;

            var x = this.x;
            var y = this.y;
            var day = month.cells[x][y].day;

            if (!month.cells[x][y].isClickable) {
                return;
            }

            calendar.clearSelection();

            calendar.selectionDay = day;

            var day = calendar.selectionDay;
            switch (calendar._selectModeLowerCase()) {
                case 'none':
                    //var s = month.cells[x][y];
                    calendar.selectionStart = day;
                    calendar.selectionEnd = day;
                    break;
                case 'day':
                    if (calendar.autoFocusOnClick) {
                        var start = day;
                        if (day < calendar._activeStart() ||
                            day >= calendar._activeEnd()) {
                            calendar.select(day);
                            return;
                        }
                    }

                    var s = month.cells[x][y];
                    calendar._cellSelect(main, x, y);
                    //calendar._addClass(s, 'select');
                    calendar.selected.push(s);
                    calendar.selectionStart = s.day;
                    calendar.selectionEnd = s.day;

                    break;
                case 'week':
                    if (calendar.autoFocusOnClick) {
                        var start = month.cells[0][y].day;
                        var end = month.cells[6][y].day;
                        if (start.firstDayOfMonth() === end.firstDayOfMonth()) {
                            if (start < calendar._activeStart() ||
                                end >= calendar._activeEnd()) {
                                calendar.select(day);
                                return;
                            }
                        }
                    }
                    for (var j = 0; j < 7; j++) {
                        calendar._cellSelect(main, j, y);
                        //calendar._addClass(month.cells[j][y], 'select');
                        calendar.selected.push(month.cells[j][y]);
                    }
                    calendar.selectionStart = month.cells[0][y].day;
                    calendar.selectionEnd = month.cells[6][y].day;

                    break;
                case 'month':
                    if (calendar.autoFocusOnClick) {
                        var start = day;
                        if (day < calendar._activeStart() ||
                            day >= calendar._activeEnd()) {
                            calendar.select(day);
                            return;
                        }
                    }

                    var start = null;
                    var end = null;
                    for (var y = 0; y < 6; y++) {
                        for (var x = 0; x < 7; x++) {
                            var s = month.cells[x][y];
                            if (!s) {
                                continue;
                            }
                            if (s.day.getYear() === day.getYear() && s.day.getMonth() === day.getMonth()) {
                                calendar._cellSelect(main, x, y);
                                //calendar._addClass(s, 'select');
                                calendar.selected.push(s);
                                if (start === null) {
                                    start = s.day;
                                }
                                end = s.day;
                            }
                        }
                    }
                    calendar.selectionStart = start;
                    calendar.selectionEnd = end;
                    break;
                default:
                    throw 'unknown selectMode';
            }

            calendar._saveState();

            calendar._timeRangeSelectedDispatch();
        };

        this._timeRangeSelectedDispatch = function(options) {
            var start = calendar.selectionStart;
            var end = calendar.selectionEnd.addDays(1);
            var days = DayPilot.DateUtil.daysDiff(start, end);
            var day = calendar.selectionDay;

            options = options || {};


            if (calendar._api2()) {

                var args = {};
                args.start = start;
                args.end = end;
                args.day = day;
                args.days =  days;
                args.mode = options.mode || calendar.selectMode;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeRangeSelect === 'function') {
                    calendar.onTimeRangeSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                // now perform the default builtin action
                switch (calendar.timeRangeSelectedHandling) {
                    case 'Bind':
                        var bound = DayPilot.Util.evalVariable(calendar.bound);
                        if (bound) {
                            var selection = {};
                            selection.start = start;
                            selection.end = end;
                            selection.days = days;
                            selection.day = day;
                            bound.commandCallBack(calendar.command, selection);
                        }
                        break;
                    case 'None':
                        break;
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end, day);
                        break;
                }

                if (typeof calendar.onTimeRangeSelected === 'function') {
                    calendar.onTimeRangeSelected(args);
                }

            }
            else {
                switch (calendar.timeRangeSelectedHandling) {
                    case 'Bind':
                        var bound = DayPilot.Util.evalVariable(calendar.bound);
                        if (bound) {
                            var selection = {};
                            selection.start = start;
                            selection.end = end;
                            selection.days = days;
                            selection.day = day;
                            bound.commandCallBack(calendar.command, selection);
                        }
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeSelected(start, end, day);
                        break;
                    case 'None':
                        break;
                    case 'PostBack':
                        calendar.timeRangeSelectedPostBack(start, end, day);
                        break;
                }
            }


        };

        this.timeRangeSelectedPostBack = function(start, end, data, day) {
            var params = {};
            params.start = start;
            params.end = end;
            params.day = day;

            this._postBack2('TimeRangeSelected', data, params);
        };

        this._clickRight = function(ev) {
            calendar._moveMonth(calendar.skipMonths);
        };

        this._clickLeft = function(ev) {
            calendar._moveMonth(-calendar.skipMonths);
        };

        this._moveMonth = function(i) {
            this.startDate = this.startDate.addMonths(i);
            this._clearTable();
            this._prepare();
            this._drawMonths();

            this._saveState();

            this._visibleRangeChangedDispatch();
            this._updateFreeBusy();
        };

        this._activeStart = function() {
            return calendar.startDate.firstDayOfMonth();
        };

        this._activeEnd = function() {
            return calendar.startDate.firstDayOfMonth().addMonths(this.showMonths);
        };

        this.visibleStart = function() {
            return calendar.startDate.firstDayOfMonth().firstDayOfWeek(resolved.weekStarts());
        };

        this.visibleEnd = function() {
            return calendar.startDate.firstDayOfMonth().addMonths(this.showMonths - 1).firstDayOfWeek(resolved.weekStarts()).addDays(42);
        };

        this._visibleRangeChangedDispatch = function() {
            var start = this.visibleStart();
            var end = this.visibleEnd();

            if (calendar._api2()) {

                var args = {};
                args.start = start;
                args.end = end;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onVisibleRangeChange === 'function') {
                    calendar.onVisibleRangeChange(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                // now perform the default builtin action
                switch (this.visibleRangeChangedHandling) {
                    case "CallBack":
                        this.visibleRangeChangedCallBack(null);
                        break;
                    case "PostBack":
                        this.visibleRangeChangedPostBack(null);
                        break;
                    case "Disabled":
                        break;
                }

                if (typeof calendar.onVisibleRangeChanged === 'function') {
                    calendar.onVisibleRangeChanged(args);
                }

            }
            else {
                switch (this.visibleRangeChangedHandling) {
                    case "CallBack":
                        this.visibleRangeChangedCallBack(null);
                        break;
                    case "PostBack":
                        this.visibleRangeChangedPostBack(null);
                        break;
                    case "JavaScript":
                        this.onVisibleRangeChanged(start, end);
                        break;
                    case "Disabled":
                        break;
                }
            }

/*
            switch (this.visibleRangeChangedHandling) {
                case "CallBack":
                    this.visibleRangeChangedCallBack(null);
                    break;
                case "PostBack":
                    this.visibleRangeChangedPostBack(null);
                    break;
                case "JavaScript":
                    this.onVisibleRangeChanged(start, end);
                    break;
                case "Disabled":
                    break;
            }
            */
        };


        this.visibleRangeChangedCallBack = function(data) {
            var parameters = {};
            this._callBack2("Visible", data, parameters);
        };

        this.visibleRangeChangedPostBack = function(data) {
            var parameters = {};
            this._postBack2("Visible", data, parameters);
        };

        this._updateView = function(result, context) {
            var result = JSON.parse(result);
            calendar.items = result.Items;
            calendar.cells = result.Cells;

            if (calendar.cells) {
                calendar.update();
            }
            else {
                calendar._updateFreeBusy();
            }
        };

        this._drawMonths = function() {
            for (var j = 0; j < this.showMonths; j++) {
                var showLinks = this._getShowLinks(j);
                this._drawTable(j, showLinks);
            }

    	    this.root.style.height = this._getHeight() + "px";

            this.nav.preselection = document.createElement("div");
            this.nav.preselection.style.position = "absolute";
            this.nav.preselection.style.left = "0px";
            this.nav.preselection.style.top = "0px";
            this.root.appendChild(this.nav.preselection);

			/*
            var div = document.createElement("div");
            div.style.clear = "left";
            div.style.height = "0px";
            div.style.width = "0px";
            this.root.appendChild(div);
            */

        };


        this._getHeight = function() {
            if (this.orientation === "Horizontal") {
                var max = 0;
                for (var i = 0; i < this.months.length; i++) {
                    var month = this.months[i];
                    if (month.height > max) {
                        max = month.height;
                    }
                }
                return max;
            }
            else {
                var total = 0;
                for (var i = 0; i < this.months.length; i++) {
                    var month = this.months[i];
                    //total += this.showMonths*(this.cellHeight*month.rowCount + this.titleHeight + this.dayHeaderHeight);
                    total += month.height;
                }
                return total;
            }
        };

        this._getShowLinks = function(j) {
            if (this.internal.showLinks) {
                return this.internal.showLinks;
            }

            var showLinks = {};
            showLinks.left = (j === 0);
            showLinks.right = (j === 0);
            showLinks.before = j === 0;
            showLinks.after = j === this.showMonths - 1;

            if (this.orientation === "Horizontal") {
                showLinks.right = (j === this.showMonths - 1);
            }

            return showLinks;
        };

        // not used at the moment - no internal changes to data

        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function() {
            if (calendar._angular.scope) {
                calendar._angular.scope["$apply"]();
            }
        };

        this.internal = {};
        // ASP.NET
        this.internal.initialized = function() {
            return calendar._initialized;
        };

        this._resolved = {};
        var resolved = this._resolved;

        resolved.locale = function() {
            return DayPilot.Locale.find(calendar.locale);
        };

        resolved.weekStarts = function() {
            if (calendar.weekStarts === 'Auto') {
                var locale = resolved.locale();
                if (locale) {
                    return locale.weekStarts;
                }
                else {
                    return 0; // Sunday
                }
            }
            else {
                return calendar.weekStarts;
            }
        };

        resolved.cellWidth = function() {
            if (calendar._cache.cellWidth) {
                return calendar._cache.cellWidth;
            }
            var width = calendar._getDimensionsFromCss("_cell_dimensions").width;
            if (!width) {
                width = calendar.cellWidth;
            }
            calendar._cache.cellWidth = width;
            return width;
        };

        this.clearSelection = function() {
            for (var j = 0; j < this.selected.length; j++) {
                //this._removeClass(this.selected[j], 'select');
                var div = this.selected[j];
                calendar._cellUnselect(div.parentNode, div.x, div.y);
            }
            this.selected = [];
        };

        this._isShortInit = function() {
            // make sure it has a place to ask
            if (this.backendUrl) {
                return (typeof calendar.items === 'undefined') || (!calendar.items);
            }
            else {
                return false;
            }
        };

        this.events = {};

        this._loadEvents = function() {
            if (!DayPilot.isArray(this.events.list)) {
                return;
            }

            this.items = {};

            for(var i = 0; i < this.events.list.length; i++) {
                var e = this.events.list[i];
                if (e.hidden) {
                    continue;
                }
                var days = this._eventDays(e);
                for(var name in days) {
                    this.items[name] = 1;
                }
            }
        };

        this._getDimensionsFromCss = function(className) {
            var div = document.createElement("div");
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.className = this._prefixCssClass(className);

            var container = calendar.root || document.body;

            container.appendChild(div);
            var height = div.offsetHeight;
            var width = div.offsetWidth;
            container.removeChild(div);

            var result = {};
            result.height = height;
            result.width = width;
            return result;
        };

        this._eventDays = function(e) {
            var start = new DayPilot.Date(e.start);
            var end = new DayPilot.Date(e.end);

            var days = {};

            var d = start.getDatePart();
            while (d.getTime() < end.getTime()) {
                days[d.toStringSortable()] = 1;
                d = d.addDays(1);
            }

            return days;
        };

        this.show = function() {
            calendar.visible = true;
            calendar.root.style.display = '';
        };

        this.hide = function() {
            calendar.visible = false;
            calendar.root.style.display = 'none';
        };

        this._loadTop = function() {
            if (this.id && this.id.tagName) {
                this.nav.top = this.id;
            }
            else if (typeof this.id === "string") {
                this.nav.top = document.getElementById(this.id);
                if (!this.nav.top) {
                    throw "DayPilot.Navigator: The placeholder element not found: '" + id + "'.";
                }
            }
            else {
                throw "DayPilot.Navigator() constructor requires the target element or its ID as a parameter";
            }

            this.root = this.nav.top;

        };

        this.init = function() {
            this._loadTop();

            if (this.root.dp) { // already initialized
                return;
            }

            if (!calendar.cssOnly) {
                calendar.cssOnly = true;
                DayPilot.Util.log("DayPilot: cssOnly = false mode is not supported since DayPilot Pro 8.0.");
            }

            this._adjustSelection();
            this._prepare();
            this._drawMonths();
            this._loadEvents();
            this._updateFreeBusy();
            this._registerDispose();
            this._registerTopHandlers();
            this._registerGlobalHandlers();

            //this.select(this.selectionStart);

            var loadFromServer = this._isShortInit();
            if (loadFromServer) {
                this._visibleRangeChangedDispatch(); // TODO change to "Init"?
            }
            this._initialized = true;
            this._postInit();

            if (this._postponedSelect) {
                var params = this._postponedSelect;
                this.select(params.date1, params.date2, params.options);
                this._postponedSelect = null;
            }

            return this;
        };

        this._registerTopHandlers = function() {
            calendar.nav.top.onmousedown = this._onTopMouseDown;
            calendar.nav.top.onmousemove = this._onTopMouseMove;
        };

        this._registerGlobalHandlers = function() {
            DayPilot.re(document, 'mouseup', calendar._gMouseUp);
        };

        this._gMouseUp = function(ev) {
            if (ps.start && ps.end) {
                var coords = DayPilot.mo3(calendar.nav.top, ev);

                // click, cancel
                if (coords.x === ps.start.coords.x && coords.y === ps.start.coords.y) {
                    ps.start = null;
                    ps.clear();
                    return;
                }

                ps.clear();

                var ordered = ps.ordered();

                ordered.start = new Position(ordered.start).nextVisible();
                ordered.end = new Position(ordered.end).previousVisible();


                calendar.selectionDay = new Position(ordered.start).date();
                calendar.selectionStart = calendar.selectionDay;
                calendar.selectionEnd = new Position(ordered.end).date();

                ps.start = null;
                ps.end = null;

                // redraw
                calendar._clearTable();
                calendar._prepare();
                calendar._drawMonths();
                calendar._updateFreeBusy();
                calendar._saveState();

                var notify = true;
                if (notify) {
                    calendar._timeRangeSelectedDispatch({"mode": "FreeHand"});
                }

            }

            // clear in either case
            ps.start = null;
            ps.end = null;

        };

        this.dispose = function() {
            var c = calendar;

            if (!c.root) {
                return;
            }

            c.root.removeAttribute("style");
            c.root.removeAttribute("class");
            c.root.dp = null;
            c.root.innerHTML = null;
            c.root = null;

        };

        this._registerDispose = function() {
            //var root = document.getElementById(id);
            this.root.dispose = this.dispose;
        };

        this.Init = this.init;

        this._loadOptions(options);
    };

    //  jQuery plugin
    if (typeof jQuery !== 'undefined') {
        (function($) {
            $.fn.daypilotNavigator = function(options) {
                var first = null;
                var j = this.each(function() {
                    if (this.daypilot) { // already initialized
                        return;
                    };

                    var daypilot = new DayPilot.Navigator(this.id);
                    this.daypilot = daypilot;
                    for (var name in options) {
                        daypilot[name] = options[name];
                    }
                    daypilot.Init();
                    if (!first) {
                        first = daypilot;
                    }
                });
                if (this.length === 1) {
                    return first;
                }
                else {
                    return j;
                }
            };
        })(jQuery);
    }

    // AngularJS plugin
    (function registerAngularModule() {
        var app = DayPilot.am();

        if (!app) {
            return;
        }


        app.directive("daypilotNavigator", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element.replaceWith(this["template"].replace("{{id}}", attrs["id"]));

                    return function link(scope, element, attrs) {
                        var calendar = new DayPilot.Navigator(element[0]);
                        calendar._angular.scope = scope;
                        calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Calendar object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }

                            }
                        }

                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        var events = attrs["events"] || attrs["daypilotEvents"];

                        watch.call(scope, config, function (value, oldVal) {
                            for (var name in value) {
                                calendar[name] = value[name];
                            }
                            calendar.update();
                        }, true);

                        watch.call(scope, events, function(value) {
                            calendar.events.list = value;
                            calendar._loadEvents();
                            calendar._updateFreeBusy();
                        }, true);

                    };
                }
            };
        }]);

    })();

    DayPilot.Navigator.def = {};

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function (DayPilot) {
    

    if (typeof DayPilot.Queue !== 'undefined' && DayPilot.Queue.def) {
        return;
    }

    DayPilot.Queue = function (id, options) {
        this.v = '2023.2.5592';

        var calendar = this;
        this.id = id; // referenced

        if (typeof DayPilot.Bubble === "function") {
            this.bubble = new DayPilot.Bubble();
        } else {
            this.bubble = null;
        }

        this.contextMenu = null;
        this.eventBarVisible = true;
        this.eventHeight = 35;
        this.eventTextWrappingEnabled = false;
        this.lineSpace = 5;
        this.theme = null;

        this.emptyText = "";
        this.emptyHtml = null;

        this.eventClickHandling = "Enabled";
        this.eventHoverHandling = "Bubble";
        this.eventRightClickHanding = "ContextMenu";
        this.eventSelectHandling = "Update";

        this.onBeforeEventRender = null;
        this.onEventClick = null;
        this.onEventClicked = null;
        this.onEventRightClick = null;
        this.onEventRightClicked = null;
        this.onEventMove = null;
        this.onEventMoving = null;
        this.onEventSelect = null;
        this.onEventSelected = null;

        this._initialized = false;
        this._cssClassPrefix = "queue_default";
        this._events = [];
        this._draggingFromQueue = false;
        this._draggingFromScheduler = false;

        this.nav = {};
        this.events = {};
        this.events.list = [];

        this.elements = {};
        this.elements.events = [];

        var createDiv = function () {
            return document.createElement("div");
        };

        this._loadTop = function () {
            if (this.id && this.id.tagName) {
                this.nav.top = this.id;
            } else if (typeof this.id === "string") {
                this.nav.top = document.getElementById(this.id);
                if (!this.nav.top) {
                    throw new DayPilot.Exception("DayPilot.Queue: The placeholder element not found: '" + id + "'.");
                }
            } else {
                throw new DayPilot.Exception("DayPilot.Queue() constructor requires the target element or its ID as a parameter");
            }
        };

        this._prefixCssClass = function (part) {
            var prefix = this.theme || this._cssClassPrefix;
            if (prefix) {
                return prefix + part;
            } else {
                return "";
            }
        };


        this._update = function () {
            var container = calendar.nav.container;
            container.innerHTML = "";
            calendar._indicator = null;
            calendar._updateCss();
            calendar._loadEvents();
            calendar._drawEvents();
            calendar._drawEmpty();
        };

        this._updateCss = function () {
            var top = calendar.nav.top;
            top.className = calendar._initialMainCss;
            DayPilot.Util.addClass(top, calendar._prefixCssClass("_main"));
        };


        this._loadEvents = function() {

            var ids = {};

            var src = calendar.events.list || [];
            calendar._events = [];

            for (var i = 0; i < src.length; i++) {
                var data = src[i];

                var validId = typeof data.id === "string" || typeof data.id === "number";
                if (!validId) {
                    throw new DayPilot.Exception("All events must have an id property (string or number)");
                }

                var key = typeof data.id + "_" + data.id;
                if (ids[key]) {
                    throw new DayPilot.Exception("Duplicate IDs not allowed.");
                }
                ids[key] = true;

                var cache = DayPilot.Util.copyProps(data);
                calendar._doBeforeEventRender(cache);
                var item = {};
                item.data = data;
                item.cache = cache;
                calendar._events.push(item);
            }

        };

        this._selection = {};
        this._selection._list = [];
        this._selection._events = [];

        var sel = calendar._selection;

        this._selection._select = function(div) {
            var e = div.event;
            sel._deselect();
            sel._highlight(div);
            sel._list[0] = e;
        };

        this._selection._highlight = function(div) {
            sel._events[0] = div;
            var css = calendar._prefixCssClass("_selected");
            DayPilot.Util.addClass(div, css);
        };

        this._selection._unhlighlight = function(div) {
            sel._events = [];
            var css = calendar._prefixCssClass("_selected");
            DayPilot.Util.removeClass(div, css);
        };

        this._selection._shouldBeSelected = function(id) {
            return calendar._selection._events.find(function(div) {
                return div.event.data.id === id;
            });
        };

        this._selection._deselect = function() {
            var current = sel._events[0];
            if (current) {
                sel._unhlighlight(current);
            }
            sel._list = [];
        };

        this._doBeforeEventRender = function(data) {
            var args = {};
            args.data = data;
            if (typeof calendar.onBeforeEventRender === "function") {
                calendar.onBeforeEventRender(args);
            }
        };


        this._drawEmpty = function() {
            if (calendar.events.list.length !== 0) {
                return;
            }

            var target = calendar.nav.container;

            var empty = createDiv();

            if (calendar.emptyHtml) {
                empty.innerHTML = calendar.emptyHtml;
            }
            else {
                empty.innerText = calendar.emptyText;
            }

            target.appendChild(empty);
        };

        this._drawEvents = function () {
            var events = calendar._events;
            calendar.elements.events = [];
            events.forEach(function (item) {
                calendar._drawEvent(item);
            });
        };

        this._drawEvent = function (item) {

            var cache = item.cache;
            var data = item.data;
            var target = calendar.nav.container;
            var div = createDiv();
            div.className = calendar._prefixCssClass("_event");
            div.style.height = calendar.eventHeight + "px";
            div.style.boxSizing = "border-box";
            div.style.overflow = "hidden";
            div.style.marginTop = calendar.lineSpace + "px";
            div.style.position = "relative";
            if (!calendar.eventTextWrappingEnabled) {
                div.style.whiteSpace = 'nowrap';
            }
            div.addEventListener("click", calendar._onEventClick);
            div.addEventListener("contextmenu", calendar._onContextMenu);

            if (calendar._selection._shouldBeSelected(data.id)) {
                calendar._selection._highlight(div);
            }

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_event_inner");

            if (typeof cache.html === "string") {
                inner.innerHTML = cache.html;
            } else {
                inner.innerText = cache.text;
            }


            if (cache.cssClass) {
                DayPilot.Util.addClass(div, cache.cssClass);
            }

            if (cache.backColor) {
                inner.style.background = cache.backColor;
            }
            if (cache.fontColor) {
                inner.style.color = cache.fontColor;
            }
            if (cache.borderColor === "darker" && cache.backColor) {
                inner.style.borderColor = DayPilot.ColorUtil.darker(cache.backColor, 2);
            }
            else {
                inner.style.borderColor = cache.borderColor;
            }

            if (cache.backImage) {
                inner.style.backgroundImage = "url(" + cache.backImage + ")";
                if (cache.backRepeat) {
                    inner.style.backgroundRepeat = cache.backRepeat;
                }
            }
            div.appendChild(inner);

            div.onmousemove = this._onEventMouseMove;
            div.onmouseleave = this._onEventMouseLeave;

            if (calendar.eventBarVisible && !cache.barHidden) {
                var bar = createDiv();
                bar.className = calendar._prefixCssClass("_event_bar");
                bar.style.position = "absolute";

                if (cache.barColor) {
                    bar.style.backgroundColor = cache.barColor;
                }

                div.appendChild(bar);
            }

            var options = {
                "eventDiv": div,
                "areas": cache.areas,
                "allowed": function() {
                    var dragging = calendar._draggingFromQueue || calendar._draggingFromScheduler;
                    return !dragging;
                }
            };

            var e = new DayPilot.Event(data, calendar);
            e.cache = cache;
            div.event = e;
            DayPilot.Areas.attach(div, e, options);

            calendar._makeDraggable(div, data);
            target.appendChild(div);

            calendar.elements.events.push(div);

        };

        this._onEventMouseMove = function(ev) {
            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble && calendar.eventHoverHandling === 'Bubble') {
                calendar.bubble.showEvent(this.event);
            }
        };

        this._onEventMouseLeave = function(ev) {
            if (calendar.bubble) {
                calendar.bubble.hideOnMouseOut();
            }
        };

        this._onContextMenu = function(ev) {
            ev.preventDefault();

            if (calendar.eventRightClickHandling === "Disabled") {
                return;
            }

            var div = this;
            var e = div.event;
            var args = {};
            args.e = div.event;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            if (typeof calendar.onEventRightClick === "function") {
                calendar.onEventRightClick(args);
            }

            if (args.preventDefault.value) {
                return;
            }

            switch (calendar.eventRightClickHanding) {
                case "Enabled":
                    break;
                case "ContextMenu":
                    var menu = e.client.contextMenu();

                    if (menu) {
                        menu.show(e);
                    }
                    else {
                        if (calendar.contextMenu) {
                            calendar.contextMenu.show(e);
                        }
                    }
                    break;
            }

            if (typeof calendar.onEventRightClicked === "function") {
                calendar.onEventRightClicked(args);
            }

        };

        this._onEventClick = function(ev) {
            ev.preventDefault();
            ev.stopPropagation();

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            if (calendar.eventClickHandling  === "Disabled") {
                return;
            }
            var div = this;
            var e = div.event;

            var args = {};
            args.e = e;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            if (typeof calendar.onEventClick === "function") {
                calendar.onEventClick(args);
            }

            if (args.preventDefault.value) {
                return;
            }

            switch (calendar.eventClickHandling) {
                case "Select":
                    calendar._eventSelectDispatch(div, e, ev);
                    break;
                case "Enabled":
                    break;
            }

            if (typeof calendar.onEventClicked === "function") {
                calendar.onEventClicked(args);
            }

        };

        this._eventSelectDispatch = function(div, e, ev) {
            var args = {};
            args.e = e;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onEventSelect === 'function') {
                calendar.onEventSelect(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            switch (calendar.eventSelectHandling) {
                case 'Update':
                    calendar._selection._select(div);
                    break;
            }

            if (typeof calendar.onEventSelected === 'function') {
                calendar.onEventSelected(args);
            }

        };

        this._onDropFromScheduler = function (data, source) {
            // add, fire move with external flag
            var position = calendar._position;

            var args = {};
            args.e = new DayPilot.Event(data, calendar);
            args.position = position;
            args.source = source;
            args.external = true;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            calendar._doOnEventMove(args);
            if (args.preventDefault.value) {
                return;
            }

            calendar.events.list.splice(position, 0, data);
            calendar._update();

            calendar._doOnEventMoved(args);

            // calendar.events.list.push(data);
            // calendar._drawEvent(data);
        };

        this._onDropFromQueue = function (data) {

            var args = {};
            args.e = new DayPilot.Event(data, calendar);
            args.position = calendar._position;
            args.source = calendar;
            args.external = false;
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };

            calendar._doOnEventMove(args);
            if (args.preventDefault.value) {
                return;
            }

            // reorder
            var originalPosition = calendar.events.list.indexOf(data);
            calendar._moveInArray(calendar.events.list, originalPosition, calendar._position);
            calendar._update();

            calendar._doOnEventMoved(args);
        };

        this._doOnEventMove = function(args) {
            if (typeof calendar.onEventMove === "function") {
                calendar.onEventMove(args);
            }
        };

        this._doOnEventMoved = function(args) {
            if (typeof calendar.onEventMoved === "function") {
                calendar.onEventMoved(args);
            }
        };

        this._moveInArray = function (array, src, target) {
            var item = array[src];
            array.splice(src, 1);
            array.splice(target, 0, item);
        };


        this._registerDropTarget = function () {

            DayPilot.Scheduler.registerDropTarget({
                element: calendar.nav.top,
                onDrop: function (args) {
                    calendar._draggingFromScheduler = false;
                    var e = args.e;
                    var data = e.data;
                    var source = args.e.calendar;
                    calendar._onDropFromScheduler(data, source);
                },
                onDragOver: function (args) {
                    calendar._draggingFromScheduler = true;
                },
                onDragLeave: function (args) {
                    calendar._draggingFromScheduler = false;
                }
            });

        };

        this._indicator = null;
        this._indicatorShow = function (position) {
            calendar._position = position;
            var div = calendar._indicator || createDiv();
            var target = calendar.nav.container;
            var height = 2;

            var unit = calendar.eventHeight + calendar.lineSpace;

            var top = position * unit;
            var minus = calendar.lineSpace / 2 + height / 2;
            top -= minus;

            div.style.top = top + "px";

            if (!calendar._indicator) {
                div.className = calendar._prefixCssClass("_shadow");
                div.style.position = "absolute";
                div.style.left = "0px";
                div.style.right = "0px";
                div.style.height = height + "px";

                calendar._indicator = div;
                target.appendChild(div);
            }

        };

        this._indicatorHide = function () {
            calendar._position = null;
            DayPilot.de(calendar._indicator);
            calendar._indicator = null;
        };


        this._coords = null;
        this._position = null;
        this._onContainerMouseMove = function (ev) {
            var target = calendar.nav.container;
            var coords = DayPilot.mo3(target, ev);
            calendar._coords = coords;

            var dragging = calendar._draggingFromQueue || calendar._draggingFromScheduler;
            if (dragging) {
                var unit = calendar.eventHeight + calendar.lineSpace;
                var position = Math.floor((coords.y + calendar.eventHeight / 2) / unit);
                if (position < 0) {
                    position = 0;
                }
                if (position > calendar._events.length) {
                    position = calendar._events.length;
                }

                calendar._indicatorShow(position);
            }

        };

        this._onContainerMouseLeave = function (ev) {
            calendar._indicatorHide();
        };

        this._onContainerMouseUp = function (ev) {
            if (calendar._draggingFromQueue) {
                var data = calendar._draggingFromQueueSource;
                calendar._onDropFromQueue(data);
                calendar._draggingFromQueueSource = null;
            }
        };

        this._initTop = function () {
            var container = createDiv();
            calendar.nav.container = container;
            var target = calendar.nav.top;

            calendar._initialMainCss = target.className || "";

            container.style.position = "relative";
            target.onmousemove = calendar._onContainerMouseMove;
            target.onmouseleave = calendar._onContainerMouseLeave;
            target.onmouseup = calendar._onContainerMouseUp;
            target.appendChild(container);
        };

        this._makeDraggable = function (div, data) {
            var e = div;

            // var duration = typeof data.duration === "number" ? DayPilot.Duration.ofSeconds(data.duration) : data.duration;
            // duration = duration ? duration : new DayPilot.Duration(data.start, data.end);

            var item = {
                element: e,
                data: data,
                keepElement: true,
                externalCssClass: "",
                externalHtml: "",
                onDragStart: function (args) {
                    calendar._draggingFromQueue = true;
                    calendar._draggingFromQueueSource = data;
                    e.style.opacity = "0.5";
                },
                onDrop: function (args) {
                    calendar._draggingFromQueue = false;
                    e.style.opacity = "";
                    // calendar.events.remove(data);
                    var droppedOutside = !!calendar._draggingFromQueueSource;
                },
            };
            DayPilot.Scheduler.makeDraggable(item);

        };

        this._loadOptions = function(options) {

            if (!options) {
                return;
            }

            var specialHandling = {
                "events": {
                    "preInit": function() {
                        var events = this.data;
                        if (!events) {
                            // This.cards.list = [];
                            return;
                        }
                        calendar.events.list = events;
                    }
                },
            };

            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
                else {
                    calendar[name] = options[name];
                }
            }
        };

        this._react = {};
        this._react.reactDOM = null;
        this._react.react = null;
        this._react._render = function(component, target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                if (!root) {
                    root = rd.createRoot(target);
                    target._root = root;
                }
                root.render(component);
            }
            else {
                rd.render(component, target);
            }

        };
        this._react._unmount = function(target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                setTimeout(function() {
                    root.unmount();
                }, 0);
            }
            else {
                rd.unmountComponentAtNode(target);
            }
        };


        this._findEventDiv = function(e) {
            if (!e) {
                return null;
            }
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (DayPilot.Util.isSameEvent(div.event, e)) {
                    return div;
                }
            }
            return null;
        };

        this.multiselect = {};

        this.multiselect.add = function(data) {
            if (typeof data === "number" || typeof data === "string") {
                data = calendar.events.find(data);
            }
            if (data instanceof DayPilot.Event) {
                data = data.data;
            }
            var div = calendar._findEventDiv(data);
            if (div) {
                calendar._selection._select(div);
            }
        };

        this.multiselect.clear = function() {
            calendar._selection._deselect();
        };

        this.multiselect.get = function() {
            var list = [];
            var current = sel._list[0];
            if (current) {
                var e = current.event;
                list.push(e);
            }
            return list;
        };

        this.events.add = function (data) {
            if (data instanceof DayPilot.Event) {
                data = data.data;
            }
            calendar.events.list.push(data);
            calendar._update();
        };

        this.events.remove = function (data) {
            if (!data) {
                return;
            }
            if (typeof data === "number" || typeof data === "string") {
                data = calendar.events.find(data);
            }
            if (data instanceof DayPilot.Event) {
                data = data.data;
            }

            var i = calendar.events.list.indexOf(data);

            if (i === -1) {
                return;
            }

            if (calendar._selection._shouldBeSelected(data.id)) {
                calendar.multiselect.clear();
            }

            calendar.events.list.splice(i, 1);
            calendar._update();
        };


        this.events.update = function(data) {
            if (data instanceof DayPilot.Event) {
                data = data.data;
            }

            var inSrc = calendar.events.find(data.id);
            if (!inSrc) {
                return;
            }

            var i = calendar.events.list.indexOf(inSrc.data);
            if (i === -1) {
                return;
            }
            calendar.events.list.splice(i, 1, data);
            calendar._update();

        };

        this.events.find = function (id) {
            var data = calendar.events.list.find(function (item) {
                return item.id === id;
            });
            if (!data) {
                return null;
            }
            return new DayPilot.Event(data, calendar);
        };

        this.init = function () {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.");
            }
            this._loadTop();

            if (this.nav.top.dp) {
                if (this.nav.top.dp === calendar) {
                    return calendar;
                }
                throw new DayPilot.Exception("The target placeholder was already initialized by another DayPilot component instance.");
            }

            this._registerDropTarget();
            this._initTop();
            this._update();

            return this;

        };

        this.update = function (options) {
            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Queue object that has been disposed already. Calling .dispose() destroys the object and makes it unusable.");
            }

            calendar._loadOptions(options);
            calendar._update();
        };

        this.dispose = function() {
            calendar.nav.top.innerHTML = "";
            calendar._disposed = true;
        };

        this.internal = {};
        this.internal.loadOptions = function(options) {
            calendar._loadOptions(options);
        };
        this.internal.enableReact = function (react, reactDOM) {
            calendar._react.react = react;
            calendar._react.reactDOM = reactDOM;
        };
        this.internal.reactRefs = function() {
            return DayPilot.Util.copyProps(calendar._react, {}, ["react", "reactDOM"]);
        };
        this.internal.findEventDiv = this._findEventDiv;

        this._loadOptions(options);
    };

    DayPilot.Queue.def = {};

})(DayPilot);
/* Copyright 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
    var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Scheduler !== 'undefined' && DayPilot.Scheduler.def) {
        return;
    }

    // temp hack
    var android = (function() {
        var nua = navigator.userAgent;
        return ((nua.indexOf('Mozilla/5.0') > -1 && nua.indexOf('Android ') > -1 && nua.indexOf('AppleWebKit') > -1) && !(nua.indexOf('Chrome') > -1));
    })();
    var ios = navigator.userAgent.indexOf("iPad") > -1 || navigator.userAgent.indexOf("iPhone") > -1;

    var DayPilotScheduler = {};

    var doNothing = function() { };

    var debug = false;

    var log = function(msg) {
        if (!debug) {
            return;
        }
        window.console && window.console.log.apply(window.console, arguments);
    };

    var qlog = function(msg) {
        if (typeof QUnit === "undefined") {
            return;
        }
        log(msg);
    };

    var console = {
        "log": log
    };

    var body = function() {
        return document.body;
    };

    var createDiv = function() {
        return document.createElement("div");
    };

    var overlaps = DayPilot.Util.overlaps;
    var removeClass = DayPilot.Util.removeClass;
    var addClass = DayPilot.Util.addClass;
    var utilDiv = DayPilot.Util.div;
    var atLeast = DayPilot.Util.atLeast;
    var isNullOrUndefined = DayPilot.Util.isNullOrUndefined;
    var copyProps = DayPilot.Util.copyProps;
    var isReactCmp = DayPilot.Util.isReactComponent;
    var mouseButton = DayPilot.Util.mouseButton;
    var DpGlobal = DayPilot.Global;
    var createList = DayPilot.list;
    var contains = DayPilot.contains;
    var deleteElement = DayPilot.de;
    var indexOf = DayPilot.indexOf;

    DayPilot.Scheduler = function(id, options) {
        this.v = '2023.2.5592';

        var calendar = this;
        this.id = id; // referenced
        this.isScheduler = true;

        // default values
        this.allowDefaultContextMenu = false;
        this.allowEventOverlap = true;
        this.allowMultiMove = false;
        this.allowMultiRange = false;
        this.allowMultiResize = false;
        this.allowMultiSelect = true;
        this.api = 2;
        // legacy, replaced by rectangleSelectMode and rectangleSelectHandling
        //this.multiSelectRectangle = "Disabled";  // "Free", "Row", "Disabled"
        this.autoRefreshCommand = 'refresh';
        this.autoRefreshEnabled = false;
        this.autoRefreshInterval = 60;
        this.autoRefreshMaxCount = 20;
        this.autoScroll = "Drag";
        this.blockOnCallBack = false;
        this.navigatorBackSync = null;
        this.backendUrl = null;
        this.beforeCellRenderCaching = true;
        this.businessBeginsHour = 9;
        this.businessEndsHour = 18;
        this.businessWeekends = false;
        this.cellDuration = 60;
        this.cellGroupBy = 'Day';
        this.cellSweeping = true;
        this.cellSweepingCacheSize = 1000;
        this.cellWidth = 40;
        this.cellWidthMin = 1;
        this.cellWidthSpec = "Fixed";
        this.cellsMarkBusiness = true;
        this.cornerText = "";
        this.cornerHtml = null;
        this.crosshairTimeHeaderLevel = "Last";  // or number (index)
        this.crosshairType = 'Header';
        this.cssClassPrefix = "scheduler_default";
        this.days = 1;
        this.doubleClickTimeout = 300;
        this.dragOutAllowed = false;
        this.drawBlankCells = true;
        this.durationBarHeight = null;
        this.durationBarVisible = true;
        this.durationBarMode = "Duration";  // "Duration" | "PercentComplete"
        this.dynamicEventRendering = 'Progressive';
        this.dynamicEventRenderingMargin = 50;
        this.dynamicEventRenderingMarginX = null;
        this.dynamicEventRenderingMarginY = null;
        this.dynamicEventRenderingCacheSweeping = false;
        this.dynamicEventRenderingCacheSize = 200;
        this.dynamicLoading = false;
        this.eventEditMinWidth = 100;
        this.eventEditTabNext = false; // legacy, to be removed
        this.eventEndSpec = "DateTime";
        this.eventHeight = 35;
        this.eventHtmlLeftMargin = 10;
        this.eventHtmlRightMargin = 10;
        this.eventMarginLeft = 0;
        this.eventMarginRight = 0;
        this.eventMarginBottom = 0;
        this.eventMinWidth = 1;
        this.eventMoveMargin = 5;
        this.eventMoveToPosition = false;
        this.eventMoveSkipNonBusiness = false;
        this.eventResizeMargin = 5;
        this.eventStackingLineHeight = 100;
        this.eventTapAndHoldHandling = "Move";  // or "ContextMenu"
        this.eventTextWrappingEnabled = false;
        this.eventUpdateInplaceOptimization = false;
        this.eventsLoadMethod = "GET";
        this.eventVersionHeight = 25;
        this.eventVersionMargin = 2;
        this.eventVersionPosition = "Above";
        this.eventVersionsEnabled = false;
        this.eventVersionsReserveSpace = false;
        this.floatingEvents = ios ? false :true;
        this.floatingTimeHeaders = true;
        this.groupConcurrentEvents = false;
        this.groupConcurrentEventsLimit = 1;
        this.headerHeight = 30;
        this.heightSpec = 'Max';
        this.height = 600;
        this.hideBorderFor100PctHeight = false;
        this.hideUntilInit = true;
        this.infiniteScrollingEnabled = false;
        this.infiniteScrollingMargin = 50;
        this.infiniteScrollingStepDays = 30;
        this.initEventEnabled = true;
        this.jointEventsResize = true;
        this.jointEventsMove = true;
        this.keyboardEnabled = false;
        this.keyboardTarget = "document";
        this.layout = 'Auto';
        this.linkCreateHandling = "Disabled";
        this.linkBottomMargin = 17;
        this.linkPointSize = 10;
        this.linksLoadMethod = "GET";
        this.locale = "en-us";
        this.loadingLabelText = "Loading...";
        this.loadingLabelHtml = null;
        this.loadingLabelVisible = true;
        this.overrideWheelScrolling = false;
        this.messageBarPosition = "Top";
        this.messageHideAfter = 5000;
        this.messageHideOnMouseOut = true;
        this.multiMoveVerticalMode = "Disabled"; // options: "Disabled", "Master", "All"
        this.moveBy = 'Full';
        this.notifyCommit = 'Immediate'; // or 'Queue'
        this.progressiveRowRendering = true;
        this.progressiveRowRenderingPreload = 25;
        this.rectangleSelectMode = "Free";  // "Free", "Row"
        this.rectangleSelectHandling = "Disabled";  // "Enabled", "Disabled", "EventSelect"
        this.rowCreateHeight = null;
        this.rowCreateHtml = null;
        this.rowCreateText = "New row...";
        this.rowDragHandleWidth = 10;
        this.rowEmptyHeight = null;
        this.rowFilterParentsAlwaysVisible = true;
        this.rowHeaderColumnDefaultWidth = 80;
        this.rowHeaderHideIconEnabled = false;
        this.rowHeaderScrolling = false;
        this.rowHeaderSplitterWidth = 3;
        this.rowHeaderWidthAutoFit = true;
        this.rowHeaderWidthAutoFitShrink = false;
        this.rowHeaderWidthMarginRight = 0;
        this.rowHeaderWidthMin = 20;
        this.rowHeaderColumnsResizable = true;
        this.rowHeaderColumnsMode = "Tabular";
        this.rowHeaderColumns = null;
        this.rowHeaderColumnsMergeParents = true;
        // this.rowHeaderCols = null;   // do not show
        this.rowHeaderWidth = 80;
        this.rowMarginBottom = 0;
        this.rowMarginTop = 0;
        this.rowMinHeight = 0;
        this.rowsLoadMethod = "GET";
        this.rowSortingMode = "LeavesOnly";  // or "ParentsOnly"
        this.scale = "CellDuration";
        this.scaleManualLimitBeyond = true;
        this.scrollDelayDynamic = 500;
        this.scrollDelayEvents = 200;
        this.scrollDelayCells = ios ? 100 : 0;
        this.scrollDelayFloats = 0;
        this.scrollDelayRows = 0;
        this.scrollStep = null;
        this.scrollX = 0;
        this.scrollY = 0;
        this.selectedRows = [];
        this.separators = [];
        this.showCurrentTimeHeader = false;
        this.showNonBusiness = true;
        this.showNonBusinessForceHours = false;
        this.showToolTip = true;
        this.snapToGrid = true;
        // this.snapToGridRectangeSelecting = true;
        this.snapToGridTimeRangeSelecting = true;
        this.snapToGridEventMoving = true;
        this.snapToGridEventResizing = true;
        this.startDate = DayPilot.Date.today();
        this.syncResourceTree = false;
        this.tapAndHoldTimeout = 300;
        this.timeHeaders = [ {"groupBy": "Default"}, {"groupBy": "Cell"} ];
        this.timeHeaderPosition = "Top";
        this.timeHeaderTextWrappingEnabled = false;
        this.treeAnimation = true;
        this.treeAutoExpand = true;
        this.treeEnabled = false;
        this.treeIndent = 20;
        this.treeImageMarginLeft = 0;
        this.treeImageMarginTop = 3;
        this.treeImageMarginRight = 5;
        this.treeImageWidth = 10;
        this.treeImageHeight = 10;
        this.treePreventParentUsage = false;
        this.timeFormat = "Auto";
        this.timeline = null;
        this.useEventBoxes = 'Always';
        this.viewType = 'Resources';
        this.visible = true;
        this.watchWidthChanges = true;
        this.weekStarts = 'Auto'; // 0 = Sunday, 1 = Monday, ... 'Auto' = use .locale
        this.width = null;
        this.xssProtection = "Enabled"; // "Disabled"
        this.zoomLevels = [];
        this.zoomPosition = "left";

        this.eventClickHandling = 'Enabled';
        this.eventDeleteHandling = "Disabled";
        this.eventHoverHandling = 'Bubble';
        this.eventDoubleClickHandling = 'Disabled';
        this.eventEditHandling = 'Update';
        this.eventMoveHandling = 'Update';
        this.eventResizeHandling = 'Update';
        this.eventRightClickHandling = 'ContextMenu';
        this.eventSelectHandling = 'Update';
        this.resourceCollapseHandling = "Enabled";
        this.resourceExpandHandling = "Enabled";
        this.rowClickHandling = 'Enabled';
        this.rowDoubleClickHandling = "Disabled";
        this.rowRightClickHandling = 'ContextMenu';
        this.rowCreateHandling = "Disabled";
        this.rowEditHandling = 'Update';
        this.rowHeaderColumnResizedHandling = "Update";
        this.rowSelectHandling = 'Update';
        this.rowMoveHandling = "Disabled";
        this.rowMoveSameLevelOnly = false;
        this.timeHeaderClickHandling = "Enabled";
        this.timeHeaderRightClickHandling = "Enabled";
        this.timeRangeClickHandling = "Enabled";
        this.timeRangeDoubleClickHandling = 'Disabled';
        this.timeRangeSelectedHandling = 'Enabled';
        this.timeRangeRightClickHandling = "ContextMenu";  // "ContextMenu", "Enabled", "Disabled"

        this.timeRangeSelectingStartEndEnabled = false;
        this.timeRangeSelectingStartEndFormat = "MMMM d, yyyy";
        this.eventMovingStartEndEnabled = false;
        this.eventMovingStartEndFormat = "MMMM d, yyyy";
        this.eventResizingStartEndEnabled = false;
        this.eventResizingStartEndFormat = "MMMM d, yyyy";

        if (typeof DayPilot.Bubble === "function") {
            this.bubble = new DayPilot.Bubble();
        } else {
            this.bubble = null;
        }

        this.cellBubble = null;
        this.resourceBubble = null;
        this.linkBubble = null;
        this.groupBubble = null;

        this.contextMenu = null;
        this.contextMenuResource = null;
        this.contextMenuSelection = null;
        this.contextMenuLink = null;

        // IE-specific default values
        if (DayPilot.browser.ie) {
            this.scrollDelayCells = 100;
            this.scrollDelayFloats = 100;
        }

        if (calendar.api === 1) {
            this.onEventMove = function() { };
            this.onEventResize = function() { };
            this.onResourceExpand = function() { };
            this.onResourceCollapse = function() { };
        }

        this.onEventClick = null;
        this.onEventClicked = null;
        this.onEventEdit = null;
        this.onEventEdited = null;
        this.onEventEditKeyDown = null;
        this.onEventMove = null;
        this.onEventMoved = null;
        this.onEventMoving = null;
        this.onEventResize = null;
        this.onEventResized = null;
        this.onEventResizing = null;
        this.onEventRightClick = null;
        this.onEventRightClicked = null;
        this.onEventMouseEnter = null;
        this.onEventMouseLeave = null;
        this.onEventMouseOver = null;  // legacy, use onEventMouseEnter
        this.onEventMouseOut = null;  // legacy, use onEventMouseLeave
        this.onIncludeTimeCell = null;
        this.onKeyboardFocusChange = null;
        this.onKeyboardFocusChanged = null;
        this.onLinkClick = null;
        this.onLinkClicked = null;
        this.onLinkCreate = null;
        this.onLinkCreated = null;
        this.onRowClick = null;
        this.onRowClicked = null;
        this.onRowDoubleClick = null;
        this.onRowDoubleClicked = null;
        // this.onRowMouseEnter = null;  // ensure it's fired for row, not cell
        // this.onRowMouseLeave = null;  // ensure it's fired for row, not cell
        this.onRowMouseOver = null;
        this.onRowMouseOut = null;
        this.onRowRightClick = null;
        this.onRowRightClicked = null;
        this.onTimeHeaderClick = null;
        this.onTimeHeaderClicked = null;
        this.onTimeHeaderRightClick = null;
        this.onTimeHeaderRightClicked = null;
        this.onTimeRangeClick = null;
        this.onTimeRangeClicked = null;
        this.onTimeRangeDoubleClick = null;
        this.onTimeRangeDoubleClicked = null;
        this.onTimeRangeSelect = null;
        this.onTimeRangeSelected = null;
        this.onTimeRangeSelecting = null;
        this.onTimeRangeRightClick = null;
        this.onTimeRangeRightClicked = null;
        this.onRowHeaderColumnResized = null;
        this.onRowHeaderResized = null;
        this.onCellMouseEnter = null;
        this.onCellMouseLeave = null;
        this.onCellMouseOver = null;  // legacy, use onCellMouseEnter instead
        this.onCellMouseOut = null;  // legacy, use onCellMouseLeave
        this.onGridMouseDown = null;

        this.onBeforeCellRender = null;
        this.onBeforeCellDomAdd = null;
        this.onBeforeCellDomRemove = null;
        this.onBeforeCornerRender = null;
        this.onBeforeCornerDomAdd = null;
        this.onBeforeCornerDomRemove = null;
        this.onBeforeEventRender = null;
        this.onBeforeEventDomAdd = null;
        this.onBeforeEventDomRemove = null;
        this.onBeforeGridLineRender = null;
        this.onBeforeTimeHeaderRender = null;
        this.onBeforeTimeHeaderDomAdd = null;
        this.onBeforeTimeHeaderDomRemove = null;
        this.onBeforeResHeaderRender = null;
        this.onBeforeRowHeaderRender = null;
        this.onBeforeRowHeaderColumnRender = null;
        this.onBeforeRowHeaderDomAdd = null;
        this.onBeforeRowHeaderDomRemove = null;

        this.onBeforeCellExport = null;
        this.onBeforeCornerExport = null;
        this.onBeforeEventExport = null;
        this.onBeforeTimeHeaderExport = null;
        this.onBeforeRowHeaderExport = null;

        this.onAfterEventRender = null;
        this.onAfterCellRender = null;
        this.onAfterEventEditRender = null;

        this.onEventFilter = null;
        this.onRowFilter = null;

        this.onRectangleSelecting = null;
        this.onRectangleSelect = null;
        this.onRectangleSelected = null;

        //this.onHeightChanged = null;  // do not expose it on the object - use onDimensionsChanged
        this.onDimensionsChanged = null;
        this.onAfterUpdate = null;

        // internal
        this._autoRefreshCount = 0;
        this._cellPropertiesLazyLoading = true; // server-based only
        this._cellPropertiesExpanded = false;
        this._cellStacking = false;
        this._cellStackingAutoHeight = false;
        this._crosshairLastY = -1;
        this._crosshairLastX = -1;
        this._disposed = false;
        this._innerHeightTree = -1;
        this._ganttAppendToResources = false;
        this._previousVisible = true;

        // internal, name kept non-minified for debugging purposes
        this.rowlist = createList();
        this.itline = createList();

        this.events = {};
        this.cells = {};

        // store the element references
        this.elements = {};
        this.elements.events = [];
        this.elements.bars = [];
        this.elements.text = [];
        this.elements.cells = [];
        this.elements.linesVertical = [];  // required for height updating
        this.elements.separators = [];
        this.elements.range = [];
        this.elements.breaks = [];
        this.elements.links = [];
        this.elements.linkpoints = [];
        this.elements.rectangle = [];
        this.elements.hover = [];
        this.elements.timeHeader = [];

        this._cache = {};
        this._cache.cells = [];
        this._cache._linesVertical = {};
        this._cache._linesHorizontal = {};
        this._cache.timeHeaderGroups = [];
        this._cache.timeHeader = {};
        this._cache.pixels = [];
        this._cache.breaks = [];
        this._cache.events = []; // processed using client-side beforeEventRender
        this._cache._layers = [];

        this.clientState = {};

        this.members = {};
        this.members.obsolete = [
            "Init",
            "cleanSelection",
            "cssClassPrefix",
            "getHScrollPosition",
            "setHScrollPosition",
            "getVScrollPosition",
            "setVScrollPosition",
            "showBaseTimeHeader"
        ];
        this.members.ignoreFilter = function(name) {
            if (name.indexOf("div") === 0) {
                return true;
            }
            return false;
        };
        this.members.ignore = [
            "internal",
            "nav",
            "debug",
            "temp",
            "elements",
            "members",
            "cellProperties",
            "itline",
            "rowlist",
            "timeHeader",
            "timeouts",
            "rowHeaderCols"
        ];
        this.members.noCssOnly = [];

        this._productCode = 'javasc';

        this.nav = {};

        this._updateView = function(result, context) {
            var result = JSON.parse(result);

            calendar.onScrollCalled = false;

            // update config
            if (result.VsUpdate) {
                var vsph = document.createElement("input");
                vsph.type = 'hidden';
                vsph.name = calendar.id + "_vsupdate";
                vsph.id = vsph.name;
                vsph.value = result.VsUpdate;
                calendar._vsph.innerHTML = '';
                calendar._vsph.appendChild(vsph);
            }

            if (result.CallBackRedirect) {
                document.location.href = result.CallBackRedirect;
                return;
            }

            if (result.BubbleGuid) {
                var guid = result.BubbleGuid;
                var bubble = this.bubbles[guid];
                delete this.bubbles[guid];

                calendar._loadingStop();
                if (typeof result.Result.BubbleHTML !== 'undefined' && bubble) {
                    bubble.updateView(result.Result.BubbleHTML, bubble);
                }
                calendar._doCallBackEnd();
                return;
            }

            if (typeof calendar.onCallBackResult === "function") { // internal API
                var args = {};
                args.result = result;
                args.preventDefault = function() {
                    args.preventDefault.value = true;
                };
                calendar.onCallBackResult(args);

                if (args.preventDefault.value) {

                    //calendar._updateFloats();
                    calendar._deleteDragSource();
                    calendar._loadingStop();
                    calendar._startAutoRefresh();

                    if (result.Message) {
                        if (calendar.message) { // condition can be removed as soon as message() is implemented properly
                            calendar.message(result.Message);
                        }
                    }

                    calendar._fireAfterRenderDetached(result.CallBackData, true);
                    calendar._doCallBackEnd();
                    calendar._clearCachedValues();

                    return;
                }
            }

            if (typeof DayPilot.Bubble !== "undefined") {
                DayPilot.Bubble.hideActive();
            }

            if (typeof result.ClientState !== 'undefined') {
                if (result.ClientState === null) {
                    calendar.clientState = {};
                }
                else {
                    calendar.clientState = result.ClientState;
                }
            }

            if (result.UpdateType === "None") {
                calendar._loadingStop();
                calendar._doCallBackEnd();

                //calendar.afterRender(result.CallBackData, true);

                if (result.Message) {
                    calendar.message(result.Message);
                }

                calendar._fireAfterRenderDetached(result.CallBackData, true);

                return;
            }

            // updateViewState();

            if (typeof result.TagFields !== 'undefined') {
                calendar.tagFields = result.TagFields;
            }

            if (typeof result.SortDirections !== 'undefined') {
                calendar.sortDirections = result.SortDirections;
            }

            calendar._cache.drawArea = null;

            if (result.UpdateType === "Full") {
                // generated
                calendar.resources = result.Resources;
                calendar.colors = result.Colors;
                calendar.palette = result.Palette;
                calendar.dirtyColors = result.DirtyColors;
                calendar.cellProperties = result.CellProperties;
                calendar.cellConfig = result.CellConfig;
                calendar.separators = result.Separators;
                calendar.timeline = result.Timeline;
                calendar.timeHeader = result.TimeHeader;
                calendar.timeHeaders = result.TimeHeaders;
                if (typeof result.Links !== "undefined") { calendar.links.list = result.Links; }
                if (typeof result.RowHeaderColumns !== 'undefined') calendar.rowHeaderColumns = result.RowHeaderColumns;

                // properties
                calendar.startDate = result.StartDate ? new DayPilot.Date(result.StartDate) : calendar.startDate;
                calendar.days = result.Days ? result.Days : calendar.days;
                calendar.cellDuration = result.CellDuration ? result.CellDuration : calendar.cellDuration;
                calendar.cellGroupBy = result.CellGroupBy ? result.CellGroupBy : calendar.cellGroupBy;
                calendar.cellWidth = result.CellWidth ? result.CellWidth : calendar.cellWidth;
                if (typeof result.CellWidthSpec !== "undefined") { calendar.cellWidthSpec = result.CellWidthSpec; }
                if (typeof result.Scale !== 'undefined') { calendar.scale = result.Scale; }
                // scrollX
                // scrollY
                calendar.viewType = result.ViewType ? result.ViewType : calendar.viewType;
                // calendar.hourNameBackColor = result.HourNameBackColor ? result.HourNameBackColor : calendar.hourNameBackColor;
                if (typeof result.ShowNonBusiness !== 'undefined') calendar.showNonBusiness = result.ShowNonBusiness;
                calendar.businessBeginsHour = result.BusinessBeginsHour ? result.BusinessBeginsHour : calendar.businessBeginsHour;
                calendar.businessEndsHour = result.BusinessEndsHour ? result.BusinessEndsHour : calendar.businessEndsHour;
                if (typeof result.DynamicLoading !== 'undefined') calendar.dynamicLoading = result.DynamicLoading;
                if (typeof result.TreeEnabled !== 'undefined') calendar.treeEnabled = result.TreeEnabled;
                // calendar.backColor = result.BackColor ? result.BackColor : calendar.backColor;
                // calendar.nonBusinessBackColor = result.NonBusinessBackColor ? result.NonBusinessBackColor : calendar.nonBusinessBackColor;
                calendar.locale = result.Locale ? result.Locale : calendar.locale;
                if (typeof result.TimeZone !== 'undefined') calendar.timeZone = result.TimeZone;
                calendar.timeFormat = result.TimeFormat ? result.TimeFormat : calendar.timeFormat;
                calendar.rowHeaderCols = result.RowHeaderCols ? result.RowHeaderCols : calendar.rowHeaderCols;
                if (typeof result.DurationBarMode !== "undefined") calendar.durationBarMode = result.DurationBarMode;
                //if (typeof result.ShowBaseTimeHeader !== "undefined") calendar.showBaseTimeHeader = result.ShowBaseTimeHeader;

                // calendar.cornerBackColor = result.CornerBackColor ? result.CornerBackColor : calendar.cornerBackColor;
                if (typeof result.CornerHTML !== 'undefined') { calendar.cornerHtml = result.CornerHTML; }

                calendar.hashes = result.Hashes;

                calendar._calculateCellWidth();
                calendar._prepareItline();

                calendar._loadResources();
                calendar._expandCellProperties();

                calendar._createCells();

            }
            if (result.Action !== "Scroll") {
                calendar._loadEvents(result.Events);
            }

            if (result.UpdateType === 'Full') {
                calendar._deleteRowHeaders();
                calendar._drawResHeader();
                calendar._updateCorner();
                calendar._drawTimeHeader();
            }

            calendar._prepareRowTops();
            calendar._show();
            //calendar._updateHeight(); // test
            calendar._resize();

            calendar._cache.drawArea = null;

            if (result.Action !== "Scroll") {
                calendar._updateRowHeaderHeights();
                calendar._updateHeaderHeight();

                if (calendar.heightSpec === 'Auto' || calendar.heightSpec === 'Max') {
                    calendar._updateHeight();
                }

                calendar._deleteCells();
                calendar._deleteEvents();
                calendar._deleteSeparators();

                calendar.multiselect.clear(true);
                calendar.multiselect._loadList(result.SelectedEvents);

                calendar._drawCells();
                calendar._drawSeparators();
                calendar._drawEvents();
            }
            else {
                calendar.multiselect.clear(true);
                calendar.multiselect._loadList(result.SelectedEvents);

                //calendar._updateRowsNoLoad(updatedRows, true);

                // draw events not called here because it's now called in loadEventsDynamic
                //calendar._drawCells();

                calendar._loadEventsDynamic(result.Events);
            }

            if (calendar.timeRangeSelectedHandling !== "HoldForever") {
                calendar._deleteRange();
            }

            if (result.UpdateType === "Full") {
                calendar.setScroll(result.ScrollX, result.ScrollY);
                calendar._saveState();
            }

            calendar._updateFloats();

            calendar._deleteDragSource();

            if (result.SelectedRows) {
                calendar._loadSelectedRows(result.SelectedRows);
            }

            calendar._loadingStop();

            if (result.UpdateType === 'Full' && navigator.appVersion.indexOf("MSIE 7.") !== -1) { // ugly bug, ugly fix - the time header disappears after expanding a dynamically loaded tree node
                window.setTimeout(function() {
                    calendar._deleteRowHeaders();
                    calendar._drawResHeader();
                    calendar._updateHeight();
                }, 0);
            }

            calendar._startAutoRefresh();

            if (result.Message) {
                if (calendar.message) { // condition can be removed as soon as message() is implemented properly
                    calendar.message(result.Message);
                }
            }

            calendar._fireAfterRenderDetached(result.CallBackData, true);

            calendar._doCallBackEnd();

            calendar._clearCachedValues();

            if (result.UpdateType === 'Full' && result.Action !== "Scroll" && !calendar.onScrollCalled) {
                setTimeout(function() {
                    calendar._onScroll();
                }, 0);
            }
        };

        this._deleteDragSource = function() {
            if (calendar._todo) {
                if (calendar._todo._del) {
                    var del = calendar._todo._del;
                    del.parentNode.removeChild(del);
                    calendar._todo._del = null;
                }
            }
        };

        this._fireAfterRenderDetached = function(data, isCallBack) {
            var afterRenderDelayed = function(data, isc) {
                return function() {
                    if (calendar._api2()) {
                        if (typeof calendar.onAfterRender === 'function') {
                            var args = {};
                            args.isCallBack = isc;
                            args.isScroll = false;
                            args.data = data;

                            calendar.onAfterRender(args);
                        }
                    }
                    else {
                        if (calendar.afterRender) {
                            calendar.afterRender(data, isc);
                        }
                    }
                };
            };

            window.setTimeout(afterRenderDelayed(data, isCallBack), 0);
        };

        this.scrollTo = function(date, animated, position) {

            if (calendar.infiniteScrollingEnabled) {
                if (calendar._initialized) {
                    var endPx = calendar.getPixels(calendar.visibleEnd()).left;
                    var endSafePx = endPx - calendar.infiniteScrollingMargin - calendar.nav.scroll.clientWidth;
                    var endSafe = calendar.getDate(endSafePx, true, true);

                    var withinRange = overlaps(calendar.visibleStart(), endSafe, date, date);
                    if (!withinRange) {
                        calendar.infinite.scrollTo(date);
                        return;
                    }
                }
                calendar._scrollTo(date, animated, position);
                return;
            }

            if (calendar._angular2.enabled) {
                calendar._angular2.scrollToRequested = date;
                setTimeout(function() {
                    var date = calendar._angular2.scrollToRequested;
                    if (date) {
                        calendar._scrollToAfterInit = null;
                        calendar._scrollTo(date, animated, position);
                    }
                }, 0);
            }
            else {
                calendar._scrollTo(date, animated, position);
            }
        };

        this._scrollTo = function(date, animated, position) {
            if (!date) {
                return;
            }

            if (!calendar._initialized) {
                calendar._scrollToAfterInit = {"date": date, "animated": animated, "position": position};
                return;
            }

            if (calendar.viewType === "Days") {
                var dpd = new DayPilot.Date(date);
                var row = calendar._findRowInDaysView(dpd);
                if (!row) {
                    return;
                }

                if (calendar._react.react) {
                    var scrollY = row.top - calendar._grids.top.height;
                    calendar.nav.scroll.scrollTop = scrollY;
                }
                else {
                    setTimeout(function() {
                        var scrollY = row.top - calendar._grids.top.height;
                        calendar.nav.scroll.scrollTop = scrollY;
                    }, 100);
                }

                var hours = dpd.getTimePart();
                date = calendar.visibleStart().getDatePart().addTime(hours);
            }

            var pixels;
            if (date instanceof DayPilot.Date) {
                pixels = this.getPixels(date).left;
            }
            else if (typeof date === "string") {
                pixels = this.getPixels(new DayPilot.Date(date)).left;
            }
            else if (typeof date === "number") {
                pixels = date;
            }
            else {
                throw new DayPilot.Exception("Invalid scrollTo() parameter. Accepted parameters: string (ISO date), number (pixels), DayPilot.Date object");
            }

            var max = calendar._maind.clientWidth;
            var width = calendar.nav.scroll.clientWidth;

            position = position || "left";
            switch(position.toLowerCase()) {
                case "left":
                    break;
                case "middle":
                    pixels -= width/2;
                    break;
                case "right":
                    pixels -= width;
                    break;
            }

            if (pixels < 0) {
                pixels = 0;
            }

            if (pixels > max - width) {
                pixels = max - width;
            }

            if (!animated) {
                calendar._setScrollX(pixels);
                return;
            }

            var distance = Math.abs(calendar.nav.scroll.scrollLeft - pixels);
            var percentage = distance / max;

            var steps = 50;


            if (typeof animated === "number") {
                steps = animated;
            }
            else if (typeof animated === "string") {
                switch (animated) {
                    case "fast":
                        steps = 30;
                        break;
                    case "normal":
                        steps = 50;
                        break;
                    case "slow":
                        steps = 100;
                        break;
                    case "linear":
                        steps = Math.floor(100 * percentage);
                        break;
                }
            }

            if (percentage > .6) {
                steps = Math.min(steps, 80);
            }

            calendar._scrollToAnimated(pixels, steps);
        };

        this._scrollToAnimated = function(pixels, steps) {
            var plan = {};
            plan.steps = [];
            plan.index = 0;
            plan.delay = 10;
            plan.next = function() {
                var step = plan.steps[plan.index];
                plan.index += 1;
                return step;
            };
            plan.finished = function() {
                calendar._onScroll();
            };

            var pos = calendar.getScrollX();
            var steps = steps || 100;
            var diff = pixels - pos;

            for (var i = 0; i < steps; i++) {
                var x = i/steps;
                var pct = ((x-.5)*2)/(Math.pow(((x-0.5)*2),2)+1)+.5;
                plan.steps.push(pos + diff*pct);
            }

            plan.steps.push(pixels);

            scrollStep(plan);

            function scrollStep(plan) {
                var step = plan.next();
                if (typeof step === "undefined") {
                    plan.finished && plan.finished();
                    return;
                }
                calendar.setScrollX(step);
                window.clearTimeout(calendar.refreshTimeout);
                setTimeout(function() {
                    scrollStep(plan);
                }, plan.delay);
            }

        };

        this.scrollToResource = function(param) {
            DayPilot.complete(function() {
                var row;
                if (typeof param === "string" || typeof param === "number") {
                    row = calendar._findRowByResourceId(param);
                }
                else if (param instanceof DayPilot.Row) {
                    row = calendar._findRowByResourceId(param.id);
                }
                else {
                    throw new DayPilot.Exception("Invalid scrollToResource() argument: id or DayPilot.Row expected");
                }

                if (!row) {
                    return;
                }
                setTimeout(function() {
                    var scrollY = row.top;
                    calendar.nav.scroll.scrollTop = scrollY;
                }, 100);

            });
        };

        this._findHeadersInViewPort = function() {

            if (!this.floatingTimeHeaders) {
                return;
            }

            if (!this.timeHeader) {
                return;
            }

            var area = calendar._getDrawArea();
            if (!area) {
                return;
            }

            calendar._deleteHeaderSections();

            var start = area.pixels.left + infitools._shiftX;
            var end = area.pixels.right + infitools._shiftX + area.sw;

            var cells = [];

            for (var y = 0; y < this.timeHeader.length; y++) {
                for (var x = 0; x < this.timeHeader[y].length; x++) {
                    var h = this.timeHeader[y][x];
                    var left = h.left;
                    var right = h.left + h.width;

                    var cell = null;

                    if (left < start && start < right) {
                        cell = {};
                        cell.x = x;
                        cell.y = y;
                        cell.marginLeft = start - left;
                        cell.marginRight = 0;
                        cell.div = calendar._cache.timeHeader[x + "_" + y];
                        cells.push(cell);
                    }
                    if (left < end && end < right) {
                        if (!cell) {
                            cell = {};
                            cell.x = x;
                            cell.y = y;
                            cell.marginLeft = 0;
                            cell.div = calendar._cache.timeHeader[x + "_" + y];
                            cells.push(cell);
                        }
                        cell.marginRight = right - end;

                        break; // end of this line
                    }
                }
            }

            for (var i = 0; i < cells.length; i++) {
                var cell = cells[i];
                calendar._createHeaderSection(cell.div, cell.marginLeft, cell.marginRight);
            }

        };

        this._updateFloats = function() {
            calendar._findHeadersInViewPort();
            calendar._findEventsInViewPort();
        };

        this._viewport = {};

        var viewport = calendar._viewport;

        viewport._eventsInRectangle = function(x, y, width, height) {
            var startX = x;
            var endX = x + width;

            var startY = y;
            var endY = y + height;

            return createList(calendar.elements.events).filter(function(e) {
                var data = e.event;
                var left = data.part.left;
                var right = data.part.left + data.part.width;

                var row = calendar.rowlist[data.part.dayIndex];
                var top = row.top + data.part.top;
                var bottom = top + data.part.height;

                if (overlaps(left, right, startX, endX) && overlaps(top, bottom, startY, endY)) {
                    return true;
                }
            });
        };

        viewport._events = function(type) {
            var list = [];
            var type = type || "All";

            var area = calendar._getDrawArea();
            if (!area) {
                return createList(list);
            }

            var start = area.pixels.left;
            var end = area.pixels.right;


            for(var i = 0; i < calendar.elements.events.length; i++) {
                var e = calendar.elements.events[i];
                var data = e.event;
                var left = data.part.left;
                var right = data.part.left + data.part.width;

                switch (type) {
                    case "Left":
                        if (left < start && start < right) {
                            list.push(e);
                        }
                        break;
                    case "All":
                        if (overlaps(left, right, start, end)) {
                            list.push(e);
                        }
                        break;
                }
            }
            return createList(list).addProps({ "area": area});
        };

        // freeze ok
        this._findEventsInViewPort = function() {

            if (!this.floatingEvents) {
                return;
            }

            var events = viewport._events("Left");

            calendar._deleteEventSections();

            events.filter(function(item) {
                return item.event.data.type !== "Milestone";
            }).forEach(function(item) {
                var e = item.event;
                var left = events.area.pixels.left;
                var start = e.part.left;
                var marginLeft = left - start;
                calendar._createEventSection(item, marginLeft, 0);
            });

        };

        this.elements.sections = [];
        this.elements.hsections = [];

        this._createHeaderSection = function(div, marginLeft, marginRight) {
            var section = createDiv();
            section.setAttribute("unselectable", "on");
            section.className = calendar._prefixCssClass("_timeheader_float");
            section.style.position = "absolute";
            section.style.left = marginLeft + "px";
            section.style.right = marginRight + "px";
            section.style.top = "0px";
            section.style.bottom = "0px";
            section.style.overflow = "hidden";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_timeheader_float_inner");
            inner.setAttribute("unselectable", "on");

            var props = div.cell.th;
/*
            if (props.innerHTML) {
                inner.innerHTML = props.innerHTML;
            }
*/
            inner.innerHTML = calendar._xssTextHtml(props.text, props.innerHTML);

            if (props.fontColor) {
                inner.style.color = props.fontColor;
            }
            section.appendChild(inner);

            div.section = section;

            div.insertBefore(section, div.firstChild.nextSibling); // after inner

            if (div.domArgs && div.domArgs.element) {
                var el = div.firstChild && div.firstChild.firstChild;
                if (el) {
                    el.style.display = "none";
                }
            }
            else {
                div.firstChild.innerHTML = ''; // hide the content of inner temporarily
            }


            this.elements.hsections.push(div);
        };

        this._deleteHeaderSections = function() {
            for (var i = 0; i < this.elements.hsections.length; i++) {
                var e = this.elements.hsections[i];

                // restore HTML in inner
                var data = e.cell;
                if (data && e.firstChild) { // might be deleted already
                    if (e.domArgs && e.domArgs.element) {
                        var el = e.firstChild && e.firstChild.firstChild;
                        if (el) {
                            el.style.display = "";
                        }
                    }
                    else {
                        // e.firstChild.innerHTML = data.th.innerHTML;
                        e.firstChild.innerHTML = calendar._xssTextHtml(data.th.text, data.th.innerHTML);;
                    }
                }

                deleteElement(e.section);
                e.section = null;
            }
            this.elements.hsections = [];
        };

        this._createEventSection = function(div, marginLeft, marginRight) {

            var section = createDiv();
            section.setAttribute("unselectable", "on");
            section.className = calendar._prefixCssClass(cssNames.eventFloat);
            section.style.position = "absolute";
            section.style.left = marginLeft + "px";
            section.style.right = marginRight + "px";
            section.style.top = "0px";
            section.style.bottom = "0px";
            section.style.overflow = "hidden";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass(cssNames.eventFloatInner);
            inner.setAttribute("unselectable", "on");
            inner.innerHTML = div.event.client.html();
            section.appendChild(inner);

            div.section = section;

            div.insertBefore(section, div.firstChild.nextSibling); // after inner
            // removing the html breaks React components inserted into events
            // div.firstChild.innerHTML = ''; // hide the content of inner temporarily

            if (div.domArgs && div.domArgs.element) {
                // div.domArgs.element.style.display = "none";
                var el = div && div.firstChild && div.firstChild.firstChild;
                if (el) {
                    el.style.display = "none";
                }
            }
            else {
                div.firstChild.innerHTML = ""; // hide the content of inner temporarily
            }


            var e = div.event;
            var cache = e.cache || e.data;
            var areas = e.cache ? e.cache.areas : e.data.areas;
            areas = areas || [];

            if (cache.fontColor) {
                inner.style.color = cache.fontColor;
            }

            var options = {
                "offsetX": calendar._cachedSegmentOffsetX(inner),
                "eventDiv": div,
                "areas": areas.filter(function(a) { return !(a.start || a.end) && !a.nonFloating; })  // only fixed-position areas
            };

            // DayPilot.Areas.remove(section);
            DayPilot.Areas.attach(section, div.event, options);
            DayPilot.Areas.disable(div);

            this.elements.sections.push(div);
        };

        this._cachedSegmentOffsetXValue = null;
        this._cachedSegmentOffsetX = function(inner) {
            if (calendar._cachedSegmentOffsetXValue === null) {
                calendar._cachedSegmentOffsetXValue = parseInt(new DayPilot.StyleReader(inner).get("padding-left"));
            }
            return calendar._cachedSegmentOffsetXValue;
        };

        this._deleteEventSections = function() {
            for (var i = 0; i < this.elements.sections.length; i++) {
                var e = this.elements.sections[i];

                // restore HTML in inner
                var data = e.event;
                if (data) { // might be deleted already
                    // e.firstChild.innerHTML = data.client.html();
                    if (e.domArgs && e.domArgs.element) {
                        var el = e && e.firstChild && e.firstChild.firstChild;
                        if (el) {
                            el.style.display = '';
                        }
                    }
                    else {
                        e.firstChild.innerHTML = data.client.html();
                    }
                }

                deleteElement(e.section);
                DayPilot.Areas.enable(e);

                e.section = null;
            }
            this.elements.sections = [];
        };

        this.setScrollX = function(scrollX) {
            if (!calendar._angular2.enabled) {
                calendar._setScrollX(scrollX);
            }
            else {
                calendar._angular2.scrollXRequested = scrollX;
                setTimeout(function() {
                    var scrollX = calendar._angular2.scrollXRequested;
                    if (typeof scrollX === "number") {
                        calendar._setScrollX(scrollX);
                    }
                }, 0);
            }
        };

        this._setScrollX = function(scrollX) {
            var scroll = calendar.nav.scroll;
            var maxWidth = calendar._getGridWidth();

            if (scroll.clientWidth + scrollX > maxWidth) {
                scrollX = maxWidth - scroll.clientWidth;
            }

            calendar.divTimeScroll.scrollLeft = scrollX;
            scroll.scrollLeft = scrollX;
        };

        this.setScrollY = function(scrollY) {
            var options = options || {};

            if (!calendar._angular2.enabled) {
                calendar._setScrollY(scrollY);
            }
            else {
                calendar._angular2.scrollYRequested = scrollY;
                setTimeout(function() {
                    var scrollY = calendar._angular2.scrollYRequested;
                    if (typeof scrollY === "number") {
                        calendar._setScrollY(scrollY);
                    }
                }, 0);
            }
        };

        this._setScrollY = function(scrollY) {
            var scroll = calendar.nav.scroll;
            var maxHeight = calendar._innerHeightTree;

            if (scroll.clientHeight + scrollY > maxHeight) {
                scrollY = maxHeight - scroll.clientHeight;
            }

            calendar.divResScroll.scrollTop = scrollY;
            scroll.scrollTop = scrollY;
        };

        this.setScroll = function(scrollX, scrollY) {
            calendar.setScrollX(scrollX);
            calendar.setScrollY(scrollY);
        };

        this._messageLeft = function() {
            return calendar._getOuterRowHeaderWidth() + resolved._splitterWidth() - 1;
        };

        /*
        options.delay
        options.cssClass
        options.rawHtml

         */
        this.message = function(text, opt) {
            if (text === null) {
                return;
            }

            if (!calendar._initialized) {
                return;
            }

            var options = {};
            var delay;
            if (typeof arguments[1] === "object") {
                options = arguments[1];
                delay = options.delay;
            }
            else {
                delay = opt;
            }

            var html = "";
            if (options.rawHtml) {
                html = text;
            }
            else {
                html = DayPilot.Util.escapeHtml(text);
            }

            delay = delay || this.messageHideAfter || 2000;

            var top = calendar._getTotalHeaderHeight() + 1;
            var left = calendar._messageLeft();
            var right = DayPilot.sw(calendar.nav.scroll) + 1;
            var bottom = DayPilot.sh(calendar.nav.scroll);

            var div;

            if (!this.nav.message) {
                div = createDiv();
                div.style.position = "absolute";
                //div.style.width = "100%";
                div.style.left = left + "px";
                div.style.right = right + "px";
                //div.style.height = "0px";
                //div.style.paddingLeft = left + "px";
                //div.style.paddingRight = right + "px";

                //div.style.opacity = 1;
                //div.style.filter = "alpha(opacity=100)"; // enable fading in IE8
                div.style.display = 'none';

                DayPilot.rePassive(div, DayPilot.touch.start, function(e) {
                    calendar.nav.message.style.display = 'none';
                    // e.preventDefault();
                    e.stopPropagation();
                });

                div.onmousemove = function() {
                    if (!calendar.messageHideOnMouseOut) {
                        return;
                    }
                    if (div.messageTimeout && !div.status) {
                        clearTimeout(div.messageTimeout);
                    }
                };

                div.onmouseout = function() {
                    if (!calendar.messageHideOnMouseOut) {
                        return;
                    }
                    if (calendar.nav.message.style.display !== 'none') {
                        div.messageTimeout = setTimeout(calendar._hideMessage, 500);
                    }
                };

                var inner = createDiv();
                inner.onclick = function() { calendar.nav.message.style.display = 'none'; };
                inner.className = calendar._prefixCssClass("_message");
                div.appendChild(inner);

                var close = createDiv();
                close.style.position = "absolute";
                close.className = calendar._prefixCssClass("_message_close");
                close.onclick = function() { calendar.nav.message.style.display = 'none'; };
                div.appendChild(close);

                this.nav.top.appendChild(div);
                this.nav.message = div;

            }
            else {
                div = calendar.nav.message;
            }

            var showNow = function() {

                if (!calendar.nav.message) {  // UpdatePanel refresh
                    return;
                }

                var inner = calendar.nav.message.firstChild;
                inner.className = calendar._prefixCssClass("_message"); // clear any custom css that may have been set

                if (options.cssClass) {
                    addClass(inner, options.cssClass);
                }

                inner.innerHTML = html;

                // update the right margin (scrollbar width)
                var right = DayPilot.sw(calendar.nav.scroll);
                calendar.nav.message.style.right = right + "px";

                // always update the position
                var position = calendar.messageBarPosition || "Top";
                if (position === "Bottom") {
                    calendar.nav.message.style.bottom = bottom + "px";
                    calendar.nav.message.style.top = "";
                }
                else if (position === "Top") {
                    calendar.nav.message.style.bottom = "";
                    calendar.nav.message.style.top = top + "px";
                }

                var end = function() { div.messageTimeout = setTimeout(calendar._hideMessage, delay); };
                DayPilot.fade(calendar.nav.message, 0.2, end);
            };

            clearTimeout(div.messageTimeout);

            // another message was visible
            if (this.nav.message.style.display !== 'none') {
                DayPilot.fade(calendar.nav.message, -0.2, showNow);
            }
            else {
                showNow();
            }
        };

        this._hideMessage = function() {
            if (!calendar.nav) {
                return;
            }
            if (!calendar.nav.message) {
                return;
            }

            var end = function() {
                calendar.nav.message.style.display = 'none';
            };
            DayPilot.fade(calendar.nav.message, -0.2, end);
        };

        this._hideMessageNow = function() {
            if (!calendar.nav) {
                return;
            }
            if (!calendar.nav.message) {
                return;
            }
            calendar.nav.message.style.display = 'none';
        };

        this.message.show = function(html) {
            calendar.message(html);
        };

        this.message.hide = function() {
            calendar._hideMessage();
        };

        this._originalBorder = null;

        // updates the height after a resize
        this._updateHeight = function() {

            // only if the control is not disposed already
            if (!this.nav.scroll) {
                return;
            }

            (function fromDrawCells() {
                var width = calendar._getGridWidth();

                calendar._maind.style.height = calendar._innerHeightTree + "px";
                calendar._maind.style.width = width + "px";

                if (calendar.cellWidthSpec === "Auto" && !calendar._minCellWidthApplied) {
                    calendar.nav.scroll.style.overflowX = "hidden";
                    calendar.nav.scroll.scrollLeft  = 0;
                }
                else {
                    if (width > calendar.nav.scroll.clientWidth) {
                        calendar.nav.scroll.style.overflowX = "auto";
                    }
                    else {
                        calendar.nav.scroll.style.overflowX = "hidden";
                    }
                }
            })();


            var dividerHeight = calendar.timeHeaderPosition === "None" ? 0 : 1;

            if (this._originalBorder !== null) {
                this.nav.top.style.border = this._originalBorder;
                this._originalBorder = null;
            }

            if (this.heightSpec === 'Parent100Pct' || this.heightSpec === "Max100Pct") {
                // similar to setHeight()
                this.nav.top.style.height = "100%";
                if (this.hideBorderFor100PctHeight) {
                    this._originalBorder = this.nav.top.style.border;
                    this.nav.top.style.border = "0 none";
                }
                this.height = parseInt(this.nav.top.clientHeight, 10) - (this._getTotalHeaderHeight()) - dividerHeight;
            }

            /*if (this.heightSpec === 'Max100Pct') {
                this.nav.top.style.height = '';
            }*/

            // getting ready for the scrollbar
            // keep it here, firefox requires it to get the scrollbar height
            this.nav.scroll.style.height = '30px';

            var height = this._getScrollableHeight();

            var total = height + this._getTotalHeaderHeight() + dividerHeight;
            if (height >= 0) {
                this.nav.scroll.style.height = (height) + 'px';
                this._scrollRes.style.height = (height) + 'px';
            }
            if (this.nav.divider) {
                if (!total || isNaN(total) || total < 0) {
                    total = 0;
                }
                this.nav.divider.style.height = (total) + "px";
            }

            // required for table-based mode
            if (this.heightSpec !== "Parent100Pct") {
                this.nav.top.style.height = (total) + "px";
            }

            if (calendar.nav.resScrollSpace) {
                var spaceHeight = 30 + calendar._grids.bottom.height;
                if (calendar.heightSpec === "Auto") {
                    spaceHeight = DayPilot.sh(calendar.nav.scroll);
                }
                calendar.nav.resScrollSpace.style.height = spaceHeight + "px";
            }

            for (var i = 0; i < this.elements.separators.length; i++) {
                this.elements.separators[i].style.height = this._innerHeightTree + 'px';
            }
            for (var i = 0; i < this.elements.linesVertical.length; i++) {
                this.elements.linesVertical[i].style.height = this._innerHeightTree + 'px';
            }

            calendar._fixedUpdatePosition();

            calendar._detectDimensionChange();

        };

        this._prepareItline = function() {

            this.startDate = new DayPilot.Date(this.startDate).getDatePart();

            this._cache.pixels = [];
            this.itline = createList();

            var autoCellWidth = this.cellWidthSpec === "Auto";
            //var customWidth = false;


            var updateCellWidthForAuto = function() {
                if (!autoCellWidth) {
                    return;
                }
                var count = 0;
                /*
                if (calendar.timeHeader) {
                    if (calendar.timeline) {
                        count = calendar.timeline.length;
                    }
                    else {
                        //var row = calendar.timeHeader[calendar.timeHeader.length - 1];
                        //count = row.length;

                    }
                }
                */
                if (calendar._serverBased() && calendar.timeline) {
                    count = calendar.timeline.length;
                }
                else {
                    if (calendar.scale === "Manual") {
                        count = calendar.timeline.length;
                    }
                    else {
                        calendar._generateTimeline();  // hack
                        count = calendar.itline.length;
                        calendar.itline = createList();
                    }
                }
                var width = calendar._getScrollableWidth();
                if (count > 0 && width > 0) {
                    // calendar.cellWidth = width / count;

                    var cell = width / count;
                    calendar.cellWidth = atLeast(cell, calendar.cellWidthMin);
                    calendar._minCellWidthApplied = cell < calendar.cellWidthMin;
                }
                //calendar.debug.message("updated cellWidth: " + calendar.cellWidth);

            };

            // required for event group calculation
            updateCellWidthForAuto();

            // set on the server, copy from there
            if (this._serverBased() && this.timeline) {  // timeline supplied from the server
                if (this.timeline) {  // TODO dissolve
                    this.itline = createList();
                    var lastEnd = null;
                    var left = 0;
                    for (var i = 0; i < this.timeline.length; i++) {

                        var src = this.timeline[i];
                        var cell = {};
                        cell.start = new DayPilot.Date(src.start);
                        cell.end =  src.end ? new DayPilot.Date(src.end) : cell.start.addMinutes(this.cellDuration);

                        if (!src.width) {
                            var right = Math.floor(left + this.cellWidth);
                            var width = right - Math.floor(left);

                            cell.left = Math.floor(left);
                            cell.width = width;
                            left += this.cellWidth;
                        }
                        else {
                            cell.left = src.left || left; // left is optional TODO remove original syntax
                            cell.width = src.width || this.cellWidth; // width is optional TODO remove original syntax
                            left += cell.width;
                        }

                        /*
                        if (autoCellWidth) {
                            cell.left = Math.floor(left);
                            cell.width = Math.floor(this.cellWidth); // width is optional
                        }
                        else {
                            cell.left = src.left || left; // left is optional
                            cell.width = src.width || this.cellWidth; // width is optional
                        }
                        */


                        cell.breakBefore = lastEnd && lastEnd.ticks !== cell.start.ticks;
                        lastEnd = cell.end;

                        this.itline.push(cell);
                    }
                }

                if (autoCellWidth) {
                    this._updateHeaderGroupDimensions();
                }
            }
            else {
                this.timeHeader = [];

                if (this.scale === "Manual") {
                    this.itline = createList();
                    var left = 0;
                    var lastEnd = null;
                    for (var i = 0; this.timeline && i < this.timeline.length; i++) {
                        var src = this.timeline[i];

                        var cell = {};
                        cell.start = new DayPilot.Date(src.start);
                        cell.end =  src.end ? new DayPilot.Date(src.end) : cell.start.addMinutes(this.cellDuration);

                        if (lastEnd && cell.start.ticks < lastEnd.ticks) {
                            throw new DayPilot.Exception("The timeline must be sequential");
                        }

                        var w = src.width || this.cellWidth;

                        var right = Math.floor(left + w);
                        var width = right - Math.floor(left);

                        cell.left = Math.floor(left);
                        cell.width = width;
                        left += w;

                        // TODO custom width

                        //cell.left = Math.floor(left);
                        //cell.width = Math.floor(src.width || this.cellWidth);
                        //cell.breakBefore = src.breakBefore;

                        cell.breakBefore = lastEnd && lastEnd.ticks !== cell.start.ticks;
                        lastEnd = cell.end;

                        this.itline.push(cell);

                        //left += cell.width;
                    }
                }
                else {
                    this._generateTimeline();
                }

                //updateItlineForAutoCellWidth();
                this._prepareHeaderGroups();
            }
        };

        // public API
        this.infinite = {};
        this.infinite.shiftStart = function(days) {
            infitools._shiftStart(days);
        };
        this.infinite.scrollTo = function(date) {
            infitools._shiftTo(date);
        };

        this._infitools = {};
        var infitools = this._infitools;

        infitools._shiftX = 0;
        infitools._active = false;

        infitools._updateRowStarts = function() {
            calendar._rowlistMerged().forEach(function(row, i) {
                row.start = calendar._visibleStart();
                row.data = null;
                calendar._ensureRowData(row.index, row.grid);
            });
        };

        infitools._isEnabled = function() {
            return calendar.infiniteScrollingEnabled && !calendar._serverBased();
        };

        infitools._shiftTo = function(day) {
            var day = new DayPilot.Date(day);
            var start = day.addDays(-calendar.infiniteScrollingStepDays).getDatePart();
            var diff = new DayPilot.Duration(start.getTime() - calendar.startDate.getDatePart().getTime()).totalDays();
            infitools._shiftStart(diff, day);
        };

        infitools._shiftStart = function(days, scrollTo) {
            var pixels;

            infitools._active = true;

            var original = calendar.startDate;
            var newStart = calendar.startDate.addDays(days);

            if (days > 0) {
                pixels = -calendar.getPixels(newStart).left;
            }

            calendar.startDate = calendar.startDate.addDays(days);

            calendar.itline = createList();
            calendar._cache.pixels = [];
            calendar._bcrCache = {};
            calendar._generateTimeline();
            infitools._updateRowStarts();

            if (days < 0) {
                pixels = calendar.getPixels(original).left;
            }

            calendar.timeHeader = []; // force redraw
            calendar._prepareHeaderGroups();
            calendar._drawTimeHeader();


            calendar.cellProperties = {};

            calendar._deleteCells();
            calendar._deleteSeparators();

            calendar._loadEvents();
            calendar._deleteEvents();

            calendar._prepareRowTops();
            calendar._updateRowHeaderHeights();

            // make sure the scrollbar is visible
            calendar._updateHeight();

            // calendar._clearCachedValues();
            // calendar._updateRowHeaderHeights();
            // calendar._drawResHeadersProgressive();

            // don't call drawCells here, it's called by onScroll
            if (typeof scrollTo !== 'undefined') {
                calendar.scrollTo(new DayPilot.Date(scrollTo));
                calendar._onScroll();
                //calendar.nav.scroll.scrollLeft = scrollX;
            }
            else {
                calendar.nav.scroll.scrollLeft += pixels;
            }

            calendar._drawSeparators();
            calendar._drawEvents();

            infitools._active = false;

            /*// debounce
            setTimeout(function() {
                infitools._active = false;
            }, 100);*/

        };

        this._generateTimeline = function() {

            if (!calendar._initialized && infitools._isEnabled()) {
                this.startDate = this.startDate.addDays(-this.infiniteScrollingStepDays);
            }

            var _endDate = (this.viewType !== 'Days') ? this.startDate.addDays(this.days) : this.startDate.addDays(1);

            var start = this.startDate;
            var end = this._addScaleSize(start); //
            var breakBefore = false;

            var left = 0;
            var previousEnd = null;
            while (end.ticks <= _endDate.ticks && end.ticks > start.ticks) {

                var adjustedStart = start;
                var adjustedEnd = end;
                if (calendar.showNonBusinessForceHours && calendar.scale == "Day") {
                    adjustedStart = start.addHours(calendar.businessBeginsHour);
                    adjustedEnd = start.addHours(calendar.businessEndsHour);
                }

                var args = this._includeCell(adjustedStart, adjustedEnd, true);

                if (!args.cell.start || !args.cell.end) {
                    throw new DayPilot.Exception("Invalid timeline cell start/end: start and/or end not specified");
                }

                args.cell.start = new DayPilot.Date(args.cell.start);
                args.cell.end = new DayPilot.Date(args.cell.end);

                if (args.cell.start >= args.cell.end) {
                    throw new DayPilot.Exception("Invalid timeline cell start/end: end before start");
                }
                if (previousEnd && previousEnd.ticks > args.cell.start.ticks) {
                    throw new DayPilot.Exception("Invalid timeline cell start/end: overlapping cells");
                }

                if (previousEnd && previousEnd.ticks < args.cell.start.ticks) {
                    breakBefore = true;
                }
                else {
                    breakBefore = false;
                }

                var cellWidth = args.cell.width || calendar.cellWidth;

                if (args.cell.visible) {

                    var right = Math.floor(left + cellWidth);
                    var width = right - Math.floor(left);

                    var timeCell = {};
                    timeCell.start = args.cell.start;
                    timeCell.end = args.cell.end;
                    timeCell.left = Math.floor(left);
                    timeCell.width = width;
                    timeCell.breakBefore = breakBefore;

                    this.itline.push(timeCell);

                    left += cellWidth;

                    previousEnd = args.cell.end;
                }

                start = end;
                end = this._addScaleSize(start);

            }
        };

        this._updateHeaderGroupDimensions = function() {
            if (!this.timeHeader) {
                return;
            }
            for (var y = 0; y < this.timeHeader.length; y++) {
                var row = this.timeHeader[y];
                for (var x = 0; x < row.length; x++) {
                    var h = row[x];

                    h.left = this.getPixels(new DayPilot.Date(h.start)).left;
                    var right = this.getPixels(new DayPilot.Date(h.end)).left;
                    var width = right - h.left;
                    h.width = width;
                }
            }
        };

        this._prepareHeaderGroups = function() {

            var timeHeaders = this.timeHeaders;
            if (!timeHeaders) {
                timeHeaders = [
                    {"groupBy": this.cellGroupBy},
                    {"groupBy": "Cell"}
                ];
            }

            if (this.itline.isEmpty()) {
                this.timeHeader = [];
                for (var i = 0; i < timeHeaders.length; i++) {
                    this.timeHeader[i] = [];
                }
                return;
            }


            var endDate = calendar._visibleEnd();

            //var timeHeaders = this.timeHeaders;
            for (var i = 0; i < timeHeaders.length; i++) {

                var groupBy = timeHeaders[i].groupBy;
                var format = timeHeaders[i].format;

                if (groupBy === "Default") {
                    groupBy = this.cellGroupBy;
                }

                var line = [];

                //var cell = {};
                var start = this._visibleStart();

                while (start.ticks < endDate.ticks) {

                    var h = {};
                    h.start = start;
                    h.end = this._addGroupSize(h.start, groupBy);

                    if (h.start.ticks === h.end.ticks) {
                        break;
                    }
                    h.left = this.getPixels(h.start).left;
                    var right = this.getPixels(h.end).left;
                    var width = right - h.left;
                    h.width = width;

                    // h.innerHTML changed to h.text
                    h.colspan = Math.ceil(width / (1.0 * this.cellWidth));
                    if (typeof format === "string") {
                        h.text = h.start.toString(format, resolved._locale());
                    }
                    else {
                        h.text = this._getGroupName(h, groupBy);
                    }
                    // h.text = h.innerHTML;

                    if (width > 0) {

                        if (typeof this.onBeforeTimeHeaderRender === 'function') {
                            var cell = {};
                            cell.start = h.start;
                            cell.end = h.end;
                            cell.text = h.text;
                            // cell.html = calendar._resolveXssText(h.text, h.innerHTML);
                            cell.html = null;
                            cell.toolTip = calendar._xssTextHtml(h.text);
                            //cell.color = null;
                            cell.backColor = null;
                            cell.fontColor = null;
                            cell.level = this.timeHeader.length;
                            cell.cssClass = null;

                            var args = {};
                            args.header = cell;
                            args.control = calendar;

                            this.onBeforeTimeHeaderRender(args);

                            // h.text = h.innerHTML; // original
                            h.innerHTML = calendar._xssTextHtml(cell.text, cell.html);
                            h.backColor = cell.backColor;
                            h.fontColor = cell.fontColor;
                            h.toolTip = cell.toolTip;
                            h.areas = cell.areas;
                            h.cssClass = cell.cssClass;
                        }

                        line.push(h);
                    }
                    start = h.end;
                }
                this.timeHeader.push(line);
            }
        };

        this._includeCell = function(start, end) {

            var cell = {};
            cell.start = start;
            cell.end = end;
            cell.visible = true;
            cell.width = null;

            var args = {};
            args.cell = cell;

            if (typeof this.onIncludeTimeCell === 'function') {
                this.onIncludeTimeCell(args);
                return args;
            }

            if (this.showNonBusiness) {
                return args;
            }

            var forceBusinessDay = calendar.viewType === "Days";
            args.cell.visible = this.isBusiness({"start":start, "end":end}, forceBusinessDay);

            return args;

        };


        // internal
        this.getPixels = function(date) {
            var ticks = date.ticks;

            var cache = this._cache.pixels[ticks];
            if (cache) {
                return cache;
            }

            var previous = null;
            var previousEndTicks = 221876841600000;  // December 31, 9000

            if (this.itline.length === 0 || ticks < this.itline[0].start.ticks) {
                var result = {};
                result.cut = false;
                result.left = 0;
                //result.left = -infinite.shiftX;
                result.boxLeft = result.left;
                result.boxRight = result.left;
                result.i = null; // not in range
                return result;
            }

            //var thisone = date.toString() === "2014-05-01T00:00:00";

            // quick hack
            var cursor = this._getItlineCellFromTimeBinary(date);
            //var startCell = cursor.previous || cursor.current;
            //var si = indexOf(startCell);
            var si = atLeast(cursor.i - 1, 0);

            for (var i = si; i < this.itline.length; i++) {
                //var found = false;
                var cell = this.itline[i];

                var cellStartTicks = cell.start.ticks;
                var cellEndTicks = cell.end.ticks;

                if (cellStartTicks < ticks && ticks < cellEndTicks) {  // inside
                    var offset = ticks - cellStartTicks;

                    var result = {};
                    result.cut = false;
                    result.left = cell.left + this._ticksToPixels(cell, offset);
                    result.boxLeft = cell.left;
                    result.boxRight = cell.left + cell.width;
                    result.i = i;
                    break;
                }
                else if (cellStartTicks === ticks) {  // start

                    var result = {};
                    result.cut = false;
                    result.left = cell.left;
                    result.boxLeft = result.left;
                    result.boxRight = result.left + cell.width;
                    result.i = i;
                    break;
                }
                else if (cellEndTicks === ticks) {  // end

                    var result = {};
                    result.cut = false;
                    result.left = cell.left + cell.width;
                    result.boxLeft = result.left;
                    result.boxRight = result.left;
                    result.i = i + 1;
                    break;
                }
                else if (ticks < cellStartTicks && ticks > previousEndTicks) {  // hidden

                    var result = {};
                    result.cut = true;
                    result.left = cell.left;
                    result.boxLeft = result.left;
                    result.boxRight = result.left;
                    result.i = i;
                    break;
                }

                previousEndTicks = cellEndTicks;
            }

            if (!result) {
                var last = this.itline[this.itline.length - 1];

                var result = {};
                result.cut = true;
                result.left = last.left + last.width;
                result.boxLeft = result.left;
                result.boxRight = result.left;
                result.i = null; // not in range
            }

            this._cache.pixels[ticks] = result;
            return result;
        };

        // left - pixel offset from start
        // precise - true: calculates exact date from pixels, false: the it's the cell start
        // isEnd - returns the end of the previous cell
        //
        // isEnd and precise can't be combined
        this.getDate = function(left, precise, isEnd) {
            //var x = Math.floor(left / this.cellWidth);
            var position = this._getItlineCellFromPixels(left, isEnd);

            if (!position) {
                return null;
            }

            var x = position.x;

            var itc = this.itline[x];

            if (!itc) {
                return null;
            }

            var start = (isEnd && !precise) ? itc.end : itc.start;

            if (!precise) {
                return start;
            }
            else {
                return start.addTime(this._pixelsToTicks(position.cell, position.offset));
            }

        };

        this._getItlineCellFromPixels = function(pixels, isEnd) {
            if (this.itline.length === 0) {
                return null;
            }

            var pos = 0;
            var previous = 0;
            for (var i = 0; i < this.itline.length; i++) {
                var cell = this.itline[i];
                var width = cell.width || this.cellWidth;
                pos += width;

                if ((pixels < pos) || (isEnd && pixels === pos)) {
                    var result = {};
                    result.x = i;
                    result.offset = pixels - previous;
                    result.cell = cell;
                    return result;
                }

                previous = pos;
            }
            var cell = calendar.itline.last();

            var result = {};
            result.x = this.itline.length - 1;
            result.offset = cell.width || this.cellWidth;
            result.cell = cell;
            return result;
        };

        this._getItlineCellFromTime = function(time) {
            return this._getItlineCellFromTimeBinary(time);
        };

        this._getItlineCellFromTimeBinary = function(time) {
            var pos = new DayPilot.Date(time);

            // before the itline
            var from = 0;
            var first = this.itline[0]; // || { "start": new DayPilot.Date(calendar.startDate)};
            if (pos.ticks < first.start.ticks) {
                var result = {};
                result.hidden = true;
                result.previous = null;
                result.current = null;
                result.next = this.itline[0];
                result.i = -1;
                return result;
            }

            var to = this.itline.length - 1;
            var last = this.itline[to]; // || { "end": new DayPilot.Date(calendar.startDate)};
            if (pos.ticks > last.end.ticks) {
                var result = {};   // not found at all, it's past the itline
                result.past = true;
                result.previous = this.itline[this.itline.length - 1];
                result.i = this.itline.length;
                return result;
            }

            if (pos.ticks === last.end.ticks) {
                var result = {};
                result.past = false;
                result.current = this.itline[this.itline.length - 1];
                result.i = this.itline.length - 1;
                return result;
            }

            var si = (function() {
                var itline = calendar.itline;
                var cur;
                while (from <= to) {
                    cur = Math.floor((from + to)/2);
                    if (itline[cur].start.ticks > pos.ticks) {
                        to = cur - 1;
                    }
                    else if (itline[cur].end.ticks < pos.ticks) {
                        from = cur + 1;
                    }
                    else {
                        return cur;
                    }
                }
                return from;
            })();

            for (var i = si; i < this.itline.length; i++) {
                var cell = this.itline[i];

                if (cell.start.ticks <= pos.ticks && pos.ticks < cell.end.ticks) {   // match
                // if (cell.start.ticks <= pos.ticks && pos.ticks <= cell.end.ticks) {   // match
                    var result = {};
                    result.hidden = false;
                    result.current = cell;
                    result.i = i;
                    return result;
                }
                if (pos.ticks < cell.start.ticks)   // it's a hidden cell or before the itline
                {
                    var result = {};
                    result.hidden = true;
                    result.previous = i > 0 ? this.itline[i - 1] : null;
                    result.current = null;
                    result.next = this.itline[i];
                    result.i = i;
                    return result;
                }
            }

            var result = {};   // not found at all, it's past the itline
            result.past = true;
            result.previous = this.itline[this.itline.length - 1];
            result.i = this.itline.length;
            return result;

        };

        this._ticksToPixels = function(cell, ticks) { // DEBUG check that it's not used improperly (timeline)
            var width = cell.width || this.cellWidth;
            var duration = cell.end.ticks - cell.start.ticks;
            return Math.floor((width * ticks) / (duration));
        };

        this._pixelsToTicks = function(cell, pixels) {
            var duration = cell.end.ticks - cell.start.ticks;
            var width = cell.width || this.cellWidth;
            return Math.floor(pixels / width * duration );
        };

        this._onEventClick = function(ev) {
            if (DpGlobal.touch.start) {
                return;
            }
            if (DayPilotScheduler._preventEventClick) {
                return;
            }
            calendar._moving = {}; // clear
            calendar._eventClickDispatch(this, ev);
        };

        this.eventClickPostBack = function(e, data) {
            this._postBack2('EventClick', e, data);
        };
        this.eventClickCallBack = function(e, data) {
            this._callBack2('EventClick', e, data);
        };

        this._eventClickDispatch = function(div, ev) {

            var e = div.event;

            if (!e) {  // heavy dynamic loading fix
                return;
            }

            // div.focus();

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }

            //if (calendar.eventDoubleClickHandling === 'Disabled') {
            if (!e.client.doubleClickEnabled()) {
                calendar._eventClickSingle(div, ev);
                return;
            }

            if (!calendar._timeouts.click) {
                calendar._timeouts.click = [];
            }

            var eventClickDelayed = function(div, ev) {
                return function() {
                    calendar._eventClickSingle(div, ev);
                };
            };

            calendar._timeouts.click.push(window.setTimeout(eventClickDelayed(div, ev), calendar.doubleClickTimeout));

        };

        this._getItline = function(x) {
            return calendar.itline[x];
        };

        this._eventClickSingle = function(div, ev) {

            if (typeof ev === "boolean") {
                throw new DayPilot.Exception("Invalid _eventClickSingle parameters");
            }
            var e = div.event;

            if (!e) {
                return;
            }

            var ctrlKey = ev.ctrlKey;
            var metaKey = ev.metaKey;

            if (!e.client.clickEnabled()) {
                return;
            }

            calendar._updateCoords(ev);

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;
                args.div = div;
                args.originalEvent = ev;
                args.ctrl = ctrlKey;
                args.meta = metaKey;
                args.shift = ev.shiftKey;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.toJSON = function() {
                    return copyProps(args, {}, ["e", "ctrl", "meta", "shift"]);
                };

                if (typeof calendar.onEventClick === 'function') {
                    calendar.onEventClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(div);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ctrlKey, metaKey);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case "RectangleSelect":
                        // if (calendar.multiSelectRectangle !== "Disabled") {
                        if (resolved._rectangleSelectMode() !== "Disabled") {
                            rectangle.start();
                            return false;
                        }
                        break;

                }

                if (typeof calendar.onEventClicked === 'function') {
                    calendar.onEventClicked(args);
                }

            }
            else {
                switch (calendar.eventClickHandling) {
                    case 'PostBack':
                        calendar.eventClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventClick(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(div);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ctrlKey, metaKey);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case "RectangleSelect":
                        // if (calendar.multiSelectRectangle !== "Disabled") {
                        if (resolved._rectangleSelectMode() !== "Disabled") {
                            rectangle.start();
                            return false;
                        }
                        break;

                }

            }

        };

        this._eventDeleteDispatch = function(e) {

            if (calendar._api2()) {

                var performDelete = function() {
                    if (args.preventDefault.value) {
                        return;
                    }

                    args.loaded = function() {};

                    switch (calendar.eventDeleteHandling) {
                        case 'PostBack':
                            calendar.eventDeletePostBack(e);
                            break;
                        case 'CallBack':
                            calendar.eventDeleteCallBack(e);
                            break;
                        case 'Update':
                            calendar.events.remove(e);
                            if (typeof DayPilot.Bubble !== "undefined") {
                                DayPilot.Bubble.hideActive();
                            }
                            break;
                    }

                    if (typeof calendar.onEventDeleted === 'function') {
                        calendar.onEventDeleted(args);
                    }
                };

                var args = {};
                args.async = false;
                args.e = e;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.control = calendar;
                args.toJSON = function() {
                    return copyProps(args, {}, ["e"]);
                };
                args.loaded = function() {
                    performDelete();
                };

                if (typeof calendar.onEventDelete === 'function') {
                    calendar.onEventDelete(args);
                }

                if (!args.async) {
                    performDelete();
                }


            }
            else {
                switch (calendar.eventDeleteHandling) {
                    case 'PostBack':
                        calendar.eventDeletePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDeleteCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDelete(e);
                        break;
                }
            }

        };

        this.eventDeletePostBack = function(e, data) {
            this._postBack2('EventDelete', e, data);
        };
        this.eventDeleteCallBack = function(e, data) {
            this._callBack2('EventDelete', e, data);
        };

        // obsolete
        this.setHScrollPosition = function(pixels) {
            this.nav.scroll.scrollLeft = pixels;
        };

        this.getScrollX = function() {
            return this.nav.scroll.scrollLeft;
        };

        // obsolete
        this.getHScrollPosition = this.getScrollX;

        this.getScrollY = function() {
            return this.nav.scroll.scrollTop;
        };

        this._eventSelect = function(div, e, ctrlKey, metaKey) {
            calendar._eventSelectDispatch(div, e, ctrlKey, metaKey);
        };

        this.eventSelectPostBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._postBack2('EventSelect', params, data);
        };
        this.eventSelectCallBack = function(e, change, data) {
            var params = {};
            params.e = e;
            params.change = change;
            this._callBack2('EventSelect', params, data);
        };

        this._eventSelectDispatch = function(div, e, ctrlKey, metaKey) {
            //var e = this.selectedEvent();

            var m = calendar.multiselect;

            var allowDeselect = false;
            var isSelected = m.isSelected(e);
            var ctrlOrMeta = ctrlKey || metaKey;
            if (!ctrlOrMeta && isSelected && !allowDeselect && m._list.length === 1) {
                return;
            }

            if (calendar._api2()) {

                m._previous = m.events();

                var args = {};
                args.e = e;
                args.selected = isSelected;
                args.ctrl = ctrlKey;
                args.meta = metaKey;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventSelect === 'function') {
                    calendar.onEventSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'Update':
                        m._toggleDiv(div, ctrlKey, metaKey);
                        break;
                }

                if (typeof calendar.onEventSelected === 'function') {
                    args.change = m.isSelected(e) ? "selected" : "deselected";
                    args.selected = m.isSelected(e);
                    calendar.onEventSelected(args);
                }

            }
            else {
                m._previous = m.events();
                m._toggleDiv(div, ctrlKey, metaKey);
                var change = m.isSelected(e) ? "selected" : "deselected";

                switch (calendar.eventSelectHandling) {
                    case 'PostBack':
                        calendar.eventSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        if (typeof WebForm_InitCallback !== 'undefined') {
                            window.__theFormPostData = "";
                            window.__theFormPostCollection = [];
                            WebForm_InitCallback();
                        }
                        calendar.eventSelectCallBack(e, change);
                        break;
                    case 'JavaScript':
                        calendar.onEventSelect(e, change);
                        break;
                }
            }


        };

        this.eventRightClickPostBack = function(e, data) {
            this._postBack2('EventRightClick', e, data);
        };
        this.eventRightClickCallBack = function(e, data) {
            this._callBack2('EventRightClick', e, data);
        };

        this._eventRightClickDispatch = function(ev) {

            if (DpGlobal.touch.active || DpGlobal.touch.start) {
                return;
            }

            var e = this.event;

            ev.cancelBubble = true;

            if (!calendar.allowDefaultContextMenu) {
                ev.preventDefault();
            }

            if (!this.event.client.rightClickEnabled()) {
                return false;
            }

            calendar._updateCoords(ev);

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.div = this;
                args.originalEvent = ev;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventRightClick === 'function') {
                    calendar.onEventRightClick(args);
                    if (args.preventDefault.value) {
                        return false;
                    }
                }

                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }

                if (typeof calendar.onEventRightClicked === 'function') {
                    calendar.onEventRightClicked(args);
                }

            }
            else {
                switch (calendar.eventRightClickHandling) {
                    case 'PostBack':
                        calendar.eventRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventRightClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventRightClick(e);
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(this.event);
                            }
                        }
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                }
            }


            return false;
        };

        this.eventDoubleClickPostBack = function(e, data) {
            this._postBack2('EventDoubleClick', e, data);
        };
        this.eventDoubleClickCallBack = function(e, data) {
            this._callBack2('EventDoubleClick', e, data);
        };

        this._eventDoubleClickDispatch = function(ev) {

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                DayPilot.Bubble.hideActive();
            }


            if (calendar._timeouts.click) {
                for (var toid in calendar._timeouts.click) {
                    window.clearTimeout(calendar._timeouts.click[toid]);
                }
                calendar._timeouts.click = null;
            }

            var e = this.event;

            ev.stopPropagation && ev.stopPropagation();
            ev.cancelBubble = true;

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.originalEvent = ev;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onEventDoubleClick === 'function') {
                    calendar.onEventDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(this);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ev.ctrlKey, ev.metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;

                }

                if (typeof calendar.onEventDoubleClicked === 'function') {
                    calendar.onEventDoubleClicked(args);
                }

            }
            else {
                switch (calendar.eventDoubleClickHandling) {
                    case 'PostBack':
                        calendar.eventDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.eventDoubleClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onEventDoubleClick(e);
                        break;
                    case 'Edit':
                        calendar._divEdit(this);
                        break;
                    case 'Select':
                        calendar._eventSelect(div, e, ev.ctrlKey, ev.metaKey);
                        break;
                    case 'Bubble':
                        if (calendar.bubble) {
                            calendar.bubble.showEvent(e);
                        }
                        break;
                    case 'ContextMenu':
                        var menu = e.client.contextMenu();
                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }
                        break;
                }

            }

        };

        this.eventResizePostBack = function(e, newStart, newEnd, data) {
            this._invokeEventResize("PostBack", e, newStart, newEnd, data);

        };
        this.eventResizeCallBack = function(e, newStart, newEnd, data) {
            this._invokeEventResize("CallBack", e, newStart, newEnd, data);
        };

        this._invokeEventResize = function(type, e, newStart, newEnd, data) {
            var usesArgs = e && !!e.preventDefault;

            var params = {};

            if (usesArgs) {
                var args = e;
                params.e = args.e;
                params.newStart = args.newStart;
                params.newEnd = args.newEnd;

                params.multiresize = [];

                args.multiresize.forEach(function(item) {
                    var mmp = {};
                    mmp.e = item.event;
                    mmp.newStart = item.start;
                    mmp.newEnd = item.end;
                    params.multiresize.push(mmp);
                });
            }
            else {
                params.e = e;
                params.newStart = newStart;
                params.newEnd = newEnd;
            }

            this._invokeEvent(type, "EventResize", params, data);
        };


        this._eventResizeDispatch = function(e, newStart, newEnd, what) {

            if (this.eventResizeHandling === 'Disabled') {
                return;
            }

            newEnd = calendar._adjustEndOut(newEnd);

            var args = {};

            args.e = e;
            args.async = false;
            args.loaded = function() {
                performResize();
            };
            args.newStart = newStart;
            args.newEnd = newEnd;
            args.what = what;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };
            args.multiresize = createList(mre.list);
            args.control = calendar;
            args.toJSON = function() {
                return copyProps(args, {}, ["e", "async", "newStart", "newEnd", "multiresize"]);
            };

            var info = {};
            info.event = e;
            info.start = newStart;
            info.end = newEnd;
            args.multiresize.splice(0, 0, info);

            if (calendar._api2()) {
                // API v2

                var performResize = function() {
                    overlay._hide();

                    if (args.preventDefault.value) {
                        return;
                    }

                    args.loaded = function() {};

                    newStart = args.newStart;
                    newEnd = args.newEnd;

                    switch (calendar.eventResizeHandling) {
                        case 'PostBack':
                            calendar.eventResizePostBack(args);
                            break;
                        case 'CallBack':
                            calendar.eventResizeCallBack(args);
                            break;
                        case 'Notify':
                            calendar.eventResizeNotify(args);
                            break;
                        case 'Update':
                            calendar._doEventMoveUpdate(args);
                            break;
                    }

                    if (typeof calendar.onEventResized === 'function') {
                        calendar.onEventResized(args);
                    }
                };


                if (typeof calendar.onEventResize === 'function') {
                    calendar.onEventResize(args);
                }

                if (!args.async) {
                    performResize();
                }
                else {
                    if (calendar.blockOnCallBack) {
                        overlay._show();
                    }
                }

            }
            else {
                switch (calendar.eventResizeHandling) {
                    case 'PostBack':
                        //newEnd = calendar._adjustEndOut(newEnd);
                        calendar.eventResizePostBack(args);
                        break;
                    case 'CallBack':
                        //newEnd = calendar._adjustEndOut(newEnd);
                        calendar.eventResizeCallBack(args);
                        break;
                    case 'JavaScript':
                        //newEnd = calendar._adjustEndOut(newEnd);
                        calendar.onEventResize(e, newStart, newEnd);
                        break;
                    case 'Notify':
                        //newEnd = calendar._adjustEndOut(newEnd);
                        calendar.eventResizeNotify(args);
                        break;
                    case 'Update':
                        calendar._doEventMoveUpdate(args);
                        break;
                }
            }

        };

        this.eventMovePostBack = function(e, newStart, newEnd, newResource, data, line) {
            this._invokeEventMove("PostBack", e, newStart, newEnd, newResource, data, line);
        };

        this.eventMoveCallBack = function(e, newStart, newEnd, newResource, data, line) {
            this._invokeEventMove("CallBack", e, newStart, newEnd, newResource, data, line);
        };

        this._invokeEventMove = function(type, e, newStart, newEnd, newResource, data, line) {
            var usesArgs = e && !!e.preventDefault;

            var params = {};

            if (usesArgs) {
                var args = e;
                params.e = args.e;
                params.newStart = args.newStart;
                params.newEnd = args.newEnd;
                params.newResource = args.newResource;
                params.position = args.position;

                params.multimove = [];

                args.multimove.forEach(function(item) {
                    var mmp = {};
                    mmp.e = item.event;
                    mmp.newStart = item.start;
                    mmp.newEnd = item.end;
                    mmp.newResource = item.event.resource();
                    if (mmp.e === args.e || mmp.e.data.id == args.e.data.id) {
                        mmp.newResource = args.newResource;
                    }
                    else if (mm.rowoffset) {
                        var ri = item.event.part.dayIndex + mm.rowoffset;
                        mmp.newResource = calendar.rowlist[ri].id;
                    }
                    params.multimove.push(mmp);
                });
            }
            else {
                params.e = e;
                params.newStart = newStart;
                params.newEnd = newEnd;
                params.newResource = newResource;
                params.position = line;
            }

            this._invokeEvent(type, "EventMove", params, data);
        };

        this._invokeTimeRangeSelected = function(type, args, data) {
            var params = {};
            params.start = args.start;
            params.end = args.end;
            params.resource = args.resource;
            params.multirange = [];

            args.multirange.forEach(function(item) {
                var mrp = {};
                mrp.start = item.start;
                mrp.end = item.end;
                mrp.resource = item.resource;
                params.multirange.push(mrp);
            });

            this._invokeEvent(type, "TimeRangeSelected", params, data);
        };

        this._invokeEvent = function(type, action, params, data) {

            if (type === 'PostBack') {
                calendar._postBack2(action, params, data);
            }
            else if (type === 'CallBack') {
                calendar._callBack2(action, params, data, "CallBack");
            }
            else if (type === 'Immediate') {
                calendar._callBack2(action, params, data, "Notify");
            }
            else if (type === 'Queue') {
                calendar.queue.add(new DayPilot.Action(this, action, params, data));
            }
            else if (type === 'Notify') {
                if (resolved._notifyType() === 'Notify') {
                    calendar._callBack2(action, params, data, "Notify");
                }
                else {
                    calendar.queue.add(new DayPilot.Action(calendar, action, params, data));
                }
            }
            else {
                throw new DayPilot.Exception("Invalid event invocation type");
            }
        };

        this.eventMoveNotify = function(e, newStart, newEnd, newResource, data, line) {
            var usesArgs = e && !!e.preventDefault;
            if (usesArgs) {
                var args = e;
                args.old = new DayPilot.Event(args.e.copy(), calendar);
                args.multimove.forEach(function(item) {
                    item.old = new DayPilot.Event(item.event.copy(), calendar);
                });
                calendar._doEventMoveUpdate(args);

                args.e = args.old;
                delete args.old;

                args.multimove.forEach(function(item) {
                    item.event = item.old;
                    delete item.old;
                });
            }
            else {
                e = new DayPilot.Event(e.copy(), calendar);

                var rows = calendar.events._removeFromRows(e.data);

                e.start(newStart);
                e.end(newEnd);
                e.resource(newResource);
                e.commit();

                rows = rows.concat(calendar.events._addToRows(e.data));
                calendar._loadRows(rows);

                calendar._updateRowHeights();

                calendar._updateRowsNoLoad(rows);
            }

            this._invokeEventMove("Notify", e, newStart, newEnd, newResource, data, line);

        };

        this.eventResizeNotify = function(e, newStart, newEnd, data) {
            var usesArgs = e && !!e.preventDefault;
            if (usesArgs) {
                var args = e;
                args.old = new DayPilot.Event(args.e.copy(), calendar);
                args.multiresize.forEach(function(item) {
                    item.old = new DayPilot.Event(item.event.copy(), calendar);
                });
                calendar._doEventMoveUpdate(args);

                args.e = args.old;
                delete args.old;

                args.multiresize.forEach(function(item) {
                    item.event = item.old;
                    delete item.old;
                });
            }
            else {
                e = new DayPilot.Event(e.copy(), calendar);

                var rows = calendar.events._removeFromRows(e.data);

                e.start(newStart);
                e.end(newEnd);
                e.commit();

                rows = rows.concat(calendar.events._addToRows(e.data));
                calendar._loadRows(rows);

                calendar._updateRowHeights();

                calendar._updateRowsNoLoad(rows);
            }

            this._invokeEventResize("Notify", e, newStart, newEnd, data);

        };

        this.zoom = {};
        this.zoom.active = -1;
        this.zoom.setActive = function(index, position, date) {

            var level;
            if (typeof index === "number") {
                level = calendar.zoomLevels[index];
            }
            else if (typeof index === "string") {
                var i = calendar.zoom._findById(index);
                level = calendar.zoomLevels[i];
            }
            else {
                throw new DayPilot.Exception("Unexpected parameter type (string or number required): " + typeof index);
            }

            if (!level) {
                throw new DayPilot.Exception("Zoom level not found: " + index + " (" + (typeof index) + ")");
            }

            if (index === calendar.zoom.active && !date) {
                return;
            }

            if (!date) {
                date = calendar.zoom._getPosition(position);
            }

            if (date) {
                calendar.startDate = date;
            }

            calendar.zoom._applyLevelProps(index, date);

            if (calendar._initialized) {
                calendar.update();
            }

            if (date) {
                calendar.scrollTo(date, null, position || calendar.zoomPosition);
            }

        };

        this.zoom._findById = function(id) {
            return createList(calendar.zoomLevels).findIndex(function(level) {
                return level.id === id;
            });
        };

        this.zoom._getPosition = function(position) {
            position = position || calendar.zoomPosition || "left";

            var date = null;

            if (!calendar.nav.scroll) {
                return null;
            }

            var viewport = calendar.getViewPort();

            switch (position) {
                case "left":
                    date = viewport.start;
                    break;
                case "middle":
                    date = viewport.start && viewport.start.addTime((calendar.getViewPort().end.getTime() - calendar.getViewPort().start.getTime())/2);
                    break;
                case "right":
                    date = viewport.end;
                    break;
            }

/*            if (!date) {
                date = calendar._visibleStart();
            }*/

            return date;

        };

        this.zoom._applyLevelProps = function(index, date) {

            // auto adjust
            var max = calendar.zoomLevels.length - 1;
            if (index > max) {
                index = max;
            }

            if (index < 0) {
                index = 0;
            }

            calendar.zoom.active = index;

            var level = calendar.zoomLevels[index];

            var args = {};
            args.date = date || new DayPilot.Date(calendar.startDate);
            args.level = level;

            DayPilot.Util.ownPropsAsArray(level.properties).forEach(function(item) {
                // if (item.key.startsWith("on")) {
                if (item.key.indexOf("on") === 0) {
                    return;
                }
                if (typeof item.val === "function") {
                    calendar[item.key] = item.val(args);
                    return;
                }
                calendar[item.key] = item.val;
            });

            return args;
        };

        // internal methods for handling event selection
        this.multiselect = {};

        this.multiselect._list = [];
        this.multiselect._divs = [];
        this.multiselect._previous = [];

        this.multiselect._loadList = function(list) {
            calendar.multiselect._list = createList(list).map(function(item) {
                return new DayPilot.Event(item, calendar);
            });
        };

        this.multiselect._serialize = function() {
            var m = calendar.multiselect;
            return JSON.stringify(m.events());
        };

        this.multiselect.events = function() {
            var m = calendar.multiselect;
            var events = createList();
            events.ignoreToJSON = true;
            for (var i = 0; i < m._list.length; i++) {
                events.push(m._list[i]);
            }
            return events;
        };

        this.multiselect.get = function() {
            return calendar.multiselect.events();
        };

        this.multiselect._updateHidden = function() {
            // not implemented
        };

        this.multiselect._toggleDiv = function(div, ctrl, meta) {
            var m = calendar.multiselect;

            if (m.isSelected(div.event)) {
                if (calendar.allowMultiSelect) {
                    if (ctrl || meta) {
                        m.remove(div.event, true);
                    }
                    else {
                        var count = m._list.length;
                        m.clear();
                        if (count > 1) {
                            m.add(div.event, true);
                        }
                    }
                }
                else { // clear all
                    m.clear();
                }
            }
            else {
                if (calendar.allowMultiSelect) {
                    if (ctrl || meta) {
                        m.add(div.event, true);
                    }
                    else {
                        m.clear();
                        m.add(div.event, true);
                    }
                }
                else {
                    m.clear();
                    m.add(div.event, true);
                }
            }
            //m.redraw();
            m._update(div);
            m._updateHidden();
        };

        // compare event with the init select list
        this.multiselect._shouldBeSelected = function(ev) {
            var m = calendar.multiselect;
            return m._isInList(ev, m._list);
        };

        this.multiselect._alert = function() {
            var m = calendar.multiselect;
            var list = [];
            for (var i = 0; i < m._list.length; i++) {
                var event = m._list[i];
                list.push(event.value());
            }
            alert(list.join("\n"));
        };

        this.multiselect.add = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            if (m._indexOf(ev) === -1) {
                m._list.push(ev);
            }

            if (dontRedraw) {
                return;
            }
            //m.redraw();
            m._updateEvent(ev);

        };

        this.multiselect.remove = function(ev, dontRedraw) {
            var m = calendar.multiselect;
            var i = m._indexOf(ev);
            if (i !== -1) {
                m._list.splice(i, 1);
            }

            if (dontRedraw) {
                return;
            }
            //m.redraw();
            m._updateEvent(ev);
        };

        this.multiselect.clear = function(dontRedraw) {
            var m = calendar.multiselect;
            m._list = [];

            if (dontRedraw) {
                return;
            }
            m.redraw();
        };

        this.multiselect.redraw = function() {
            var m = calendar.multiselect;
            m._divs = [];

            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (!div.event) {
                    continue;
                }
                if (!div.event.isEvent) {
                    continue;
                }
                if (m.isSelected(div.event)) {
                    m._divSelect(div);
                }
                else {
                    m._divDeselect(div);
                }
            }
        };

        // used for faster redraw
        this.multiselect._update = function(div) {
            if (!div) {
                return;
            }

            var m = calendar.multiselect;

            if (m.isSelected(div.event)) {
                m._divSelect(div);
            }
            else {
                m._divDeselect(div);
            }
        };

        this.multiselect._updateEvent = function(e) {
            var m = calendar.multiselect;
            var div = calendar._findEventDiv(e);
            m._update(div);
        };

        this.multiselect._divSelect = function(div) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            var div = m._findContentDiv(div);
            addClass(div, cn);
            m._divs.push(div);
        };


        this.multiselect._findContentDiv = function(div) {
            return div;
        };

        this.multiselect._divDeselectAll = function() {
            var m = calendar.multiselect;
            for (var i = 0; i < m._divs.length; i++) {
                var div = m._divs[i];
                m._divDeselect(div, true);
            }
            m._divs = [];
        };

        this.multiselect._divDeselect = function(div, dontRemoveFromCache) {
            var m = calendar.multiselect;
            var cn = calendar._prefixCssClass("_selected");
            removeClass(div, cn);

            if (dontRemoveFromCache) {
                return;
            }
            var i = indexOf(m._divs, div);
            if (i !== -1) {
                m._divs.splice(i, 1);
            }

        };

        this.multiselect.isSelected = function(ev) {
            if (!ev) {
                return false;
            }
            if (!ev.isEvent) {
                return false;
            }
            return calendar.multiselect._isInList(ev, calendar.multiselect._list);
        };

        this.multiselect._indexOf = function(ev) {
            var data = ev.data;
            for (var i = 0; i < calendar.multiselect._list.length; i++) {
                var item = calendar.multiselect._list[i];
                if (calendar._isSameEvent(item.data, data)) {
                    return i;
                }
            }
            return -1;
        };

        this.multiselect._isInList = function(e, list) {
            if (!list) {
                return false;
            }
            for (var i = 0; i < list.length; i++) {
                var ei = list[i];
                if (calendar._isSameEvent(e, ei)) {
                    return true;
                }
            }

            return false;
        };

        this.multiselect.startRectangle = function() {
            rectangle.start();
        };

        this._updateSeparators = function() {
            this._deleteSeparators();
            this._drawSeparators();
        };

        this._updateLinks = function() {
            linktools._load();
        };

        this._updateRowHeaderColumns = function() {
            calendar._drawHeaderColumns();
            calendar._deleteRowHeaders();
            calendar._drawResHeader();
            calendar._updateRowHeaderHeights();
            calendar._updateRowHeaderWidth();

            if (calendar.progressiveRowRendering) {
                calendar._drawResHeadersProgressive();
            }

        };

        this._update = function(args) {
            args = args || {};
            var full = !args.eventsOnly;

            window.clearTimeout(calendar._drawEventsTimeout);

            var kbFocus = calendar.keyboard.getFocus();

            // 2023-05-09 needs to be called for events-only update as well (access to args.row.events in onBeforeRowHeaderRender)
            calendar._deleteRowHeaders();

            if (full) {

                if (!this._serverBased()) {
                    calendar.timeHeader = null;
                    calendar.cellProperties = {};
                }
                calendar._bcrCache = {};
                calendar._calculateCellWidth();
                calendar._prepareItline();

                if (!args || !args.dontLoadResources) {
                    calendar._loadResources();
                }

                if (calendar._renderedTimeHeaderPosition !== calendar.timeHeaderPosition) {
                    calendar._initPrepareDiv();
                }

                calendar.events._postponedClear();
                calendar._resolved._clearCache();

                calendar.clearSelection();

                if (kbFocus) {
                    calendar._focus._removeFocus();
                }
            }

            // this._fixedInit();

            calendar._loadEvents();

            calendar._filterRows();
            calendar._createCells();

            // 2020-01-10: called before drawResHeader (fixed rows)
            calendar._prepareRowTops();

            // 2016-03-12: row headers are now always updated (because of onBeforeRowHeaderRender)
            calendar._drawResHeader();

            if (full) {
                calendar._updateTheme();
                calendar._updateCorner();
                calendar._drawTimeHeader();
                calendar._loadSelectedRows(calendar.selectedRows);
                calendar._updateRowHeaderHideIconVisibility();
            }

            calendar._updateRowHeaderHeights();
            calendar._updateRowHeaderWidth();
            calendar._updateHeaderHeight();

            linktools._hideLinkpoints();

            this._deleteEvents();
            this._deleteCells();

            this._clearCachedValues();
            this._expandCellProperties();

            calendar._updateHeight();

            this._drawCells();
            this._updateSeparators();

            // calendar._updateHeight();

            if (args.immediateEvents || args.eventsOnly) {
                calendar._drawEvents();
            }
            else {
                setTimeout(function() { calendar._drawEvents(); }, 100);
            }

            if (full && kbFocus) {
                if (kbFocus.e) {
                    var ev = calendar.events.find(id);
                    if (ev) {
                        calendar.keyboard.focusEvent(e.id());
                    }
                }
                else if (kbFocus.cell) {
                    var fdate = kbFocus.cell.start;
                    var fresource = kbFocus.cell.resource;
                    var cell = calendar._cellFindByStartRes(fdate, fresource);
                    if (cell && cell.grid === "main") {
                        calendar.keyboard.focusCell(fdate, fresource);
                    }
                }
            }

            if (this.visible) {
                if (calendar._previousVisible != calendar.visible) {
                    this.show();
                }
                //this._show();
            }
            else {
                this.hide();
            }
            this._previousVisible = this.visible;

            this._updateFloats();


            var angular = calendar._angular.scope || calendar._angular2.enabled;

/*            if (!angular || calendar._initialized) {
                if (!infitools.isEnabled()) {
                    this._onScroll();
                }
            }*/
            if (angular) {
                if (calendar._initialized) {
                    calendar._onScroll();
                }
                else if (!infitools._isEnabled()) {
                    calendar._onScroll();
                }
            }
            else {
                calendar._onScroll();
            }

            this._doAfterUpdate();

            this._startAutoRefresh();
            this._nowStart();

            // calendar._svgCacheFill();

        };

        this._doAfterUpdate = function() {
            if (typeof calendar.onAfterUpdate !== "function") {
                return;
            }
            var args = {};
            calendar.onAfterUpdate(args);
        };


        // full update
        this.update = function(options) {

            if (!calendar._initialized) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Scheduler object that hasn't been initialized.");
            }

            if (calendar._disposed) {
                throw new DayPilot.Exception("You are trying to update a DayPilot.Scheduler object that has been disposed already. Calling .dispose() destroys the object and makes it unusable.");
            }

            postponedUpdate.request(options);

        };

        var postponedUpdate = {};
        postponedUpdate.timeout = null;
        postponedUpdate.options = null;

        // if enabled, all update() calls within a single block are merged
        // - but the update itself is performed asynchronously and it's unexpectd behavior
        postponedUpdate.enabled = false;

        postponedUpdate.request = function(options) {
            if (postponedUpdate.enabled) {
                clearTimeout(postponedUpdate.timeout);
                postponedUpdate._mergeOptions(options);
                postponedUpdate.timeout = setTimeout(postponedUpdate.doit);
            }
            else {
                postponedUpdate._mergeOptions(options);
                postponedUpdate.doit();
            }
        };

        postponedUpdate._mergeOptions = function(options) {
            if (!options) {
                return;
            }

            if (!postponedUpdate.options) {
                postponedUpdate.options = {};
            }

            for (var name in options) {
                postponedUpdate.options[name] = options[name];
            }
        };

        postponedUpdate.doit = function() {

            var options = postponedUpdate.options;
            postponedUpdate.options = null;

            if (!calendar._initialized) {
                calendar._loadOptions(options);
                return;
            }

            // selected single-property updates are optimized
            if (DayPilot.Util.isOnlyProperty(options, "events")) {
                calendar.events.list = options.events;
                calendar._update({"eventsOnly": true});
                focus._updateDefaultForCurrentPosition();
                return;
            }

            if (DayPilot.Util.isOnlyProperty(options, "separators")) {
                calendar.separators = options.separators;
                calendar._updateSeparators();
                return;
            }

            if (DayPilot.Util.isOnlyProperty(options, "rowHeaderColumns") && !calendar._isTabularMode()) {
                calendar.rowHeaderColumns = options.rowHeaderColumns;
                calendar._updateRowHeaderColumns();
                return;
            }

            if (DayPilot.Util.isOnlyProperty(options, "links")) {
                calendar.links.list = options.links;
                calendar._updateLinks();
                return;
            }


            // full update
            calendar._loadOptions(options);
            calendar._update({"immediateEvents":true});
            calendar._postInit();
            focus._updateDefaultForCurrentPosition();
            calendar._fireAfterRenderDetached(null, false);

        };

        this._drawRowsForced = function(rows) {
            rows.forEach(function(row) {
                calendar._drawRowForced(row.index, row.grid);
            });
        };

        this._ensureRowsArray = function(rows) {
            if (!rows || rows.length === 0) {
                return [];
            }
            if (rows[0].isRow) {
                return rows;
            }
            return rows.map(function(i) {
                return calendar.rowlist[i];
            });
        };

        this._updateRowsNoLoad = function(rows, appendOnlyIfPossible, finishedCallBack) {

            rows = DayPilot.ua(rows);
            rows = calendar._ensureRowsArray(rows);

            calendar._drawRowsForced(rows);

            if (this._rowsDirty) {
                this._prepareRowTops();
                this._updateRowHeaderHeights();

                this._deleteCells();

                this._deleteSeparators();

                rows.forEach(function(row) {
                    calendar._deleteEventsInRow(row.index, row.grid);
                });

                rows.forEach(function(row) {
                    calendar._drawEventsInRow(row.index, row.grid);
                });

                this._drawCells();

                this._drawSeparators();
                this._updateEventTops();

                this._crosshairHide();
                this._crosshair();

            }
            else {
/*
                // turned off because it doesn't work well with manual async event updates in onEventMove
                var batch = false;

                if (batch) {
                    var doRow = function(i) {
                        if (i >= rows.length) {
                            return;
                        }
                        var ri = rows[i];
                        if (!appendOnlyIfPossible) {
                            calendar._deleteEventsInRow(ri);
                        }
                        calendar._drawEventsInRow(ri);
                        if (i + 1 < rows.length) {
                            setTimeout(function() { doRow(i+1); }, 10);
                        }
                        else {
                            calendar._findEventsInViewPort();
                            linktools.load();
                            calendar.multiselect.redraw();
                            if (finishedCallBack) {
                                finishedCallBack();
                            }
                        }
                    };
                    doRow(0);
                }
                else {
                    for (var i = 0; i < rows.length; i++) {
                        var ri = rows[i];
                        if (!appendOnlyIfPossible) {
                            this._deleteEventsInRow(ri);
                        }
                        this._drawEventsInRow(ri);
                    }

                }
*/

                rows.forEach(function(row) {
                    if (!appendOnlyIfPossible) {
                        calendar._deleteEventsInRow(row.index, row.grid);
                    }
                    calendar._drawEventsInRow(row.index, row.grid);
                });

                rows.forEach(function(row) {
                    calendar._deleteCellsInRow(row.index, row.grid);
                });
                calendar._drawCells();
            }

            calendar._findEventsInViewPort();
            linktools._load();
            calendar.multiselect.redraw();

            if (finishedCallBack) {
                finishedCallBack();
            }

            this._clearCachedValues();

        };

        this._adjustEndOut = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            if (date.getDatePart().ticks === date.ticks) {
                return date.addDays(-1);
            }
            return date.getDatePart();
        };

        this._adjustEndIn = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            return date.getDatePart().addDays(1);
        };

        this._adjustEndNormalize = function(date) {
            if (calendar.eventEndSpec === "DateTime") {
                return date;
            }
            return date.getDatePart();
        };

        this._eventMoveDispatch = function(e, newStart, newEnd, newResource, external, ev, line) {

            calendar._lastEventMoving = null;

            if (calendar.eventMoveHandling === 'Disabled') {
                return;
            }

            newEnd = calendar._adjustEndOut(newEnd);

            var args = {};

            args.e = e;
            args.newStart = newStart;
            args.newEnd = newEnd;
            args.newResource = newResource;
            args.external = external;
            args.ctrl = false;
            args.meta = false;
            args.shift = false;
            if (ev) {
                args.shift = ev.shiftKey;
                args.ctrl = ev.ctrlKey;
                args.meta = ev.metaKey;
            }
            args.multimove = createList(mm.list);
            args.areaData = DpGlobal.movingAreaData;
            args.control = calendar;
            args.toJSON = function() {
                return copyProps(args, {}, ["e", "newStart", "newEnd", "newResource", "external", "ctrl", "meta", "shift", "multimove", "areaData"]);
            };

            var info = {};
            info.event = e;
            info.start = newStart;
            info.end = newEnd;
            info.overlapping = false;
            info.resource = newResource;
            args.multimove.splice(0, 0, info);

            args.position = line;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (calendar._api2()) {
                // API v2

                var performMove = function() {

                    // make sure it can't be fired anymore
                    args.loaded = function() {};

                    overlay._hide();

                    if (args.preventDefault.value) {
                        DayPilotScheduler._preventEventClick = true;
                        calendar._clearMovingShadow();
                        return;
                    }

                    newStart = args.newStart;
                    newEnd = args.newEnd;

                    switch (calendar.eventMoveHandling) {
                        case 'PostBack':
                            calendar.eventMovePostBack(args);
                            break;
                        case 'CallBack':
                            calendar.eventMoveCallBack(args);  // e, newStart, newEnd, newResource, null, line
                            break;
                        case 'Notify':
                            calendar.eventMoveNotify(args);
                            break;
                        case 'Update':
                            //newEnd = calendar._adjustEndIn(newEnd);
                            calendar._doEventMoveUpdate(args);
                            break;
                    }

                    calendar._clearMovingShadow();

                    if (typeof calendar.onEventMoved === 'function') {
                        calendar.onEventMoved(args);
                    }

                };

                args.async = false;
                args.loaded = function() {
                    performMove();
                };

                if (typeof calendar.onEventMove === 'function') {
                    calendar.onEventMove(args);
                }

                if (!args.async) {
                    performMove();
                }
                else {
                    if (calendar.blockOnCallBack) {
                        overlay._show();
                    }
                }

            }
            else {
                switch (calendar.eventMoveHandling) {
                    case 'PostBack':
                        calendar.eventMovePostBack(args);
                        break;
                    case 'CallBack':
                        calendar.eventMoveCallBack(args);
                        break;
                    case 'JavaScript':
                        calendar.onEventMove(e, newStart, newEnd, newResource, external, ev ? ev.ctrlKey : false, ev ? ev.shiftKey : false, line);
                        break;
                    case 'Notify':
                        calendar.eventMoveNotify(args);
                        break;
                    case 'Update':
                        calendar._doEventMoveUpdate(args);
                        /*
                        e.start(newStart);
                        e.end(newEnd);
                        e.resource(newResource);
                        calendar.events.update(e);*/
                        break;
                }

                calendar._clearMovingShadow();
            }

        };

        this._doEventMoveUpdate = function(args) {
            /*
             e.start(newStart);
             e.end(newEnd);
             calendar.events.update(e);

             */

            var e = args.e;
            var newStart = args.newStart;
            var newEnd = args.newEnd;
            var newResource = args.newResource;
            var external = args.external;

            e.start(newStart);
            e.end(newEnd);
            e.resource(newResource);
            if (external) {
                e.commit();
                calendar.events.add(e);
            }
            else {
                calendar.events.update(e);
            }
            if (args.multimove && !args.multimove.isEmpty()) {
                args.multimove.forEach(function(item) {
                    if (item.event === e) { // skip the main event
                        return;
                    }

                    item.event.start(item.start);
                    item.event.end(item.end);
                    item.event.resource(item.resource);

/*                    if (mm.rowoffset) {
                        var ri = item.event.part.dayIndex + mm.rowoffset;
                        var newResource = calendar.rowlist[ri].id;
                        item.event.resource(newResource);
                    }*/

                    item.event.commit();
                    calendar.events.update(item.event);
                });
            }
            if (args.multiresize && !args.multiresize.isEmpty()) {
                args.multiresize.forEach(function(item) {
                    if (item.event === e) { // skip the main event
                        return;
                    }

                    item.event.start(item.start);
                    item.event.end(item.end);
                    item.event.commit();
                    calendar.events.update(item.event);
                });

            }
            calendar.events._immediateRefresh();
            calendar._deleteDragSource();

        };


        this._bubbleCallBack = function(args, bubble) {
            var guid = calendar._recordBubbleCall(bubble);

            var params = {};
            params.args = args;
            params.guid = guid;

            calendar._callBack2("Bubble", params);
        };

        this._recordBubbleCall = function(bubble) {
            var guid = DayPilot.guid();
            if (!this.bubbles) {
                this.bubbles = [];
            }

            this.bubbles[guid] = bubble;
            return guid;
        };

        this.eventMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.e = e;
            params.command = command;

            this._postBack2('EventMenuClick', params, data);
        };
        this.eventMenuClickCallBack = function(e, command, data) {

            var params = {};
            params.e = e;
            params.command = command;

            this._callBack2('EventMenuClick', params, data);
        };

        this._eventMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.eventMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.eventMenuClickCallBack(e, command);
                    break;
            }
        };

        this.timeRangeSelectedPostBack = function(start, end, resource, data) {
            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._postBack2('TimeRangeSelected', range, data);
        };
        this.timeRangeSelectedCallBack = function(start, end, resource, data) {

            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._callBack2('TimeRangeSelected', range, data);
        };

        this._timeRangeSelectedDispatchFromRange = function(range) {
            if (!range) {
                return;
            }
            if (range.disabled) {
                calendar.clearSelection();
                return;
            }

            if (range.args) {
                calendar._timeRangeSelectedDispatch(range.args.start, range.args.end, range.args.resource);
            }
            else {
                var sel = calendar._getSelection(range);
                if (!sel) {
                    return;
                }
                calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);
            }
        };

        this._timeRangeSelectedDispatch = function(start, end, resource) {

            if (calendar.timeRangeSelectedHandling === 'Disabled') {
                return;
            }

            var rawend = end;
            end = calendar._adjustEndOut(rawend);

            var args = {};
            args.control = calendar;
            args.start = start;
            args.end = end;
            args.resource = resource;
            args.preventDefault = function () {
                this.preventDefault.value = true;
            };
            args.multirange = createList(mr.list).map(function (item) {
                return calendar._getSelection(item);
            });
            if (args.multirange.isEmpty()) {
                args.multirange.push({"start": args.start, "end": args.end, "resource": args.resource});
            }
            args.toJSON = function() {
                return copyProps(args, {}, ["start", "end", "resource", "multirange"]);
            };

            if (calendar._api2()) {

                if (typeof calendar.onTimeRangeSelect === 'function') {
                    calendar.onTimeRangeSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }

                    start = args.start;
                    end = args.end;
                }

                end = calendar._adjustEndIn(end);

                calendar._updateRange(calendar._rangeHold, start, end, args.multirange);

                // this was corrupting the custom position indicators set using onTimeRangeSelecting
                //calendar._drawRange(DayPilotScheduler._rangeHold, true);

                calendar._drawRange(calendar._rangeHold);

                // now perform the default built-in action
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar._invokeTimeRangeSelected("PostBack", args);
                        break;
                    case 'CallBack':
                        calendar._invokeTimeRangeSelected("CallBack", args);
                        break;
                }

                if (typeof calendar.onTimeRangeSelected === 'function') {
                    calendar.onTimeRangeSelected(args);
                }

            }
            else {
                switch (calendar.timeRangeSelectedHandling) {
                    case 'PostBack':
                        calendar._invokeTimeRangeSelected("PostBack", args);
                        break;
                    case 'CallBack':
                        calendar._invokeTimeRangeSelected("CallBack", args);
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeSelected(start, end, resource, args.multirange);
                        break;
                    case 'Hold':
                        break;
                }
            }

        };

        // requires normalized/raw end (timeline)
        this._updateRange = function(range, start, end, multirange) {

            if (!range || (multirange && multirange.length > 1)) {
                return;
            }

            // requires normalized end
            // var rawend = calendar._adjustEndIn(end);
            var rawend = end;

            var itc, cell;

            var rowOffset = 0;
            if (calendar.viewType === "Days") {
                var row = calendar._findRowInDaysView(start);
                rowOffset = row.start.getTime() - calendar._visibleStart().getTime();
            }

            // fix start
            if (start.getTime() < calendar.itline[0].start.getTime()) {
                range.start.x = 0;
                range.start.time = calendar.itline[0].start.getTime();
            }
            else {
                itc = calendar._getItlineCellFromTime(start.addTime(-rowOffset));
                cell = itc.current || itc.previous;
                range.start.x = indexOf(calendar.itline, cell);
                range.start.time = start;
            }

            // fix end
            itc = calendar._getItlineCellFromTime(rawend.addMilliseconds(-1).addTime(-rowOffset));
            if (itc.past) {
                range.end.x = calendar.itline.length - 1;
                range.end.time = calendar.itline[calendar.itline.length - 1].end.getTime();
            }
            else {
                cell = itc.current || itc.next;
                range.end.x = indexOf(calendar.itline, cell);
                range.end.time = end;
            }
        };

        this._findRowInDaysView = function(start) {
            /*
            // inefficient
            var day = start.getDatePart().getTime();
            for (var i = 0; i < calendar.rowlist.length; i++) {
                var row = calendar.rowlist[i];
                var rs = row.start.getTime();
                if (rs === day) {
                    return row;
                }
            }
            */
            var day = start.getDatePart();
            return createList(calendar.rowlist).find(function(item) {
                return item.start.getDatePart() === day;
            });
        };

        this.timeRangeDoubleClickPostBack = function(start, end, resource, data) {
            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._postBack2('TimeRangeDoubleClick', range, data);
        };
        this.timeRangeDoubleClickCallBack = function(start, end, resource, data) {

            var range = {};
            range.start = start;
            range.end = end;
            range.resource = resource;

            this._callBack2('TimeRangeDoubleClick', range, data);
        };


        this._timeRangeDoubleClickDispatch = function(start, end, resource) {

            end = calendar._adjustEndOut(end);

            if (calendar._api2()) {


                var args = {};
                args.start = start;
                args.end = end;
                args.resource = resource;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeRangeDoubleClick === 'function') {
                    calendar.onTimeRangeDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end, resource);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end, resource);
                        break;
                }

                if (typeof calendar.onTimeRangeDoubleClicked === 'function') {
                    calendar.onTimeRangeDoubleClicked(args);
                }
            }
            else {
                //end = calendar._adjustEndOut(end);
                switch (calendar.timeRangeDoubleClickHandling) {
                    case 'PostBack':
                        calendar.timeRangeDoubleClickPostBack(start, end, resource);
                        break;
                    case 'CallBack':
                        calendar.timeRangeDoubleClickCallBack(start, end, resource);
                        break;
                    case 'JavaScript':
                        calendar.onTimeRangeDoubleClick(start, end, resource);
                        break;
                }

            }

        };

        this.timeRangeMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.selection = e;
            params.command = command;

            this._postBack2("TimeRangeMenuClick", params, data);
        };
        this.timeRangeMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.selection = e;
            params.command = command;

            this._callBack2("TimeRangeMenuClick", params, data);
        };


        this._timeRangeMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.timeRangeMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.timeRangeMenuClickCallBack(e, command);
                    break;
            }
        };

        this.linkMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.link = e;
            params.command = command;

            this._postBack2("LinkMenuClick", params, data);
        };

        this.linkMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.link = e;
            params.command = command;

            this._callBack2("LinkMenuClick", params, data);
        };

        this._linkMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.linkMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.linkMenuClickCallBack(e, command);
                    break;
            }
        };

        this.rowMenuClickPostBack = function(e, command, data) {
            var params = {};
            params.resource = e;
            params.command = command;

            this._postBack2("RowMenuClick", params, data);
        };

        // backwards compatibility
        this.resourceHeaderMenuClickPostBack = this.rowMenuClickPostBack;

        this.rowMenuClickCallBack = function(e, command, data) {
            var params = {};
            params.resource = e;
            params.command = command;

            this._callBack2("RowMenuClick", params, data);
        };

        this.resourceHeaderMenuClickCallBack = this.rowMenuClickCallBack;

        this._rowMenuClick = function(command, e, handling) {
            switch (handling) {
                case 'PostBack':
                    calendar.rowMenuClickPostBack(e, command);
                    break;
                case 'CallBack':
                    calendar.rowMenuClickCallBack(e, command);
                    break;
            }
        };

        this._rowUpdateText = function (oldRow, newText, column) {

            var r = calendar._createRowObject(oldRow);
            var data = r.data;

            if (oldRow.task) {
                data = oldRow.task;
            }

            if (calendar.rowHeaderColumns) {
                var display = calendar.rowHeaderColumns[column].display;
                if (column === 0 && !display) {
                    data.name = newText;
                    data.html = calendar._xssTextHtml(newText);
                }
                if (display) {
                    calendar._setTabularValue(data, display, newText);
                }
            }
            else {
                data.name = newText;
                data.html = calendar._xssTextHtml(newText);
            }

            calendar.rows.update(r);

        };

        this._rowCreateDispatch = function(row, newText) {
            if (!newText) {
                return;
            }

            var args = {};
            args.text = newText;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onRowCreate === "function") {
                calendar.onRowCreate(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            switch (calendar.rowCreateHandling) {
                case "CallBack":
                    calendar.rowCreateCallBack(args.text);
                    break;
                case "PostBack":
                    calendar.rowCreatePostBack(args.text);
                    break;

            }

            if (typeof calendar.onRowCreated === "function") {
                calendar.onRowCreated(args);
            }

        };

        this._rowEditDispatch = function(row, newText, canceled, columnIndex) {
            if (row.isNewRow) {
                if (!canceled) {
                    calendar._rowCreateDispatch(row, newText);
                }
                return;
            }

            var index = indexOf(calendar.rowlist, row);
            var e = calendar._createRowObject(row, index);

            if (calendar._api2()) {


                var args = {};
                args.resource = e;
                args.row = e;
                args.x = columnIndex; // testing, check name
                args.newText = newText;
                args.canceled = canceled;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.async = false;
                args.loaded = function() {
                    doit();
                };

                var doit = function() {
                    if (!canceled) {
                        switch (calendar.rowEditHandling) {
                            case 'PostBack':
                                calendar.rowEditPostBack(e, args.newText);
                                break;
                            case 'CallBack':
                                calendar.rowEditCallBack(e, args.newText);
                                break;
                            case 'Update':
                                calendar._rowUpdateText(row, args.newText, columnIndex);
                                break;
                        }

                        if (typeof calendar.onRowEdited === 'function') {
                            calendar.onRowEdited(args);
                        }
                    }

                };

                if (typeof calendar.onRowEdit === 'function') {
                    calendar.onRowEdit(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                if (!args.async) {
                    doit();
                }

            }
            else {
                switch (calendar.rowEditHandling) {
                    case 'PostBack':
                        calendar.rowEditPostBack(e, newText);
                        break;
                    case 'CallBack':
                        calendar.rowEditCallBack(e, newText);
                        break;
                    case 'JavaScript':
                        calendar.onrowEdit(e, newText);
                        break;
                }
            }
        };

        this.rowCreatePostBack = function(newText, data) {
            var params = {};
            params.text = newText;

            this._postBack2("RowCreate", params, data);
        };

        this.rowCreateCallBack = function(newText, data) {
            var params = {};
            params.text = newText;

            this._callBack2("RowCreate", params, data);
        };

        this.rowEditPostBack = function(e, newText, data) {
            var params = {};
            params.resource = e;
            params.newText = newText;

            this._postBack2("RowEdit", params, data);
        };

        this.rowEditCallBack = function(e, newText, data) {
            var params = {};
            params.resource = e;
            params.newText = newText;

            this._callBack2("RowEdit", params, data);
        };

        this.rowMovePostBack = function(source, target, position, data) {
            var params = {};
            params.source = source;
            params.target = target;
            params.position = position;

            this._postBack2("RowMove", params, data);
        };

        this.rowMoveCallBack = function(source, target, position, data) {
            var params = {};
            params.source = source;
            params.target = target;
            params.position = position;

            this._callBack2("RowMove", params, data);
        };

        this.rowMoveNotify = function(source, target, position, data) {
            var params = {};
            params.source = source;
            params.target = target;
            params.position = position;

            this._callBack2("RowMove", params, data, "Notify");
        };

        this.rowClickPostBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._postBack2("RowClick", params, data);
        };

        // backwards compatibility
        this.resourceHeaderClickPostBack = this.rowClickPostBack;

        this.rowClickCallBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._callBack2("RowClick", params, data);
        };

        // backwards compatibility
        this.resourceHeaderClickCallBack = this.rowClickCallBack;

        this._rowClickDispatch = function(e, ev, column) {

            if (calendar.rowDoubleClickHandling === "Disabled") {
                calendar._rowClickSingle(e, ev, column);
                return;
            }

            if (!calendar._timeouts.resClick) {
                calendar._timeouts.resClick = [];
            }

            var resClickDelayed = function(e, ev) {
                return function() {
                    calendar._rowClickSingle(e, ev, column);
                };
            };

            calendar._timeouts.resClick.push(window.setTimeout(resClickDelayed(e, ev), calendar.doubleClickTimeout));
        };

        this._rowClickSingle = function(e, ev, column) {

            // backwards compatibility
            var rowClickHandling = calendar.resourceHeaderClickHandling || calendar.rowClickHandling;

            if (calendar._api2()) {

                var args = {};
                args.resource = e;
                args.row = e;
                args.x = column;
                args.ctrl = ev.ctrlKey;
                args.shift = ev.shiftKey;
                args.meta = ev.metaKey;
                args.originalEvent = ev;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onRowClick === 'function') {
                    calendar.onRowClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                // backwards compatiblity
                if (typeof calendar.onResourceHeaderClick === 'function') {
                    calendar.onResourceHeaderClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (rowClickHandling) {
                    case 'PostBack':
                        calendar.rowClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.rowClickCallBack(e);
                        break;
                    case 'Select':
                        calendar._rowSelectDispatch(e.$.row, ev.ctrlKey, ev.shiftKey, ev.metaKey);
                        break;
                    case 'Edit':
                        calendar._rowtools._edit(e.$.row, column);
                        break;
                }

                if (typeof calendar.onRowClicked === 'function') {
                    calendar.onRowClicked(args);
                }

                if (typeof calendar.onResourceHeaderClicked === 'function') {
                    calendar.onResourceHeaderClicked(args);
                }

            }
            else {

                switch (rowClickHandling) {
                    case 'PostBack':
                        calendar.rowClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.rowClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onRowClick(e);
                        break;
                    case 'Select':
                        calendar._rowSelectDispatch(e.$.row, ev.ctrlKey, ev.shiftKey);
                        break;
                    case 'Edit':
                        calendar._rowtools._edit(e.$.row, column);
                        break;
                }
            }
        };
        //

        this.timeHeaderClickPostBack = function(e, data) {
            var params = {};
            params.header = e;

            this._postBack2("TimeHeaderClick", params, data);
        };

        this.timeHeaderClickCallBack = function(e, data) {
            var params = {};
            params.header = e;

            this._callBack2("TimeHeaderClick", params, data);
        };

        this._timeHeaderClickDispatch = function(e) {
            if (calendar._api2()) {

                var args = {};
                args.header = e;
                args.control = calendar;
                /*
                 * start
                 * end
                 * level
                 *
                 */
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeHeaderClick === 'function') {
                    calendar.onTimeHeaderClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (this.timeHeaderClickHandling) {
                    case 'PostBack':
                        calendar.timeHeaderClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.timeHeaderClickCallBack(e);
                        break;
                }

                if (typeof calendar.onTimeHeaderClicked === 'function') {
                    calendar.onTimeHeaderClicked(args);
                }
            }
            else {
                switch (this.timeHeaderClickHandling) {
                    case 'PostBack':
                        calendar.timeHeaderClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.timeHeaderClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onTimeHeaderClick(e);
                        break;
                }
            }
        };

        //
        this.resourceCollapsePostBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._postBack2("ResourceCollapse", params, data);
        };
        this.resourceCollapseCallBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._callBack2("ResourceCollapse", params, data);
        };

        this._resourceCollapseDispatch = function(e) {

            if (calendar._api2()) {

                var args = {};
                args.resource = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onResourceCollapse === 'function') {
                    calendar.onResourceCollapse(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (this.resourceCollapseHandling) {
                    case 'PostBack':
                        calendar.resourceCollapsePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.resourceCollapseCallBack(e);
                        break;
                }
            }
            else {
                switch (this.resourceCollapseHandling) {
                    case 'PostBack':
                        calendar.resourceCollapsePostBack(e);
                        break;
                    case 'CallBack':
                        calendar.resourceCollapseCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onResourceCollapse(e);
                        break;
                }
            }

        };

        // expand
        this.resourceExpandPostBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._postBack2("ResourceExpand", params, data);
        };
        this.resourceExpandCallBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._callBack2("ResourceExpand", params, data);
        };

        this._resourceExpandDispatch = function(e) {

            if (calendar._api2()) {

                var args = {};
                args.resource = e;
                args.row = e;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onResourceExpand === 'function') {
                    calendar.onResourceExpand(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (this.resourceExpandHandling) {
                    case 'PostBack':
                        calendar.resourceExpandPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.resourceExpandCallBack(e);
                        break;
                }

            }
            else {
                switch (this.resourceExpandHandling) {
                    case 'PostBack':
                        calendar.resourceExpandPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.resourceExpandCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onResourceExpand(e);
                        break;
                }

            }

        };

        this.eventEditPostBack = function(e, newText, data) {
            var params = {};
            params.e = e;
            params.newText = newText;

            this._postBack2("EventEdit", params, data);
        };
        this.eventEditCallBack = function(e, newText, data) {

            var params = {};
            params.e = e;
            params.newText = newText;

            this._callBack2("EventEdit", params, data);
        };

        this.eventEditNotify = function(e, newText, data, options) {

            var old = new DayPilot.Event(e.copy(), this);

            e.text(newText);
            calendar.events.update(e, null, options);

            var params = {};
            params.e = old;
            params.newText = newText;

            this._callBack2("EventEdit", params, data, "Notify");
        };
        this._eventEditDispatch = function(e, newText, canceled) {

            focus._focusCell();

            if (calendar._api2()) {

                var args = {};
                args.e = e;
                args.control = calendar;
                args.newText = newText;
                args.canceled = canceled;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };
                args.async = false;
                args.loaded = function() {
                    doit();
                };

                var doit = function() {

                    args.loaded = function() {};

                    if (!canceled) {
                        switch (calendar.eventEditHandling) {
                            case 'PostBack':
                                calendar.eventEditPostBack(e, args.newText);
                                break;
                            case 'CallBack':
                                calendar.eventEditCallBack(e, args.newText);
                                break;
                            case 'Update':
                                e.text(args.newText);
                                calendar.events.update(e, null, {"inplace": true});
                                break;
                        }
                    }

                    if (typeof calendar.onEventEdited === 'function') {
                        calendar.onEventEdited(args);
                    }

                };

                if (typeof calendar.onEventEdit === 'function') {
                    calendar.onEventEdit(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                if (!args.async) {
                    doit();
                }
            }
            else {
                //if (!canceled) {
                    switch (calendar.eventEditHandling) {
                        case 'PostBack':
                            calendar.eventEditPostBack(e, args.newText);
                            break;
                        case 'CallBack':
                            calendar.eventEditCallBack(e, args.newText);
                            break;
                        case 'Notify':
                            calendar.eventEditNotify(e, args.newText, null, {"inplace": true});
                            break;
                        case 'JavaScript':
                            calendar.onEventEdit(e, args.newText);
                            break;
                    }
                //}
            }
        };

        this.commandCallBack = function(command, data) {
            this._invokeCommand("CallBack", command, data);
        };

        this.commandPostBack = function(command, data) {
            this._invokeCommand("PostBack", command, data);
        };

        this._invokeCommand = function(type, command, data) {
            var params = {};
            params.command = command;

            this._invokeEvent(type, "Command", params, data);
        };


        this._postBack2 = function(action, parameters, data) {
            var envelope = {};
            envelope.action = action;
            envelope.type = "PostBack";
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var commandstring = "JSON" + JSON.stringify(envelope);
            __doPostBack(calendar.uniqueID, commandstring);
        };

        this._callBack2 = function(action, parameters, data, type) {

            if (!calendar._serverBased()) {
                calendar.debug.message("Callback invoked without the server-side backend specified. Callback canceled.", "warning");
                return;
            }

            if (typeof type === 'undefined') {
                type = "CallBack";
            }

            this._pauseAutoRefresh();

            calendar._loadingStart({"delay": 100});

            var envelope = {};

            envelope.action = action;
            envelope.type = type;
            envelope.parameters = parameters;
            envelope.data = data;
            envelope.header = this._getCallBackHeader();

            var json = JSON.stringify(envelope);

            var commandstring;
            if (typeof Iuppiter !== 'undefined' && Iuppiter.compress) {
                commandstring = "LZJB" + Iuppiter.Base64.encode(Iuppiter.compress(json));
            }
            else {
                commandstring = "JSON" + json;
            }

            this._doCallBackStart(envelope);

            var context = null;
            if (this.backendUrl) {
                DayPilot.request(this.backendUrl, this._callBackResponse, commandstring, this._ajaxError);
            }
            else if (typeof WebForm_DoCallback === 'function') {
                WebForm_DoCallback(this.uniqueID, commandstring, this._updateView, context, this.callbackError, true);
            }
        };


        this._doCallBackStart = function(envelope) {
            var args = {};
            if (typeof calendar.onCallBackStart === 'function') {
                calendar.onCallBackStart(args);
            }
        };

        this._doCallBackEnd = function() {
            var args = {};
            if (typeof calendar.onCallBackEnd === 'function') {
                setTimeout(function() {
                    calendar.onCallBackEnd(args);
                }, 0);
            }
        };

        this._serverBased = function() {
            return (calendar._productCode !== "javasc" && calendar._productCode.indexOf("DCODE") === -1) || calendar.devsb;
        };

        this._isAspnetWebForms = function() {
            if (typeof WebForm_DoCallback === 'function' && this.uniqueID) {
                return true;
            }
            return false;
        };

        this._ajaxError = function(req) {
            if (typeof calendar.onAjaxError === 'function') {
                var args = {};
                args.request = req;
                calendar.onAjaxError(args);
            }
            else if (typeof calendar.ajaxError === 'function') { // backwards compatibility
                calendar.ajaxError(req);
            }
        };

        this._callBackResponse = function(response) {
            calendar._updateView(response.responseText);
        };

        this.callbackProps = [];

        this._getCallBackHeader = function() {
            var h = {};

            h.v = this.v;
            h.control = "dps";
            h.id = this.id;

            // callback-changeable state
            h.startDate = calendar.startDate;
            h.days = calendar.days;
            h.cellDuration = calendar.cellDuration;
            h.cellGroupBy = calendar.cellGroupBy;
            h.cellWidth = calendar.cellWidth;
            h.cellWidthSpec = calendar.cellWidthSpec;

            // extra properties
            h.viewType = calendar.viewType; // serialize
            // h.hourNameBackColor = calendar.hourNameBackColor;
            h.showNonBusiness = calendar.showNonBusiness;
            h.businessBeginsHour = calendar.businessBeginsHour;
            h.businessEndsHour = calendar.businessEndsHour;
            h.weekStarts = calendar.weekStarts;
            h.treeEnabled = calendar.treeEnabled;
            //h.backColor = calendar.cellBackColor;
            //h.nonBusinessBackColor = calendar.cellBackColorNonBusiness;
            h.locale = calendar.locale;
            h.timeZone = calendar.timeZone;
            h.tagFields = calendar.tagFields;
            h.timeHeaders = calendar.timeHeaders;
            h.cssClassPrefix = calendar.cssClassPrefix;
            h.durationBarMode = calendar.durationBarMode;
            // h.showBaseTimeHeader = true; // to be removed
            h.rowHeaderColumns = calendar.rowHeaderColumns;
            h.rowMarginBottom = calendar.rowMarginBottom;
            h.rowMarginTop = calendar.rowMarginTop;
            h.rowMinHeight = calendar.rowMinHeight;
            h.scale = calendar.scale;

            // custom state
            h.clientState = calendar.clientState;

            // user-changeable state
            if (this.nav.scroll) {
                h.scrollX = atLeast(0, this.nav.scroll.scrollLeft);   // Safari can return a negative value
                h.scrollY = atLeast(0, this.nav.scroll.scrollTop);   // Safari can return a negative value
            }

            h.selected = calendar.multiselect.events();
            h.selectedRows = rowtools._getSelectedList();

            // special
            h.hashes = calendar.hashes;

            var area = calendar._getArea(h.scrollX, h.scrollY);

            if (area) {
                var range = calendar._getAreaRange(area);
                var res = calendar._getAreaResources(area);

                h.rangeStart = range.start;
                h.rangeEnd = range.end;
                h.resources = res;
            }
            else {
                h.rangeStart = calendar.startDate;
                h.rangeEnd = calendar.startDate;
                h.resources = [];
            }

            h.dynamicLoading = calendar.dynamicLoading;

            h.separators = this.separators;

            if (this.syncResourceTree && this.viewType != "Days") {
                h.tree = this._getTreeState();
            }
            if (this.syncLinks) {
                h.links = this._getLinksState();
            }
            if (this.scale === "Manual") {
                h.timeline = this._getTimelineState();
            }

            if (typeof calendar.onCallBackHeader === "function") {
                var args = {};
                args.header = h;
                calendar.onCallBackHeader(args);
            }

            var props = calendar.callbackProps;
            if (DayPilot.isArray(props)) {
                h.props = {};
                props.forEach(function(name) {
                    h.props[name] = calendar[name];
                });
            }

            return h;
        };

        this._getTimelineState = function() {
            var list = [];

            createList(calendar.timeline).forEach(function(item) {
                var json = {};
                json.start = item.start;
                json.end = item.end;
                json.width = item.width;

                list.push(json);
            });

            return list;
        };

        this._getLinksState = function() {
            var list = [];

            var getTags = function(link) {
                var result = {};
                if (link.tags) {
                    for (var name in link.tags) {
                        result[name] = "" + link.tags[name];
                    }
                }
                return result;
            };

            if (!DayPilot.isArray(calendar.links.list)) {
                return list;
            }

            for (var i = 0; i < calendar.links.list.length; i++) {
                var link = calendar.links.list[i];
                var json = {};
                json.id = link.id;
                json.from = link.from;
                json.to = link.to;
                json.type = link.type;
                json.tags = getTags(link);
                list.push(json);
            }
            return list;
        };

        this.getViewPort = function() {
            var scrollX = this.nav.scroll.scrollLeft - infitools._shiftX;
            var scrollY = this.nav.scroll.scrollTop;

            var viewport = {};

            if (calendar.viewType !== "Days") {
                var area = calendar._getArea(scrollX, scrollY);
                var range = calendar._getAreaRange(area);
                var res = calendar._getAreaResources(area);
                var leftCell = calendar.itline[area.start.x];
                var rightCell = calendar.itline[area.end.x];

                viewport.start = calendar.getDate(scrollX, true);
                viewport.end = calendar.getDate(scrollX + calendar.nav.scroll.clientWidth, true, true);
                viewport.resources = res;

                if (leftCell) {
                    viewport.topLeft = {
                        "start": leftCell.start,
                        "end": leftCell.end,
                        x: area.start.x,
                        y: area.start.y,
                        "resource": res[0]
                    };
                }

                if (rightCell) {
                    viewport.bottomRight = {
                        "start": rightCell.start,
                        "end": rightCell.end,
                        x: area.end.x,
                        y: area.end.y,
                        "resource": res[res.length - 1]
                    };
                }
            }
            else {
                var area = calendar._getArea(scrollX, scrollY);
                var range = calendar._getAreaDaysView(area);

                viewport.start = range.start;
                viewport.end = range.end;
                viewport.resources = [];
            }

            viewport.rows = function() {
                return viewport.resources.map(function(r) { return calendar.rows.find(r)});
            };

            viewport.events = function() {
                if (calendar.viewType === "Days") {
                    return calendar.events.forRange(viewport.start, viewport.end);
                }

                var events = [];
                viewport.rows().forEach(function(r) {
                    events = events.concat(r.events.forRange(viewport.start, viewport.end));
                });
                return events;
            };

            return viewport;
        };

        this._getArea = function(scrollX, scrollY) {
            var area = {};
            area.start = {};
            area.end = {};

            var start = calendar._getItlineCellFromPixels(scrollX);
            var end = calendar._getItlineCellFromPixels(scrollX + calendar.nav.scroll.clientWidth);

            if (start) {
                area.start.x = start.x;
            }

            if (end) {
                area.end.x = end.x;
            }

            var topY = scrollY + calendar._grids.top.height;
            var bottomY = scrollY + calendar.nav.scroll.clientHeight - calendar._grids.bottom.height;
            area.start.y = calendar._getRow(topY).i;
            area.end.y = calendar._getRow(bottomY).i;

            area.start.x = atLeast(area.start.x, 0);

            var maxX = this.itline.length;
            if (area.end.x >= maxX) {
                area.end.x = maxX - 1;
            }

            return area;
        };

        this._getAreaCurrent = function() {
            var scrollX = this.nav.scroll.scrollLeft - infitools._shiftX;
            var scrollY = this.nav.scroll.scrollTop;
            return calendar._getArea(scrollX, scrollY);
        };

        this._getAreaRange = function(area) {
            var result = {};

            if (this.itline.length <= 0) {
                result.start = this.startDate;
                result.end = this.startDate;
                return result;
            }

            if (!this.itline[area.start.x]) {
                throw new DayPilot.Exception('Internal error: area.start.x is null.');
            }
            result.start = this.itline[area.start.x].start;
            result.end = this.itline[area.end.x].end;

            return result;
        };

        this._getAreaResources = function(area) {
            // this might not be necessary, ported from DPSD
            if (!area) {
                var area = this._getArea(this.nav.scroll.scrollLeft, this.nav.scroll.scrollTop);
            }

            var res = [];
            res.ignoreToJSON = true;  // preventing Gaia and prototype to mess up with Array serialization

            for (var i = area.start.y; i <= area.end.y; i++) {
                var r = calendar.rowlist[i];
                if (r && !r.hidden) {
                    res.push(r.id);
                }
            }
            return res;
        };

        this._getAreaDaysView = function(area) {
            // this might not be necessary, ported from DPSD
            if (!area) {
                var area = this._getArea(this.nav.scroll.scrollLeft, this.nav.scroll.scrollTop);
            }

            var res = {};

            if (calendar.rowlist.length === 0) {
                return res;
            }

            var itlineDuration = calendar.itline[calendar.itline.length - 1].end.getTime() - calendar.itline[0].start.getTime();

            res.start = calendar.rowlist[area.start.y] && calendar.rowlist[area.start.y].start;
            res.end = calendar.rowlist[area.end.y] && calendar.rowlist[area.end.y].start.addTime(itlineDuration);

            return res;
        };


        this._getTreeState = function() {
            var tree = [];
            tree.ignoreToJSON = true; // preventing Gaia and prototype to mess up with Array serialization

            for (var i = 0; i < this.rowlist.length; i++) {
                var row = this.rowlist[i];
                if (row.level > 0) {
                    continue;
                }

                if (row.isNewRow) {
                    continue;
                }

                var node = this._getNodeState(i);
                tree.push(node);
            }
            return tree;
        };

        this._getNodeChildren = function(indices) {
            var children = [];
            children.ignoreToJSON = true; // preventing Gaia to mess up with Array serialization
            for (var i = 0; i < indices.length; i++) {
                var index = indices[i];
                var row = calendar.rowlist[index];
                if (row.isNewRow) {
                    continue;
                }
                children.push(calendar._getNodeState(index));
            }
            return children;
        };

        this._getNodeState = function(i) {
            var row = this.rowlist[i];

            if (typeof calendar.onGetNodeState === "function") {
                var args = {};
                args.row = row;
                args.preventDefault = function() {
                    args.preventDefault.value = true;
                };
                args.result = {};

                calendar.onGetNodeState(args);

                if (args.preventDefault.value) {
                    return args.result;
                }
            }

            var node = {};
            node.Value = row.id;
            node.BackColor = row.backColor;
            node.Name = row.name;
            node.InnerHTML = row.html;
            node.ToolTip = row.toolTip;
            node.Expanded = row.expanded;
            node.Children = this._getNodeChildren(row.children);
            node.Loaded = row.loaded;
            node.IsParent = row.isParent;
            node.Columns = this._getNodeColumns(row);
            node.Tags = row.tags;

            if (row.start.getTime() !== calendar._visibleStart().getTime()) {
                node.Start = row.start;
            }

            if (row.minHeight !== calendar.rowMinHeight) {
                node.MinHeight = row.minHeight;
            }
            if (row.marginBottom !== calendar.rowMarginBottom) {
                node.MarginBottom = row.marginBottom;
            }
            if (row.marginTop !== calendar.rowMarginTop) {
                node.MarginTop = row.marginTop;
            }
            if (row.eventHeight !== calendar.eventHeight) {
                node.EventHeight = row.eventHeight;
            }


            return node;
        };

        this._getNodeColumns = function(row) {

            if (!row.columns || row.columns.length === 0) {
                return null;
            }

            var columns = [];
            columns.ignoreToJSON = true; // preventing Gaia to mess up with Array serialization

            for (var i = 0; i < row.columns.length; i++) {
                var c = {};
                c.InnerHTML = row.columns[i].html;

                columns.push(c);
            }

            return columns;
        };

        this._prefixCssClass = function(part) {
            var prefix = this.theme || this.cssClassPrefix;
            if (prefix) {
                return prefix + part;
            }
            else {
                return "";
            }
        };

        this._updateTheme = function() {
            // manually update theme for elements that are not redrawn during update
            //return;

            var needsUpdate = calendar.nav.top.className !== calendar._prefixCssClass("_main");

            if (!needsUpdate) {
                return;
            }

            calendar.nav.top.className = calendar._prefixCssClass("_main");
            calendar.nav.dh1.className = calendar._prefixCssClass("_divider_horizontal");
            calendar.nav.dh2.className = calendar._prefixCssClass("_divider_horizontal");
            calendar.divResScroll.className = calendar._prefixCssClass("_rowheader_scroll");
            calendar.nav.divider.className  = calendar._prefixCssClass("_divider") + " " + calendar._prefixCssClass("_splitter");
            calendar.nav.scroll.className = calendar._prefixCssClass("_scrollable");
            calendar._maind.className = calendar._prefixCssClass("_matrix") + " " + calendar._prefixCssClass("_grid_main");
            calendar.nav.loading.className = calendar._prefixCssClass("_loading");
        };

        this._registerDispose = function() {
            this.nav.top.dispose = this.dispose;
            this.nav.limit;
        };

        this.dispose = function() {

            var c = calendar;

            if (!c._initialized) {
                return;
            }

            if (c._disposed) {
                return;
            }

            c._disposed = true;

            if (c._watchObserver) {
                c._watchObserver.disconnect();
            }

            c._pauseAutoRefresh();
            clearInterval(c._visibilityInterval);
            clearInterval(c._widthChangeDetectionInterval);

            for (var name in c._timeouts) {
                var item = c._timeouts[name];
                if (DayPilot.isArray(item)) {
                    createList(item).forEach(function(t) {
                        clearTimeout(t);
                    });
                }
                else {
                    clearTimeout(item);
                }
            }

            c._deleteEvents();
            c._deleteCells();
            c._disposeCorner();
            c._disposeRows("main");
            c._disposeRows("top");
            c._disposeRows("bottom");
            c._disposeTimeHeader();
            c._nowDeactivate();

            c.divBreaks = null;
            c.divCells = null;
            c.divCorner = null;
            c.divCrosshair = null;
            c.divEvents = null;
            if (c.divHeader) {
                c.divHeader.rows = null;
            }
            c.divHeader = null;
            c.divLines = null;
            c.divNorth = null;
            c.divRange = null;
            c.divResScroll = null;
            c.divSeparators = null;
            c.divSeparatorsAbove = null;
            c.divStretch = null;
            c.divTimeScroll = null;
            c._scrollRes = null;
            c._vsph = null;
            c._maind.calendar = null;
            c._maind = null;

            c.nav.loading = null;

            c.nav.top.onmousemove = null;
            c.nav.top.onmouseout = null;
            c.nav.top.dispose = null;
            DayPilot.ue(c.nav.top, "touchstart", touch._onMainTouchStart);
            DayPilot.ue(c.nav.top, "touchmove", touch._onMainTouchMove);
            DayPilot.ue(c.nav.top, "touchend", touch._onMainTouchEnd);

            focus._unregisterEvents();

            c.nav.top.removeAttribute('style');
            c.nav.top.removeAttribute('class');
            var resetHtml = !(calendar._react.reactDOM && DayPilot.browser.ie);
            if (resetHtml) {
                c.nav.top.innerHTML = "";
            }
            c.nav.top.dp = null;
            c.nav.top = null;

            DayPilot.ue(c.nav.scroll, "wheel", calendar._onNavScrollWheel);

            c.nav.scroll.onscroll = null;
            c.nav.scroll.root = null;
            c.nav.scroll = null;

            clearTimeout(c.refreshTimeout);

            if (c._splitter) {
                c._splitter.dispose();
                c._splitter = null;
            }

            // jQuery
            if (c.daypilot) {
                delete c.daypilot;
            }

            DayPilot.ue(window, 'resize', c._onWindowResize);
            DayPilot.ue(document, 'keydown', c._onKeyDown);
            DayPilot.ue(document, 'keyup', c._onKeyUp);

            DayPilotScheduler._unregister(c);

            eventloading = null;

            if (typeof DayPilot.Bubble !== "undefined") {
                DayPilot.Bubble.cancelShowing();
                DayPilot.Bubble.hide({"calendar": c});
            }

            if (typeof DayPilot.Menu !== "undefined") {
                DayPilot.Menu.hide({"calendar": c});
            }

            (function clearProps() {
                // don't use, it's extremely slow
                return;
                for (var name in c) {
                    c[name] = null;
                }
            })();

        };

        this._disposeRows = function(grid) {
            // merge with _deleteRowHeaders() if possible

            if (typeof calendar.onBeforeRowHeaderDomAdd !== "function" && typeof calendar.onBeforeRowHeaderDomRemove !== "function") {
                return;
            }

            var gi = calendar._gridInfo(grid);
            var divHeader = gi.divHeader;
            var rowlist = gi.rowlist;

            var addAndReact = typeof calendar.onBeforeRowHeaderDomAdd === "function" && calendar._react.reactDOM;
            if (addAndReact || typeof calendar.onBeforeRowHeaderDomRemove === "function") {
                // delete rows one by one to ensure proper React unmounting
                for (var i = 0; i < rowlist.length; i++) {
                    if (divHeader.rows[i]) {
                        calendar._deleteRow(i, grid);
                    }
                }
            }
        };

        this._disposeTimeHeader = function() {

            if (typeof calendar.onBeforeTimeHeaderDomAdd !== "function" && typeof calendar.onBeforeTimeHeaderDomRemove !== "function") {
                return;
            }

            calendar.elements.timeHeader.forEach(function(div) {

                var domArgs = div.domArgs;
                div.domArgs = null;

                if (typeof calendar.onBeforeTimeHeaderDomRemove === "function") {
                    calendar.onBeforeTimeHeaderDomRemove(domArgs);
                }

                if (typeof calendar.onBeforeTimeHeaderDomAdd === "function" && calendar._react.reactDOM) {
                    var target = domArgs && domArgs._targetElement;

                    if (target) {
                        var isReact = isReactCmp(domArgs.element);
                        if (isReact) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._unmount(target);
                        }
                    }
                }
            });
        };

        // freeze ok
        this._createShadow = function(object) {
            var event = null;
            if (object.nodeType) {
                event = object.event;
            }
            else {
                event = object;
            }

            var ev = event;

            var verticalAllowed = (ev.cache && typeof ev.cache.moveVDisabled !== 'undefined') ? !ev.cache.moveVDisabled : !ev.data.moveVDisabled;
            var horizontalAllowed = (ev.cache && typeof ev.cache.moveHDisabled !== 'undefined') ? !ev.cache.moveHDisabled :!ev.data.moveHDisabled;

            // var maind = calendar._maind;
            var coords = calendar._getShadowCoords(event);
            var grid = calendar._grids[coords.grid];
            if (!verticalAllowed && DayPilotScheduler._moving) {
                grid = calendar._grids[event.part.grid];
            }
            var rowlist = grid.rowlist;

            if (calendar._isRowDisabled(coords.rowIndex, coords.grid)) {
                return null;
            }

            var height = event.part.height || calendar._resolved._eventHeight();
            var top = (event.part && event.part.top && rowlist[event.part.dayIndex]) ? (event.part.top + rowlist[event.part.dayIndex].top) : coords.top;
            var left = coords.left;
            var width = coords.width;


            if (!verticalAllowed && DayPilotScheduler._moving) {
                top = rowlist[ev.part.dayIndex].top;
            }
            if (!horizontalAllowed && DayPilotScheduler._moving) {
                left = event.part.left;
                if (typeof left === "undefined") {
                    var duration = DayPilot.DateUtil.diff(event.start(), event.end());
                    duration = atLeast(duration, 1);
                    left = resolved._useBox(duration) ? calendar.getPixels(event.start()).boxLeft : calendar.getPixels(event.start()).left;
                    var right = resolved._useBox(duration) ? calendar.getPixels(event.end()).boxRight : calendar.getPixels(event.end()).left;
                    width = right - left;

                }
            }

            var shadow = document.createElement('div');
            shadow.setAttribute('unselectable', 'on');
            shadow.style.position = 'absolute';
            shadow.style.width = width + 'px';
            shadow.style.height = height + 'px';
            shadow.style.left = left + 'px';
            shadow.style.top = top + 'px';
            // shadow.style.zIndex = 101;
            shadow.style.overflow = 'hidden';

            var inner = createDiv();
            shadow.appendChild(inner);
            shadow.className = this._prefixCssClass("_shadow");
            inner.className = this._prefixCssClass("_shadow_inner");

            // maind.appendChild(shadow);
            grid.divShadow.appendChild(shadow);
            shadow.calendar = calendar;
            shadow.grid = coords.grid;

            return shadow;
        };

        // y is in pixels, not row index
        // freeze ok
        this._getRow = function(y, gridName, splitParent) {
            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            var result = {};
            var element;

            var top = 0;
            var rowEnd = 0;
            if (gridName ==="main") {
                top = calendar._grids.top.height;
                rowEnd = top;
            }
            var iMax = rowlist.length; // maximum row index

            for (var i = 0; i < iMax; i++) {
                var row = rowlist[i];
                if (row.hidden) {
                    continue;
                }
                var height = row.height;
                if (splitParent && row.split && row.split.parent) {
                    height = row.split.parent.split.totalHeight();
                }

                rowEnd += height;

                top = rowEnd - height;
                element = row;

                // make sure it's the last visible row
                result.top = top;
                result.bottom = rowEnd;
                result.i = i;  // visible row index
                result.element = element;
                result.grid = gridName;

                if (splitParent && row.split && row.split.parent) {
                    i += row.split.parent.split.list.length - 1;
                }

                if (y < rowEnd) {
                    break;
                }
            }

            return result;
        };

        this.links = {};
        this.links.list = [];


        this.links.add = function(link) {
            if (!link) {
                return;
            }
            var data = link;
            if (link instanceof DayPilot.Link) {
                data = link.data;
            }
            calendar.links.list.push(link);
            linktools._load();
        };

        this.links.remove = function(link) {
            if (typeof link === "number" || typeof link === "string") {
                var found = calendar.links.find(link);
                if (found) {
                    linktools._remove(found.data);
                }
                return;
            }

            var props = link.data;
            if (!link.isLink) {
                props = link;
            }

            linktools._remove(props);
        };

        this.links.find = function(id) {
            if (!DayPilot.isArray(calendar.links.list)) {
                return null;
            }
            var data = calendar.links.list.find(function(item) {
                return item.id === id;
            });
            if (data) {
                return new DayPilot.Link(data, calendar);
            }
            return null;
        };

        this.links.findByFromTo = function(from, to) {
            if (!DayPilot.isArray(calendar.links.list)) {
                return null;
            }
            var data = calendar.link.list.find(function(item) {
                return item.from === from && item.to === to;
            });
            if (data) {
                return new DayPilot.Link(data, calendar);
            }
            return null;
        };

        this.links.load = function(url, success, error, options) {

            if (!url) {
                throw new DayPilot.Exception("links.load(): 'url' parameter required");
            }

            options = options || {};

            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.links.list = data;
                    if (calendar._initialized) {
                        // calendar.update();
                        linktools._load();
                    }
                }
            };

            var usePost = calendar.linksLoadMethod && calendar.linksLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "contentType": "application/json",
                    "data": { "start": calendar.visibleStart().toString(), "end": calendar.visibleEnd().toString()},
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                var fullUrl = url;
                if (!options.dontAddStartEnd) {
                    var queryString = "start=" + calendar.visibleStart().toString() + "&end=" + calendar.visibleEnd().toString();
                    if (fullUrl.indexOf("?") > -1) {
                        fullUrl += "&" + queryString;
                    }
                    else {
                        fullUrl += "?" + queryString;
                    }
                }

                DayPilot.ajax({
                    "method": "GET",
                    "url": fullUrl,
                    "success": onSuccess,
                    "error": onError
                });
            }
        };


        var linktools = {};

        this._linktools = linktools;

        linktools._items = [];

        linktools._clear = function() {
            calendar.divLinksAbove.innerHTML = '';
            calendar.divLinksBelow.innerHTML = '';
            calendar.elements.links = [];

            linktools._items = [];
        };

        linktools._remove = function(props) {
            var item = linktools._findItem(props);

            DayPilot.rfa(calendar.links.list, props);

            if (!item) {
                return;
            }

            item.clear();

            DayPilot.rfa(linktools._items, item);
        };

        linktools._findItem = function(props) {
            for (var i = 0; i < linktools._items.length; i++) {
                var item = linktools._items[i];
                if (item.props === props) {
                    return item;
                }
            }
            return null;
        };

        linktools._showLinkpoints = function() {
            var events = viewport._events();
            events.forEach(function(div) {
                linktools._showLinkpoint(div);
            });
        };

        linktools._showLinkpoint = function(div) {

            var event = div.event;
            var cache = event.cache || event.data;
            var disabled = cache.linkCreateDisabled;

            if (disabled) {
                return;
            }

            var width = calendar.linkPointSize;
            var mid = width/2;

            var left = div.event.part.left;
            var top = calendar.rowlist[div.event.part.dayIndex].top + div.event.part.top;
            var height = div.event.part.height;
            var right = div.event.part.right;

            var start = utilDiv(calendar.divLinkpoints, left - mid, top - mid + height/2, width, width);
            start.className = calendar._prefixCssClass("_linkpoint");
            start.style.boxSizing = "border-box";
            start.coords = {x: left, y: top + height/2};
            start.type = "Start";
            start.event = div.event;
            linktools._activateLinkpoint(start);
            calendar.elements.linkpoints.push(start);

            var end = utilDiv(calendar.divLinkpoints, right - mid, top - mid + height/2, width, width);
            end.className = calendar._prefixCssClass("_linkpoint");
            end.style.boxSizing = "border-box";
            end.coords = {x: right, y: top + height/2};
            end.type = "Finish";
            end.event = div.event;
            linktools._activateLinkpoint(end);
            calendar.elements.linkpoints.push(end);
        };

        linktools._activateLinkpoint = function(div) {

            //linktools.clearHideTimeout();

            div.onmousedown = function(ev) {
                linking.source = div;
                linking.calendar = calendar;
                linktools._showLinkpoints();
                ev.preventDefault(); // prevent text selection cursor in chrome
                ev.stopPropagation();
                return false;
            };
            div.onmousemove = function(ev) {
                addClass(div, calendar._prefixCssClass("_linkpoint_hover"));
                //div.style.backgroundColor = "black";
                linktools._clearHideTimeout();
            };
            div.onmouseout = function(ev) {
                if (!linking.source || linking.source.event !== div.event) {
                    removeClass(div, calendar._prefixCssClass("_linkpoint_hover"));
                }
            };
            div.onmouseup = function(ev) {
                if (linking.source) {
                    var type = linking.source.type + "To" + div.type;
                    var from = linking.source.event.id();
                    var to = div.event.id();

                    var args = {};
                    args.from = from;
                    args.to = to;
                    args.type = type;
                    args.id = null;
                    args.preventDefault = function() {
                        this.preventDefault.value = true;
                    };

                    if (typeof calendar.onLinkCreate === "function") {
                        calendar.onLinkCreate(args);
                        if (args.preventDefault.value) {
                            return;
                        }
                    }

                    var update = function() {
                        if (!DayPilot.isArray(calendar.links.list)) {
                            calendar.links.list = [];
                        }
                        calendar.links.list.push({"from": from, "to": to, "type": type, "id": args.id});
                        linktools._load();
                    };

                    switch (calendar.linkCreateHandling) {
                        case "Update":
                            update();
                            break;
                        case "CallBack":
                            calendar._linkCreateCallBack(args);
                            break;
                        case "PostBack":
                            calendar._linkCreatePostBack(args);
                            break;
                        case "Notify":
                            update();
                            calendar._linkCreateNotify(args);
                            break;
                    }

                    if (typeof calendar.onLinkCreated === "function") {
                        calendar.onLinkCreated(args);
                    }

                }
            };
        };

        linktools._hideLinkpoints = function() {
            calendar.divLinkpoints.innerHTML = '';
            calendar.elements.linkpoints = [];
        };

        linktools._hideTimeout = null;

        linktools._hideLinkpointsWithDelay = function() {
            linktools._hideTimeout = setTimeout(function() {
                linktools._hideLinkpoints();
            }, 100);
        };

        linktools._clearHideTimeout = function() {
            if (linktools._hideTimeout) {
                clearTimeout(linktools._hideTimeout);
                linktools._hideTimeout = null;
            }
        };

        linktools._load = function() {
            linktools._clear();
            if (!DayPilot.isArray(calendar.links.list)) {
                return;
            }
            for (var i = 0; i < calendar.links.list.length; i++) {
                var link = calendar.links.list[i];
                linktools._drawLinkId(link.from, link.to, link);
            }
        };

        linktools._drawLinkId = function(from, to, props) {
            // var start = calendar.events.find(from);
            // var end = calendar.events.find(to);

            // TODO make more effective
            var fromE = calendar.events.find(from);
            var start = calendar.events._findEventInRows(fromE && fromE.data);

            var toE = calendar.events.find(to);
            var end = calendar.events._findEventInRows(toE && toE.data);

            if ((start && start.rendered) || (end && end.rendered)) {
                linktools._drawLink2(start, end, props);
            }
        };

        linktools._getEventRect = function(divOrEvent, includeHiddenRows) {
            var isDiv = divOrEvent && divOrEvent.tagName && divOrEvent.tagName.toLowerCase() === "div";
            if (isDiv) {
                var div = divOrEvent;
                return {
                    "top": div.offsetTop,
                    "right": div.offsetLeft + div.offsetWidth,
                    "left": div.offsetLeft,
                    "height": div.offsetHeight
                };
            }
            else if (divOrEvent instanceof DayPilot.Event) {
                var e = divOrEvent;
                var row = calendar.rowlist[e.part.dayIndex];
                var rowTop = includeHiddenRows ? row.absTop : row.top;

                // guess "top" value for events in rows that are out of the viewport
                // don't use e.part.right
                // --> both values are calculated in _updateEventPositionsInRow()
                return {
                    "top": rowTop + (e.part.top || 0),
                    "right": e.part.left + e.part.width,
                    "left": e.part.left,
                    "height": e.part.height
                };
            }
            else {
                // throw new DayPilot.Exception("Unsupported target type");
                return null;
            }
        };

        linktools._isRendered = function(props) {
            return linktools._items.some(function(item) {
                return item.props === props;
            });
        };

        linktools._drawLink2 = function(from, to, props) {
            if (linktools._isRendered(props)) {
                return null;
            }

            var segments = linktools._getSegments(from, to, props);
            if (!segments) {
                return null;
            }

            var item = linktools._drawLinkSegments(segments, props);
            if (!item) {
                return null;
            }

            linktools._items.push(item);
            return item;
        };

        linktools._drawLinkSegments = function(segments, props) {
            if (!segments) {
                return null;
            }

            var result = {
                "divs": [],
                "props": props,
                "clear": function() {
                    var link = this;
                    deleteElement(link.divs);
                    link.divs.forEach(function(div) {
                        DayPilot.rfa(calendar.elements.links, div);
                    });

                }
            };
            var indent = calendar.eventHeight/2;

            var width = props.width || 1;
            var color = props.color;
            var style = props.style;
            var layer = props.layer || "Above";
            var above = layer === "Above";
            var divLinks = above ? calendar.divLinksAbove : calendar.divLinksBelow;
            //var border = width + "px " + style + " " + color;

            var applyBorder = function(div, which) {
                if (color) {
                    div.style["border" + which + "Color"] = color;
                }
                if (style) {
                    div.style["border" + which + "Style"] = style;
                }
            };

            var divs = [];

            var saveDiv = function(div, dontHover) {
                calendar.elements.links.push(div);
                activateHover(div);
                activateContextMenu(div);
                activateClick(div);

                div.divs = divs;
                // required for hover
                if (!dontHover) {
                    divs.push(div);
                }
                result.divs.push(div); // always include
            };

            var activateContextMenu = function(div) {

                div.onmousedown = function(ev) {
                    ev.cancelBubble = true;
                };

                div.onmouseup = function(ev) {
                    ev.cancelBubble = true;
                };

                div.oncontextmenu = function(ev) {
                    if (calendar.contextMenuLink) {
                        var link = new DayPilot.Link(props, calendar);
                        calendar.contextMenuLink.show(link);
                    }

                    ev.cancelBubble = true;
                    ev.preventDefault();
                };
            };

            var activateHover = function(div) {
                div.onmouseenter = function() {
                    addClass(div.divs, calendar._prefixCssClass("_link_hover"));
                    if (calendar.linkBubble) {
                        calendar.linkBubble.showLink(new DayPilot.Link(props, calendar));
                    }
                };
                div.onmouseleave = function() {
                    removeClass(div.divs, calendar._prefixCssClass("_link_hover"));
                    if (calendar.linkBubble) {
                        calendar.linkBubble.hideOnMouseOut();
                    }
                };
            };

            var activateClick = function(div) {
                div.onclick = function(ev) {
                    var args = {};
                    args.link = props;
                    if (typeof calendar.onLinkClick === "function") {
                        calendar.onLinkClick(args);
                    }
                    if (typeof calendar.onLinkClicked === "function") {
                        calendar.onLinkClicked(args);
                    }
                };
            };

            segments.forEach(function(s) {
                switch (s.type) {
                    case "Dot":
                        var w = 10;
                        var a;
                        if (color) {
                            a = utilDiv(divLinks, s.endX - w/2, s.endY - w/2, w, w);
                            a.style.borderRadius = w + "px";
                            a.style.backgroundColor = color;
                        }
                        else {
                            a = utilDiv(divLinks, s.endX - w/2, s.endY - w/2, w, w);
                            a.className = calendar._prefixCssClass("_link_dot");
                            addClass(a, props.cssClass);
                        }
                        saveDiv(a, true);
                        break;

                    case "HorizontalLine":
                        var h1 = utilDiv(divLinks, s.startX, s.startY, s.endX - s.startX, width);
                        h1.style.boxSizing = "border-box";
                        h1.style.borderBottomWidth = width + "px";
                        h1.className = calendar._prefixCssClass("_link_horizontal");
                        addClass(h1, props.cssClass);
                        applyBorder(h1, "Bottom");
                        saveDiv(h1);
                        break;

                    case "VerticalLine":
                        var v1 = utilDiv(divLinks, s.startX, s.startY, width, s.endY - s.startY);
                        v1.style.boxSizing = "border-box";
                        v1.style.borderRightWidth = width + "px";
                        v1.className = calendar._prefixCssClass("_link_vertical");
                        addClass(v1, props.cssClass);
                        applyBorder(v1, "Right");
                        saveDiv(v1);
                        break;

                    case "ArrowUp":
                        var a;
                        if (color) {
                            a = utilDiv(divLinks, s.endX - 5 + Math.floor(width/2), s.endY - 5, 0, 0);
                            a.style.borderColor = "transparent transparent " + color + " transparent";
                            a.style.borderStyle = "solid";
                            a.style.borderWidth = "5px";
                        }
                        else {
                            a = utilDiv(divLinks, s.endX - 6 + Math.floor(width/2), s.endY - 6, 6, 6);
                            a.className = calendar._prefixCssClass("_link_arrow_up");
                            addClass(a, props.cssClass);
                        }
                        saveDiv(a, true);

                        break;
                    case "ArrowDown":
                        var a;
                        if (color) {
                            a = utilDiv(divLinks, s.endX - 5 + Math.floor(width/2), s.endY - 5, 0, 0);
                            a.style.borderColor = color + " transparent transparent transparent";
                            a.style.borderStyle = "solid";
                            a.style.borderWidth = "5px";
                        }
                        else {
                            a = utilDiv(divLinks, s.endX - 5 + Math.floor(width/2), s.endY - 6, 6, 6);
                            // a = utilDiv(divLinks, s.endX - 5 + (width/2), s.endY - 6, 6, 6);
                            a.className = calendar._prefixCssClass("_link_arrow_down");
                            addClass(a, props.cssClass);
                        }
                        saveDiv(a, true);
                        break;

                    case "ArrowRight":
                        var a;
                        if (color) {
                            a = utilDiv(divLinks, s.endX - 6, s.endY - 5, 0, 0);
                            a.style.borderWidth = "6px";
                            a.style.borderColor = "transparent transparent transparent " + color;
                            a.style.borderStyle = "solid";
                        }
                        else {
                            a = utilDiv(divLinks, s.endX - 6, s.endY - 5, 6, 6);
                            a.className = calendar._prefixCssClass("_link_arrow_right");
                            addClass(a, props.cssClass);
                        }
                        saveDiv(a, true);
                        break;

                    case "ArrowLeft":
                        var a;
                        if (color) {
                            a = utilDiv(divLinks, s.endX - 6, s.endY - 5, 0, 0);
                            a.style.borderColor = "transparent " + color + " transparent transparent";
                            a.style.borderStyle = "solid";
                            a.style.borderWidth = "6px";
                        }
                        else {
                            a = utilDiv(divLinks, s.endX - 6, s.endY - 5, 6, 6);
                            a.className = calendar._prefixCssClass("_link_arrow_left");
                            addClass(a, props.cssClass);
                        }
                        saveDiv(a, true);
                        break;
                    default:
                        throw new DayPilot.Exception("Invalid segment type");
                }
            });

            return result;

        };


        linktools._getSegments = function(from, to, props, includeHiddenRows) {

            var rectFrom = linktools._getEventRect(from, includeHiddenRows);
            var rectTo = linktools._getEventRect(to, includeHiddenRows);

            if (!rectFrom) {
                return null;
            }

            if (!rectTo) {
                return null;
            }

            // TODO skip if both rects are out of the viewport

            var type = props.type || "FinishToStart";
            var width = props.width || 1;
            var height = calendar.eventHeight;
            var bottom = calendar.linkBottomMargin;
            var indent = calendar.eventHeight/2;

            var start, end;
            switch (type) {
                case "FinishToStart":
                    start = {x: rectFrom.right, y: rectFrom.top};
                    end = {x: rectTo.left, y: rectTo.top};

                    if (start.y > end.y) {
                        if (rectTo.top + rectTo.height > rectFrom.top) {  // can happen for shadow
                            end.y = start.y;
                        }
                        else if (start.x <= end.x) {
                            end.y += rectTo.height;
                            end.bottom = true;
                        }
                    }
                    break;
                case "StartToFinish":
                    start = {x: rectFrom.left, y: rectFrom.top};
                    end = {x: rectTo.right, y: rectTo.top};
                    break;
                case "StartToStart":
                    start = {x: rectFrom.left, y: rectFrom.top};
                    end = {x: rectTo.left, y: rectTo.top};
                    break;
                case "FinishToFinish":
                    start = {x: rectFrom.right, y: rectFrom.top};
                    end = {x: rectTo.right, y: rectTo.top};
                    break;
            }

            var segments = [];

            if (type === "FinishToStart") {
                if (start.y === end.y && start.x === end.x && !end.bottom) {
                    var tox = start.x ;
                    var toy = start.y + height - bottom;

                    segments.push({
                       "type": "Dot",
                       "startX": tox,
                       "startY": toy,
                       "endX": tox,
                       "endY": toy
                    });
                }
                else if (start.y > end.y || (start.y == end.y && end.bottom)) {
                    if (start.x <= end.x) {
                        var startx = start.x;
                        var starty = start.y + height - bottom;

                        var tox = end.x + indent;
                        var toy = end.y;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": startx,
                            "startY": starty,
                            "endX": tox,
                            "endY": starty
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": tox,
                            "startY": starty,
                            "endX": tox,
                            "endY": toy
                        });


                        segments.push({
                            "type": start.y < end.y ? "ArrowDown" : "ArrowUp",
                            "startX": tox,
                            "startY": toy,
                            "endX": tox,
                            "endY": toy
                        });

                    }
                    else {
                        var below = 5;
                        var midy = end.y + height + below;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": start.x,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent + width,
                            "endY": start.y + height - bottom
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": start.x + indent,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent,
                            "endY": midy
                        });

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": start.x + indent + width,
                            "endY": midy
                        });


                        segments.push({
                            "type": "VerticalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": end.x - indent,
                            "endY": end.y + height - bottom
                        });


                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": end.y + height - bottom,
                            "endX": end.x - indent + indent,
                            "endY": end.y + height - bottom
                        });


                        segments.push({
                            "type": "ArrowRight",
                            "startX": end.x,
                            "startY": end.y + height - bottom,
                            "endX": end.x,
                            "endY": end.y + height - bottom
                        });

                    }
                }
                else if (start.y === end.y) {  // same line
                    if (start.x < end.x) {
                        var startx = start.x;
                        var starty = start.y + height - bottom;
                        var tox = end.x;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": startx,
                            "startY": starty,
                            "endX": tox,
                            "endY": starty
                        });

                        segments.push({
                            "type": "ArrowRight",
                            "startX": end.x,
                            "startY": end.y + height - bottom,
                            "endX": end.x,
                            "endY": end.y + height - bottom
                        });
                    }
                    else {
                        var below = 5;
                        //var midy = end.y + above;
                        var midy = end.y + height + below;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": start.x,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent + width,
                            "endY": start.y + height - bottom
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": start.x + indent,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent,
                            "endY": midy
                        });

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": start.x + indent + width,
                            "endY": midy
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": end.x - indent,
                            "endY": end.y + height - bottom
                        });

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": end.y + height - bottom,
                            "endX": end.x,
                            "endY": end.y + height - bottom
                        });


                        segments.push({
                            "type": "ArrowRight",
                            "startX": end.x,
                            "startY": end.y + height - bottom,
                            "endX": end.x,
                            "endY": end.y + height - bottom
                        });

                    }
                } else {
                    if (start.x > end.x) {
                        var above = 5;
                        var midy = end.y - above;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": start.x,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent,
                            "endY": start.y + height - bottom
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": start.x + indent,
                            "startY": start.y + height - bottom,
                            "endX": start.x + indent,
                            "endY": midy
                        });

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": start.x + indent,
                            "endY": midy
                        });


                        segments.push({
                            "type": "VerticalLine",
                            "startX": end.x - indent,
                            "startY": midy,
                            "endX": end.x - indent,
                            "endY": end.y + height - bottom
                        });


                        segments.push({
                            "type": "HorizontalLine",
                            "startX": end.x - indent,
                            "startY": end.y + height - bottom,
                            "endX": end.x - indent + indent,
                            "endY": end.y + height - bottom
                        });


                        segments.push({
                            "type": "ArrowRight",
                            "startX": end.x,
                            "startY": end.y + height - bottom,
                            "endX": end.x,
                            "endY": end.y + height - bottom
                        });

                    }
                    else {
                        var startx = start.x;
                        var starty = start.y + height - bottom;

                        var tox = end.x + indent;
                        var toy = end.y;

                        segments.push({
                            "type": "HorizontalLine",
                            "startX": startx,
                            "startY": starty,
                            "endX": tox,
                            "endY": starty
                        });

                        segments.push({
                            "type": "VerticalLine",
                            "startX": tox,
                            "startY": starty,
                            "endX": tox,
                            "endY": toy
                        });

                        segments.push({
                            "type": start.y < end.y ? "ArrowDown" : "ArrowUp",
                            "startX": tox,
                            "startY": toy,
                            "endX": tox,
                            "endY": toy
                        });

                    }
                }
            }
            else if (type === "StartToFinish") {
                var above = 5;
                var midy = end.y - above;

                segments.push({
                    "type": "HorizontalLine",
                    "startX": end.x,
                    "startY": end.y + height - bottom,
                    "endX": end.x + indent + width,
                    "endY": end.y + height - bottom
                });

                segments.push({
                    "type": "VerticalLine",
                    "startX": end.x + indent,
                    "startY": end.y + height - bottom,
                    "endX": end.x + indent,
                    "endY": midy
                });

                segments.push({
                    "type": "HorizontalLine",
                    "startX": start.x - indent,
                    "startY": midy,
                    "endX": end.x + indent + width,
                    "endY": midy
                });

                segments.push({
                    "type": "VerticalLine",
                    "startX": start.x - indent,
                    "startY": midy,
                    "endX": start.x - indent,
                    "endY": start.y + height - bottom
                });

                segments.push({
                    "type": "HorizontalLine",
                    "startX": start.x - indent,
                    "startY": start.y + height - bottom,
                    "endX": start.x,
                    "endY": start.y + height - bottom
                });


                segments.push({
                    "type": "ArrowLeft",
                    "startX": end.x,
                    "startY": end.y + height - bottom,
                    "endX": end.x,
                    "endY": end.y + height - bottom
                });

            }
            else if (type === "StartToStart") {
                var nx = Math.min(start.x, end.x) - indent;

                segments.push({
                    "type": "HorizontalLine",
                    "startX": nx,
                    "startY": start.y + height - bottom,
                    "endX": start.x,
                    "endY": start.y + height - bottom
                });

                segments.push({
                    "type": "VerticalLine",
                    "startX": nx,
                    "startY": start.y + height - bottom,
                    "endX": nx,
                    "endY": end.y + height - bottom
                });

                segments.push({
                    "type": "HorizontalLine",
                    "startX": nx,
                    "startY": end.y + height - bottom,
                    "endX": end.x,
                    "endY": end.y + height - bottom
                });

                segments.push({
                    "type": "ArrowRight",
                    "startX": end.x,
                    "startY": end.y + height - bottom,
                    "endX": end.x,
                    "endY": end.y + height - bottom
                });

            }
            else if (type === "FinishToFinish") {
                var fx = Math.max(end.x, start.x) + indent;

                segments.push({
                    "type": "HorizontalLine",
                    "startX": start.x,
                    "startY": start.y + height - bottom,
                    "endX": fx,
                    "endY": start.y + height - bottom
                });

                segments.push({
                    "type": "VerticalLine",
                    "startX": fx,
                    "startY": start.y + height - bottom,
                    "endX": fx,
                    "endY": height - bottom + end.y
                });

                segments.push({
                    "type": "HorizontalLine",
                    "startX": end.x,
                    "startY": end.y + height - bottom,
                    "endX": fx,
                    "endY": end.y + height - bottom
                });


                segments.push({
                    "type": "ArrowLeft",
                    "startX": end.x,
                    "startY": end.y + height - bottom,
                    "endX": end.x,
                    "endY": end.y + height - bottom
                });

            }

            return segments;

        };


        linktools._clearShadow = function() {
            calendar.divLinkShadow.innerHTML = '';
            calendar.elements.linkshadow = [];
        };

        linktools._drawShadow = function(from, to) {
            linktools._clearShadow();

            var parent = calendar.divLinkShadow;
            var line = DayPilot.line(from.x, from.y, to.x, to.y, {"arrow": true, "cssClass": calendar._prefixCssClass("_link_shadow")});
            parent.appendChild(line);
            calendar.elements.linkshadow.push(line);
        };


        this._linkCreateCallBack = function(args, data) {
            var params = {};
            params.from = args.from;
            params.to = args.to;
            params.type = args.type;

            calendar._callBack2("LinkCreate", params, data);
        };

        this._linkCreateNotify = function(args, data) {
            var params = {};
            params.from = args.from;
            params.to = args.to;
            params.type = args.type;

            calendar._callBack2("LinkCreate", params, data, "Notify");
        };

        this._linkCreatePostBack = function(args, data) {
            var params = {};
            params.from = args.from;
            params.to = args.to;
            params.type = args.type;

            calendar._postBack2("LinkCreate", params, data);
        };

        this._getRowByIndex = function(i, gridName) {
            var top = 0;
            var bottom = 0;
            var index = 0; // visible index
            var grid = calendar._gridInfo(gridName);
            var rowlist = grid.rowlist;

            if (i > rowlist.length - 1) {
                throw new DayPilot.Exception("Row index too high");
            }

            for (var j = 0; j <= i; j++) {
                var row = rowlist[j];

                if (row.hidden) {
                    continue;
                }

                bottom += row.height;
                index++;
            }

            top = bottom - row.height;

            var result = {};
            result.top = top;
            result.height = row.height;
            result.bottom = bottom;
            result.i = index - 1;
            result.data = row;

            return result;

        };

        this._isShortInit = function() {
            return !!this.backendUrl;
        };

        this.events.find = function(id) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }
            if (typeof id === "function") {
                return calendar._eventsFindByFunction(id);
            }
            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].id === id) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        this.events.findAll = function(f) {
            if (typeof f === "function") {
                var len = calendar.events.list.length;
                var result = [];
                for (var i = 0; i < len; i++) {
                    var e = new DayPilot.Event(calendar.events.list[i], calendar);
                    if (f(e)) {
                        result.push(e);
                    }
                }
                return result;
            }
            if (typeof f === "object") {
                return calendar.events.findAll(function(e) {
                    for (var name in f) {
                        if (f[name] !== e.data[name]) {
                            return false;
                        }
                    }
                    return true;
                });
            }
            throw new DayPilot.Exception("function or object argument expected");
        };

        this._eventsFindByFunction = function(f) {
            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                var e = new DayPilot.Event(calendar.events.list[i], calendar);
                if (f(e)) {
                    return e;
                }
            }
            return null;
        };

        this.events.focus = function(e) {
            var div = calendar._findEventDivEnsureRendered(e);
            div && div.focus();
        };

        this.events.scrollIntoView = function(e) {
            var div = calendar._findEventDivEnsureRendered(e);
            if (!div) {
                return;
            }

            var target = e.start();
            var viewport = calendar.getViewPort();


            if (!overlaps(viewport.start, viewport.end, e.start(), e.end()) && overlaps(calendar._visibleStart(), calendar._visibleEnd(), e.start(), e.end())) {
                calendar.scrollTo(target, "fast", "middle");
            }

            var r = e.resource();
            if (calendar.getViewPort().resources.indexOf(r) === -1) {
                calendar.scrollToResource(r);
            }

        };

        this.events.all = function() {
            var list = [];
            for (var i = 0; i < calendar.events.list.length; i++) {
                var e = new DayPilot.Event(calendar.events.list[i], calendar);
                list.push(e);
            }
            return createList(list);
        };

        this.events.forRange = function(start, end) {
            start = start ? new DayPilot.Date(start) : calendar.visibleStart();
            end = end ?  new DayPilot.Date(end) : calendar.visibleEnd();

            var list = createList();
            for (var i = 0; i < calendar.events.list.length; i++) {
                var e = new DayPilot.Event(calendar.events.list[i], calendar);
                if (overlaps(e.start(), e.rawend(), start, end)) {
                    list.push(e);
                }
            }
            return list;
        };

        this.events.filter = function(args, dontUpdate) {
            calendar.events._filterParams = args;

            if (dontUpdate) {
                return;
            }
            calendar._update({"eventsOnly":true});
        };

        this.events.edit = function(e) {
            if (!(e instanceof DayPilot.Event)) {
                e = new DayPilot.Event(e);
            }

            var nowEditing = DayPilotScheduler._editing;
            if (nowEditing) {
                if (calendar._isSameEvent(nowEditing.event, e)) {
                    return;
                }
                else {
                    focus._unfocusCell();
                    focus._supressHighlight = true;
                    DayPilotScheduler._editing.blur();
                }
            }

            var queued = !createList(calendar.events._postponedData.rows).isEmpty();
            if (queued) {
                focus._supressHighlight = true;
                calendar.events._immediateRefresh({"dontResetFocus": true});
            }

            focus._supressHighlight = false;

            var div = calendar._findEventDiv(e);

            if (!div) {
                focus._focusCell();
                return;
            }
            else {
                focus._unfocusCell();
                calendar._divEdit(div);
            }
        };

        this.events.load = function(url, success, error) {

            if (!url) {
                throw new DayPilot.Exception("events.load(): 'url' parameter required");
            }
            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.events.list = sargs.data;
                    if (calendar._initialized) {
                        calendar.update();
                    }
                }
            };

            var usePost = calendar.eventsLoadMethod && calendar.eventsLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "contentType": "application/json",
                    "data": { "start": calendar.visibleStart().toString(), "end": calendar.visibleEnd().toString()},
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                var fullUrl = url;
                var queryString = "start=" + calendar.visibleStart().toString() + "&end=" + calendar.visibleEnd().toString();
                if (fullUrl.indexOf("?") > -1) {
                    fullUrl += "&" + queryString;
                }
                else {
                    fullUrl += "?" + queryString;
                }

                DayPilot.ajax({
                    "method": "GET",
                    "url": fullUrl,
                    "success": onSuccess,
                    "error": onError
                });
            }

        };

        this.events.findRecurrent = function(masterId, time) {
            if (!calendar.events.list || typeof calendar.events.list.length === 'undefined') {
                return null;
            }

            var len = calendar.events.list.length;
            for (var i = 0; i < len; i++) {
                if (calendar.events.list[i].recurrentMasterId === masterId && calendar.events.list[i].start.getTime() === time.getTime()) {
                    return new DayPilot.Event(calendar.events.list[i], calendar);
                }
            }
            return null;
        };

        // internal
        // freeze ok
        this.events._removeFromRows = function(data) {
            var rows = [];
            var rowlist = calendar._rowlistMerged();
            rowlist.forEach(function(row) {
                if (row.isNewRow) {
                    return;
                }
                calendar._ensureRowData(row.index, row.grid);
                for (var r = 0; r < row.events.length; r++) {
                    var rd = row.events[r].data;
                    if (calendar._isSameEvent(rd, data)) {
                        //data.rendered = false;
                        rows.push(row);
                        row.events.splice(r, 1);
                        break; // only once per row
                    }
                }
            });
            return rows;
        };

        // internal
        this.events._findEventInRows = function(data) {

            if (!data) {
                return null;
            }

            var rowlist = calendar._rowlistMerged();
            for (var i = 0; i < rowlist.length; i++) {
                var row = rowlist[i];

                if (row.hidden) {
                    continue;
                }
                if (row.isNewRow) {
                    continue;
                }
                calendar._ensureRowData(row.index, row.grid);
                for (var r = 0; r < row.events.length; r++) {
                    var re = row.events[r];
                    if (calendar._isSameEvent(re.data, data)) {
                        return row.events[r];
                    }
                }
            }
            return null;
        };

        // internal
        // fast, use instead of full loadEvents()
        // freeze ok
        this.events._addToRows = function(data) {
            var rows = [];
            var testAll = calendar._containsDuplicateResources() || calendar.viewType === "Days";

            var index = indexOf(calendar.events.list, data);
            calendar._doBeforeEventRender(index);

            var rowlist = calendar._rowlistMerged();
            var quit = false;
            rowlist.forEach(function(row) {
                if (quit) {
                    return;
                }
                if (row.isNewRow) {
                    return;
                }
                calendar._ensureRowData(row.index, row.grid);
                var ep = calendar._loadEvent(data, row);
                if (ep) {
                    if (typeof calendar.onBeforeEventRender === 'function') {
                        ep.cache = calendar._cache.events[index];
                    }

                    rows.push(row);
                    if (!testAll) {
                        quit = true;
                    }
                }
            });
            return rows;
        };


        this._isSameEvent = function(data1, data2) {
            return DayPilot.Util.isSameEvent(data1, data2);
        };

        this.events.update = function(e, data, options) {

            var updateFocus = function(data) {
                var fp = focus._position;
                if (fp && fp.type === "event") {
                    var isFocused = calendar._isSameEvent(fp.event.data, data);
                    if (isFocused) {
                        fp.event = calendar.events._findEventInRows(data);
                    }
                }
            };

            if (typeof e === "object" && !(e instanceof DayPilot.Event)) {
                // updateByData
                // var data = e;
                var ev = calendar.events.find(e.id);
                calendar.events.remove(ev);
                calendar.events.add(e);
                updateFocus(e);
                return;
            }

            var params = {};
            params.oldEvent = new DayPilot.Event(e.copy(), calendar);
            params.newEvent = new DayPilot.Event(e.temp(), calendar);

            var options = options || {};

            var action = new DayPilot.Action(calendar, "EventUpdate", params, data);

            // don't add it if it wasn't in the list
            var inList = createList(calendar.events.list).find(function(item) {
                // var data = item instanceof DayPilot.Event ? item.data : item;
                // return data === e.data || data.id == e.data.id;
                return calendar._isSameEvent(item, e.data);
            });

            if (!inList) {
                return;
            }

            if (calendar._angular.scope) {
                calendar._angular.notify(function() {
                    e.commit();
                });
            }
            else {

                if (calendar._angular2._eventsFromAttr) {
                    calendar._angular2.skip = true;
                }

                var inplaceEnabled = calendar.eventUpdateInplaceOptimization || options.inplace;

                // optimization - don't redraw the whole row if the event arrangement didn't change
                if (inplaceEnabled && params.oldEvent.resource() === params.newEvent.resource() && params.oldEvent.start()  === params.newEvent.start() && params.oldEvent.end()  === params.newEvent.end()) {

                    e.commit();

                    var div = calendar._findEventDiv(e);
                    // doesn't have to be in rendered state
                    if (div) {
                        var oldPart = div.event.part;
                        calendar._deleteEvent(div);
                        DayPilot.rfa(calendar.elements.events, div);
                        e.part = oldPart;  // might not be necessary
                    }
                    else {
                        doNothing("Old div not found");
                    }

                    var rows = calendar.events._removeFromRows(e.data);
                    rows = rows.concat(calendar.events._addToRows(e.data));
                    calendar._loadRows(rows);

                    var ue = calendar.events._findEventInRows(e.data);
                    ue && calendar._drawEvent(ue);
                    calendar._redrawInvalidatedCells();
                }
                else {
                    var rows = calendar.events._removeFromRows(e.data);
                    e.commit();
                    rows = rows.concat(calendar.events._addToRows(e.data));
                    calendar.events._postponedUpdate(rows);
                }
            }

            updateFocus(e.data);

            return action;
        };

        this.events.remove = function(e, data) {

            if (!e) {
                return;
            }

            if (typeof e === "string" || typeof e === "number") {
                var found = calendar.events.find(e);
                calendar.events.remove(found);
                return;
            }

            var params = {};
            params.e = new DayPilot.Event(e.data, calendar);

            var action = new DayPilot.Action(calendar, "EventRemove", params, data);

            /*var index = indexOf(calendar.events.list, e.data);
            if (index >= 0) { // if found
                calendar.events.list.splice(index, 1);
            }*/
            var inList = calendar._findEventInList(e.data);
            if (inList) {
                calendar.events.list.splice(inList.index, 1);
            }

            if (calendar._angular.scope) {
                calendar._angular.notify();
            }
            else {
                if (calendar._angular2._eventsFromAttr) {
                    calendar._angular2.skip = true;
                }

                var rows = calendar.events._removeFromRows(e.data);
                //calendar.events._postponedUpdate(rows);

                var inplaceEnabled = calendar.eventUpdateInplaceOptimization;

                if (inplaceEnabled && rows.length === 1 && !calendar.events._overlaps(e)) {
                    // can be done manually if it's too slow (removing from lines)
                    calendar._loadRow(calendar.rowlist[rows[0]]);

                    var div = calendar._findEventDiv(e);
                    if (div) {
                        var index = calendar.elements.events.indexOf(div);
                        calendar.elements.events.splice(index, 1);
                        calendar._deleteEvent(div);
                        calendar._redrawInvalidatedCells();
                    }
                }
                else {
                    calendar.events._postponedUpdate(rows);
                }

                /*
                calendar._loadRows(rows);
                calendar._updateRowHeights();

                if (calendar._initialized) {
                    if (calendar.viewType === "Gantt") {
                        calendar.update();
                    }
                    else {
                        calendar._updateRowsNoLoad(rows);
                        calendar._updateHeight();
                    }
                }
                */
            }

            return action;
        };

        this.events.add = function(e, data, options) {

            var options = options || {};
            var renderOnly = options.renderOnly;

            if (!(e instanceof DayPilot.Event)) {
                e = new DayPilot.Event(e);
            }

            e.calendar = calendar;

            if (!calendar.events.list) {
                calendar.events.list = [];
            }

            var inList = calendar._findEventInList(e);

            if (renderOnly) {
                if (!inList) {
                    throw new DayPilot.Exception("Unexpected: event not found in list");
                }
            }
            else {
                if (inList && !calendar.temp.allowDuplicateEventIds) {
                    throw new DayPilot.Exception("The event you are trying to add using DayPilot.Scheduler.events.add() is already loaded. A unique ID is required.");
                }
                if (!inList) {
                    calendar.events.list.push(e.data);
                }
            }

            var action = new DayPilot.Action(calendar, "EventAdd", params, data);

            if (!calendar._initialized) {
                return action;
            }

            if (calendar._angular.scope) {
                calendar._angular.notify();
            }
            else {
                if (calendar._angular2._eventsFromAttr) {
                    calendar._angular2.skip = true;
                }

                var params = {};
                params.e = e;

                var rows = calendar.events._addToRows(e.data);

                var height = e.data.height || calendar.eventHeight;

                var inplaceEnabled = calendar.eventUpdateInplaceOptimization;

                if (inplaceEnabled && rows.length === 1 && !calendar.events._overlaps(e) && height <= calendar.eventHeight && !calendar.eventVersionsEnabled) {

                    var row = calendar.rowlist[rows[0]];
                    calendar._loadRow(row);

                    var ep = row.events.find(function(item) {
                        return item.data === e.data;
                    });

                    ep.part.top = 0;
                    ep.part.height = height;
                    ep.part.line = 0;

                    calendar._drawEvent(ep);
                    calendar._redrawInvalidatedCells();
                    focus._updateDefaultForCurrentPosition();
                }
                else {
                    calendar.events._postponedUpdate(rows);
                }
            }

            return action;

        };

        this.events._overlaps = function(e) {
            var data = e instanceof DayPilot.Event ? e.data : e;
            var start = new DayPilot.Date(data.start);
            var end = new DayPilot.Date(data.end);

            var overlapping = createList(calendar.events.list).find(function(item) {
                if (calendar._isSameEvent(data, item)) {
                     return false;
                }
/*
                if (data === item || data.id == item.id) {
                     return false;
                }
*/
                if (data.resource !== item.resource) {
                    return false;
                }
                var itemStart = new DayPilot.Date(item.start);
                var itemEnd = new DayPilot.Date(item.end);
                return overlaps(start, end, itemStart, itemEnd);
            });
            return !!overlapping;
        };

        this.events.addByData = function(data) {
            calendar.events.add(new DayPilot.Event(data));
        };

        this.events.removeByData = function(data) {
            var e = calendar.events.find(data.id);
            if (!e) {
                throw new DayPilot.Exception("The event to be removed was not found");
            }
            calendar.events.remove(e);
        };

        this.events.updateByData = function(data) {
            var e = calendar.events.find(data.id);
            if (!e) {
                throw new DayPilot.Exception("The event to be updated was not found");
            }
            calendar.events.remove(e);
            calendar.events.add(new DayPilot.Event(data));
        };

        this.events.removeById = function(id) {
            var e = calendar.events.find(id);
            if (!e) {
                throw new DayPilot.Exception("The event to be removed was not found");
            }
            calendar.events.remove(e);
        };

        this.events._postponedData = { "rows": [] };
        this.events._postponedTimeout = null;
        this.events._postponedClear = function() {
            clearTimeout(calendar.events._postponedTimeout);
            calendar.events._postponedTimeout = null;
            calendar.events._postponedData.rows = [];
        };
        this.events._queueUpdateInterval = 0;

        // freeze ok
        this.events._postponedUpdate = function(rows) {

            //clearTimeout(calendar.events._postponedTimeout);

            var update = calendar.events._postponedData.rows;
            createList(rows).forEach(function(row) {
                update.push(row);
            });

            calendar.events._postponedData.rows = DayPilot.ua(update); // merge

            var doit = calendar.events._immediateRefresh;

            if (!calendar.events._postponedTimeout) {
                calendar.events._postponedTimeout = setTimeout(doit, calendar.events._queueUpdateInterval);
            }
        };

        this.events._immediateRefresh = function(options) {

            options = options || {};

            clearTimeout(calendar.events._postponedTimeout);
            calendar.events._postponedTimeout = null;

            var rows = calendar.events._postponedData.rows;
            calendar.events._postponedData.rows = [];

            calendar._loadRows(rows);
            calendar._updateRowHeights();

            if (calendar._initialized) {
                if (calendar.viewType === "Gantt") {
                    calendar.update();
                }
                else {
                    if (calendar._rowsDirty){
                        calendar._prepareRowTops();
                    }
                    calendar._updateHeight();
                    calendar._updateRowsNoLoad(rows);
                    calendar._redrawInvalidatedCells();

                    if (!options.dontResetFocus) {
                        focus._updateDefaultForCurrentPosition();
                    }
                }
            }
        };

        this._angular2 = {};
        this._angular2.enabled = false;
        this._angular2.skip = false;
        this._angular2.skipUpdate = function() {
            return calendar._angular2.skip;
        };
        this._angular2.skipped = function() {
            calendar._angular2.skip = false;
        };
        this._angular2._resourcesFromAttr = false;
        this._angular2._eventsFromAttr = false;

        this._react = {};
        this._react.reactDOM = null;
        this._react.react = null;
        this._react._render = function(component, target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                if (!root) {
                    root = rd.createRoot(target);
                    target._root = root;
                }
                root.render(component);
            }
            else {
                rd.render(component, target);
            }

        };
        this._react._unmount = function(target) {
            var rd = calendar._react.reactDOM;
            if (typeof rd.createRoot === "function") {  // React 18
                var root = target._root;
                setTimeout(function() {
                    root.unmount();
                    target._root = null;
                }, 0);
            }
            else {
                rd.unmountComponentAtNode(target);
            }
        };

        this.queue = {};
        this.queue.list = [];
        this.queue.list.ignoreToJSON = true;

        this.queue.add = function(action) {
            if (!action) {
                return;
            }
            if (action.isAction) {
                calendar.queue.list.push(action);
            }
            else {
                throw new DayPilot.Exception("DayPilot.Action object required for queue.add()");
            }
        };

        this.queue.notify = function(data) {
            var params = {};
            params.actions = calendar.queue.list;
            calendar._callBack2('Notify', params, data, "Notify");

            calendar.queue.list = [];
        };


        this.queue.clear = function() {
            calendar.queue.list = [];
        };

        this.queue.pop = function() {
            return calendar.queue.list.pop();
        };

        this.cells.find = function(start, resource) {
            var cell = calendar._cellFindByStartRes(start, resource);
            if (!cell) {
                return cellArray();
            }
            return this.findXy(cell.x, cell.y, cell.grid);
        };

        this.cells.findByPixels = function(x, y) {
            var itc = calendar._getItlineCellFromPixels(x);
            if (!itc) {
                return cellArray();
            }
            var x = itc.x;

            var row = calendar._getRow(y);
            if (!row) {
                return cellArray();
            }
            var y = row.i;
            return this.findXy(x, y);
        };

        this.cells.all = function() {
            var list = [];
            // may require optimization
            var maxX = calendar.itline.length;
            var maxY = calendar.rowlist.length;
            for(var x = 0; x < maxX; x++) {
                for (var y = 0; y < maxY; y++) {
                    var cell = calendar.cells.findXy(x, y);
                    list.push(cell[0]);
                }
            }
            return cellArray(list);
        };

        this.cells._cell = function(x, y, gridName) {
            //var itc = calendar.itline[x];
            gridName = gridName || "main";

            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            var itc = calendar._getItline(x);
            var row = rowlist[y];

            if (!itc) {
                return null;
            }
            if (!row) {
                return null;
            }

            var rowOffset = row.start.getTime() - calendar._visibleStart().getTime();
            var start = itc.start.addTime(rowOffset);
            var end = itc.end.addTime(rowOffset);

            var cell = {};
            cell.x = x;
            cell.y = y;
            cell.grid = gridName;
            cell.displayY = row.displayY;
            cell.i = gridName + "_" + x + "_" + y;

            if (!row.id) {
                //debugger;
            }
            cell.resource = row.id;
            (function() {
                var cached;
                Object.defineProperty(cell, "row", {
                    get: function() {
                        if (!cached) {
                            cached = new DayPilot.Row(row, calendar);
                        }
                        return cached;
                    },
                });
            })();
            cell.start = start;
            cell.end = end;
            cell.calendar = calendar; // required for active areas
            cell.isParent = !!(row.children && row.children.length);
            //cell.row = calendar._createRowObject(row);
            cell.update = function() { // if visible

                if (!rowlist[cell.y].hidden) {
                    // always delete, might have been already rendered
                    var old = calendar._cache.cells[cell.i];
                    calendar._deleteCell(old);

                    // draw the deleted cells in the visible area
                    var area = calendar._getDrawArea();
                    if (area.xStart <= cell.x && cell.x <= area.xEnd) {
                        if (area.yStart <= cell.y && cell.y <= area.yEnd) {
                            calendar._drawCell(cell.x, cell.y, cell.grid);
                        }
                    }
                }

            };
            cell.utilization = function(name) {
                if (row.isNewRow) {
                    return 0;
                }
                if (!row.sections) {
                    row._calculateUtilization();
                }
                return row.sections.forRange(start, end).maxSum(name);
            };
            cell.events = function() {
                return row.events.forRange(start, end);
            };
            cell.div = calendar._cache.cells[cell.i];

            var p = calendar._getCellProperties(x, y, gridName);
            cell.properties = p;

            return cell;
        };

        /* accepts findXy(0,0) or findXy([{x:0, y:0}, {x:0, y:1}]) */
        this.cells.findXy = function(x, y, gridName) {

            gridName = gridName || "main";

            if (DayPilot.isArray(x)) {
                var cells = [];
                for (var i = 0; i < x.length; i++) {
                    var o = x[i];
                    cells.push(calendar.cells._cell(o.x, o.y, gridName));
                }
                return cellArray(cells);
            }
            else if (x === null || y === null) {
                return cellArray(); // empty
            }
            var cell = calendar.cells._cell(x, y, gridName);
            return cellArray(cell);
        };

        this._cellFindByStartRes = function(start, resource) {

            var row;
            if (resource instanceof DayPilot.Row) {
                row = resource.$.row;
            }
            else if (resource.isRow) {
                row = resource;
            }
            else {
                row = calendar._findRowByResourceId(resource);
            }

            if (!row) {
                return null;
            }

            if (!calendar.itline || calendar.itline.length === 0) {
                return null;
            }

            var offset = row.start.getTime() - calendar._visibleStart().getTime();
            var refStart = new DayPilot.Date(start).addTime(-offset);

            var pixels = calendar.getPixels(refStart);
            if (!pixels) {
                return null;
            }

            if (pixels.i === null) {
                return null;
            }

            var result = {};
            result.x = pixels.i;
            result.y = row.index;
            result.grid = row.grid;

            return result;
        };

        this._cellArray = function(a) {
            var list = createList();

            if (DayPilot.isArray(a)) {
                for (var i = 0; i < a.length; i++) {
                    list.push(a[i]);
                }
            }
            else if (typeof a === 'object' && a) {
                list.push(a);
            }

            list.cssClass = function(css) {
                this.forEach(function(item) {
                    item.properties.cssClass = DayPilot.Util.addClassToString(item.properties.cssClass, css);
                    item.update();
                });
                return this;
            };

            list.removeClass = function(css) {
                this.forEach(function(item) {
                    item.properties.cssClass = DayPilot.Util.removeClassFromString(item.properties.cssClass, css);
                    item.update();
                });
                return this;
            };

            list.addClass = list.cssClass;

            list.html = function(html) {
                this.forEach(function(item) {
                    item.properties.html = html;
                    item.update();
                });
                return this;
            };

            list.invalidate = function() {
                this.forEach(function(item) {
                    delete calendar._bcrCache[item.i];
                });

                return this;
            };

            return list;
        };

        var cellArray = this._cellArray;

        // AngularJS
        this._angular = {};
        this._angular.scope = null;
        this._angular.notify = function(f) {
            if (calendar._angular.scope) {
                DayPilot.Util.safeApply(calendar._angular.scope, f);
                //calendar._angular.scope["$apply"](f);
            }
        };

        this.debug = new DayPilot.Debug(this);

        this._getRowStartInDaysView = function(date) {
            if (calendar.viewType !== 'Days') {
                throw new DayPilot.Exception("Checking row start when viewType !== 'Days'");
            }
            if (date.getTime() < calendar.visibleStart().getTime()) {
                return calendar.visibleStart();
            }
            for (var i = 0; i < calendar.rowlist.length; i++) {
                var row = calendar.rowlist[i];
                var data = row.element ? row.element.data : row.data;
                var start = data.start;
                if (date.getTime() >= start.getTime() && date.getTime() < start.addDays(1).getTime()) {
                    return start;
                }
            }
            return null;
        };

        this._getBoxStart = function(date) {

            var start = calendar._visibleStart();

            if (date.ticks === start.ticks) {
                return date;
            }

            var cursor = start;

            if (date.ticks < start.ticks) {
                var firstCellDuration = this.itline[0].end.ticks - this.itline[0].start.ticks;
                while (cursor.ticks > date.ticks) {
                    cursor = cursor.addTime(-firstCellDuration);
                }
                return cursor;
            }

            if (calendar.viewType === 'Days') {
                // already adjusted
                // var rowStart = this._getRowStartInDaysView(date);
                // var offset = rowStart.getTime() - calendar._visibleStart().getTime();
                var offset = 0;

                var cell = this._getItlineCellFromTime(date.addTime(-offset));
                if (cell.current) {
                    return cell.current.start.addTime(offset);
                }
                if (cell.past) {
                    return cell.previous.end.addTime(offset);
                }
                throw new DayPilot.Exception("getBoxStart(): time not found");

            }
            else {
                var cell = this._getItlineCellFromTime(date);
                if (cell.current) {
                    return cell.current.start;
                }
                if (cell.past) {
                    return cell.previous.end;
                }
                if (cell.hidden) {
                    var diff = cell.next.start.getTime() - date.getTime();
                    var cellduration = cell.next.end.getTime() - cell.next.start.getTime();
                    var rounded = Math.ceil(diff / cellduration) * cellduration;
                    var result = cell.next.start.addTime(-rounded);
                    return result;
                }
                throw new DayPilot.Exception("getBoxStart(): time not found");
            }
        };

        this._getShadowCoords = function(e) {

            // get row
            var row = this._getRow(calendar.coords.y, calendar.coords.grid);

            var limitManualBeyond = calendar.scaleManualLimitBeyond;

            if (typeof e.end !== 'function') {
                throw new DayPilot.Exception("e.end function is not defined");
            }
            if (!e.end()) {
                throw new DayPilot.Exception("e.end() returns null");
            }
            var duration = DayPilot.DateUtil.diff(e.rawend(), e.start());
            duration = atLeast(duration, 1);

            var useBox = resolved._useBox(duration);

            var isMilestone = e.data && e.data.type === "Milestone";
            var milestoneWidth = calendar.eventHeight;

            //var day = e.start().getDatePart();
            var startOffsetTime = 0;

            var x = calendar.coords.x;
            if (isMilestone) {
                x += milestoneWidth/2;
            }

            if (limitManualBeyond && calendar.scale === "Manual" && !calendar.eventMoveSkipNonBusiness) {
                var minusDurationPx = (function() {
                    var end = calendar.getDate(calendar.coords.x, true, true);
                    var start = end.addTime(-duration);

                    var startPix = calendar.getPixels(start).boxLeft;
                    var endPix = calendar.getPixels(end).boxRight;

                    var end = Math.min(endPix, calendar.coords.x);

                    return end - startPix;
                })();

                var offset = Math.min(DayPilotScheduler._moveOffsetX ? DayPilotScheduler._moveOffsetX : 0, minusDurationPx);

                x = calendar.coords.x - offset;
            }

            var srccal = DayPilotScheduler._movingEvent ? DayPilotScheduler._movingEvent.calendar : calendar;

            var rowOffset = 0;
            //var useCustomRowStart = this.viewType === 'Days' || this._rowsWithCustomStart();
            var useCustomRowStart = this.viewType === 'Days' || this._rowsWithCustomStart();
            var sameSource = !e.part.external && srccal === calendar;
            if (useCustomRowStart && sameSource) {
                rowOffset = this.rowlist[e.part.dayIndex].start.getTime() - this._visibleStart().getTime();
            }

            if (useBox && !isMilestone && srccal === calendar) {
                //startOffsetTime = e.start().getTime() - (day.getTime() + Math.floor((e.start().getHours() * 60 + e.start().getMinutes()) / calendar.cellDuration) * calendar.cellDuration * 60 * 1000);

                var cell = calendar._getItlineCellFromTime(e.start());
                var startInTimeline = !cell.hidden && !cell.past;

                startOffsetTime = e.start().getTime() - this._getBoxStart(e.start().addTime(-rowOffset)).addTime(rowOffset).getTime();

                if (startInTimeline) {
                    startOffsetTime = (function(originalTime, offset) {
                        var oticks = calendar._getCellTicks(calendar._getItlineCellFromTime(originalTime).current);
                        var nticks = calendar._getCellTicks(calendar._getItlineCellFromPixels(x).cell);

                        if (oticks > nticks * 1.2) { // normally one would be fine but avoid month issues when moving to shorter month (28 vs 31 days)
                            var sign = offset > 0 ? 1 : -1;
                            var offset = Math.abs(offset);
                            while (offset >= nticks) {
                                offset -= nticks;
                            }
                            offset *= sign;
                        }
                        return offset;
                    })(e.start(), startOffsetTime);
                }
            }

            if (srccal && srccal !== calendar) {
                if (srccal._getCellDuration() !== calendar._getCellDuration()) {
                    startOffsetTime = 0;
                }
            }

            var dragOffsetTime = 0;

            // this keeps the cell offset the same after moving
            if (DayPilotScheduler._moveDragStart && (calendar.scale !== "Manual" || !limitManualBeyond) && srccal === calendar) {
                if (useBox) {
                    var estart = e.start().addTime(-rowOffset);
                    var boxStart = this._getBoxStart(estart);
                    dragOffsetTime = DayPilotScheduler._moveDragStart.getTime() - boxStart.getTime();
                    var cellDurationTicks = calendar._getCellDuration() * 60 * 1000;
                    dragOffsetTime = Math.floor(dragOffsetTime/cellDurationTicks) * cellDurationTicks;
                }
                else {
                    dragOffsetTime = DayPilotScheduler._moveDragStart.getTime() - e.start().addTime(-rowOffset).getTime();
                }
            }
            else { // external drag
                //dragOffsetTime = this.cellDuration * 60000 / 2; // half cell duration
                dragOffsetTime = 0; // half cell duration
            }

            if (this.eventMoveToPosition) {
                dragOffsetTime = 0;
            }
            if (isMilestone) {
                var startXMilestone =  calendar.getDate(x, true);
                var endXMilestone = calendar.getDate(x + milestoneWidth/2, true);
                var milestoneHalfTime = (endXMilestone.getTime() - startXMilestone.getTime())/2;

                dragOffsetTime = -milestoneHalfTime;
            }

            var start = this.getDate(x, true).addTime(-dragOffsetTime).addTime(rowOffset);

            if (DayPilotScheduler._resizing) {
                start = e.start();
            }

            var snapToGrid = calendar.snapToGrid;
            if (DayPilotScheduler._moving) {
                snapToGrid = snapToGrid && calendar.snapToGridEventMoving;
            }
            else if (DayPilotScheduler._resizing) {
                snapToGrid = snapToGrid && calendar.snapToGridEventResizing;
            }
            else if (DayPilotScheduler._range) {
                snapToGrid = snapToGrid && calendar.snapToGridTimeRangeSelecting;
            }

            if (snapToGrid) { // limitation: this blocks moving events before startDate
                start = this._getBoxStart(start.addTime(-rowOffset)).addTime(rowOffset);
            }

            start = start.addTime(startOffsetTime);
            var end = start.addTime(duration);

            var adjustedStart = start;
            var adjustedEnd = end;

            if (useCustomRowStart) {
                adjustedStart = start.addTime(-rowOffset);
                adjustedEnd = adjustedStart.addTime(duration);

                var currentRowOffset = row.element.data.start.getTime() - this._visibleStart().getTime();
                start = adjustedStart.addTime(currentRowOffset);
                end = start.addTime(duration);
            }


            if (limitManualBeyond && calendar.scale === "Manual") {
                var rowEnd = row.element._end();
                if (end > rowEnd) {
                    var beyondOffset = end.getTime() - rowEnd.getTime();
                    start = start.addTime(-beyondOffset);
                    end = end.addTime(-beyondOffset);
                }

                adjustedStart = start.addTime(-rowOffset);
                adjustedEnd = end.addTime(-rowOffset);
            }

            if (DayPilotScheduler._moving && calendar.eventMoveSkipNonBusiness) {
                var y = row.i;

                var mid = 0;
                if (DayPilotScheduler._moveDragStart) {
                    mid = DayPilotScheduler._moveDragStart.addTime(rowOffset);  // in row time
                    if (snapToGrid) { // limitation: this blocks moving events before startDate
                        mid = this._getBoxStart(mid.addTime(-rowOffset)).addTime(rowOffset);
                    }
                }

                var isExternal = !e.part.dayIndex;
                var before = 0;

                if (!isExternal) {
                    before = calendar._getBusinessDuration(e.start(), mid, e.part.dayIndex);
                }

                var duration = calendar._getEventDurationWithoutNonBusiness(e);

                var mouseTime = calendar.getDate(x, true);
                if (snapToGrid) {
                    mouseTime = calendar.getDate(x);
                }
                var offset = calendar._adjustBackwardOffsetForBusiness(mouseTime, before, y, row.grid);

                start = mouseTime.addTime(-offset).addTime(rowOffset);

                if (snapToGrid) { // limitation: this blocks moving events before startDate
                    start = this._getBoxStart(start.addTime(-rowOffset)).addTime(rowOffset);
                }

                if (!isExternal) {
                    startOffsetTime = calendar._getBusinessDuration(this._getBoxStart(e.start().addTime(-rowOffset)).addTime(rowOffset), e.start(), y, row.grid);
                }
                else {
                    startOffsetTime = 0;
                }

                start = start.addTime(startOffsetTime);
                if (start <= calendar.visibleStart()) {
                    start = calendar._getNextCell(calendar.visibleStart(), y, row.grid).start;
                }

                end = calendar._addBusinessDuration(start, duration, y, row.grid);

                if (end >= calendar.visibleEnd()) {
                    end = calendar._getPreviousCell(calendar.visibleEnd(), y, row.grid).end;
                    // start = end.addTime(-calendar._backwardOffsetInVisibleTimeline(end, duration, y));
                    start = end.addTime(-calendar._adjustBackwardOffsetForBusiness(end, duration, y));
                }

                adjustedStart = start.addTime(-rowOffset);
                adjustedEnd = end.addTime(-rowOffset);
            }


            var startPixels = this.getPixels(adjustedStart);
            var endPixels = this.getPixels(adjustedEnd);

/*
            var left = (useBox) ? startPixels.boxLeft : startPixels.left;
            var width = (useBox) ? (endPixels.boxRight - left) : (endPixels.left - left);
*/

            var left = (snapToGrid) ? startPixels.boxLeft : startPixels.left;
            // var width = (useBox) ? (endPixels.boxRight - left) : (endPixels.left - left);
            var width = (snapToGrid && useBox) ? (endPixels.boxRight - left) : (endPixels.left - left);


            if (isMilestone) {
                width = milestoneWidth;
                left -= width/2;
            }

            var coords = {};
            coords.top = row.top;
            coords.left = left;
            coords.row = row.element;
            coords.rowIndex = row.i;
            coords.grid = calendar.coords.grid;
            coords.width = width;
            coords.start = start;
            coords.end = end;
            coords.relativeY = calendar.coords.y - row.top;

            return coords;
        };

        this._hiddenTimeBetween = function(start, end) {
            var startX = calendar._getItlineCellFromTime(start);
            var endX = calendar._getItlineCellFromTime(end);
            var previousEnd = null;
            var hiddenticks = 0;
            if (startX.hidden) {
                previousEnd = start;
            }
            for (var x = startX.i; x <= endX.i; x++) {
                var cell = calendar.itline[x];
                if (previousEnd && previousEnd < cell.start) {
                    hiddenticks += cell.start.getTime() - previousEnd.getTime();
                }
                previousEnd = cell.end;
            }
            return hiddenticks;
        };

        // freeze ok
        this._addBusinessDuration = function(start, duration, y, gridName) {
            gridName = gridName || "main";
            var remains = duration;
            var row = calendar.rowlist[y];
            var rowOffset = row.data.start.getTime() - calendar._visibleStart().getTime();
            var adjustedStart = start.addTime(-rowOffset);

            var nextCell = calendar._getNextCell(adjustedStart, y, gridName);
            if (!nextCell) {
                throw new DayPilot.Exception("No next cell found");
            }

            var x = indexOf(calendar.itline, nextCell);
            if (nextCell.start > start) {
                //start = nextCell.start;
                //adjustedStart = start.addTime(-rowOffset);
            }
            else {
                remains -= nextCell.end.getTime() - adjustedStart.getTime();
                if (remains <= 0) {
                    return start.addTime(duration);
                }
                x += 1;
            }

            for (var i = x; i < calendar.itline.length; i++) {
                var cell = calendar._getCellProperties(i, y, gridName);
                var itc = calendar.itline[i];

                if (cell.business) {
                    var cellStart = itc.start.addTime(rowOffset);
                    var cellEnd = itc.end.addTime(rowOffset);
                    var cellDuration = cellEnd.getTime() - cellStart.getTime();

                    if (remains <= cellDuration) {
                        return cellStart.addTime(remains);
                    }

                    remains -= cellDuration;
                }
            }

            // event stretches beyond itline, assume all time is working time
            /*if (!cellStart) {
                cellStart = calendar.itline[calendar.itline.length - 1].end;
            }
            return cellStart.addTime(remains);*/
            return calendar.itline[calendar.itline.length - 1].end.addTime(remains);
        };

        // freeze ok
        this._getBusinessDuration = function(start, end, y, gridName) {

            gridName = gridName || "main";

            var grid = calendar._gridInfo(gridName);
            var rowlist = grid.rowlist;

            var row = rowlist[y];
            var rowOffset = row.data.start.getTime() - calendar._visibleStart().getTime();

            var cell = calendar._getItlineCellFromTime(start);

            var adjustedStart = start.addTime(-rowOffset);
            var adjustedEnd = end.addTime(-rowOffset);

            var nextCell = calendar._getNextCell(adjustedStart, y, gridName);
            if (!nextCell) {
                throw new DayPilot.Exception("No next cell found");
            }

            var duration = 0;

            var x = indexOf(calendar.itline, nextCell);
            if (nextCell.start <= adjustedEnd) {
                if (end < nextCell.end.addTime(rowOffset)) {
                    if (nextCell.start > adjustedStart) {
                        return end.getTime() - nextCell.start.addTime(rowOffset).getTime();
                    }
                    else {
                        return end.getTime() - start.getTime();
                    }
                }
                if (adjustedStart > nextCell.start) {
                    duration += nextCell.end.getTime() - adjustedStart.getTime();
                }
                else {
                    duration += nextCell.end.getTime() - nextCell.start.getTime();
                }
                x += 1;
            }

            for (var i = x; i < calendar.itline.length; i++) {
                var cell = calendar._getCellProperties(i, y, gridName);
                if (cell.business) {
                    var itc = calendar.itline[i];
                    var cellStart = itc.start.addTime(rowOffset);
                    var cellEnd = itc.end.addTime(rowOffset);
                    var cellDuration = cellEnd.getTime() - cellStart.getTime();

                    if (end < cellStart) {
                        return duration;
                    }
                    if (end <= cellEnd) {
                        duration += end.getTime() - cellStart.getTime();
                        return duration;
                    }

                    duration += cellDuration;

                }
            }

            var remainder = end.getTime() - calendar.itline.last().end.addTime(rowOffset).getTime();
            duration += atLeast(0, remainder);

            return duration;

        };

        this._getEventDurationWithoutNonBusiness = function(e) {
            if (e.part.duration) {
                if (isNaN(e.part.duration)) {
                    throw new DayPilot.Exception("Unable to get calculated duration");
                }
                return e.part.duration;
            }
            var y = e.part.dayIndex;
            return calendar._getBusinessDuration(e.start(), e.rawend(), y);
        };


        // freeze ok
        this._adjustBackwardOffsetForBusiness = function(start, offset, y, gridName) {
            gridName = gridName || "main";
            var result = 0;
            var remains = offset;

            var cell = calendar._getItlineCellFromTime(start);
            if (!cell.current) {
                throw new DayPilot.Exception("Current cell not found.");
            }
            var x = indexOf(calendar.itline, cell.current);

            if (calendar._getCellProperties(x, y, gridName).business) {
                if (start.addTime(-offset) >= cell.current.start) {
                    return offset;
                }
            }
            else {
                // first cell
                if (offset === 0 || start.addTime(-offset) >= cell.current.start) {
                    var next = calendar._getNextCell(start, y, gridName);
                    if (next) {
                        return start.getTime() - next.start.getTime();
                    }
                    else {
                        var previous = calendar._getPreviousCell(start, y, gridName);
                        return start.getTime() - previous.start.getTime();
                    }
                }
            }

            result += start.getTime() - cell.current.start.getTime();
            remains -= start.getTime() - cell.current.start.getTime();

            x -= 1;

            var previousStart = cell.current.start;

            while (x >= 0) {
                var cell = calendar.itline[x];

                if (previousStart > cell.end) {
                    result += previousStart.getTime() - cell.end.getTime();
                }
                previousStart = cell.start;

                var cellDuration = cell.end.getTime() - cell.start.getTime();

                if (calendar._getCellProperties(x, y, gridName).business) {
                    if (remains <= cellDuration) {
                        result += remains;
                        return result;
                    }

                    result += cellDuration;
                    remains -= cellDuration;
                }
                else {
                    result += cellDuration;
                }

                x -= 1;
            }

            return result + remains;
            //throw new DayPilot.Exception("Unable to calculate backward offset in visible timeline");
        };

        // freeze ok
        this._getPreviousCell = function(time, y, gridName) {
            gridName = gridName || "main";
            var cell = calendar._getItlineCellFromTime(time);
            var i = 0;

            if (cell.past) {  // invalid
                return null;
            }

            if (cell.current) {
                i =  cell.i;
            }
            else if (cell.previous) {
                i = indexOf(calendar.itline, cell.previous);
            }
            else {
                return null; // invalid
            }

            // now we have at least one cell to test
            for (var x = i; x >= 0; x--) {
                var isWorking = calendar._isBusinessCell(x, y, gridName);
                if (isWorking) {
                    return calendar.itline[x];
                }
            }

            return null;

        };

        // freeze ok
        this._getNextCell = function(time, y, gridName) {
            gridName = gridName || "main";
            var cell = calendar._getItlineCellFromTime(time);
            var i = 0;

            if (cell.past) {  // invalid
                return null;
            }

            if (cell.current) {
                i =  cell.i;
            }
            else if (cell.next) {
                i = indexOf(calendar.itline, cell.next);
            }
            else {
                return null; // invalid
            }

            // now we have at least one cell to test
            for (var x = i; x < calendar.itline.length; x++) {
                var isWorking = calendar._isBusinessCell(x, y, gridName);
                if (isWorking) {
                    return calendar.itline[x];
                }
            }

            return null;

        };

        // freeze ok
        this._isBusinessCell = function(x, y, gridName) {
            gridName = gridName || "main";
            var props = calendar._getCellProperties(x, y, gridName);
            return props.business;
        };

        this._getCellDuration = function() {  // approximate, needs to be updated for a specific time (used only for rounding in getShadowCoords
            switch (this.scale) {
                case "CellDuration":
                    return this.cellDuration;
                case "Minute":
                    return 1;
                case "Hour":
                    return 60;
                case "Day":
                    return 60*24;
                case "Week":
                    return 60*24*7;
                case "Month":
                    return 60*24*30;
                case "Year":
                    return 60*24*365;
                case "Manual":
                    if (calendar.itline.length > 0) {
                        var cell = calendar.itline[0];
                        return (cell.end.getTime() - cell.start.getTime()) / (60 * 1000);
                    }
                    else {
                        return calendar.cellDuration;
                    }

            }
            throw new DayPilot.Exception("can't guess cellDuration value");
        };

        this._getCellTicks = function(itc) {
            return itc.end.ticks - itc.start.ticks;
        };

        this._isRowDisabled = function(y, gridName) {
            gridName = gridName || "main";

            if (gridName === "main" && this.treePreventParentUsage && this._isRowParent(y, gridName)) {
                return true;
            }
            if (this._preventRowUsage(y, gridName)) {
                return true;
            }

            return false;
        };

        this._isRowParent = function(y, gridName) {
            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            var row = rowlist[y];
            if (row.isParent) {
                return true;
            }
            if (this.treeEnabled) {
                if (row.children && row.children.length > 0) {
                    return true;
                }
            }
            return false;
        };

        this._preventRowUsage = function(y, gridName) {
            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            var row = rowlist[y];
            if (row.isNewRow) {
                return true;
            }
            if (row.resource.preventUsage) {
                return true;
            }
            return false;
        }

        this._autoexpand = {};
        this._expandParent = function() {

            if (!calendar.treeAutoExpand) {
                return;
            }

            var coords = this._getShadowCoords(DayPilotScheduler._movingEvent);
            var y = coords.rowIndex;
            var isParent = this._isRowParent(y);

            var expand = this._autoexpand;

            if (expand.timeout && expand.y !== y) {
                clearTimeout(expand.timeout);
                expand.timeout = null;
                expand.y = null;
            }

            if (isParent) {
                expand.y = y;
                var collapsed = !calendar.rowlist[expand.y].expanded;
                if (!expand.timeout && collapsed) {
                    expand.timeout = setTimeout(function() {
                        var collapsed = !calendar.rowlist[expand.y].expanded;
                        if (collapsed) {
                            calendar._toggle(expand.y, {"notAnimated": true});
                            calendar._moveShadow();
                        }
                        expand.timeout = null;
                        expand.y = null;
                    }, 500);
                }
            }
        };

        this._cancelAutoexpand = function() {
            clearTimeout(calendar._autoexpand.timeout);
            calendar._autoexpand.timeout = null;
            calendar._autoexpand.y = null;
        };


        this._updateResizingShadow = function() {
            var shadowWidth = DayPilotScheduler._resizingShadow.width;
            var shadowLeft = DayPilotScheduler._resizingShadow.left;
            var e = DayPilotScheduler._resizingEvent;
            var border = DayPilotScheduler._resizing.dpBorder;

            // TODO involve rowStart for Days mode
            var row = calendar.rowlist[e.part.dayIndex];
            var rowOffset = 0;

            rowOffset = row.start.getTime() - calendar._visibleStart().getTime();

            var newStart = null;
            var newEnd = null;

            var snapToGrid = calendar.snapToGrid && calendar.snapToGridEventResizing;
            var exact = !snapToGrid;

            if (border === 'left') {
                newStart = calendar.getDate(shadowLeft, exact).addTime(rowOffset);
                newEnd = e.rawend();
            }
            else if (border === 'right') {
                newStart = e.start();
                newEnd = calendar.getDate(shadowLeft + shadowWidth, exact, true).addTime(rowOffset);
            }

            DayPilotScheduler._resizingShadow.start = newStart;
            DayPilotScheduler._resizingShadow.end = newEnd;

        };

        this.exportAs = function(format, options) {
            if (!calendar._visible()) {
                throw new DayPilot.Exception("DayPilot.Scheduler.exportAs(): The instance must be visible during export.");
            }
            var board = img.generate(format, options);
            return new DayPilot.Export(board);
        };

        this["export"] = this.exportAs;

        this._img = {};
        var img = this._img;

        img._getWidth = function() {
            var mode = img._mode;

            switch (mode) {
                case "viewport":
                    return calendar.nav.top.offsetWidth;
                case "full":
                    return calendar._getGridWidth() + img.getRowHeaderWidth();
                case "range":
                    return calendar.getPixels(img.getRangeEnd()).boxRight - calendar.getPixels(img.getRangeStart()).boxLeft + img.getRowHeaderWidth();
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img._getHeight = function() {
            var mode = img._mode;

            switch (mode) {
                case "viewport":
                    return calendar.nav.top.offsetHeight - DayPilot.sh(calendar.nav.scroll) - 1;
                case "full":
                    return calendar._getScrollableInnerHeight() + calendar._getTotalHeaderHeight() - DayPilot.sh(calendar.nav.scroll);
                case "range":
                    var rows = img.getRows();
                    if (rows.length === 0) {
                        return calendar._getTotalHeaderHeight();
                    }
                    else {
                        var from = rows.first();
                        var to = rows.last();
                        // return to.top - from.top + to.height + calendar._getTotalHeaderHeight();
                        var height = img._rowTop(to) - img._rowTop(from) + to.height + calendar._getTotalHeaderHeight();
                        height += calendar._grids.top.height;
                        height += calendar._grids.bottom.height;
                        return height;
                    }
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img._rowTop = function(row) {
            var top = img._options.includeHiddenRows ? row.absTop : row.top;
            if (row.grid === "bottom") {
                if (img._mode === "viewport") {
                    top += calendar._grids.bottom.top - calendar._getTotalHeaderHeight();
                }
                else if (img._mode === "full") {
                    top += calendar._innerHeightTree;
                }
                else if (img._mode === "range") {
                    top += img._getHeight() - calendar._getTotalHeaderHeight() - calendar._grids.bottom.height;

                }
            }
            return top;
        };

        img._rowOffset = function(row) {
            var offset = img.getViewportOffsetTop();
            if (row.grid !== "main") {
                offset = 0;
            }
            return offset;
        };

        img.getRangeStart = function() {
            var from = img._options.dateFrom || calendar._visibleStart();
            return new DayPilot.Date(from);
        };

        img.getRangeEnd = function() {
            var to = img._options.dateTo || calendar._visibleEnd();
            return new DayPilot.Date(to);
        };

        img.getRangeResStart = function() {
            if (!img._options.resourceFrom) {
                return calendar.rowlist.find(function(row) { return !row.hidden});
                //return calendar.rowlist[0];
            }
            return calendar._findRowByResourceId(img._options.resourceFrom);
        };

        img.getRangeResEnd = function() {
            if (!img._options.resourceTo) {
                return calendar.rowlist.last();
            }
            return calendar._findRowByResourceId(img._options.resourceTo);
        };

        img.getRowHeaderWidth = function() {
            return calendar._getOuterRowHeaderWidth();
        };

        img.getTimeHeaderHeight = function() {
            return calendar._getTotalHeaderHeight();
        };

        img.getCanvas = function() {
            return img.canvas();
        };

        img.getRectangles = function() {
            var rowHeaderWidth = img.getRowHeaderWidth();
            var timeHeaderHeight = img.getTimeHeaderHeight();

            var rectangles = {};
            rectangles.main = {"x": 0, "y": 0, "w": img._getWidth(), "h": img._getHeight()};
            rectangles.corner = {"x": 0, "y": 0, "w": rowHeaderWidth, "h": timeHeaderHeight};
            rectangles.grid = {"x": rowHeaderWidth, "y": timeHeaderHeight, "w": img._getWidth() - rowHeaderWidth, "h": img._getHeight() - timeHeaderHeight};

            var width = rectangles.grid.w;
            var lastTimeHeader = calendar.itline.last();
            if (lastTimeHeader && (lastTimeHeader.left + lastTimeHeader.width) < rectangles.grid.w) {
                width = lastTimeHeader.left + lastTimeHeader.width;
            }

            var height = rectangles.grid.h;
            var lastRow = calendar.rowlist.last();
            if (lastRow && (lastRow.top + lastRow.height) < rectangles.grid.h) {
                height = lastRow.top + lastRow.height;
            }

            rectangles.gridContent = {"x": rowHeaderWidth, "y": timeHeaderHeight, "w": width, "h": height};

            return rectangles;
        };

        img.getRows = function() {
            var mode = img._mode;
            var result = createList();

            var top, bottom, cellTop, cellBottom;

            switch (mode) {
                case "viewport":
                    top = calendar._scrollTop;
                    bottom = top + calendar.nav.scroll.offsetHeight;
                    cellTop = calendar._getRow(top).i;
                    cellBottom = calendar._getRow(bottom).i;
                    break;
                case "full":
                    top = 0;
                    cellTop = 0;
                    cellBottom = calendar.rowlist.length;
                    break;
                case "range":

                    var from = img.getRangeResStart();
                    var to = img.getRangeResEnd();
                    if (!from) {
                        throw new DayPilot.Exception("Resource specified using resourceFrom option not found during export.");
                    }
                    if (!to) {
                        throw new DayPilot.Exception("Resource specified using resourceTo option not found during export.");
                    }

                    cellTop = from.index;
                    cellBottom = to.index;
                    break;
            }

            if (cellBottom < calendar.rowlist.length) {
                cellBottom += 1;
            }

            // var push = 0;
            for (var y = cellTop; y < cellBottom; y++) {
                var row = calendar.rowlist[y];

                if (!img._options.includeHiddenRows && row.hidden) {
                    continue;
                }

                result.push(row);
            }

            result.offset = cellTop;

            return result;

        };

        img.getRowsTop = function() {
            return calendar._grids.top.rowlist;
        };

        img.getRowsBottom = function() {
            return calendar._grids.bottom.rowlist;
        };

        img.getRowsAll = function() {
            var rows = img.getRows();
            rows = rows.concat(img.getRowsTop());
            rows = rows.concat(img.getRowsBottom());
            return rows;
        };

        img.getRowsTopAndBottom = function() {
            var rows = [];
            rows = rows.concat(img.getRowsTop());
            rows = rows.concat(img.getRowsBottom());
            return rows;
        };

        img.bottomFrozenY = function() {
            if (calendar._grids.bottom.enabled()) {
                if (img._mode === "viewport") {
                    return calendar._grids.bottom.top;
                }
                else if (img._mode === "full") {
                    return img._getHeight() - calendar._grids.bottom.height;
                }
                else if (img._mode === "range") {
                    return img._getHeight() - calendar._grids.bottom.height;
                }
            }
            return img._getHeight();
        };

        img.getEvents = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    var all = createList();
                    createList(calendar.rowlist).forEach(function(row) {
                        if (row.hidden) {
                            return;
                        }
                        createList(row.events).forEach(function(e) {
                            all.push(e);
                        });
                    });
                    return all;
                case "viewport":
                    return viewport._events().filter(function(div) { return div.event.part.grid === "main"; }).map(function(div) { return div.event; });
                case "range":
                    var all = createList();
                    var start = img.getRangeStart();
                    var end = img.getRangeEnd();

                    img.getRows().forEach(function(row) {
                        createList(row.events).filter(function(item) { return overlaps(item.start(), item.end(), start, end) }).forEach(function(e) {
                            all.push(e);
                        });
                    });
                    return all;
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img.getEventsFrozen = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    var all = createList();
                    var rows = img.getRowsTopAndBottom();
                    rows.forEach(function(row) {
                        if (row.hidden) {
                            return;
                        }
                        createList(row.events).forEach(function(e) {
                            all.push(e);
                        });
                    });
                    return all;
                case "viewport":
                    return viewport._events().filter(function(div) { return div.event.part.grid !== "main"; }).map(function(div) { return div.event; });
                case "range":
                    var all = createList();
                    var start = img.getRangeStart();
                    var end = img.getRangeEnd();

                    img.getRowsTopAndBottom().forEach(function(row) {
                        createList(row.events).filter(function(item) { return overlaps(item.start(), item.end(), start, end) }).forEach(function(e) {
                            all.push(e);
                        });
                    });
                    return all;
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img.getLinks = function() {
            if (!DayPilot.isArray(calendar.links.list)) {
                return;
            }
            var paths = [];
            for (var i = 0; i < calendar.links.list.length; i++) {
                var link = calendar.links.list[i];

                var fromE = calendar.events.find(link.from);
                var start = calendar.events._findEventInRows(fromE && fromE.data);

                var toE = calendar.events.find(link.to);
                var end = calendar.events._findEventInRows(toE && toE.data);

                var path = linktools._getSegments(start, end, link, img._options.includeHiddenRows);

                if (path) {
                    paths.push(path);
                }
            }

            return paths;
        };

        img.getTimeline = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    return createList(calendar.itline).addProps({"offset":0});
                case "viewport":
                    return img.getViewportTimeline();
                case "range":
                    return img.getRangeTimeline();
                default:
                    throw new DayPilot.Exception("Unsupported export mode: " + mode);
            }
        };

        img.getRangeTimeline = function() {
            var result = createList();
            if (calendar.itline && calendar.itline.length > 0) {

                var start = calendar._getItlineCellFromTime(img.getRangeStart()).i;
                var end = calendar._getItlineCellFromTime(img.getRangeEnd()).i;

                var totalWidth = calendar._cellCount();
                end = Math.min(end, totalWidth - 1); // make sure it's within the boundaries
                start = atLeast(start, 0); // check the left side

                for (var x = start; x <= end; x++) {
                    var cell = calendar.itline[x];
                    result.push(cell);
                }
                result.offset = start;
            }
            return result;
        };

        img.getViewportTimeline = function() {
            var result = createList();
            if (calendar.itline && calendar.itline.length > 0) {
                var left = calendar._scrollPos;
                var right = left + calendar.nav.scroll.offsetWidth;

                var start = calendar._getItlineCellFromPixels(left).x;
                var end = calendar._getItlineCellFromPixels(right, true).x;
                var totalWidth = calendar._cellCount();
                end = Math.min(end, totalWidth); // make sure it's within the boundaries
                start = atLeast(start, 0); // check the left side

                for (var x = start; x <= end; x++) {
                    var cell = calendar.itline[x];
                    result.push(cell);
                }
                result.offset = start;
            }
            return result;
        };

        img.getTimeHeader = function(y) {
            var mode = img._mode;

            if (mode === "full") {
                return createList(calendar.timeHeader[y]);
            }
            else {
                var result = createList();

                var viewportOffsetStart, viewportOffsetEnd;

                viewportOffsetStart = img.getViewportOffsetStart();
                viewportOffsetEnd = viewportOffsetStart + img.getViewportOffsetWidth();

                var startCell = calendar._getTimeHeaderCellForY(y, viewportOffsetStart);
                var endCell = calendar._getTimeHeaderCellForY(y, viewportOffsetEnd);
                if (!endCell) {
                    endCell = {"x": calendar.timeHeader[y].length - 1};
                }
                for (var x = startCell.x; x <= endCell.x; x++) {
                    var cell = calendar.timeHeader[y][x];

                    result.push(cell);
                }

                return result;
            }
        };

        img.getSeparators = function() {
            return createList(calendar.separators)
                .map(function(sep) {
                    var time = new DayPilot.Date(sep.location);

                    // check the start and end dates of the visible area
                    if (time.getTime() < calendar._visibleStart().getTime()) {
                        return null;
                    }
                    if (time.getTime() >= calendar._visibleEnd().getTime()) {
                        return null;
                    }

                    var pixels = calendar.getPixels(time);

                    // check if it's in the hidden area, don't show in that case
                    if (pixels.cut) {
                        return null;
                    }

                    if (pixels.left < 0) {
                        return null;
                    }
                    if (pixels.left > calendar._getGridWidth()) {
                        return null;
                    }

                    return {
                        "left": pixels.left,
                        "color": sep.color,
                        "width": sep.width || 1
                    };
                })
                .filter(function(sep) {
                    return !!sep;
                });
        };

        img.fakeDurationBar = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass(cssNames.event);

            var bar = createDiv();
            bar.className = calendar._prefixCssClass(cssNames.eventBar);

            var inner = createDiv();
            inner.className = calendar._prefixCssClass(cssNames.eventBarInner);

            body().appendChild(div);

            bar.appendChild(inner);
            div.appendChild(bar);
            return div;
        };

        img.fakeEventLeft = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_event_left");

            body().appendChild(div);

            return div;
        };

        img.fakeGroup = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass(cssNames.event) + " " + calendar._prefixCssClass("_task_group");

            var inner = createDiv();
            inner.className = calendar._prefixCssClass(cssNames.eventInner);

            div.appendChild(inner);

            calendar.divEvents.appendChild(div);
            return div;
        };

        img.fakeMilestone = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass(cssNames.event) + " " + calendar._prefixCssClass("_task_milestone");

            var inner = createDiv();
            inner.className = calendar._prefixCssClass(cssNames.eventInner);

            div.appendChild(inner);

            calendar.divEvents.appendChild(div);
            return div;
        };

        img.fakeCell = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_cell");

            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_cell_inner");
            div.appendChild(inner);

            calendar.divCells.appendChild(div);

            return div;
        };

        img.fakeRowHeader = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_rowheader");

            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_rowheader_inner");
            div.appendChild(inner);

            calendar.divResScroll.appendChild(div);

            return div;
        };

        img._fakeCorner = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass("_corner");

            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";

            var inner = createDiv();
            inner.className = calendar._prefixCssClass("_corner_inner");
            div.appendChild(inner);

            calendar.nav.top.appendChild(div);

            return div;
        };


        img.fakeExpand = function() {
            var div = createDiv();
            div.style.display = "none";
            div.className = calendar._prefixCssClass('_tree_image_expand');

            body().appendChild(div);
            return div;
        };

        img.fakeIcon = function(cssClass) {
            var div = document.createElement("i");
            div.className = cssClass;

            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";

            return div;
        };


        img.extractUrl = function(str) {
            // both or no quotes: /url\((")?([^"].*[^"])\1\)/    read array[2]
            // quotes required: /url\("(.*)"\)/                  read array[1]
            var array = /url\((")?([^"].*[^"])\1\)/.exec(str);
            if (!array) {
                return null;
            }
            return array[2];
        };

        img.getImages = function() {
            var result = {};

            var node = img.fakeExpand();

            result.expand = img.extractUrl(new DayPilot.StyleReader(node).get("background-image"));

            node.className = calendar._prefixCssClass("_tree_image_collapse");
            result.collapse = img.extractUrl(new DayPilot.StyleReader(node).get("background-image"));

            node.className = calendar._prefixCssClass("_tree_image_no_children");
            result.nochildren = img.extractUrl(new DayPilot.StyleReader(node).get("background-image"));

            deleteElement(node);

            return result;
        };

        img.getFont = function(element) {
            return new DayPilot.StyleReader(element).getFont();
        };

        img.getViewportOffsetStart = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    return 0;
                case "viewport":
                    return calendar.nav.scroll.scrollLeft;
                case "range":
                    return calendar.getPixels(img.getRangeStart()).boxLeft;
            }
        };

        img.getViewportOffsetTop = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    return 0;
                case "viewport":
                    return calendar.nav.scroll.scrollTop;
                case "range":
                    return img._rowTop(img.getRangeResStart()) - calendar._grids.top.height;
            }
        };

        img.getViewportOffsetWidth = function() {
            var mode = img._mode;
            switch (mode) {
                case "full":
                    return calendar._getGridWidth();
                case "viewport":
                    return calendar.nav.scroll.offsetWidth;
                case "range":
                    return calendar.getPixels(img.getRangeEnd()).boxRight - img.getViewportOffsetStart();
            }
        };

        img.excelBoard = function() {
            var excel = new DayPilot.Excel();
            var sheet = excel.worksheets.create("Scheduler");

            // duplicate
            var cornerBackground = new DayPilot.StyleReader(calendar.nav.corner).get("background-color");
            var borderColor = new DayPilot.StyleReader(calendar.nav.top).get("border-top-color");

            // doesn't work if no event is rendered
            var divSampleEvent = createList(calendar.elements.events).filter(function(div) { return !div.event.data.type;}).map(function(item) {return item.firstChild;}).last();
            var eventBorderColor = new DayPilot.StyleReader(divSampleEvent).get("border-right-color");

            excel.styles.getDefault().setBackColor("#ffaaaa");

            var styleTimeHeader = excel.styles.create();
            styleTimeHeader.setHorizontalAlignment("Center");
            styleTimeHeader.setBackColor(cornerBackground);
            styleTimeHeader.setBorderColor(borderColor);

            var styleRowHeader = excel.styles.create();
            styleRowHeader.setVerticalAlignment("Top");
            styleRowHeader.setBackColor(cornerBackground);
            styleRowHeader.setBorderColor(borderColor);

            var styleEvent = excel.styles.create();
            styleEvent.setVerticalAlignment("Top");
            styleEvent.setBackColor("#ff0000");
            styleEvent.setBorderColor(eventBorderColor);

            sheet.enableGridlines(false);

            // corner
            sheet.cell(0, 0).setRowspan(calendar.timeHeader.length).setStyle(styleTimeHeader);

            sheet.cell(10, 10).setText("hi there");

            // time header
            createList(calendar.timeHeader).forEach(function(item, y) {
                var offset = {
                    "x": 1,
                    "y": 0
                };
                //var startX = 1;
                img.getTimeHeader(y, "full").forEach(function(cell, x) {
                    var colspan = cell.colspan;
                    sheet.cell(x + offset.x, y + offset.y).setText(cell.innerHTML).setColspan(colspan).setStyle(styleTimeHeader);
                    //startX += colspan;
                });
            });

            // resources
            createList(calendar.rowlist).forEach(function(row, y) {
                var offset = {
                    "x": 0,
                    "y": 1  // corner is merged
                };
                var prefix = "";
                for (var i = 0; i < row.level; i++) {
                    prefix += "  ";
                }
                sheet.cell(offset.x, y + offset.y).setText(prefix + row.html).setRowspan(row.lines.length).setStyle(styleRowHeader);
            });

            // events
            var offset = {
                "x": 0,
                "y": calendar.timeHeader.length  // corner is merged
            };
            var offsetY = offset.y;
            createList(calendar.rowlist).forEach(function(row, y) {
                createList(row.lines).forEach(function(line, i) {
                    var offsetX = offset.x;
                    createList(line).forEach(function(e) {
                        var start = calendar._getItlineCellFromTime(e.start()).i;
                        var end = calendar._getItlineCellFromTime(e.end()).i;
                        var colspan = 1 + end - start;

                        sheet.cell(start + offsetX, y + offsetY).setText(e.client.html()).setColspan(colspan).setStyle(styleEvent);

                        offsetX += colspan - 1;
                    });
                });
                offsetY += row.lines.length - 1;
            });

            return excel;
        };

        img._options = null;
        img._mode = null;

        // ff, ch, ie 9+
        img.generate = function(format, options) {

            if (typeof format === "object") {
                options = format;
                format = null;
            }

            var options = options || {};
            var format = format || options.format || "svg";
            var scale = options.scale || 1;

            if (format === "xls") {
                return img.excelBoard();
            }

            /*if (format === "config") {
                return
            }*/

            // backwards compatibility
            if (format.toLowerCase() === "jpg") {
                format = "jpeg";
            }

            var mode = options.area || "viewport";
            img._options = copyProps(options);
            img._mode = mode;

            img._options.includeHiddenRows = img._options.includeHiddenRows && (mode === "range");

            // make sure event positions are calculated
            img.getRows().forEach(function(row) {
                calendar._updateEventPositionsInRow(row);
            });

            var width = img._getWidth();
            var height = img._getHeight();

            var board;
            switch (format.toLowerCase()) {
                case "svg":
                    board = new DayPilot.Svg(width, height);
                    break;
                case "png":
                    board = new DayPilot.Canvas(width, height, "image/png", scale);
                    break;
                case "jpeg":
                    board = new DayPilot.Canvas(width, height, "image/jpeg", scale, options.quality);
                    break;
                default:
                    throw new DayPilot.Exception("Export format not supported: " + format);
            }

            var rectangles = img.getRectangles();
            var images = img.getImages();

            var backColor = new DayPilot.StyleReader(calendar.nav.top).get("background-color");

            var cornerBackground = new DayPilot.StyleReader(calendar.nav.corner).get("background-color");
            var borderColor = new DayPilot.StyleReader(calendar.nav.top).get("border-top-color");
            var dividerColor = new DayPilot.StyleReader(calendar.nav.divider).get("background-color");

            // event
            // TODO requires at least one event to be rendered
            var divSampleEvent = createList(calendar.elements.events).filter(function(div) { return !div.event.data.type;}).map(function(div) {return div.firstChild;}).last();
            var eventBorderColor = new DayPilot.StyleReader(divSampleEvent).get("border-right-color");
            var eventFont = img.getFont(divSampleEvent);
            var eventColor = new DayPilot.StyleReader(divSampleEvent).get("color");
            var eventBackColor = new DayPilot.StyleReader(divSampleEvent).get("background-color");
            eventBackColor = DayPilot.Util.isTransparentColor(eventBackColor) ? "white" : eventBackColor;

            // milestone
            var milestone = img.fakeMilestone();
            var milestoneBackColor = new DayPilot.StyleReader(milestone.firstChild).get("background-color");
            deleteElement(milestone);

            // group
            var divGroup = img.fakeGroup();
            var groupBackColor = new DayPilot.StyleReader(divGroup.firstChild).get("background-color");
            deleteElement(divGroup);

            // duration bar
            var bar = img.fakeDurationBar();
            var eventBarBackColor = new DayPilot.StyleReader(bar.firstChild).get("background-color");
            var eventBarColor = new DayPilot.StyleReader(bar.firstChild.firstChild).get("background-color");
            deleteElement(bar);

            // event left
            var divEventLeft = img.fakeEventLeft();
            var eventLeftColor = new DayPilot.StyleReader(divEventLeft).get("color");
            deleteElement(divEventLeft);

            // grid cell
            // rendered progressively
            var cell = img.fakeCell();
            var nonBusinessBackColor = new DayPilot.StyleReader(cell).get("background-color");
            addClass(cell, calendar._prefixCssClass("_cell_business"));
            var businessBackColor = new DayPilot.StyleReader(cell).get("background-color");
            var cellFont = img.getFont(cell);
            var cellColor = new DayPilot.StyleReader(cell).get("color");
            deleteElement(cell);

            var firstLineHorizontal = DayPilot.Util.firstPropValue(calendar._cache._linesHorizontal);
            var gridLineColorHorizontal = new DayPilot.StyleReader(firstLineHorizontal).get("background-color");

            var firstLineVertical = DayPilot.Util.firstPropValue(calendar._cache._linesVertical);
            var gridLineColorVertical = new DayPilot.StyleReader(firstLineVertical).get("background-color");

            /// time header
            // it's always rendered in full, use the real object
            var timeHeader = calendar._cache.timeHeader["0_0"];
            var timeHeaderFont = img.getFont(timeHeader);
            var timeHeaderColor = new DayPilot.StyleReader(timeHeader).get("color");
            var timeHeaderBackground = new DayPilot.StyleReader(timeHeader).get("background-color");
            // var timeHeaderBackground = new DayPilot.StyleReader(timeHeader).get("background");

            // row header
            // rendered progressively
            var rowHeader = img.fakeRowHeader();
            var rowHeaderFont = img.getFont(rowHeader);
            var rowHeaderColor = new DayPilot.StyleReader(rowHeader).get("color");
            var rowHeaderBackground = new DayPilot.StyleReader(rowHeader).get("background-color");
            deleteElement(rowHeader);

            // corner
            var corner = img._fakeCorner();
            var cornerFont = img.getFont(corner);
            var cornerColor = new DayPilot.StyleReader(corner).get("color");
            var cornerBackground = new DayPilot.StyleReader(corner).get("background-color");

            // row header cols
            if (calendar.rowHeaderColumns && calendar._splitter && calendar._splitter.blocks[0]) {
                var rowHeaderCol = calendar._splitter.blocks[0].section.firstChild;
                var rowHeaderColFont = new DayPilot.StyleReader(rowHeaderCol).getFont();
                var rowHeaderColColor = new DayPilot.StyleReader(rowHeaderCol).get("color");
                // var rowHeaderColBackColor = new DayPilot.StyleReader(rowHeaderCol).get("background-color");
            }

            var viewportOffsetStart = img.getViewportOffsetStart();
            var viewportOffsetTop = img.getViewportOffsetTop();

            board.fillRect(rectangles.main, "white");
            board.fillRect(rectangles.main, backColor);

            // corner
            (function exportCorner() {
                var args = {};
                args.backColor = cornerBackground;
                args.text = calendar.cornerText;
                args.fontSize = cornerFont.size;
                args.fontFamily = cornerFont.family;
                args.fontStyle = cornerFont.style;
                args.fontColor = cornerColor;
                args.horizontalAlignment = "left";
                args.verticalAlignment = "top";

                if (typeof calendar.onBeforeCornerExport === "function") {
                    calendar.onBeforeCornerExport(args);
                }

                var font = {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle};

                board.fillRect(rectangles.corner, args.backColor);
                board.text(rectangles.corner, args.text, font, args.fontColor, args.horizontalAlignment, 0, args.verticalAlignment);

            })();

            // row header column titles
            var colLeft = rectangles.corner.x;
            resolved._rowHeaderColumnsVisible().forEach(function exportRowHeaderColumn(col, i) {
                var width = calendar.rowHeaderCols[i];
                var rect = {};
                rect.x = colLeft;
                rect.w = width + 1;
                rect.y = rectangles.corner.h - calendar._splitter.height;
                rect.h = calendar._splitter.height + 1;

                var padding = 3;
                var rectText = copyProps(rect);
                rectText.x += padding;
                rectText.w -= padding;

                var text = col.name || col.title || "";

                board.fillRect(rect, cornerBackground);
                board.text(rectText, text, rowHeaderColFont, rowHeaderColColor, "left", 0, "center");
                board.rect(rect, borderColor);

                colLeft += width;
            });

            var beforeTimeHeaderExport = typeof calendar.onBeforeTimeHeaderExport === "function";
            var beforeRowHeaderRender = typeof calendar.onBeforeRowHeaderRender === "function";
            var beforeRowHeaderExport = typeof calendar.onBeforeRowHeaderExport === "function";
            var beforeCellExport = typeof calendar.onBeforeCellExport === "function";

            // time headers used to be here

            // row headers here
            img.getRows().forEach(exportRow);
            img.getRowsTop().forEach(exportRow);
            img.getRowsBottom().forEach(exportRow);

            function exportRow(row) {
                var top = rectangles.grid.y + img._rowTop(row) - img._rowOffset(row);
                var shiftY = atLeast(0, rectangles.grid.y - top);
                top += shiftY;

                var showTreeIcon = calendar.treeEnabled && !row.isNewRow;

                var imageWidth = 10;
                var dragHandleWidth = 10;
                var left = showTreeIcon ? row.level * calendar.treeIndent + calendar.treeImageMarginLeft + 5 : 5;

                if (calendar.rowMoveHandling !== "Disabled") {
                    left += dragHandleWidth;
                }

                var rect = {"x": 0, "y": top, "w": rectangles.grid.x + 1, "h": row.height + 1};

                var props = row;
                if (beforeRowHeaderRender) {
                    var brhra = calendar._doBeforeRowHeaderRender(row);
                    props = brhra.row;
                }

                var columns = calendar.rowHeaderCols ? calendar.rowHeaderCols.length : 0;
                var isTabular = calendar._isTabularMode();
                var useStandardColumns = calendar.internalUseStandardColumns && !row.isNewRow;
                var standardGlobalColumns = useStandardColumns || (isTabular && DayPilot.isArray(calendar.rowHeaderColumns));

                var args = {};
                args.text = props.html;
                var rowHeaderColumns = resolved._rowHeaderColumnsVisible();
                if (rowHeaderColumns.length > 0 && standardGlobalColumns) {
                    var firstFiltered = props.columns.find(function(col, i) { return !calendar.rowHeaderColumns[i].hidden;});
                    args.text = firstFiltered.text || firstFiltered.html;
                }
                args.backColor = props.backColor || rowHeaderBackground;
                args.fontSize = rowHeaderFont.size;
                args.fontFamily = rowHeaderFont.family;
                args.fontStyle = rowHeaderFont.style;
                args.fontColor = props.fontColor || rowHeaderColor;
                args.borderColor = borderColor;
                args.horizontalAlignment = "left";
                args.verticalAlignment = "center";

                args.row = calendar._createRowObject(row);
                args.columns = [];
                args.row.columns = args.columns;  // backwards compatibility, 2021-11-09

                props.columns && props.columns.forEach(function(c) {
                    var column = copyProps(c, {}, ["text", "html", "backColor", "horizontalAlignment", "verticalAlignment"]);
                    column.text = c.text || c.html;
                    column.fontSize = args.fontSize;
                    column.fontFamily = args.fontFamily;
                    column.fontStyle = args.fontStyle;
                    column.fontColor = args.fontColor;
                    column.horizontalAlignment = column.horizontalAlignment || args.horizontalAlignment;
                    column.verticalAlignment = column.verticalAlignment || args.verticalAlignment;
                    column.backColor = column.backColor || args.backColor;

                    args.columns.push(column);
                });

                if (row.isNewRow) {
                    args.text = calendar.rowCreateText;
                }

                if (beforeRowHeaderExport) {
                    calendar.onBeforeRowHeaderExport(args);
                }

                var imgHeight = 10;
                var halfHeight = imgHeight/2;
                var rectImage = {"x": left, "y": top + calendar.treeImageMarginTop + 2, "w": 10, "h": imgHeight};
                var fontFirst = {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle};

                if (args.verticalAlignment === "center") {
                    rectImage.y = top + rect.h/2 - halfHeight;
                }

                var leftText = showTreeIcon ? left + imageWidth + 3 : left;
                var widthText = showTreeIcon ? rect.w - leftText : rect.w;
                var rectText = {"x": leftText, "y": top, "w": widthText, "h": row.height + 1};

                if (calendar.rowHeaderCols) {
                    rectText.w = calendar.rowHeaderCols[0] - leftText;
                }

                board.fillRect(rect, args.backColor);

                board.text(rectText, args.text, fontFirst, args.fontColor, args.horizontalAlignment, 0, args.verticalAlignment);
                board.rect(rect, args.borderColor);

                // var imgBelow = rectImage.y > img.bottomFrozenY() && row.grid !== "bottom";
                if (showTreeIcon) {
                    var image = null;
                    if (createList(row.children).isEmpty()) {
                        image = images.nochildren;
                    }
                    else if (row.expanded || img._options.includeHiddenRows) {
                        image = images.collapse;
                    }
                    else {
                        image = images.expand;
                    }
                    board.image(rectImage, image);
                }

                // filtered export
                var filteredColumns = createList(args.row.columns);

                // skip hidden columns, only for rowHeaderColumns defined or passed from Gantt
                if (standardGlobalColumns) {
                    filteredColumns = filteredColumns.filter(function(col, i) { return !calendar.rowHeaderColumns[i].hidden;});
                    columns = filteredColumns.length;
                }

                // row header columns
                if (calendar.rowHeaderCols) {
                    var left = rect.x;

                    createList(calendar.rowHeaderCols).forEach(function(w, i) {
                        var skip = (i === 0);

                        if (!skip) {
                            var shift = (useStandardColumns || calendar._isTabularMode()) ? 0 : 1;
                            // var x = calendar._isTabularMode() ? i: i - 1;
                            var x = i - shift;
                            var col = filteredColumns[x] || {};
                            // var col = args.row.columns[x] || {};
                            var cellRect = copyProps(rect);
                            cellRect.x = left;
                            cellRect.w = w + 1;

                            var padding = 3;
                            var cellTextRect = copyProps(cellRect);
                            cellTextRect.x += padding;
                            cellTextRect.w -= padding;

                            // var text = col.text;
                            var backColor = col.backColor || args.backColor;

                            board.fillRect(cellRect, backColor);
                            if (col.text) {
                                board.text(cellTextRect, col.text, {"size": col.fontSize, "family": col.fontFamily, "style": col.fontStyle}, col.fontColor, col.horizontalAlignment, 0, col.verticalAlignment);
                            }
                            board.rect(cellRect, args.borderColor);

                        }

                        left += w;
                    });
                }

            }

            // cells main grid
            img.getRows().forEach(function(row, y, rows) {
                var y = row.index;
                img.getTimeline().forEach(function(cell, x, timeline) {
                    var x = timeline.offset + x;
                    exportCell(x, y, row.grid);
                });
            });

            function exportCell(x, y, gridName) {

                gridName = gridName || "main";

                var cell = calendar.itline[x];
                var row = calendar._grids[gridName].rowlist[y];

                var props = calendar._getCellProperties(x, y, gridName);
                var business = props.business;

                var args = calendar._doBeforeCellRender(x, y, gridName);
                if (!args) {  // reuse the args if available
                    args = {};
                    args.cell = calendar.cells.findXy(x, y, gridName)[0];
                }

                // customizable
                var text = props.html;
                var halign = props.horizontalAlignment || "left";
                var backColor = props.backColor || (business ? businessBackColor : nonBusinessBackColor);

                args.areas = args.cell && args.cell.properties && args.cell.properties.areas || [];
                args.text = text;
                args.horizontalAlignment = halign;
                args.backColor = backColor;
                args.fontSize = cellFont.size;
                args.fontFamily = cellFont.family;
                args.fontStyle = cellFont.style;
                args.fontColor = args.cell && args.cell.properties && args.cell.properties.fontColor || cellColor;

                if (beforeCellExport) {
                    calendar.onBeforeCellExport(args);

                    text = args.text;
                    halign = args.horizontalAlignment;
                    backColor = args.backColor;
                }

                var top = rectangles.grid.y + img._rowTop(row) - img._rowOffset(row);
                var shiftY = atLeast(0, rectangles.grid.y - top);
                top += shiftY;

                var left = rectangles.grid.x + cell.left - viewportOffsetStart;
                var shiftX = atLeast(0, rectangles.grid.x - left);
                left += shiftX;

                var rect = {"x": left, "y": top, "w": cell.width, "h": row.height};
                board.fillRect(rect, backColor);

                var textRect = {};
                textRect.x = rect.x + 1;
                textRect.y = rect.y + 1;
                textRect.w = rect.w - 2;
                textRect.h = rect.h - 2;

                var font = {
                    "size": args.fontSize,
                    "family": args.fontFamily,
                    "style": args.fontStyle
                };

                if (text) {
                    board.text(textRect, text, font, args.fontColor, halign);
                }

                // active areas
                var areas = args.areas;
                createList(areas).forEach(function(area) {

                    if (!DayPilot.Areas.isVisible(area)) {
                        return;
                    }

                    var groupData = {
                        "type": "cell-area",
                    };

                    if (typeof area.id !== "undefined") {
                        groupData.id = area.id;
                    }

                    board.groupStart(groupData);

                    var areaLeft = 0;
                    if (typeof area.left === "number") {
                        areaLeft = area.left;
                    } else if (area.start) {
                        areaLeft = calendar.getPixels(new DayPilot.Date(area.start)).left - cell.left;
                    } else if (typeof area.right === "number") {
                        areaLeft = cell.width - area.right - area.width;
                    }

                    var width = area.width || area.w;
                    if (typeof area.right === "number") {
                        width = (cell.width - area.right) - areaLeft;
                    } else if (area.end) {
                        width = calendar.getPixels(new DayPilot.Date(area.end)).left - area.left - cell.left + 1;
                    }

                    var areaTop = area.top || 0;
                    var height = area.height || area.h;
                    if (typeof area.bottom === "number") {
                        height = (cell.height - area.bottom) - areaTop;
                    }
                    if (!height) {
                        height = cell.height - areaTop;
                    }

                    var rect = {"x": left + areaLeft, "y": top + areaTop, "w": width, "h": height};

                    if (area.backColor) {
                        board.fillRect(rect, area.backColor);
                    }
                    if (area.icon) {
                        var iconInfo = calendar._img.areaIcon(area.icon);
                        board.text(rect, iconInfo.text, iconInfo.font, area.fontColor || args.fontColor, area.horizontalAlignment, area.padding, area.verticalAlignment);
                    }
                    else if (area.image) {
                        var img = new Image();
                        img.src = area.image;
                        board.image(rect, img);
                    }
                    else if (area.symbol) {
                        board.symbol(rect, area.symbol, {color: area.fontColor || args.fontColor});
                    }
                    else if (area.text || area.html) {
                        board.text(rect, area.text || area.html, {
                            "size": area.fontSize || args.fontSize,
                            "family": area.fontFamily || args.fontFamily,
                            "style": area.fontStyle || args.fontStyle
                        }, area.fontColor || args.fontColor, area.horizontalAlignment, area.padding, area.verticalAlignment);
                    }

                    board.groupEnd();

                });


            }

            var beforeGridLine = typeof calendar.onBeforeGridLineRender === "function";

            // matrix horizontal
            img.getRows().forEach(exportMatrixHorizontal);

            function exportMatrixHorizontal(row) {
                var top = rectangles.grid.y + img._rowTop(row) - img._rowOffset(row);
                var shiftY = atLeast(0, rectangles.grid.y - top);
                top += shiftY;

                if (top === rectangles.grid.y) {
                    return;
                }

                if (row.grid === "main" && top > img.bottomFrozenY()) {
                    return;
                }

                var color = gridLineColorHorizontal;
                var args = {};
                if (beforeGridLine) {
                    args.row = calendar._createRowObject(row);
                    args.hidden = false;
                    args.cssClass = null;
                    args.type = "HorizontalLine";
                    args.color = null;

                    calendar.onBeforeGridLineRender(args);

                    if (args.hidden) {
                        return;
                    }

                    color = args.color || gridLineColorHorizontal;
                }

                board.line(rectangles.gridContent.x + 1, top, rectangles.gridContent.x + rectangles.gridContent.w - 1, top, color);

                // hack
                if (row.grid === "top") {
                    if (row === calendar._grids.top.rowlist.last()) {
                        board.line(rectangles.gridContent.x + 1, top + row.height, rectangles.gridContent.x + rectangles.gridContent.w - 1, top + row.height, gridLineColorHorizontal);
                    }
                }
            }

            // matrix vertical
            img.getTimeline().forEach(function(cell) {
                exportMatrixVertical(cell, "main");
            });

            function exportMatrixVertical(cell, grid) {
                var left = rectangles.grid.x + cell.left - viewportOffsetStart;

                var shiftX = atLeast(0, rectangles.grid.x - left);
                left += shiftX;

                if (left === rectangles.grid.x) {
                    return;
                }

                var top = rectangles.grid.y + 1;
                var bottom = rectangles.grid.y + rectangles.grid.h - 2;
                if (grid === "top") {
                    bottom = top + calendar._grids.top.height;
                }
                if (grid === "bottom") {
                    top = img.bottomFrozenY();
                }

                var color = gridLineColorVertical;

                var args = {};
                if (beforeGridLine) {
                    args.start = cell.start;
                    args.end = cell.end;
                    args.hidden = false;
                    args.cssClass = null;
                    args.type = "VerticalLine";
                    args.color = null;

                    calendar.onBeforeGridLineRender(args);

                    if (args.hidden) {
                        return;
                    }

                    color = args.color || gridLineColorVertical;
                }

                board.line(left, top, left, bottom, color);

            }

            var lastTimelineCell = img.getTimeline().last();

            (function(cell) {
                if (!cell) {
                    return;
                }

                var color = gridLineColorVertical;
                var args = {};
                if (beforeGridLine) {
                    args.start = cell.end;
                    args.end = cell.end;
                    args.hidden = false;
                    args.cssClass = null;
                    args.type = "VerticalLine";
                    args.color = null;

                    calendar.onBeforeGridLineRender(args);

                    if (args.hidden) {
                        return;
                    }

                    color = args.color || gridLineColorVertical;
                }


                var left = rectangles.grid.x + cell.left - viewportOffsetStart + cell.width;
                board.line(left, rectangles.grid.y + 1, left, rectangles.grid.y + rectangles.grid.h - 2, color);
            })(lastTimelineCell);

            // separators
            img.getSeparators().forEach(function(sep) {
                var left = rectangles.grid.x + sep.left - viewportOffsetStart;
                if (left < img.getRowHeaderWidth()) {
                    return;
                }
                board.line(left, rectangles.grid.y + 1, left + sep.width, rectangles.grid.y + rectangles.grid.h - 2, sep.color);
            });

            img.getLinks().forEach(function exportLink(link) {
                if (!link) {
                    return;
                }
                link.map(function(segment) {
                    return img.shiftableSegment(segment).shift(rectangles.grid.x - viewportOffsetStart, rectangles.grid.y - viewportOffsetTop);
                }).forEach(function(segment) {
                    switch (segment.type) {
                        case "HorizontalLine":
                            board.line(segment.startX, segment.startY, segment.endX, segment.endY, "red");
                            break;
                        case "VerticalLine":
                            board.line(segment.startX, segment.startY, segment.endX, segment.endY, "red");
                            break;
                        case "ArrowRight":
                            board.triangle({x: segment.startX - 10, y: segment.startY - 4.5, w: 10, h: 10}, "red");
                            break;
                        case "ArrowDown":
                            board.triangle({x: segment.startX - 4.5, y: segment.startY - 10, w: 10, h: 10}, "red", 90);
                            break;
                        case "ArrowLeft":
                            board.triangle({x: segment.startX, y: segment.startY - 4.5, w: 10, h: 10}, "red", 180);
                            break;
                        case "ArrowUp":
                            board.triangle({x: segment.startX - 4.5, y: segment.startY, w: 10, h: 10}, "red", -90);
                            break;
                    }
                });
            });

            // events in main grid
            img.getEvents().forEach(exportEvent);

            function exportEvent(e) {

                var row = calendar._grids[e.part.grid].rowlist[e.part.dayIndex];

                // var rowTop = img._rowTop(calendar.rowlist[e.part.dayIndex]);
                var rowTop = img._rowTop(row);
                var width = e.part.width;

                var barVisible = e.client && e.client.barVisible && e.client.barVisible();

                // var top = rectangles.grid.y + rowTop + e.part.top - viewportOffsetTop;
                var top = rectangles.grid.y + rowTop + e.part.top - img._rowOffset(row);

                // do not shift
                // var shiftY = atLeast(0, rectangles.grid.y - top);
                // top += shiftY;

                var left = rectangles.grid.x + e.part.left - viewportOffsetStart + 1;
                var shiftX = atLeast(0, rectangles.grid.x - left);
                left += shiftX;
                width -= shiftX;

                var cache = e.cache || e.data;

                var barColor = cache.barColor || eventBarColor;
                var barBackColor = cache.barBackColor || eventBarBackColor;
                var backColor = cache.backColor || eventBackColor;
                var fontColor = cache.fontColor || eventColor;

                var barLeft = e.part.barLeft;
                var barWidth = e.part.barWidth;
                if (calendar.durationBarMode === "PercentComplete") {
                    barLeft = 0;
                    // barWidth = atLeast(1, e.part.width * (cache.complete || 0)/100);
                    barWidth = atLeast(0, Math.floor(e.part.width * (cache.complete || 0)/100));
                }

                if (e.data.type === "Milestone") {
                    backColor = milestoneBackColor;
                }

                var barHeight = 4;
                var paddingLeft = 2;
                var textPadding = 2;

                var args = {};
                args.e = e;
                args.text = e.text ? e.text() : e.client.html();
                args.areas = DayPilot.Util.createArrayCopy(cache.areas);
                args.fontSize = eventFont.size;
                args.fontFamily = eventFont.family;
                args.fontStyle = eventFont.style;
                args.fontColor = fontColor;
                args.backColor = backColor;
                args.borderColor = eventBorderColor;
                args.horizontalAlignment = "left";
                args.verticalAlignment = "center";
                args.barHeight = barHeight;
                args.textPadding = textPadding;
                args.textLeft = cache.textLeft || cache.htmlLeft;
                args.textRight = cache.textRight || cache.htmlRight;

                if (typeof calendar.onBeforeEventExport === "function") {
                    calendar.onBeforeEventExport(args);
                }

                var rect = {"x": left, "y": top, "w": width, "h": e.part.height};

                board.groupStart({
                    "type": "event",
                    "id": e.id()
                });

                if (e.data.type === "Milestone") {
                    drawMilestone();
                }
                else if (e.data.type === "Group") {
                    drawGroup();
                }
                else {
                    drawEvent();
                }

                // text left
                var textLeft = args.textLeft;
                if (textLeft) {
                    var textLeftFont = {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle};
                    var textLeftWidth = board.textWidth(textLeft, textLeftFont);
                    var rectLeft = {"x": left - (calendar.eventHtmlLeftMargin + textLeftWidth), "y": top, "w": textLeftWidth, "h": e.part.height};
                    board.text(rectLeft, textLeft, textLeftFont, eventLeftColor, null, 0, "center");
                }

                // text right
                var textRight = args.textRight;
                if (textRight) {
                    var textRightFont = {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle};
                    var textRightWidth = board.textWidth(textRight, textRightFont);
                    var rectRight = {"x": left + width + calendar.eventHtmlRightMargin, "y": top, "w": textRightWidth, "h": e.part.height};
                    board.text(rectRight, textRight, textRightFont, eventLeftColor, null, 0, "center");
                }

                board.groupEnd();

                var versions = e.versions || [];
                versions.forEach(drawVersion);

                function drawMilestone() {
                    var color = args.backColor;
                    board.diamond(rect, color);
                }

                function drawGroup() {
                    var barBackRect = {"x": left, "y": top, "w": width, "h": args.barHeight};
                    var barRect = {"x": left + barLeft, "y": top, "w": barWidth, "h": args.barHeight};

                    // copied from the default theme
                    var color = cache.backColor || groupBackColor;
                    var topRect = {x: left, y: top + 5, h: rect.h - 6 - 5, w: rect.w };
                    board.fillRect(topRect, color);

                    var text = cache.text || cache.html;
                    board.text(topRect, text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle} , args.fontColor, args.horizontalAlignment, args.textPadding, args.verticalAlignment);

                    board.upperRightCorner({x: left + rect.w - 6, y: topRect.y + topRect.h, w: 6, h: 6}, color);
                    board.upperLeftCorner({x: left, y: topRect.y + topRect.h, w: 6, h: 6}, color);

                    if (barVisible) {
                        board.fillRect(barBackRect, barBackColor);
                        if (barWidth > 0) {
                            board.fillRect(barRect, barColor);
                        }
                    }

                }

                function drawVersion(part, i) {
                    var version = cache.versions[i];

                    board.groupStart({
                        "type": "event-version",
                        "event-id": e.id()
                    });

                    var width = part.width;

                    var top = rectangles.grid.y + rowTop + part.top - viewportOffsetTop;
                    var shiftY = atLeast(0, rectangles.grid.y - top);
                    top += shiftY;

                    var left = rectangles.grid.x + part.left - viewportOffsetStart + 1;
                    var shiftX = atLeast(0, rectangles.grid.x - left);
                    left += shiftX;
                    width -= shiftX;

                    var height = calendar.eventVersionHeight;

                    var barVisible = calendar.durationBarVisible && !version.barHidden;
                    var barHeight = barVisible ? resolved._barHeight() : 0;

                    var rect = {"x": left, "y": top, "w": width, "h": height};

                    board.fillRect(rect, version.backColor || args.backColor);

                    var rectInner = {"x": left + paddingLeft, "y": top + barHeight, "w": atLeast(0, width - paddingLeft), "h": height - barHeight};
                    board.text(rectInner, version.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle} , args.fontColor, args.horizontalAlignment, args.textPadding, args.verticalAlignment);

                    // board.fillRect(rect, version.args.backColor);
                    board.rect(rect, version.borderColor || args.borderColor);

                    // var barVisible = calendar.durationBarVisible && !version.barHidden;
                    if (barVisible) {
                        var barBackColor = version.barBackColor || eventBarBackColor;
                        var barColor = version.barColor || eventBarColor;

                        var barLeft = 100 * part.barLeft / (width); // %
                        var barWidth = Math.ceil(100 * part.barWidth / (width)); // %

                        var barBackRect = {"x": left, "y": top + 1, "w": width, "h": barHeight};
                        var barRect = {"x": left + barLeft, "y": top + 1, "w": barWidth, "h": barHeight};

                        board.fillRect(barBackRect, barBackColor);
                        if (barWidth > 0) {
                            board.fillRect(barRect, barColor);
                        }
                    }

                    board.groupEnd();
                }

                function drawEvent() {
                    var barBackRect = {"x": left, "y": top, "w": width, "h": args.barHeight};
                    var barRect = {"x": left + barLeft, "y": top, "w": barWidth, "h": args.barHeight};
                    var rectInner = {"x": left + paddingLeft, "y": top + args.barHeight, "w": width - paddingLeft, "h": e.part.height - args.barHeight};
                    board.fillRect(rect, args.backColor);
                    board.text(rectInner, args.text, {"size": args.fontSize, "family": args.fontFamily, "style": args.fontStyle} , args.fontColor, args.horizontalAlignment, args.textPadding, args.verticalAlignment);
                    board.rect(rect, args.borderColor);

                    if (barVisible) {
                        board.fillRect(barBackRect, barBackColor);
                        if (barWidth > 0) {
                            board.fillRect(barRect, barColor);
                        }
                    }


                    createList(args.areas).forEach(function(area) {

                        if (!DayPilot.Areas.isVisible(area)) {
                            return;
                        }

                        var groupData = {
                            "type": "event-area",
                        };

                        if (typeof area.id !== "undefined") {
                            groupData.id = area.id;
                        }

                        board.groupStart(groupData);

                        var areaLeft = 0;
                        if (typeof area.left === "number") {
                            areaLeft = area.left;
                        } else if (area.start) {
                            areaLeft = calendar.getPixels(new DayPilot.Date(area.start)).left - e.part.left;
                        } else if (typeof area.right === "number") {
                            areaLeft = e.part.width - area.right - area.width;
                        }

                        var width = area.width || area.w;
                        if (typeof area.right === "number") {
                            width = (e.part.width - area.right) - areaLeft;
                        } else if (area.end) {
                            width = calendar.getPixels(new DayPilot.Date(area.end)).left - area.left - e.part.left + 1;
                        }


                        var areaTop = area.top || 0;
                        var height = area.height || area.h;
                        if (typeof area.bottom === "number") {
                            height = (e.part.height - area.bottom) - areaTop;
                        }
                        if (!height) {
                            height = e.part.height - areaTop;
                        }

                        var rect = {"x": left + areaLeft, "y": top + areaTop, "w": width, "h": height};

                        if (area.backColor) {
                            board.fillRect(rect, area.backColor);
                        }
                        if (area.icon) {
                            var iconInfo = calendar._img.areaIcon(area.icon);
                            board.text(rect, iconInfo.text, iconInfo.font, area.fontColor || args.fontColor, area.horizontalAlignment, area.padding, area.verticalAlignment);
                        }
                        else if (area.image) {
                            var img = new Image();
                            img.src = area.image;
                            board.image(rect, img);
                        }
                        else if (area.symbol) {
                            board.symbol(rect, area.symbol, {color: area.fontColor || args.fontColor});
                        }
                        else if (area.text || area.html) {
                            board.text(rect, area.text || area.html, {
                                "size": area.fontSize || args.fontSize,
                                "family": area.fontFamily || args.fontFamily,
                                "style": area.fontStyle || args.fontStyle
                            }, area.fontColor || args.fontColor, area.horizontalAlignment, area.padding, area.verticalAlignment);
                        }

                        board.groupEnd();

                    });

                }

            }

            // cells in frozen rows
            img.getRowsTopAndBottom().forEach(function(row, y, rows) {
                // var y = rows.offset + y;
                var y = row.index;
                img.getTimeline().forEach(function(cell, x, timeline) {
                    var x = timeline.offset + x;
                    exportCell(x, y, row.grid);
                });
                exportMatrixHorizontal(row);
            });

            // matrix vertical lines in frozen rows
            img.getTimeline().forEach(function(cell) {
                exportMatrixVertical(cell, "top");
                exportMatrixVertical(cell, "bottom");
            });

            // events in frozen rows
            img.getEventsFrozen().forEach(exportEvent);

            // time header
            createList(calendar.timeHeader).forEach(function(item, y) {
                img.getTimeHeader(y, mode).forEach(function exportTimeHeaderCell(cell) {
                    var left = rectangles.grid.x + cell.left - viewportOffsetStart;
                    var width = cell.width;

                    var headerDim = dim._timeHeader(y);
                    var top = headerDim.top;
                    var height = headerDim.height;

                    var args = {};
                    args.header = {};
                    args.header.start = cell.start;
                    args.header.end = cell.end;
                    args.header.level = y;
                    args.header.text = cell.text;
                    args.header.html = cell.innerHTML;
                    args.text = cell.text;
                    args.backColor = cell.backColor;
                    args.verticalAlignment = "center";
                    args.horizontalAlignment = "center";
                    args.fontColor = timeHeaderColor;
                    args.fontSize = timeHeaderFont.size;
                    args.fontFamily = timeHeaderFont.family;
                    args.fontStyle = timeHeaderFont.style;

                    if (beforeTimeHeaderExport) {
                        calendar.onBeforeTimeHeaderExport(args);
                    }

                    var shiftX = atLeast(0, rectangles.grid.x - left);
                    left += shiftX;
                    width -= shiftX;

                    var shiftX = atLeast(0, left + width - (rectangles.grid.x + rectangles.grid.w));
                    width -= shiftX;

                    var cellRect = {"x": left, "y": top, "w": width + 1, "h": height + 1};

                    var font = {
                        "size": args.fontSize,
                        "family": args.fontFamily,
                        "style": args.fontStyle
                    };

                    board.fillRect(cellRect, args.backColor || timeHeaderBackground);
                    board.rect(cellRect, borderColor);
                    board.text(cellRect, args.text, font, args.fontColor, args.horizontalAlignment, 0, args.verticalAlignment);
                });
            });


            // row headers used to be here


            board.rect(rectangles.main, borderColor);
            board.line(rectangles.grid.x, 0, rectangles.grid.x, rectangles.main.h, dividerColor);
            board.line(0, rectangles.grid.y, rectangles.main.w, rectangles.grid.y, dividerColor);

            return board;

        };

        img.areaIcon = function(icon) {
            var el = img.fakeIcon(icon);

            body().appendChild(el);
            var text = window.getComputedStyle(el, ":before").content.replace(/"/g, "");
            var font = new DayPilot.StyleReader(el).getFont();
            body().removeChild(el);

            return {
                "text": text,
                "font": font
            }
        };

        img.shiftableSegment = function(segment) {
            return {
                "startX": segment.startX,
                "endX": segment.endX,
                "startY": segment.startY,
                "endY": segment.endY,
                "type": segment.type,
                "shift": function(x, y) {
                    return img.shiftableSegment({
                        "startX": segment.startX + x,
                        "endX": segment.endX + x,
                        "startY": segment.startY + y,
                        "endY": segment.endY + y,
                        "type": segment.type,
                    });
                }
            };
        };


        this._joint = {};
        var joint = this._joint;
        joint.findJointDivs = function (e) {
            var id = e.data.join;
            if (!id) {
                return createList();
            }
            var divs = createList(calendar.elements.events).filter(function(item) {
                return item.event.data.join === id && item.event !== e;
            });
            return divs;
        };

        this._multiresize = {};
        var mre = this._multiresize;
        mre.divs = [];
        mre.list = [];
        mre.forbidden = false;

        mre.additional = function() {
            var list = createList();

            var draggingSelected = calendar.multiselect.isSelected(DayPilotScheduler._resizing.event);
            var enabled = calendar.allowMultiResize;

            var list = createList();

            if (draggingSelected && enabled) {
                list = createList(calendar.multiselect._divs).filter(function(item) {
                    return item !== DayPilotScheduler._resizing;
                });
            }

            if (calendar.jointEventsResize) {
                var j = joint.findJointDivs(DayPilotScheduler._resizingEvent);
                list = list.concat(j);
            }

            return list;
        };

        mre.update = function() {
            mre.clear();
            mre.draw();
        };

        mre.clear = function() {
            deleteElement(mre.divs);
            mre.divs = [];
        };

        mre.isInvalid = function() {
            return mre.divs.some(function(div) { return div.info.invalid; });
        };

        mre._listCopy = function() {
            return calendar._multiListCopy(mre.list);
        };

        mre._calculate = function() {
            if (!DayPilotScheduler._resizing) {
                return;
            }
            var e = DayPilotScheduler._resizingEvent;
            var shadow = DayPilotScheduler._resizingShadow;
            var startOffset = shadow.start.getTime() - e.start().getTime();
            var endOffset = shadow.end.getTime() - e.end().getTime();

            var rowoffset = 0;

            mre.list = [];
            mre.forbidden = false;
            mre.invalid = false;
            mre.rowoffset = rowoffset;

            mre.additional().forEach(function(item) {
                if (!item.event) {
                    return;
                }
                var event = item.event;
                var row = calendar.rowlist[event.part.dayIndex + rowoffset];
                if (!row) {  // don't draw it, it's out of the grid
                    mre.invalid = true;
                    return;
                }

                var adjustedStart = event.start().addTime(startOffset);
                var adjustedEnd = event.end().addTime(endOffset);

                var info = {};

                info.$ = {};

                if (adjustedStart >= adjustedEnd) {

                    info.invalid = true;

                    // info.overlapping = true; // hack
                    // mre.invalid = true;
                    // mre.forbidden = true;
                    // make sure it has some minimal duration (for display purposes)
                    if (startOffset > 0) {
                        info.$._originalStart = adjustedStart;
                        info.$._adjustedStart = adjustedEnd.addSeconds(-1);

                    }
                    else if (endOffset < 0) {
                        info.$._originalEnd = adjustedEnd;
                        info.$._adjustedEnd = adjustedStart.addSeconds(1);
                    }
                }

                info.event = event;
                info.start = adjustedStart;
                info.end = adjustedEnd;
                // not detected here but later
                // info.overlapping = false;
                info.$._row = row;
                mre.list.push(info);
            });
        };


        mre._draw = function() {
            var rowoffset = 0;

            mre.list.forEach(function(info) {

                var event = info.event;
                var row = info.$._row;

                var top = event.part.top + row.top;
                var height = event.part.height;

                if (rowoffset) {
                    top = row.top;
                    height = row.height;
                }

                var start = new DayPilot.Date(info.start);
                var end = new DayPilot.Date(info.end);

                var startPixels = calendar.getPixels(start);
                var endPixels = calendar.getPixels(end);

                // only apply the adjustment if info.start/end wasn't modified
                if (info.$._originalStart === start && info.$._adjustedStart) {
                    startPixels = calendar.getPixels(info.$._adjustedStart);
                }

                if (info.$._originalEnd === end && info.$._adjustedEnd) {
                    endPixels = calendar.getPixels(info.$._adjustedEnd);
                }

                // TODO wrong, use adjustedStart, adjustedEnd
                var duration = DayPilot.DateUtil.diff(event.rawend(), event.start());
                // var duration = DayPilot.DateUtil.diff(info.$._adjustedEnd, info.$._adjustedStart);
                duration = atLeast(duration, 1);

                var useBox = resolved._useBox(duration);

                var left = (useBox) ? startPixels.boxLeft : startPixels.left;
                var width = (useBox) ? (endPixels.boxRight - left) : (endPixels.left - left);

                var div = createDiv();
                div.style.position = "absolute";
                div.style.left = left + "px";
                div.style.top = top + "px";
                div.style.height = height + "px";
                div.style.width = width + "px";
                div.style.zIndex = 101;
                div.style.overflow = "hidden";
                div.className = calendar._prefixCssClass("_shadow");
                //div.event = event;
                div.info = info;// store for overlap checking

                var inner = createDiv();
                inner.className = calendar._prefixCssClass("_shadow_inner");
                div.appendChild(inner);

                calendar._maind.appendChild(div);
                mre.divs.push(div);

            });

            // this is not likely to happen in multi-resizing, consider deleting
            if (mre.invalid) {
                var cssClass = calendar._prefixCssClass("_shadow_overlap");
                createList(mre.divs).forEach(function(item) {
                    addClass(item, cssClass);
                });
                return;
            }

            // overlap checking must be separate, after all items are rendered
            createList(mre.divs).forEach(function(item) {
                if (!item.info) {
                    return;
                }

                var div = item;
                var info = item.info;
                var event = item.info.event;
                var row = calendar.rowlist[event.part.dayIndex + rowoffset];

                var startPixels = calendar.getPixels(info.start);
                var endPixels = calendar.getPixels(info.end);

                var left = startPixels.left;
                var width = endPixels.left - left;

                if (item.info.invalid) {
                    addClass(item, calendar._prefixCssClass("_shadow_invalid"));
                }

                var except = createList(mre.list).map(function(item) { return item.event.data; }).add(DayPilotScheduler._resizing.event.data);
                calendar._overlappingShadow(div, row, left, width, except);
                calendar._checkDisabledCells(div, info.start, info.end, event.resource());

                if (div.overlapping) {
                    info.overlapping = true;
                    mre.forbidden = true;
                }

            });


        };

        mre.draw = function() {
            mre._calculate();
            mre._draw();
        };

        this._config = {};
        var config = this._config;

        config.modifiedProps = function() {
            var clean = new DayPilot.Scheduler();

            var members = DayPilot.Util.members(calendar, 2);

            var result = [];

            result.push("<div id='dp'></div>");
            result.push("<script>");
            result.push("var dp = new DayPilot.Scheduler('dp');");

            members.properties.forEach(function(item) {
                var name = item.name;

                var path = name.split(".");
                var isPath = path.length > 1;

                var ref, instance;

                if (isPath) {
                    var path0 = path[0];
                    var path1 = path[1];
                    ref = JSON.stringify(clean[path0][path1]);
                    instance = JSON.stringify(calendar[path0][path1]);
                }
                else {
                    ref = JSON.stringify(clean[name]);
                    instance = JSON.stringify(calendar[name]);
                }

                if (ref !== instance) {
                    result.push("dp." + name + " = " + instance + ";");
                }
            });

            members.events.forEach(function(item) {
                var name = item.name;

                if (typeof calendar[name] === "function") {
                    result.push("dp." + name + " = " + calendar[name].toString() + ";");
                }
            });

            result.push("dp.init();");
            result.push("</script>");

            return result.join("\n");

        };

        this._multimove = {};
        var mm = this._multimove;
        mm.divs = [];
        mm.list = [];
        mm.forbidden = false;
        mm._rowoffset = 0;
        mm.verticalAll = function() {
            return calendar.multiMoveVerticalMode === "All";
        };

        mm.additional = function() {
            var list = createList();
            var moving = calendar._moving;

            var draggingSelected = calendar.multiselect.isSelected(DayPilotScheduler._movingEvent);
            var enabled = calendar.allowMultiMove;

            if (draggingSelected && enabled) {
                list = createList(calendar.multiselect._divs).filter(function(item) {
                     return item !== DayPilotScheduler._moving && item !== moving._moving;
                });
            }

            if (calendar.jointEventsMove) {
                var j = joint.findJointDivs(DayPilotScheduler._movingEvent);
                list = list.concat(j);
            }

            return list;
        };

        mm.update = function() {
            mm.clear();
            mm.draw();
        };


        mm._listCopy = function() {
            return calendar._multiListCopy(mm.list);
        };

        mm._calculate = function() {
            mm.list = [];
            mm.rowoffset = 0;

            if (!DayPilotScheduler._moving) {
                return;
            }
            var e = DayPilotScheduler._movingEvent;
            var isMovingShadow = !!DayPilotScheduler._movingShadow;
            var start = isMovingShadow ? DayPilotScheduler._movingShadow.start : e.start();
            var offset = start.getTime() - e.start().getTime();

            var originalRow = e.part.dayIndex;
            var newRow = isMovingShadow ? indexOf(calendar.rowlist, DayPilotScheduler._movingShadow.row) : originalRow;
            var rowoffset = newRow - originalRow;
            if (!mm.verticalAll()) {
                rowoffset = 0;
            }

            mm.forbidden = false;
            mm.invalid = false;
            mm.rowoffset = rowoffset;

            mm.additional().forEach(function(item) {
                if (!item.event) {
                    return;
                }
                var event = item.event;
                var row = calendar.rowlist[event.part.dayIndex + rowoffset];
                if (!row) {  // don't draw it, it's out of the grid
                    mm.invalid = true;
                    return;
                }

                var adjustedStart = event.start().addTime(offset);
                var adjustedEnd = event.end().addTime(offset);

                var info = {};
                info.event = event;
                info.start = adjustedStart;
                info.end = adjustedEnd;
                info.resource = row.id;
                // info.overlapping = false;
                mm.list.push(info);

            });

        };


        mm._draw = function() {
            var rowoffset = mm.rowoffset;
            mm.list.forEach(function(info) {
                var adjustedStart = info.start;
                var adjustedEnd = info.end;
                var event = info.event;

                var startPixels = calendar.getPixels(adjustedStart);
                var endPixels = calendar.getPixels(adjustedEnd);

                var duration = DayPilot.DateUtil.diff(event.rawend(), event.start());
                duration = atLeast(duration, 1);

                var useBox = resolved._useBox(duration);

                // var row = info.$._row;
                var row = calendar._findRowByResourceId(info.resource);
                if (!row) {
                    mm.invalid = true;
                    return;
                }

                info.$ = {};
                info.$._row = row;

                var left = (useBox) ? startPixels.boxLeft : startPixels.left;
                var width = (useBox) ? (endPixels.boxRight - left) : (endPixels.left - left);
                var top = event.part.top + row.top;
                var height = event.part.height;

                if (info.resource !== info.event.data.resource) {
                    top = row.top;
                    height = row.height;
                }


                var div = createDiv();
                div.style.position = "absolute";
                div.style.left = left + "px";
                div.style.top = top + "px";
                div.style.height = height + "px";
                div.style.width = width + "px";
                // div.style.zIndex = 101;
                div.style.overflow = "hidden";
                div.className = calendar._prefixCssClass("_shadow");
                //div.event = event;
                div.info = info;// store for overlap checking

                var inner = createDiv();
                inner.className = calendar._prefixCssClass("_shadow_inner");
                div.appendChild(inner);

                calendar._maind.appendChild(div);
                mm.divs.push(div);

            });

            if (mm.invalid) {
                var cssClass = calendar._prefixCssClass("_shadow_overlap");
                createList(mm.divs).forEach(function(item) {
                    addClass(item, cssClass);
                });
                return;
            }

            // overlap checking must be separate, after all items are rendered
            createList(mm.divs).forEach(function(item) {
                if (!item.info) {
                    return;
                }

                var div = item;
                var info = item.info;
                var event = item.info.event;
                // var row = calendar.rowlist[event.part.dayIndex + rowoffset];
                var row = item.info.$._row;

                /*
                // should never happen, checked above
                if (!row) {
                    mm.forbidden = true;
                    return;
                }
                */

                var startPixels = calendar.getPixels(info.start);
                var endPixels = calendar.getPixels(info.end);

                var left = startPixels.left;
                var width = endPixels.left - left;

                var except = createList(mm.list).map(function(item) { return item.event.data; }).add(DayPilotScheduler._movingEvent.data);
                calendar._overlappingShadow(div, row, left, width, except);
                calendar._checkDisabledCells(div, info.start, info.end, info.resource);

                info.overlapping = false;
                if (div.overlapping) {
                    info.overlapping = true;
                    mm.forbidden = true;
                }

            });

        };

        // includes calculations
        mm.draw = function() {
            mm._calculate();
            mm._draw();
        };

        mm.clear = function() {
            deleteElement(mm.divs);
            mm.divs = [];
        };

        this._multiListCopy = function(list, readonly) {
            readonly = ["$"].concat(readonly || []);
            return list.map(function(info) {
                var source = info;
                var target = {};

                for (var name in source) {
                    var isReadOnly = readonly && indexOf(readonly, name) !== -1;
                    if (source.hasOwnProperty(name) && typeof source[name] !== 'undefined') {
                        if (!isReadOnly) {
                            target[name] = source[name];
                        }
                        else {
                            Object.defineProperty(target, name, {
                                "value": source[name]
                            });
                        }
                    }
                }

                return target;
            });
        };

        this._resizeShadow = function() {
            var coords = calendar.coords;

            var border = DayPilotScheduler._resizing.dpBorder;

            var e = DayPilotScheduler._resizing.event;

            var refX = e.part.left; // using x relative to maind
            if (border == "right") {
                refX += e.part.width;
            }

            var _step = DayPilotScheduler._resizing.event.calendar.cellWidth;
            var originalWidth = DayPilotScheduler._resizing.event.part.width;
            var originalLeft = DayPilotScheduler._resizing.event.part.left;
            var _startOffset = 0;
            var delta = (coords.x - refX);

            var newLeft, newWidth;

            var snapToGrid = calendar.snapToGrid && calendar.snapToGridEventResizing;

            if (border === 'right') {
                newLeft = originalLeft;
                if (snapToGrid) {
                    //newWidth = Math.ceil(((originalWidth + originalLeft + delta)) / _step) * _step - originalLeft;
                    var itc =  calendar._getItlineCellFromPixels(originalWidth + originalLeft + delta).cell;

                    var startitc = calendar._getItlineCellFromPixels(originalLeft).cell;
                    var minWidth = (startitc.left + startitc.width) - originalLeft;

                    var newRight = itc.left + itc.width;
                    newWidth = newRight - originalLeft;

                    if (newWidth < minWidth) {
                        newWidth = minWidth;
                    }

                }
                else {
                    newWidth = originalWidth + delta;
                }

                var max = calendar._getGridWidth();

                if (originalLeft + newWidth > max) {
                    newWidth = max - originalLeft;
                }

                DayPilotScheduler._resizingShadow.left = originalLeft;
                DayPilotScheduler._resizingShadow.width = newWidth;
            }
            else if (border === 'left') {
                if (snapToGrid) {
                    if (delta >= originalWidth) {
                        delta = originalWidth;
                    }
                    newLeft = Math.floor(((originalLeft + delta) + 0) / _step) * _step;
                    if (newLeft < _startOffset) {
                        newLeft = _startOffset;
                    }
                }
                else {
                    newLeft = originalLeft + delta;
                }

                newWidth = originalWidth - (newLeft - originalLeft);
                var right = originalLeft + originalWidth;

                var min = _step;

                if (!snapToGrid) {
                    min = 1;
                }
                else if (calendar.useEventBoxes === "Never") {
                    if (originalWidth < _step) {
                        min = originalWidth;
                    }
                    else {
                        min = 1;
                    }
                }

                if (newWidth < min) {
                    newWidth = min;
                    newLeft = right - newWidth;
                }

                DayPilotScheduler._resizingShadow.left = newLeft;
                DayPilotScheduler._resizingShadow.width = newWidth;
            }
            else {
                throw new DayPilot.Exception("Invalid dpBorder.");
            }


            (function checkOverlap() {
                DayPilotScheduler._resizingShadow.overlapping = false;

                var ev = DayPilotScheduler._resizing.event;
                var row = calendar.rowlist[ev.part.dayIndex];
                var left = newLeft;
                var width = newWidth;

                calendar._overlappingShadow(DayPilotScheduler._resizingShadow, row, left, width, ev.data);

                var shadow = DayPilotScheduler._resizingShadow;
                if (shadow.start) {
                    var position = {
                        "start": shadow.start,
                        "end": calendar._adjustEndOut(shadow.end)
                    };
                    calendar._checkDisabledCells(DayPilotScheduler._resizingShadow, position.start, position.end, row.id);
                }
            })();

            calendar._doEventResizing();

        };

        this._moveShadow = function() {

            var scroll = this.nav.scroll;
            if (!calendar.coords) {
                return;
            }

            if (!DayPilotScheduler._movingEvent) {
                return;
            }

            calendar._hideMessageNow();

            var shadow = DayPilotScheduler._movingShadow;
            var coords = this._getShadowCoords(DayPilotScheduler._movingEvent);

            if (calendar._isRowDisabled(coords.rowIndex, coords.grid)) {
                return;
            }

            var ev = DayPilotScheduler._movingEvent;

            var verticalAllowed = (ev.cache && typeof ev.cache.moveVDisabled !== 'undefined') ? !ev.cache.moveVDisabled : !ev.data.moveVDisabled;
            var horizontalAllowed = (ev.cache && typeof ev.cache.moveHDisabled !== 'undefined') ? !ev.cache.moveHDisabled :!ev.data.moveHDisabled;

            var multimove = !mm.additional().isEmpty();

            if (multimove && calendar.multiMoveVerticalMode === "Disabled") {
                verticalAllowed = false;
            }


            if (verticalAllowed && coords.grid !== shadow.grid) {
                shadow.parentNode.removeChild(shadow);
                calendar._grids[coords.grid].divShadow.appendChild(shadow);
                shadow.grid = coords.grid;
            }

            var linepos = 0;
            var relY = 0;
            (function calculatePosition() {

                if (calendar._cellStacking) {
                    var y = coords.relativeY;
                    var colindex = calendar._getItlineCellFromPixels(coords.left).x;
                    var row = coords.row;
                    var column = row.evColumns[colindex];
                    var e = column.events.find(function(e)  {
                        //return e.part.top <= y && y < e.part.top + e.part.height + calendar.eventMarginBottom;
                        return y < e.part.top + e.part.height + calendar.eventMarginBottom;
                    });
                    if (!e) {  // after last one
                        e = column.events.last();
                    }
                    if (e) {
                        relY = e.part.top;
                        linepos = indexOf(column.events, e);
                        if ((y - e.part.top) > e.part.height /2) {
                            relY = e.part.top + e.part.height + calendar.eventMarginBottom/2;
                            linepos += 1;
                        }
                    }
                }
                else {
                    var y = coords.relativeY;
                    var row = coords.row;
                    var top = 0;
                    // var top = row.marginTop;
                    var lh = calendar._resolved._eventHeight();
                    var max = row.lines.length;
                    for (var i = 0; i < row.lines.length; i++) {
                        var line = row.lines[i];
                        if (line._isFree(coords.left, calendar.cellWidth)) {
                            max = i;
                            break;
                        }
                    }

                    var pos = Math.floor((y - top + lh / 2) / lh);  // rounded position
                    pos = Math.min(max, pos);  // no more than max
                    pos = atLeast(0, pos);  // no less then 0

                    linepos = pos;
                    relY = calendar.rowMarginTop + linepos * (calendar._resolved._eventHeight() + calendar.eventMarginBottom) + calendar.eventMarginBottom/2;
                }
            })();

            if (relY > 0) {
                relY -= 3;
            }

            if (verticalAllowed) {
                if (!this._isRowDisabled(coords.rowIndex, coords.grid)) {
                    shadow.row = coords.row;
                    shadow.style.top = (shadow.row.top + shadow.row.marginTop) + 'px';
                    shadow.style.height = atLeast(shadow.row.height - shadow.row.marginTop - shadow.row.marginBottom, 0) + 'px';
                    if (calendar.eventMoveToPosition) {
                        shadow.style.top = (coords.top + relY) + "px";
                        shadow.style.height = "3px";
                        shadow.line = linepos;
                    }
                }
                else {
                    var oldRow = shadow.row;
                    var dir = 1;
                    if (oldRow) {
                        dir = coords.rowIndex < oldRow.index ? 1 : -1;
                    }
                    else {
                        //oldRow = { "index": 0};
                        return;
                    }

                    for (var i = coords.rowIndex; i !== oldRow.index; i += dir) {
                        var row = this.rowlist[i];
                        if (!this._isRowDisabled(i, coords.grid) && !row.hidden) {
                            // shadow.style.top = (row.top) + 'px';
                            // shadow.style.height = atLeast(row.height, 0) + 'px';

                            shadow.row = row;
                            shadow.style.top = (shadow.row.top + shadow.row.marginTop) + 'px';
                            shadow.style.height = atLeast(shadow.row.height - shadow.row.marginTop - shadow.row.marginBottom, 0) + 'px';


                            if (calendar.eventMoveToPosition) {
                                linepos = dir > 0 ? 0 : row.lines.length - 1;
                                shadow.style.top = (coords.top + relY) + "px";
                                shadow.style.height = "3px";
                                shadow.line = linepos;
                            }

                            break;
                        }
                    }
                }
            }
            else {
                var rowlist = calendar._grids[ev.part.grid].rowlist;
                var oldRow = rowlist[ev.part.dayIndex];
                //var oldRow = this.rowlist[this._getRow(parseInt(shadow.style.top)).i];

                var max = oldRow.lines.length;
                for (var i = 0; i < oldRow.lines.length; i++) {
                    var line = oldRow.lines[i];
                    if (line._isFree(coords.left, calendar.cellWidth)) {
                        max = i;
                        break;
                    }
                }

                if (!multimove) {
                    shadow.style.height = atLeast(oldRow.height, 0) + 'px';
                    shadow.style.top = (oldRow.top) + 'px';
                }
                shadow.row = oldRow;
                if (calendar.eventMoveToPosition && !multimove) {
                    if (coords.row === oldRow) {
                        shadow.style.top = (oldRow.top + relY) + "px";
                        shadow.style.height = "3px";
                        shadow.line = linepos;
                    }
                    else {
                        var pos = (coords.rowIndex > oldRow.index && max > 0) ? max * calendar._resolved._eventHeight() - 3 : 0;
                        shadow.style.top = (oldRow.top + pos) + "px";
                        shadow.style.height = "3px";
                        shadow.line = 0;
                    }
                }
            }

            if (horizontalAllowed) {
                shadow.style.left = coords.left + 'px';
                if (calendar.eventMoveToPosition) {
                    shadow.style.width = (calendar.cellWidth) + 'px';
                }
                else {
                    shadow.style.width = (coords.width) + 'px';
                }
                shadow.start = coords.start;
                shadow.end = coords.end;
            }
            else {
                shadow.style.left = ev.part.left + "px";
                shadow.start = ev.start();
                shadow.end = ev.rawend();

                coords.left = ev.part.left; // reset the value for overlap checking
            }

            (function checkOverlap() {
                shadow.overlapping = false;

                var row = shadow.row;
                var data = ev.data;
                var width = coords.width;
                var left = coords.left;

                var except = createList(mm.list).map(function(item) {return item.event.data;}).add(data);
                calendar._overlappingShadow(shadow, row, left, width, except);

                calendar._checkDisabledCells(DayPilotScheduler._movingShadow, shadow.start, shadow.end, shadow.row.id);

                //calendar._overlappingShadow(shadow, row, left, width, data);
            })();


            calendar._doEventMoving();
        };

        this._doEventMoving = function() {
            var shadow = DayPilotScheduler._movingShadow;
            var mm = calendar._multimove;
            var last = calendar._lastEventMoving;
            var ev = DayPilotScheduler._movingEvent;

            // don't fire the event if there is no change
            if (last) {
                var sameStart = last.start.getTime() === shadow.start.getTime();
                var sameEnd = last.end.getTime() === shadow.end.getTime();
                var sameResource = last.resource === shadow.row.id;
                var sameKeys = last.shift + "_" + last.ctrl + "_" + last.meta + "_" + last.alt === calendar.coords.shift + "_" + calendar.coords.ctrl + "_" + calendar.coords.meta + "_" + calendar.coords.alt;

                if (sameStart && sameEnd && sameResource && sameKeys) {
                    return;
                }
            }

            if (last) {
                removeClass(shadow, last.cssClass);
                shadow.firstChild.innerHTML = "";
            }

            // mm.update();
            mm.clear();
            mm._calculate();

            var external = (DayPilotScheduler._drag ? true : false) && ev.part.external;

            var args = {};
            args.start = shadow.start;
            args.end = calendar._adjustEndOut(shadow.end);
            args.duration = new DayPilot.Duration(args.start, args.end);
            args.e = ev;
            args.external = external;
            //args.row = shadow.row;
            args.control = calendar;
            args.resource = shadow.row.id;
            args.html = null;
            args.row = calendar._createRowObject(shadow.row);
            args.position = shadow.line;
            args.overlapping = shadow.overlapping || mm.forbidden;
            args.allowed = true;
            args.left = {};
            args.left.html = args.start.toString(calendar.eventMovingStartEndFormat, resolved._locale());
            args.left.enabled = calendar.eventMovingStartEndEnabled;
            args.left.space = 5;
            args.left.width = null;
            args.left.height = calendar.eventHeight;
            args.right = {};
            args.right.html = args.end.toString(calendar.eventMovingStartEndFormat, resolved._locale());
            args.right.enabled = calendar.eventMovingStartEndEnabled;
            args.right.space = 5;
            args.right.width = null;
            args.right.height = calendar.eventHeight;
            args.multimove = mm._listCopy();
            args.shift = calendar.coords.shift;
            args.ctrl = calendar.coords.ctrl;
            args.meta = calendar.coords.meta;
            args.alt = calendar.coords.alt;
            args.areaData = DpGlobal.movingAreaData;
            args.link = null;
            args.cssClass = null;
            args.html = null;

            var info = {};
            info.event = ev;
            info.start = args.start;
            info.end = args.end;
            info.overlapping = args.overlapping;
            info.resource = args.resource;
            //info.overlapping = false;  // always false, this event is not fired if overlapping is forbidden
            args.multimove.splice(0, 0, info);

            calendar._lastEventMoving = args;

            var original = {
                "start": args.start,
                "end": args.end,
                "resource": args.resource
            };

            if (typeof calendar.onEventMoving === 'function') {
                calendar.onEventMoving(args);
            }

            if (!DayPilotScheduler._moving) {
                return;
            }

            mm.list = createList(args.multimove, true);
            mm.list.splice(0, 1);

            mm._draw();

            shadow.allowed = args.allowed;

            addClass(shadow, args.cssClass);

            if (args.html) {
                shadow.firstChild.innerHTML = args.html;
            }

            if (args.start !== original.start || args.end !== original.end) {
                // allow adjusting the start and end
                var start = args.start;
                var end = calendar._adjustEndIn(args.end);

                shadow.start = start;
                shadow.end = end;

                var duration = DayPilot.DateUtil.diff(start, end);
                duration = atLeast(duration, 1);

                var useBox = resolved._useBox(duration);

                var left = useBox ? calendar.getPixels(start).boxLeft : calendar.getPixels(start).left;
                var right = useBox ? calendar.getPixels(end).boxRight : calendar.getPixels(end).left;
                shadow.style.left = left + "px";
                shadow.style.width = (right - left) + "px";
            }


            // updated resource, line and relY need to be recalculated
            if (args.resource !== original.resource) {
                var row = calendar._findRowByResourceId(args.resource);
                if (row) {
                    shadow.row = row;
                    shadow.style.height = atLeast(row.height, 0) + 'px';
                    shadow.style.top = (row.top) + 'px';
                    if (calendar.eventMoveToPosition) {
                        var relY = calendar.rowMarginTop;
                        var linepos = 0;
                        shadow.style.top = (row.top + relY) + "px";
                        shadow.style.height = "3px";
                        shadow.line = linepos;
                    }
                }
            }

            if (args.html) {
                shadow.firstChild.innerHTML = args.html;
            }
            else {
                shadow.firstChild.innerHTML = "";
            }

            calendar._disabledShadow(shadow, args);

            calendar._showShadowHover(shadow, args);

            if (DpGlobal.movingLink) {
                DpGlobal.movingLink.clear();
            }

            if (args.link) {
                DpGlobal.movingLink = linktools._drawLink2(args.link.from, shadow, args.link);
            }

        };

        this._overlappingShadow = function(shadow, row, left, width, data) {

            if (calendar.allowEventOverlap) {
                return;
            }

            (function calculate() {
                shadow.overlapping = false;
                for (var i = 0; i < row.lines.length; i++) {
                    var line = row.lines[i];
                    if (!line._isFree(left, width, data)) {
                        shadow.overlapping = true;
                        return;
                    }
                }

                var rowy = row.index;  // correct ?

                var overlapsWithMultiRange = createList(mr.list).some(function(item) {
                    var div = item.div;

                    var rleft = parseInt(div.style.left);
                    var rwidth = parseInt(div.style.width);
                    var ry = item.start.y;
                    if (shadow === div) {
                        return false;
                    }
                    if (ry !== rowy) {
                        return false;
                    }
                    return overlaps(left, left + width, rleft, rleft + rwidth);
                });

                if (overlapsWithMultiRange) {
                    shadow.overlapping = true;
                    return;
                }

                var overlapsWithMultiMove = createList(mm.divs).some(function(div) {
                    // var div = item.div;
                    var item = div.info;


                    var rleft = parseInt(div.style.left);
                    var rwidth = parseInt(div.style.width);
                    var ry = item.$._row.index;
                    if (shadow === div) {
                        return false;
                    }
                    if (ry !== rowy) {
                        return false;
                    }
                    return overlaps(left, left + width, rleft, rleft + rwidth);
                });

                if (overlapsWithMultiMove) {
                    shadow.overlapping = true;
                    return;
                }

                var overlapsWithMultiRange = createList(mre.divs).some(function(div) {
                    // var div = item.div;
                    var item = div.info;

                    var rleft = parseInt(div.style.left);
                    var rwidth = parseInt(div.style.width);
                    var ry = item.$._row.index;
                    if (shadow === div) {
                        return false;
                    }
                    if (ry !== rowy) {
                        return false;
                    }
                    return overlaps(left, left + width, rleft, rleft + rwidth);
                });

                if (overlapsWithMultiRange) {
                    shadow.overlapping = true;
                    return;
                }

            })();

            var overlapping = shadow.overlapping;

            var cssClass = calendar._prefixCssClass("_shadow_overlap");
            if (overlapping) {
                addClass(shadow, cssClass);
            }
            else {
                removeClass(shadow, cssClass);
            }
        };

        this._checkDisabledCells = function(shadow, start, end, resource) {

            var disabled = calendar._overDisabledCells(start, end, resource);

            // prevent clearing an already set value (event overlap)
            if (disabled) {
                shadow.overlapping = true;
            }


            var cssClass = calendar._prefixCssClass("_shadow_overlap");
            if (shadow.overlapping) {
                addClass(shadow, cssClass);
            }
            else {
                removeClass(shadow, cssClass);
            }

        };

        this._overDisabledCells = function(start, end, resource) {

            var hasDisabled = (calendar.cellConfig && calendar.cellConfig.hasDisabled) || calendar._bcrCache._dirtyDisabled;
            if (!hasDisabled) {
                return false;
            }

            var rowStart = null;
            if (calendar.viewType === "Days") {
                rowStart = calendar._getRowStartInDaysView(start);
            }
            var cells = calendar.rows.find(resource, rowStart).cells.forRange(start, end);
            if (!cells) {
                return false;
            }
            var disabled = cells.some(function(cell) {
                return cell.properties.disabled;
            });
            return disabled;
        };

        this._disabledShadow = function(shadow, args) {
            var cssClass = calendar._prefixCssClass("_shadow_forbidden");
            if (!args.allowed || mm.invalid) {
                addClass(shadow, cssClass);
            }
            else {
                removeClass(shadow, cssClass);
            }
        };

        this._showShadowHover = function(shadow, args) {

            /*
             * uses:
             *
             * args.left.width (optional)
             * args.left.height
             * args.left.space
             * args.left.html
             * args.left.enabled
             *
             * args.right.width (optional)
             * args.right.height
             * args.right.space
             * args.right.html
             * args.right.enabled
             *
             */

            var space = 5;

            this._clearShadowHover();

            if (shadow.calendar !== calendar) {
                // touch moving between two schedulers
                return;
            }

            var grid = calendar._gridInfo(shadow.grid);

            var pos = {};
            pos.left = parseInt(shadow.style.left);
            pos.top = parseInt(shadow.style.top);
            pos.right = pos.left + parseInt(shadow.style.width);

            var width = args.left.width || 10;

            var left = createDiv();
            left.style.position = "absolute";
            left.style.left = (pos.left - width - args.left.space) + "px";
            left.style.top = pos.top + "px";
            left.style.height = args.left.height + "px";
            left.style.overflow = "hidden";
            left.style.boxSizing = "border-box";
            left.innerHTML = args.left.html;
            left.className = calendar._prefixCssClass("_event_move_left");
            left.onmousemove = calendar._onMaindMouseMove;

            if (DayPilot.browser.ie) {
                left.style.display = "block";
            }

            if (args.left.enabled) {
                grid.divHover.appendChild(left);

                if (args.left.width) {
                    left.style.width = width + "px";
                }
                else {
                    left.style.whiteSpace = "nowrap";
                    var nwidth = left.offsetWidth;
                    var nleft = pos.left - nwidth - args.left.space;
                    left.style.width = nwidth + "px";
                    left.style.left = nleft + "px";

                    var scrollPx = calendar.nav.scroll.scrollLeft;
                    if (nleft < scrollPx) {
                        grid.divHover.removeChild(left);
                    }

                    var outleft = calendar._getOuterRowHeaderWidth() + (nleft - scrollPx);

                    if (outleft > 0) {
                        left.style.left = outleft + "px";
                        // left.style.top = (pos.top - calendar.nav.scroll.scrollTop + grid.top) + "px";
                        left.style.top = (pos.top - grid.div.scrollTop + grid.top) + "px";

                        calendar.nav.top.appendChild(left);
                        calendar.elements.hover.push(left);
                    }
                }
            }

            var width = args.right.width || 10;
            var right = createDiv();
            right.style.position = "absolute";
            right.style.left = (pos.right + args.right.space) + "px";
            right.style.top = pos.top + "px";
            right.style.height = args.right.height + "px";
            right.style.overflow = "hidden";
            right.style.boxSizing = "border-box";
            if (args.right.width) {
                right.style.width = args.right.width + "px";
            }
            else {
                right.style.whiteSpace = "nowrap";
            }
            right.innerHTML = args.right.html;
            right.className = this._prefixCssClass("_event_move_right");
            right.onmousemove = calendar._onMaindMouseMove;

            if (DayPilot.browser.ie) {
                right.style.display = "block";
            }

            if (args.right.enabled) {
                grid.divHover.appendChild(right);
                var totalPx = calendar.nav.scroll.scrollWidth;
                var rightPx = pos.right + args.right.space + right.offsetWidth;
                if (rightPx >= totalPx) {
                    grid.divHover.removeChild(right);
                }
            }

        };

        this._clearShadowHover = function() {
            calendar.divHover.innerHTML = ''; // clear
            calendar._grids.top.divHover.innerHTML = '';
            calendar._grids.bottom.divHover.innerHTML = '';
            deleteElement(calendar.elements.hover);
            calendar.elements.hover = [];
        };

        this._loadRowHeaderColumns = function() {
            var defaultWidth = calendar.rowHeaderColumnDefaultWidth;

            if (this.rowHeaderColumns) {
                var rhc = resolved._rowHeaderColumnsVisible();
                this.rowHeaderCols = DayPilot.Util.propArray(rhc, "width", defaultWidth);
            }
            else {
                this.rowHeaderCols = null;
            }
        };

        this._getTotalRowHeaderWidth = function() {
            var totalWidth = 0;
            this._loadRowHeaderColumns();
            if (this.rowHeaderCols) {
                for (var i = 0; i < this.rowHeaderCols.length; i++) {
                    totalWidth += this.rowHeaderCols[i];
                }
            }
            else {
                totalWidth = this.rowHeaderWidth;
            }
            return totalWidth;
        };

        this._getAreaRowsWithMargin = function() {
            return this._getAreaRows(calendar.progressiveRowRenderingPreload);
        };

        this._getAreaRows = function(margin) {
            //var margin = calendar.progressiveRowRenderingPreload;
            var margin = margin || 0;

            var start = 0;
            var end = calendar.rowlist.length;
            var progressive = calendar.progressiveRowRendering;
            if (progressive) {
                var area = calendar._getDrawArea();
                start = area.yStart;

                (function adjustForSplit() {
                    var row = calendar.rowlist[start];
                    var parent = row && row.split && row.split.parent;
                    if (parent) {
                        start = parent.index;
                    }
                })();

                end = area.yEnd + 1;

                start = atLeast(0, start - margin);
                end = Math.min(calendar.rowlist.length, end + margin);
            }

            return {
                "start": start,
                "end": end
            }
        };

        this._autoRowHeaderWidth = function() {
            if (!this._visible()) {   // not visible, doesn't make sense now
                return;
            }

            var needsUpdate = false;
            var maxAll = 0;

            if (this.rowHeaderWidthAutoFit) {
                var table = this.divHeader;

                if (!table) {
                    return;
                }

                if (!table.rows) {
                    return;
                }

                var max = [];

                this._loadRowHeaderColumns();

                var shrink = calendar.rowHeaderWidthAutoFitShrink;
                if (shrink) {

                    if (!calendar.rowHeaderScrolling) {
                        calendar.rowHeaderWidth = 0;
                    }
                    if (calendar.rowHeaderCols) {
                        calendar.rowHeaderCols.forEach(function(c, i) {
                            calendar.rowHeaderCols[i] = 0;
                        });
                    }
                }

                var range = calendar._getAreaRowsWithMargin();

                adjustTable("main", range.start, range.end);
                if (calendar._grids.top.enabled()) {
                    adjustTable( "top",0, calendar._grids.top.divHeader.rows.length);
                }
                if (calendar._grids.bottom.enabled()) {
                    adjustTable( "bottom",0, calendar._grids.bottom.divHeader.rows.length);
                }

                function adjustTable(grid, start, end) {
                    var table = calendar._gridInfo(grid).divHeader;
                    for (var i = start; i < end; i++) {
                        var row = table.rows[i];
                        if (!row) {
                            continue;
                        }
                        var info = {
                            "row": row,
                            "grid": grid,
                            "i": i
                        };
                        calendar._autoAdjustRowWidth(info, max);
                    }
                }

                if (this.rowHeaderCols) {
                    for (var i = 0; i < max.length; i++) {
                        if (typeof this.rowHeaderCols[i] === "number") {
                            if (max[i] > this.rowHeaderCols[i]) {
                                this.rowHeaderCols[i] = max[i];
                                needsUpdate = true;
                            }
                            maxAll += this.rowHeaderCols[i];
                        }
                    }
                }
                else {
                    maxAll = this.rowHeaderWidth;
                    var splitterWidth = resolved._splitterWidth();
                    if (this.rowHeaderWidth < max[0] + calendar.rowHeaderWidthMarginRight + splitterWidth) {
                        maxAll = max[0] + calendar.rowHeaderWidthMarginRight + splitterWidth;
                        needsUpdate = true;
                    }
                }

            }

            if (needsUpdate) {
                if (this._splitter) {
                    // update header
                    this._splitter.widths = this.rowHeaderCols;
                    this._splitter.updateWidths();
                    // update cells
                    DayPilot.Util.updatePropsFromArray(resolved._rowHeaderColumnsVisible(), "width", this.rowHeaderCols);
                }

                // testing: it needs to be adjusted even for rowHeaderScrolling = true

                // if (!this.rowHeaderScrolling) {
                if (!this.rowHeaderCols) {
                    this.rowHeaderWidth = maxAll;
                }

                this._updateRowHeaderWidth();
                this._updateAutoCellWidth();
            }

        };


        this._autoAdjustRowWidth = function(info, max) {
            var tableRow = info.row;
            var grid = calendar._gridInfo(info.grid);
            var row = grid.rowlist[info.i];
            var cols = calendar.rowHeaderColumns;

            if (row.hidden) {
                return;
            }

            for (var j = 0; j < tableRow.cells.length; j++) {
                if (!tableRow.cells[j]) {
                    continue;
                }
                /*if (!row.cells[j].firstChild) {
                    continue;
                }*/
                if (typeof tableRow.cells[j]._w === "number") {
                    continue;
                }
                var inner = tableRow.cells[j].firstChild.firstChild;
                if (!inner || !inner.style) {
                    continue;
                }
                var oldWidth = inner.style.width;
                var oldRight = inner.style.right;
                var oldDisplay = inner.style.display;
                inner.style.position = "absolute";
                inner.style.width = "auto";
                inner.style.right = "auto";
                inner.style.whiteSpace = "nowrap";
                inner.style.display = "block";

                var w = inner.offsetWidth + 2;
                tableRow.cells[j]._w = w;
                inner.style.position = "";
                inner.style.width = oldWidth;
                inner.style.right = oldRight;
                inner.style.display = oldDisplay;
                inner.style.whiteSpace = "";

            }
            for (var j = 0; j < tableRow.cells.length; j++) {
                if (!tableRow.cells[j]) {
                    //max[j] = 0;
                    continue;
                }
                var w = tableRow.cells[j]._w;
                if (typeof max[j] === 'undefined') { max[j] = 0; }

                if (cols && cols[j]) {
                    // row header column, maxWidth
                    if (typeof cols[j].maxAutoWidth === "number") {
                        var colMax = cols[j].maxAutoWidth;
                        w = Math.min(w, colMax);
                    }
                }

                max[j] = Math.max(max[j], w);
            }
        };

        this._drawResHeader = function() {

            this._resHeaderDivBased = true;

            //DayPilot.puc(parent);
            //parent.innerHTML = '';

            this._loadRowHeaderColumns();

            //var rowHeaderCols = this.rowHeaderCols;
            //var columns = rowHeaderCols ? this.rowHeaderCols.length : 0;
            var totalWidth = this._getTotalRowHeaderWidth();

            var wrap = this.divHeader;
            wrap.style.width = totalWidth + "px";
            wrap.style.height = calendar._innerHeightTree + "px";
            calendar._grids.main.divHeader = wrap;

            var progressive = calendar.progressiveRowRendering;
            if (progressive) {
                doNothing();
            }
            else {
                var m = this.rowlist.length;
                for (var i = 0; i < m; i++) {
                    calendar._drawRow(i);
                }
            }

            if (calendar._grids.top.enabled()) {
                for (var i = 0; i < calendar._grids.top.rowlist.length; i++) {
                    calendar._drawRow(i, "top");
                }
            }

            if (calendar._grids.bottom.enabled()) {
                for (var i = 0; i < calendar._grids.bottom.rowlist.length; i++) {
                    calendar._drawRow(i, "bottom");
                }
            }

            calendar._drawResScrollSpace();

            this.divResScroll.appendChild(wrap);

            if (this.rowHeaderWidthAutoFit) {
                this._autoRowHeaderWidth();
            }


        };


        this._deleteRowHeaders = function() {

            clearGridHeader("main");
            clearGridHeader("top");
            clearGridHeader("bottom");

            function clearGridHeader(grid) {
                var gi = calendar._gridInfo(grid);
                var divHeader = gi.divHeader;

                var content = divHeader;
                if (divHeader._content) {
                    content = divHeader._content;
                }

                calendar._disposeRows(grid);

                if (content) {
                    if (DayPilot.browser.ie) {
                        for (var i = 0; i < content.childNodes.length; i++) {
                            deleteElement(content.childNodes[i]);
                        }
                    }
                    content.innerHTML = '';
                    DayPilot.puc(content);
                }

                if (divHeader) {
                    divHeader.rows = [];
                }


            }

        };

        this._drawResHeadersProgressive = function() {

            if (!calendar.progressiveRowRendering) {
                return;
            }

            var area = this._getAreaRowsWithMargin();

            for (var i = 0; i < calendar.rowlist.length; i++) {
                if (area.start <= i && i < area.end) {
                    calendar._drawRow(i);
                }
                else {
                    calendar._deleteRow(i);
                }
            }

            if (this.rowHeaderWidthAutoFit && !DayPilotScheduler._splitting) {
                var originalWidth = calendar._getOuterRowHeaderWidth();
                this._autoRowHeaderWidth();
                var newWidth = calendar._getOuterRowHeaderWidth();
                if (newWidth !== originalWidth) {
                    var originalCellWidth = this.cellWidth;
                    this._calculateCellWidth();
                    var newCellWidth = this.cellWidth;
                    if (newCellWidth !== originalCellWidth) {
                        calendar._prepareItline();
                        calendar._updateCorner();
                        calendar._drawTimeHeader();
                        calendar._updateHeight();
                        calendar._loadEvents();
                        calendar._deleteLines();
                    }
                }
            }

        };

        this._drawResScrollSpace = function() {

            if (calendar._resolved._mobile()) {
                return;
            }

            var wrap = calendar.divHeader;

            var c = createDiv();
            c.style.position = "absolute";
            //c.colSpan = columns + 1;
            wrap.appendChild(c);

            calendar.nav.resScrollSpace = c;

            c.setAttribute("unselectable", "on");

            var div = createDiv();
            div.style.position = "relative";
            div.style.height = "100%";
            div.className = this._prefixCssClass("_rowheader");
            c.appendChild(div);


            var totalWidth = this._getTotalRowHeaderWidth();

            var c = calendar.nav.resScrollSpace;
            c.style.width = totalWidth + "px";
            c.style.top = this._innerHeightTree + "px";
            // c.style.height = (calendar.divResScroll.clientHeight + frozenBottomHeight + 20) + "px";

        };

        this._deleteRow = function(i, gridName) {

            var grid = calendar._gridInfo(gridName);

            var row = grid.divHeader.rows[i];

            if (!row) {
                return;
            }

            // var div = row.cells[0];
            if (row) {
                // var domArgs = div.domArgs;
                var domArgs = row.domArgs;
                row.domArgs = null;

                if (domArgs && typeof calendar.onBeforeRowHeaderDomRemove === "function") {
                    // only the first column supported in this version
                    // var domArgs = div.domArgs;
                    calendar.onBeforeRowHeaderDomRemove(domArgs);
                }

                if (domArgs && typeof calendar.onBeforeRowHeaderDomAdd === "function" && calendar._react.reactDOM) {
                    var target = domArgs && domArgs._targetElement;
                    if (target) {
                        var isReact = isReactCmp(domArgs.element);
                        if (isReact) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._unmount(target);
                        }
                    }
                }

                if (domArgs) {
                    domArgs.element = null;
                    domArgs._targetElement = null;
                }
            }

            deleteElement(row.cells);
            grid.divHeader.rows[i] = null;
        };

        // freeze ok
        this._drawRowForced = function(i, gridName) {
            this._deleteRow(i, gridName);
            this._drawRow(i, gridName);
        };

        this._isTabularMode = function() {
            return calendar.rowHeaderColumnsMode === "Standard" || calendar.rowHeaderColumnsMode === "Tabular";
        };

        // resource[].tags.property first, then resource[].property
        this._getTabularValue = function(res, propertyName) {
            var tagVal = undefined;
            if (res.tags) {
                tagVal = res.tags[propertyName];
            }
            //res.tags && res.tags[propertyName];
            if (typeof tagVal !== "undefined") {
                return tagVal;
            }
            return res[propertyName];
        };

        this._setTabularValue = function(res, propertyName, value) {
            if (res.tags) {
                if (typeof res.tags[propertyName] !== "undefined") {
                    res.tags[propertyName] = value;
                    return;
                }
            }
            res[propertyName] = value;
        }

        this._drawRow = function(i, gridName) {

            var grid = calendar._gridInfo(gridName);
            var rowlist = grid.rowlist;

            var divHeader = grid.divHeader;
            var wrap = divHeader;
            if (divHeader._content) {
                wrap = divHeader._content;
            }

            if (!divHeader) {
                // ResizeObserver fires this in shortInit() when it's not rendered yet.
                return;
            }

            if (divHeader.rows[i]) { // already rendered
                return;
            }

            var rowHeaderCols = this.rowHeaderCols;
            var row = rowlist[i];

            if (!row) {  // not found
                return;
            }

            //var node = this.tree[i];
            if (row.hidden) {
                return;
            }

            var selected = rowsel._cache[i];

            var height = row.height;
            var cellInfo = row.cells && row.cells[0];
            if (cellInfo && cellInfo.rowspan > 1) {
                height = cellInfo.row.split.totalHeight();
            }

            var pargs = null;
            if (row.split && row.split.parent && row.split._isFirstVisible()) {
                pargs = calendar._doBeforeRowHeaderRender(row.split.parent);
            }
            var args = this._doBeforeRowHeaderRender(row);

            var showColumns = rowHeaderCols && args.row.columns && args.row.columns.length > 0;
            var columns = showColumns ? this.rowHeaderCols.length : 0;
            var totalWidth = this._getTotalRowHeaderWidth();

            divHeader.rows[i] = {};
            divHeader.rows[i].cells = [];

            var c = createDiv();
            c.style.position = "absolute";
            c.style.top = row.top + "px";

            c.row = pargs ? row.split.parent : row;
            c.index = i;
            c.column = 0;

            var props = args.row;

            var col = pargs ? pargs.row : props;

            var isTabular = calendar._isTabularMode();
            var isParent = row.children.length > 0;
            var useStandardColumns = calendar.internalUseStandardColumns && !row.isNewRow;
            var rhcDefined = DayPilot.isArray(calendar.rowHeaderColumns);
            var standardGlobalColumns = useStandardColumns || (isTabular && rhcDefined);

            var filteredColumns = createList(args.row.columns);
            if (pargs && rhcDefined &&  args.row.columns.length === calendar.rowHeaderColumns.length) {
                calendar.rowHeaderColumns.forEach(function(coldef, i) {
                    if (!coldef.split) {
                        filteredColumns[i] = pargs.row.columns[i];
                    }
                });
            }

            // skip hidden columns, only for rowHeaderColumns defined or passed from Gantt
            if (standardGlobalColumns) {
                filteredColumns = filteredColumns.filter(function(col, i) { return !calendar.rowHeaderColumns[i].hidden;});
                columns = filteredColumns.length;
            }

            var useCol = !(calendar.rowHeaderColumnsMergeParents && isParent);
            if (standardGlobalColumns && useCol) {
                col = filteredColumns[0] || args.row;

                var firstColDef = calendar.rowHeaderColumns.find(function(col) { return !col.hidden;});
                if (firstColDef && firstColDef.split) {
                    c.row = row;
                }
            }

            if (calendar._serverBased()) {
                col = args.row;
            }

            var width = showColumns ? rowHeaderCols[0] : totalWidth;
            c.style.width = (width) + "px";
            c.style.border = "0px none";

            var toolTip = col.toolTip || props.toolTip;
            if (toolTip) {
                c.title = toolTip;
            }
            c.setAttribute("unselectable", "on");

            if (typeof props.ariaLabel !== "undefined") {
                c.setAttribute("aria-label", props.ariaLabel);
            }
            else {
                c.setAttribute("aria-label", col.text || "");
            }
            //c.setAttribute('resource', row.id);

            c.onmouseenter = calendar._onRowMouseEnter;
            c.onmouseleave = calendar._onRowMouseLeave;
            c.onmousemove = calendar._onResMouseMove;
            c.onmouseout = calendar._onResMouseOut;
            c.onmouseup = calendar._onResMouseUp;
            c.oncontextmenu = calendar._onResRightClick;
            c.onclick = calendar._onResClick;
            c.ondblclick = calendar._onResDoubleClick;

            DayPilot.rePassive(c, "touchstart", calendar._touch._onRowTouchStart);
            DayPilot.reNonPassive(c, "touchend", calendar._touch._onRowTouchEnd);

            var div = createDiv();
            div.style.width = (width) + "px";
            div.setAttribute("unselectable", "on");
            div.className = this._prefixCssClass('_rowheader');
            if (selected) {
                addClass(div, calendar._prefixCssClass("_rowheader_selected"));
            }
            if (props.cssClass) {
                addClass(div, props.cssClass);
            }
            if (col.cssClass) {
                addClass(div, col.cssClass);
            }
            var backColor = col.backColor || props.backColor;
            if (backColor) {
                div.style.background = backColor;
            }
            var fontColor = col.fontColor || props.fontColor;
            if (fontColor) {
                div.style.color = fontColor;
            }
            var horizontalAlignment = col.horizontalAlignment || props.horizontalAlignment;

            // not allowed if tree is enabled
            if (calendar.treeEnabled) {
                horizontalAlignment = null;
            }
            if (horizontalAlignment) {
                div.style.textAlign = horizontalAlignment;
            }
            div.style.height = (height) + "px";
            div.style.overflow = 'hidden';
            div.style.position = 'relative';

            var inner = createDiv();
            inner.setAttribute("unselectable", "on");
            inner.className = this._prefixCssClass('_rowheader_inner');

            switch (horizontalAlignment) {
                case "right":
                    inner.style.justifyContent = "flex-end";
                    break;
                case "left":
                    inner.style.justifyContent = "flex-start";
                    break;
                case "center":
                    inner.style.justifyContent = "center";
                    break;
            }

            div.appendChild(inner);

            var moving = this.rowMoveHandling !== "Disabled" && row.grid === "main";
            var dragHandleWidth = calendar.rowDragHandleWidth;

            var areas = col.areas || [];

            if (moving && !props.moveDisabled) { // add moving handle
                areas.push({
                    "v": "Hover",
                    "w": dragHandleWidth,
                    "bottom": 0,
                    "top": 0,
                    "left": 0,
                    "css": calendar._prefixCssClass("_rowmove_handle"),
                    "action": "Move"
                });
            }

            var ro = calendar._createRowObject(row);
            DayPilot.Areas.attach(div, ro, {
                "areas": areas,
                "allowed": function() { return !rowmoving.row; }
            });

            var border = createDiv();
            border.style.position = "absolute";
            border.style.bottom = "0px";
            border.style.width = "100%";
            border.style.height = "0px";
            border.style.boxSizing = "content-box";
            border.style.borderBottom = "1px solid transparent";
            border.className = this._prefixCssClass(cssNames.resourcedivider);
            div.appendChild(border);

            function drawText2() {

                var wrap = createDiv();
                if (calendar.treeEnabled  && !row.isNewRow) {

                    var left = row.level * calendar.treeIndent + calendar.treeImageMarginLeft;
                    if (moving) {
                        left += dragHandleWidth;
                    }
                    var width = calendar.treeImageWidth;
                    var height = calendar.treeImageHeight;

                    wrap.style.marginLeft = left + 'px';
                    wrap.style.position = "relative";
                    wrap.className = calendar._prefixCssClass("_rowheader_inner_indent");

                    var expand = createDiv();

                    expand.style.width = width + "px";
                    expand.style.height = height + "px";
                    expand.style.backgroundRepeat = "no-repeat";
                    expand.style.position = 'absolute';
                    expand.style.top = calendar.treeImageMarginTop + "px";
                    // expand.style.display = "inline-block";

                    if (!row.loaded && row.children.length === 0) {
                        expand.className = calendar._prefixCssClass('_tree_image_expand');
                        expand.style.cursor = 'pointer';
                        expand.index = i;
                        expand.onclick = function(ev) { calendar._loadNode(this.index); ev.cancelBubble = true; };
                    }
                    else if (row.children.length > 0) {
                        if (row.expanded) {
                            expand.className = calendar._prefixCssClass('_tree_image_collapse');
                        }
                        else {
                            expand.className = calendar._prefixCssClass('_tree_image_expand');
                        }

                        expand.style.cursor = 'pointer';
                        expand.index = i;
                        expand.onclick = function(ev) { calendar._toggle(this.index); ev.cancelBubble = true; };
                    }
                    else {
                        expand.className = calendar._prefixCssClass('_tree_image_no_children');
                    }

                    wrap.appendChild(expand);

                }

                var text = createDiv();
                if (calendar.treeEnabled) {
                    // text.style.marginLeft = (left + width) + "px";
                    var marginRight = calendar.treeImageMarginRight;
                    text.style.marginLeft = (width + marginRight) + "px";
                }
                // text.style.display = "inline-block";
                // text.innerHTML = col.html || col.text || "";
                text.innerHTML = calendar._xssTextHtml(col.text, col.html);
                text.className = calendar._prefixCssClass("_rowheader_inner_text");
                c.textDiv = text;
                c.cellDiv = div;

                wrap.appendChild(text);

                inner.appendChild(wrap);

                var va = col.verticalAlignment || props.verticalAlignment;

                if (va) {
                    inner.style.display = "flex";
                    switch (va) {
                        case "center":
                            inner.style.alignItems = "center";
                            break;
                        case "top":
                            inner.style.alignItems = "flex-start";
                            break;
                        case "bottom":
                            inner.style.alignItems = "flex-end";
                            break;
                    }
                }
            }

            drawText2();


            c.appendChild(div);

            (function domAdd() {

                if (typeof calendar.onBeforeRowHeaderDomAdd !== "function" && typeof calendar.onBeforeRowHeaderDomRemove !== "function") {
                    return;
                }

                // this is the first cell, needs update
                var div = c;

                var args = {};
                args.control = calendar;
                args.row = calendar._createRowObject(row);
                args.element = null;
                args.target = "Cell";

                // div.domArgs = args;
                divHeader.rows[i].domArgs = args;

                if (typeof calendar.onBeforeRowHeaderDomAdd === "function") {
                    calendar.onBeforeRowHeaderDomAdd(args);
                }

                if (args.element) {
                    var target = null;
                    switch (args.target && args.target.toLowerCase()) {
                        case "text":
                            target = text;
                            break;
                        case "cell":
                            target = inner;
                            break;
                    }
                    if (target) {
                        args._targetElement = target;
                        target.innerHTML = "";

                        var isReactComponent = isReactCmp(args.element);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }

            })();

            var dontRender = cellInfo && cellInfo.refCell;
            if (!dontRender) {
                wrap.appendChild(c);
                divHeader.rows[i].cells[0] = c;
            }

            var mergedParent = !row.isNewRow && calendar.rowHeaderColumnsMergeParents && args.row.children().length > 0;

            if (!args.row.columns || args.row.columns.length === 0 || mergedParent) {
                c.colSpan = "max";
                div.style.width = totalWidth + "px";
            }
            else {
                var left = width;

                var shift = (useStandardColumns || isTabular) ? 0 : 1;
                for (var j = 1; j < columns; j++) {
                    var col = filteredColumns[j - shift] || {};

                    var cellInfo = row.cells[j-shift];
                    var height = row.height;
                    if (cellInfo.rowspan > 1) {
                        height = cellInfo.row.split.totalHeight();
                    }

                    var c = createDiv();
                    c.style.position = "absolute";
                    c.style.top = row.top + "px";
                    c.style.left = left + "px";

                    if (!cellInfo.refCell) {
                        wrap.appendChild(c);
                        // shift is incorrect here (for the legacy mode)
                        // divHeader.rows[i].cells[j-shift] = c;
                        divHeader.rows[i].cells[j] = c;
                    }

                    c.row = row;
                    c.index = i;
                    c.column = j;

                    var colToolTip = col.toolTip || props.toolTip;
                    if (colToolTip) {
                        c.title = colToolTip;
                    }
                    c.setAttribute("unselectable", "on");

                    // c.onmouseenter = calendar._doRowMouseEnter;
                    c.onmousemove = calendar._onResMouseMove;
                    c.onmouseout = calendar._onResMouseOut;
                    c.onmouseup = calendar._onResMouseUp;
                    c.oncontextmenu = calendar._onResRightClick;
                    c.onclick = calendar._onResClick;
                    c.ondblclick = calendar._onResDoubleClick;

                    var div = createDiv();
                    var w = rowHeaderCols[j];
                    left += w;

                    var backColor = col.backColor || props.backColor;
                    if (backColor) {
                        div.style.backgroundColor = backColor;
                    }

                    var fontColor = col.fontColor || props.fontColor;
                    if (fontColor) {
                        div.style.color = fontColor;
                    }

                    div.style.width = w + "px";
                    div.style.height = (height) + "px";
                    div.style.overflow = 'hidden';
                    div.style.position = 'relative';
                    div.setAttribute("unselectable", "on");
                    addClass(div, this._prefixCssClass("_rowheader"));
                    addClass(div, this._prefixCssClass("_rowheadercol"));
                    addClass(div, this._prefixCssClass("_rowheadercol" + j));
                    if (selected) {
                        addClass(div, calendar._prefixCssClass("_rowheader_selected"));
                    }
                    if (props.cssClass) {
                        addClass(div, props.cssClass);
                    }
                    if (col.cssClass) {
                        addClass(div, col.cssClass);
                    }
                    var colha = col.horizontalAlignment || props.horizontalAlignment;
                    if (colha) {
                        div.style.textAlign = colha;
                    }

                    var inner = createDiv();
                    //inner.style.position = 'absolute';
                    inner.setAttribute("unselectable", "on");
                    inner.className = this._prefixCssClass("_rowheader_inner");

                    switch (colha) {
                        case "right":
                            inner.style.justifyContent = "flex-end";
                            break;
                        case "left":
                            inner.style.justifyContent = "flex-start";
                            break;
                        case "center":
                            inner.style.justifyContent = "center";
                            break;
                    }

                    div.appendChild(inner);

                    var border = createDiv();
                    border.style.position = "absolute";
                    border.style.bottom = "0px";
                    border.style.width = "100%";
                    border.style.height = "0px";
                    border.style.boxSizing = "content-box";
                    border.style.borderBottom = "1px solid transparent";
                    border.className = this._prefixCssClass("_resourcedivider");
                    div.appendChild(border);

                    var text = createDiv();

                    // var innerHTML = col.html || col.text || "";
                    var innerHTML = calendar._xssTextHtml(col.text, col.html);

                    text.innerHTML = innerHTML;
                    c.textDiv = text;
                    c.cellDiv = div;

                    inner.appendChild(text);

                    DayPilot.Areas.attach(div, ro, {
                        "areas": col.areas,
                        "allowed": function() { return !rowmoving.row; }
                    });

                    c.appendChild(div);
                }
            }
        };


        this._onResRightClick = function(ev) {

            if (calendar.rowRightClickHandling === "Disabled") {
                return false;
            }

            var rowFromList = this.row;

            var row = calendar._createRowObject(rowFromList);

            var args = {};

            args.ctrl = ev.ctrlKey;
            args.shift = ev.shiftKey;
            args.meta = ev.metaKey;

            args.originalEvent = ev;
            args.row = row;
            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onRowRightClick === "function") {
                calendar.onRowRightClick(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            switch (calendar.rowRightClickHandling) {
                case "ContextMenu":
                    if (rowFromList.contextMenu) {
                        rowFromList.contextMenu.show(row);
                    }
                    break;
            }

            if (typeof calendar.onRowRightClicked === "function") {
                calendar.onRowRightClicked(args);
            }

            return false;
        };

        this._onResClick = function(ev) {
            if (rowtools.cancelClick) {
                return;
            }

            var row = this.row;
            var column = this.column;
            var r = calendar._createRowObject(row, this.index);

            if (row.isNewRow) {
                calendar._rowtools._edit(row);
                return;
            }

            calendar._rowClickDispatch(r, ev, column);
        };

        this._onResDoubleClick = function(ev) {

            if (calendar._timeouts.resClick) {
                for (var toid in calendar._timeouts.resClick) {
                    window.clearTimeout(calendar._timeouts.resClick[toid]);
                }
                calendar._timeouts.resClick = null;
            }

            var row = this.row;
            var e = calendar._createRowObject(row, this.index);
            var column = this.column;

            if (calendar._api2()) {

                var args = {};
                args.resource = e;
                args.row = e;
                args.x = column;

                args.ctrl = ev.ctrlKey;
                args.shift = ev.shiftKey;
                args.meta = ev.metaKey;
                args.originalEvent = ev;

                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onRowDoubleClick === 'function') {
                    calendar.onRowDoubleClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.rowDoubleClickHandling) {
                    case 'PostBack':
                        calendar.rowDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.rowDoubleClickCallBack(e);
                        break;
                    case 'Select':
                        calendar._rowSelectDispatch(row, ev.ctrlKey, ev.shiftKey, ev.metaKey);
                        break;
                    case 'Edit':
                        calendar._rowtools._edit(row, column);
                        break;
                }

                if (typeof calendar.onRowDoubleClicked === 'function') {
                    calendar.onRowDoubleClicked(args);
                }

            }
            else {
                switch (calendar.rowDoubleClickHandling) {
                    case 'PostBack':
                        calendar.rowDoubleClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.rowDoubleClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onRowDoubleClick(e);
                        break;
                    case 'Select':
                        calendar._rowSelectDispatch(row, ev.ctrlKey, ev.shiftKey, ev.metaKey);
                        break;
                    case 'Edit':
                        calendar._rowtools._edit(row, column);
                        break;
                }
            }
        };

        this.rowDoubleClickPostBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._postBack2("RowDoubleClick", params, data);
        };
        this.rowDoubleClickCallBack = function(e, data) {
            var params = {};
            params.resource = e;

            this._callBack2("RowDoubleClick", params, data);
        };

        this._onTimeHeaderClick = function(ev) {

            if (calendar.timeHeaderClickHandling === "Disabled") {
                return;
            }

            var cell = {};

            cell.start = this.cell.start;
            cell.level = this.cell.level;
            cell.end = this.cell.end;
            if (!cell.end) {
                cell.end = new DayPilot.Date(cell.start).addMinutes(calendar.cellDuration);
            }

            calendar._timeHeaderClickDispatch(cell);
        };

        this._onTimeHeaderRightClick = function(ev) {

            if (calendar.timeHeaderRightClickHandling === "Disabled") {
                return;
            }

            ev.cancelBubble = true;
            ev.preventDefault();

            var cell = {};

            cell.start = this.cell.start;
            cell.level = this.cell.level;
            cell.end = this.cell.end;
            if (!cell.end) {
                cell.end = new DayPilot.Date(cell.start).addMinutes(calendar.cellDuration);
            }

            if (calendar._api2()) {

                var args = {};
                args.header = cell;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onTimeHeaderRightClick === 'function') {
                    calendar.onTimeHeaderRightClick(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (this.timeHeaderRightClickHandling) {
                    case 'PostBack':
                        calendar.timeHeaderRightClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.timeHeaderRightClickCallBack(e);
                        break;
                }

                if (typeof calendar.onTimeHeaderRightClicked === 'function') {
                    calendar.onTimeHeaderRightClicked(args);
                }
            }
            // not supported atm
/*            else {
                switch (this.timeHeaderClickHandling) {
                    case 'PostBack':
                        calendar.timeHeaderClickPostBack(e);
                        break;
                    case 'CallBack':
                        calendar.timeHeaderClickCallBack(e);
                        break;
                    case 'JavaScript':
                        calendar.onTimeHeaderClick(e);
                        break;
                }
            }*/
        };

        this._rowHeightResolved = function(i) {
            var row = calendar.rowlist[i];
            if (row.hidden) {
                return 0;
            }
            var now = row.height;
            if (typeof row.forcedHeight === "number") {
                now = row.forcedHeight;
            }
            return now;
        };


        this._rowAnimate2 = function(rows, target, onComplete) {
            // target: "show" / "hide"

            var header = calendar.divHeader;
            var cells = calendar.elements.cells;
            var cells2 = calendar._cache.cells; // [x_y]

            if (target === "show") {

            }
            rows.forEach(function(i) {

            });
        };

        this._rowAnimate = function(i, target, onComplete) {

            var duration = 200;

            var rows = [];
            if (typeof i === "number") {
                addRow(i);
            }
            else if (DayPilot.isArray(i)) {
                i.forEach(function(item) {
                    addRow(item);
                });
            }
            else {
                throw new DayPilot.Exception("Unexpected param (must be number/array).")
            }

            var start = 0;

            var scroll = calendar.nav.scroll;
            var ofx = scroll.style.overflowX;
            var ofy = scroll.style.overflowY;

            var noScrollbar = DayPilot.sw(scroll) === 0;

            if (noScrollbar) {
                scroll.style.overflowY = "hidden";
            }

            window.requestAnimationFrame(draw);

            function addRow(i) {
                var from = calendar._rowHeightResolved(i);

                var to = target;
                if (target === "hide") {
                    to = 0;
                }
                else if (target === "show") {
                    to = calendar.rowlist[i].height;
                }

                var dist = to - from;
                rows.push({
                    "i": i,
                    "now": from,
                    "dist": dist
                });

            }

            function draw(timestamp) {

                if (!start) {
                    start = timestamp;
                }
                var progress = timestamp - start;

                var complete = Math.min(1, progress/duration);

                // first step
                if (complete === 0) {
                    complete = 0.1;
                }

                rows.forEach(function(r) {
                    var h = r.now + r.dist * complete;
                    calendar.rowlist[r.i].forcedHeight = h;
                });

                calendar._updateAfterRowChange();

                if (complete < 1) {
                    window.requestAnimationFrame(draw);
                }
                else {
                    scroll.style.overflowX = ofx;
                    scroll.style.overflowY = ofy;

                    if (typeof onComplete === "function") {
                        onComplete();
                    }
                }

            }
        };

        this._createRowObject = function(row) {
            return new DayPilot.Row(row, calendar);
        };

        this._ensureRowData = function(i, gridName) {

            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            var row = rowlist[i];

            if (!row.events) {
                row._resetEvents();
            }

            if (row.data) {
                return;
            }

            row.data = {};

            // to be used later during client-side operations
            // rowStart
            row.data.start = new DayPilot.Date(row.start);
            // rowStartTicks
            row.data.startTicks = row.data.start.getTime();
            // rowEnd
            var duration = this._visibleEnd().getTime() - this._visibleStart().getTime();
            row.data.end = resolved._isResourcesView() ? row.data.start.addTime(duration) : row.data.start.addDays(1);
            // rowEndTicks
            row.data.endTicks = row.data.end.getTime();
            // rowOffset
            row.data.offset = row.start.getTime() - this._visibleStart().getTime();
            row.data.i = i;
            row.data.grid = gridName;
        };

        this._eventHashes = {};

        this._loadEvents = function(events) {
            if (events) {
                this.events.list = events;
            }
            else if (!this.events.list) {
                this.events.list = [];
            }

            if (this.events.list != null && !DayPilot.isArray(this.events.list)) {
                throw new DayPilot.Exception("DayPilot.Scheduler.events.list expects an array object");
            }

            eventloading._prepareRows(true);

            var list = this.events.list;

            var ober = typeof this.onBeforeEventRender === 'function';
            var rows;
            var isRes = calendar.viewType === "Resources";

            calendar._eventHashes = {};

            for (var j = 0; j < list.length; j++) {

                var edata = list[j];

                if (!edata) {
                    continue;
                }

                if (typeof edata !== "object") {
                    throw new DayPilot.Exception("Event data item must be an object");
                }
                if (!edata.start) {
                    throw new DayPilot.Exception("Event data item must specify 'start' property");
                }

                if (edata instanceof DayPilot.Event) {
                    throw new DayPilot.Exception("DayPilot.Scheduler: DayPilot.Event object detected in events.list array. Use raw event data instead.");
                    //edata = edata.data;
                }

                // validate id
                var validId = typeof edata.id === "string" || typeof edata.id === "number";
                var validRecurId = typeof edata.recurrentMasterId === "string" || typeof edata.recurrentMasterId === "number";
                if (!validId) {
                    var validRecurId = typeof edata.recurrentMasterId === "string" || typeof edata.recurrentMasterId === "number";
                    if (!validRecurId) {
                        throw new DayPilot.Exception("All events must have an id property (string or number)");
                    }
                }

                // check id duplicity, backwards compatible with server-side recurrence support
                var checkDuplicates = !calendar.temp.allowDuplicateEventIds;
                if (checkDuplicates) {
                    var hash = "_" + edata.id;
                    if (!validId && validRecurId) {
                        hash = "#" + edata.recurrentMasterId + "#" + new DayPilot.Date(edata.start);
                    }
                    if (calendar._eventHashes[hash]) {
                        throw new DayPilot.Exception("Duplicate event IDs are not allowed: " + hash);
                    }
                    calendar._eventHashes[hash] = true;
                }

                if (edata.type === "Milestone") {
                    edata.end = edata.start;
                }

                if (ober) {
                    this._doBeforeEventRender(j);
                }

                if (edata.resource === "*") {
                    rows = calendar.rowlist;
                }
                else if (isRes) {
                    rows = calendar._rowcacheFor(edata.resource).concat(calendar._rowcacheFor("*"));  // make sure wildcard resources are always there;
                }
                else if (calendar.viewType === "Days") {
                    rows = calendar.rowlist;
                }
                else if (calendar.viewType === "Gantt") {
                    rows = calendar._rowcacheFor(edata.id);
                }

                for (var x = 0; rows && x < rows.length; x++) {
                    var row = rows[x];
                    var ep = this._loadEvent(edata, row);

                    if (!ep) {
                        continue;
                    }

                    if (ober) {
                        ep.cache = this._cache.events[j];
                    }
                }
            }

            // sort events inside rows
            var rowlist = calendar._rowlistMerged();
            rowlist.forEach(function(row) {
                calendar._loadRow(row);
            });

            calendar._updateRowHeights();
        };

        // assumes rows collection is created

        this._eventloading = {};
        var eventloading = this._eventloading;

        eventloading._rowcache = {};

        eventloading._prepareRows = function(resetEvents) {
            eventloading._rowcache = {};

            /*var rows = calendar.rowlist.map(function(row, i) { return {"row": row, "i": i, "grid": "main"}; });
            if (calendar._grids.top.enabled()) {
                rows = rows.concat(calendar._grids.top.rowlist.map(function(row, i) { return {"row": row, "i": i, "grid": "top"}; } ));
            }*/

            var rows = calendar._rowlistMerged();

            // initialize
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (resetEvents) {
                    row._resetEvents();
                }
                calendar._ensureRowData(row.index, row.grid);

                if (!row.id) {
                    continue;
                }
                var key = typeof row.id + "_" + row.id;
                if (!eventloading._rowcache[key]) {
                    eventloading._rowcache[key] = createList();
                }
                eventloading._rowcache[key].push(row);
            }
        };

        eventloading.loadEvent = function(edata) {

        };

        this._rowcacheFor = function(id) {
            var key = typeof id + "_" + id;
            return createList(eventloading._rowcache[key]);
        };

        this._containsDuplicateResources = function() {
            var idlist = {};

            if (calendar.viewType !== "Resources") {
                return false;
            }
            for (var i = 0; i < calendar.rowlist.length; i++) {
                var row = calendar.rowlist[i];
                var id = row.id;
                if (idlist[id]) {
                    return true;
                }
                idlist[id] = true;
            }
            return false;
        };

        this._doBeforeEventRender = function(i) {
            var cache = this._cache.events;
            var data = this.events.list[i];
            var evc = {};

            if (data instanceof DayPilot.Event) {
                data = data.data;
            }

            // make a copy
            for (var name in data) {
                evc[name] = data[name];
            }

            if (typeof evc.start === "string") {
                evc.start = new DayPilot.Date(evc.start);
            }
            if (typeof evc.end === "string") {
                evc.end = new DayPilot.Date(evc.end);
            }

            if (typeof this.onBeforeEventRender === 'function') {
                var args = {};
                args.e = evc;
                args.data = evc;
                // args.onElementCreate = null;
                // args.onElementRemove = null;
                this.onBeforeEventRender(args);

                // copyProps(args, evc, ["onElementCreate", "onElementRemove"]);
            }

            cache[i] = evc;

        };

        this._containerId = function(e) {
            var cd = e.data.container;
            var type = typeof cd;
            if (type !== "string" && type !== "number") {
                return null;
            }
            return typeof cd + "_" + cd;
        };

        // internal
        this._loadRow = function(row) {
            row.lines = [];
            row.sections = null;
            //row.blocks = [];

            if (row.isNewRow) {
                return;
            }

            if (this.sortDirections) {
                row.events.sort(this._eventComparerCustom);
            }
            else if (!calendar._cellStacking) {
                row.events.sort(this._eventComparer);
            }

            row.containerCache = {};
            row.containers = [];
            row.events.forEach(function(e) {
                var cid = calendar._containerId(e);
                if (cid) {
                    // var ci = calendar._containerId(e);
                    var container = row.containerCache[cid];
                    if (!container) {
                        container = {
                            "events": [],
                            "line": null,
                            "start": null,
                            "end": null,
                            "left": null,
                            "width": null
                        };
                        row.containerCache[cid] = container;
                        row.containers.push(container);
                    }
                    e.part.container = container;
                    container.events.push(e);
                }
            });

            row.containers.forEach(function(c) {
                // check for overlaps within container
                // might not be necessary, simply render everything in one line
                /*c.events.forEach(function(e, i) {
                    for (var x = i+1; x < c.events.length; x++) {
                        var compareTo = c.events[x];
                        if (DayPilot.Util.overlaps(e.part.start, e.part.end, compareTo.part.start, compareTo.part.end)) {
                            throw new DayPilot.Exception("Overlaps within container not allowed");
                        }
                    }
                });*/

                var first = c.events[0];
                var last = c.events[c.events.length - 1];
                // container boundaries
                c.start = first.part.start;
                c.end = last.part.end;
                c.left = first.part.left;
                c.width = last.part.right - first.part.left;
                c.right = last.part.right;

            });

            var stackingMode = calendar._cellStacking;
            if (stackingMode) {
                cellstacking._loadRow(row);
                return;
            }

            var collapsible = calendar.groupConcurrentEvents;

            if (collapsible) {
                for (var i = 0; i < row.blocks.length; i++) {
                    //row.blocks[i].events = [];
                    row.blocks[i].clear();
                }
            }

            // calculate event height
            createList(row.events).forEach(function(e) {
                if (e.part.height) {
                    return;
                }
                if (row.eventHeight) {
                    e.part.height = row.eventHeight;
                    return;
                }
                e.part.height = resolved._eventHeight();
            });

            var hasLineNumber = function(e) { return typeof e.data.line === "number"; };
            row.events.filter(hasLineNumber).forEach(function(e) {
                row._putIntoLine(e);
            });

            // put into lines
            for (var j = 0; j < row.events.length; j++) {
                var e = row.events[j];
                row._putIntoLine(e);
                if (collapsible) {
                    row._putIntoBlock(e);
                }
            }

            // calculate line tops
            var lineTop = 0;
            for (var i = 0; i < row.lines.length; i++) {
                var line = row.lines[i];
                line.top = lineTop;
                lineTop += (line.height || row.eventHeight) * row.eventStackingLineHeight/100;
            }

            if (collapsible) {
                for (var j = 0; j < row.blocks.length; j++) {
                    var block = row.blocks[j];
                    block.lines = [];
                    block.events.sort(this._eventComparerCustom);
                    for (var k = 0; k < block.events.length; k++) {
                        var e = block.events[k];
                        block._putIntoLine(e);
                    }
                    if (block.lines.length <= calendar.groupConcurrentEventsLimit) {
                        block.expanded = true;
                    }
                    var anyItemExpandedBefore = createList(block.events).map(function(e) {return e.id();}).some(function(item) {
                        return contains(calendar._blockExpandedEvents, item);
                    });
                    if (anyItemExpandedBefore) {
                        block.expanded = true;
                    }

                    // calculate line tops
                    var lineTop = 0;
                    for (var i = 0; i < block.lines.length; i++) {
                        var line = block.lines[i];
                        line.top = lineTop;
                        lineTop += (line.height || row.eventHeight) * row.eventStackingLineHeight/100;
                    }

                }
            }

        };

        // internal
        // freeze ok
        this._loadRows = function(rows) {  // row indices
            rows = DayPilot.ua(rows); // unique
            rows = calendar._ensureRowsArray(rows);

            rows.forEach(function(row) {
                // calendar._loadRow(calendar.rowlist[ri]);
                calendar._loadRow(row);
            });

            if (calendar._cellStacking) {
                cellstacking._calculateEventPositions();
            }
            else {
                rows.forEach(function(row) {
                    calendar._updateEventPositionsInRow(row);
                });
            }

        };

        this._rowsWithCustomStart = function() {
            var start = calendar.scale === "Manual" ? calendar.itline[0].start : calendar.startDate;
            return createList(calendar.rowlist).some(function(item) {
                if (!item.start) {
                    return false;
                }
                return item.start.getTime() !== new DayPilot.Date(start).getTime();
            });
        };

        // internal
        // returns ep if the event was added to this row, otherwise null
        this._loadEvent = function(e, row) {
            if (row.hideEvents) {
                return;
            }

            var undef = DayPilot.Util.isNullOrUndefined;
            var start = new DayPilot.Date(e.start);
            var end = new DayPilot.Date(e.end);

            /*
            if (calendar.eventEndSpec === "Date") {
                end = end.getDatePart().addDays(1);
            }
            */
            end = calendar._adjustEndIn(end);

            var startTicks = start.ticks;
            var endTicks = end.ticks;

            if (endTicks < startTicks) {  // skip invalid events
                return null;
            }

            var cache = null;
            if (typeof calendar.onBeforeEventRender === 'function') {
                var index = indexOf(calendar.events.list, e);
                cache = calendar._cache.events[index];
            }

            if (cache) {
                if (cache.hidden) {
                    return null;
                }
            }
            else if (e.hidden) {
                return null;
            }

            // belongs here
            var belongsHere = false;
            switch (this.viewType) {
                case 'Days':
                    var timeMatches = !(endTicks <= row.data.startTicks || startTicks >= row.data.endTicks) || (startTicks === endTicks && startTicks === row.data.startTicks);
                    var resourceMatches = (undef(row.id) && undef(e.resource)) || (row.id === e.resource);
                    belongsHere = timeMatches && resourceMatches;
                    break;
                case 'Resources':
                    belongsHere = (row.id === e.resource || row.id === "*" || e.resource === "*") && (!(endTicks <= row.data.startTicks || startTicks >= row.data.endTicks) || (startTicks === endTicks && startTicks === row.data.startTicks));
                    break;
                case 'Gantt':
                    belongsHere = (row.id === e.id) && !(endTicks <= row.data.startTicks || startTicks >= row.data.endTicks);
                    break;

            }

            if (!belongsHere) {
                return null;
            }

            var ep = new DayPilot.Event(e, calendar); // event part
            ep.part.dayIndex = row.data.i;
            ep.part.grid = row.data.grid;

            //ep.part.start = row.data.startTicks < startTicks ? ep.start() : row.data.start;
            ep.part.start = row.data.startTicks < startTicks ? start : row.data.start;
            //ep.part.end = row.data.endTicks > endTicks ? ep.end() : row.data.end;
            ep.part.end = row.data.endTicks > endTicks ? end : row.data.end;

            var partStartPixels = this.getPixels(ep.part.start.addTime(-row.data.offset));
            var partEndPixels = this.getPixels(ep.part.end.addTime(-row.data.offset));

            if (ep.part.start === ep.part.end) {
                partEndPixels = this.getPixels(ep.part.end.addTime(-row.data.offset).addMilliseconds(1));
            }

            if (cache && cache.height) {  // custom height, from onBeforeEventRender
                ep.part.height = cache.height;
            }
            else if (e.height) {  // custom height from event data
                ep.part.height = e.height;
            }

            var cacheOrData = cache || ep.data;

            ep.part._getHeightWithVersions = function() {
                var pheight = this.height;
                if (calendar.eventVersionsEnabled && !createList(ep.versions).isEmpty()) {
                    //var count = ep.data.versions.length;
                    var count = ep.versions.length;
                    pheight += count*calendar.eventVersionHeight;
                    pheight += count*calendar.eventVersionMargin;
                }
                return pheight + calendar.eventMarginBottom;
            };

            var left = partStartPixels.left;
            var right = partEndPixels.left;

            // DEBUG: remove
            ep.part.startPixels = partStartPixels;
            ep.part.endPixels = partEndPixels;

            // events in the hidden areas
            if (left === right) {
                if (partStartPixels.cut || partEndPixels.cut) {
                    return null;
                }
                // check if it's hidden because of hidden timeline cells vs. too big scale
                var mid = (ep.part.start.addTime(-row.data.offset).getTime() + ep.part.end.addTime(-row.data.offset).getTime()) / 2;
                var midPixels = calendar.getPixels(new DayPilot.Date(Math.floor(mid)));
                if (midPixels.cut) {
                    return null;
                }

            }

            ep.part.box = resolved._useBox(endTicks - startTicks);

            var milestoneWidth = calendar.eventHeight;


            if (e.type === "Milestone") {
                var width = e.width || milestoneWidth;
                ep.part.end = ep.part.start;
                ep.part.left = left - width /2;
                ep.part.width = width;
                ep.part.barLeft = 0;
                ep.part.barWidth = width;
            }
            else if (ep.part.box) {
                var boxLeft = partStartPixels.boxLeft;
                var boxRight = partEndPixels.boxRight;
                //var itc = this._getItlineCellFromPixels()

                //ep.part.left = Math.floor(left / this.cellWidth) * this.cellWidth;
                ep.part.left = boxLeft;
                ep.part.width = boxRight - boxLeft;
                ep.part.barLeft = atLeast(left - ep.part.left, 0);  // minimum 0
                ep.part.barWidth = atLeast(right - left, 1);  // minimum 1
            }
            else {
                ep.part.left = left;
                ep.part.width = atLeast(right - left, 1);
                ep.part.barLeft = 0;
                ep.part.barWidth = atLeast(right - left - 1, 1);
            }

            var minWidth = calendar.eventMinWidth;
            ep.part.width = Math.max(ep.part.width, minWidth);

            ep.part.right = ep.part.left + ep.part.width;
            ep.cache = cache;  // duplicate, but needed here

            if (calendar.eventVersionsEnabled) {
                calendar._fillOriginalEventData(ep, row);
            }

            if (typeof calendar.onEventFilter === "function" && calendar.events._filterParams) {
                var args = {};
                args.filter = calendar.events._filterParams;
                args.filterParam = calendar.events._filterParams;
                args.visible = true;
                args.e = ep;

                calendar.onEventFilter(args);

                if (!args.visible) {
                    return null;
                }
            }

            row.events.push(ep);

            return ep;

        };

        this._fillOriginalEventData = function(ep, row) {
            ep.versions = [];

            var data = ep.cache || ep.data;

            var list = createList(data.versions);

            if (list.isEmpty()) {
                return;
            }

            var versionsLeft = ep.part.left;
            var versionsRight = ep.part.left + ep.part.width;

            list.forEach(function(source) {
                var start = new DayPilot.Date(source.start);
                var end = new DayPilot.Date(source.end);

                var partStartPixels = calendar.getPixels(start.addTime(-row.data.offset));
                var partEndPixels = calendar.getPixels(end.addTime(-row.data.offset));

                if (start.ticks === end.ticks) {
                    partEndPixels = calendar.getPixels(end.addTime(-row.data.offset).addTime(1));
                }

                var left = partStartPixels.left;
                var right = partEndPixels.left;

                // events in the hidden areas
                if (left === right && (partStartPixels.cut || partEndPixels.cut)) {
                    return null;
                }

                var version = {};
                version.left = left;
                version.continueLeft = start < row.data.start;
                version.right = right;
                version.continueRight = end > row.data.end;
                version.width = right - left;

                ep.versions.push(version);

                if (version.left < versionsLeft) {
                    versionsLeft = version.left;
                }
                if (version.right > versionsRight) {
                    versionsRight = version.right;
                }

            });

            if (!calendar.eventVersionsReserveSpace) {
                ep.part.versionsLeft = ep.part.left;
                ep.part.versionsRight = ep.part.left + ep.part.width;
                ep.part.versionsWidth = ep.part.width;
            }
            else {
                ep.part.versionsLeft = versionsLeft;
                ep.part.versionsRight = versionsRight;
                ep.part.versionsWidth = versionsRight - versionsLeft;
            }

        };

        this._eventComparer = function(a, b) {
            if (!a || !b || !a.start || !b.start) {
                return 0; // no sorting, invalid arguments
            }

            var byStart = a.start().ticks - b.start().ticks;
            if (byStart !== 0) {
                return byStart;
            }

            var byEnd = b.end().ticks - a.end().ticks; // desc
            return byEnd;
        };

        this._eventComparerCustom = function(a, b) {
            if (!a || !b) {
                return 0; // no sorting, invalid arguments
            }

            var srcA = a.cache || a.data;
            var srcB = b.cache || b.data;
            var sortSpecified = srcA.sort && srcA.sort.length > 0 && srcB.sort && srcB.sort.length > 0;

            if (!sortSpecified) { // no custom sorting, using default sorting (start asc, end asc);
                return calendar._eventComparer(a, b);
            }

            var result = 0;
            var i = 0;
            while (result === 0 && typeof srcA.sort[i] !== "undefined" && typeof srcB.sort[i] !== "undefined") {
                if (srcA.sort[i] === srcB.sort[i]) {
                    result = 0;
                }
                else if (typeof srcA.sort[i] === "number" && typeof srcB.sort[i] === "number") {
                    result = srcA.sort[i] - srcB.sort[i];
                }
                else {
                    result = calendar._stringComparer(srcA.sort[i], srcB.sort[i], calendar.sortDirections[i]);
                }
                i++;
            }

            return result;
        };

        this._stringComparer = function(a, b, direction) {
            var asc = (direction !== "desc");
            var aFirst = asc ? -1 : 1;
            var bFirst = -aFirst;

            if (a === null && b === null) {
                return 0;
            }
            // nulls first
            if (b === null) { // b is smaller
                return bFirst;
            }
            if (a === null) {
                return aFirst;
            }

            //return asc ? a.localeCompare(a, b) : -a.localeCompare(a, b);

            var ar = [];
            ar[0] = a;
            ar[1] = b;

            ar.sort();

            return a === ar[0] ? aFirst : bFirst;
        };

        this._rowSelectDispatch = function(row, ctrl, shift, meta) {

            if (calendar._api2()) {

                var index = indexOf(calendar.rowlist, row);
                var e = calendar._createRowObject(row, index);
                var selected = indexOf(rowtools._selected, row) !== -1;
                var change = selected ? "deselected" : "selected";

                var args = {};
                args.row = e;
                args.selected = selected;
                args.ctrl = ctrl;
                args.shift = shift;
                args.meta = meta;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onRowSelect === 'function') {
                    calendar.onRowSelect(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                var shiftAction = shift && !ctrl && !meta;

                if (!shift) {
                    rowtools._rowSelectLast = {"row": row, "index": index};
                }

                if (shiftAction) {
                    rowtools._fixRowSelectLast();

                    var startIndex = rowtools._rowSelectLast.index;
                    var endIndex = index;

                    rowtools._selectRange(startIndex, endIndex);
                }

                switch (calendar.rowSelectHandling) {
                    case 'PostBack':
                        calendar.rowSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        calendar.rowSelectCallBack(e, change);
                        break;
                    case "Notify":
                        !shiftAction && rowtools._select(row, ctrl, shift, meta);
                        calendar.rowSelectNotify(e, change);
                        break;
                    case 'Update':
                        !shiftAction && rowtools._select(row, ctrl, shift, meta);
                        break;
                }

                if (typeof calendar.onRowSelected === 'function') {
                    args.selected = indexOf(rowtools._selected, row) !== -1;
                    calendar.onRowSelected(args);
                }

            }
            else {
                rowtools._select(row, ctrl, shift);

                var index = indexOf(calendar.rowlist, row);
                var e = calendar._createRowObject(row, index);
                var selected = indexOf(rowtools._selected, row) !== -1;
                var change = selected ? "deselected" : "selected";

                switch (calendar.rowSelectHandling) {
                    case 'PostBack':
                        calendar.rowSelectPostBack(e, change);
                        break;
                    case 'CallBack':
                        calendar.rowSelectCallBack(e, change);
                        break;
                    case "Notify":
                        calendar.rowSelectNotify(e, change);
                        break;
                    case 'JavaScript':
                        calendar.onRowSelect(e, change);
                        break;
                }
            }

        };

        this.rowSelectPostBack = function(r, change, data) {
            var params = {};
            params.resource = r;
            params.change = change;
            this._postBack2('RowSelect', params, data);
        };

        this.rowSelectCallBack = function(r, change, data) {
            var params = {};
            params.resource = r;
            params.change = change;
            this._callBack2('RowSelect', params, data);
        };

        this.rowSelectNotify = function(r, change, data) {
            var params = {};
            params.resource = r;
            params.change = change;
            this._callBack2('RowSelect', params, data, "Notify");
        };

        this.rows = {};
        this.rows.selection = {};

        var rowsel = this.rows.selection;

        rowsel._cache = [];

        rowsel.get = function() {
            var list = [];
            createList(rowtools._selected).forEach(function(item) {
                list.push(calendar._createRowObject(item));
            });
            return list;
        };

        rowsel.clear = function() {
            rowtools._clearSelection();

            // rowsel._updateInitialList();
        };

        rowsel.add = function(row) {
            if (!row || !row.isRow) {
                throw new DayPilot.Exception("DayPilot.Scheduler.rows.selection.add(): DayPilot.Row object expected");
            }
            var alreadyThere = createList(rowtools._selected).some(function(item) {
                return item === row.$.row;
            });

            if (!alreadyThere) {
                rowtools._selected.push(row.$.row);
                rowsel._updateInitialList();
                rowtools._highlight(row.$.row);
            }

            // optimization: only updating the affected row
            // rowtools._updateHighlighting();

            // optimization: only updated when the list has changed
            // rowsel._updateInitialList();
        };

        rowsel.remove = function(row) {
            if (!row || !row.isRow) {
                throw new DayPilot.Exception("DayPilot.Scheduler.rows.selection.remove(): DayPilot.Row object expected");
            }
            var selected = rowsel.isSelected(row);

            if (selected) {
                // rowtools.unselect(row.$.row);
                DayPilot.rfa(rowtools._selected, row.$.row);
                rowsel._updateInitialList();
                rowtools._highlight(row.$.row);
            }


        };

        rowsel.isSelected = function(row) {
            if (!row || !row.isRow) {
                throw new DayPilot.Exception("DayPilot.Scheduler.rows.selection.isSelected(): DayPilot.Row object expected");
            }

            var selected = indexOf(rowtools._selected, row.$.row) !== -1;
            return selected;
        };

        rowsel._updateInitialList = function() {
            calendar.selectedRows = createList(rowtools._selected).map(function(item) {
                return item.id;
            });

            // cache
            rowsel._cache = [];
            rowtools._selected.forEach(function(row) {
               rowsel._cache[row.index] = true;
            });
        };

        this.rows.all = function() {
            var list = createList();
            for(var i = 0; i < calendar.rowlist.length; i++) {
                var r = calendar._createRowObject(calendar.rowlist[i]);
                list.push(r);
            }
            return list;

        };

        this.rows.visible = function() {
            var list = createList();
            for(var i = 0; i < calendar.rowlist.length; i++) {
                var r = calendar.rowlist[i];
                if (!r.hidden) {
                    var r = calendar._createRowObject(calendar.rowlist[i]);
                    list.push(r);
                }
            }
            return list;
        };

        this.rows.each = function(f) {
            calendar.rows.all().forEach(f);
        };

        this.rows.forEach = function(f) {
            calendar.rows.all().forEach(f);
        };

        this.rows.filter = function(param, dontUpdate) {
            calendar.rows._filterParams = param;

            if (dontUpdate) {
                return;
            }

            if (calendar._initialized) {
                calendar._update({"immediateEvents": true});
            }

        };

        Object.defineProperty(calendar.rows, "filterParam", {
            get: function() {
                return calendar.rows._filterParams;
            },
        });

        // accept sort string or object
        // first version - single field in ascending order 9
        // options = leaf nodes only, maybe specify levels
        this.rows.sort = function(spec) {
            var old = calendar.rows.sortParam;

            if (typeof spec === "string") {
                calendar.rows._sortParam = {"field": spec, "order": "asc"};
            }
            else if (typeof spec === "object") {
                var param = copyProps(spec);
                if (!param.order) {
                    param.order = "asc";
                }
                calendar.rows._sortParam = param;
            }
            else {
                calendar.rows._sortParam = null;
            }

            if (calendar._initialized) {
                calendar._update({"immediateEvents": true});
            }

            if (typeof calendar.onRowSorted === "function") {
                var args = {};
                args.oldSortParam = old;

                calendar.onRowSorted(args);
            }
        };

        Object.defineProperty(calendar.rows, "sortParam", {
            get: function() {
                return {
                    "order": calendar.rows._sortOrder(),
                    "field": calendar.rows._sortField()
                };
            },
        });

        this.rows._sortField = function() {
            var param = calendar.rows._sortParam;
            if (!param) {
                return null;
            }
            return param.field;
        };

        this.rows._sortOrder = function() {
            var param = calendar.rows._sortParam;
            if (!param) {
                return "asc";
            }
            return param.order;
        };

        this.rows.find = function(param, start) {
            if (typeof param === "string" || typeof param === "number" || (!param && start)) {
                // var matchingRows = createList(eventloading.rowcache[id]);  // wrap, can be empty
                var matchingRows = calendar._rowcacheFor(param);

                if (!param) {
                    matchingRows = calendar.rowlist;
                }

                var first = null;
                if (typeof start === "string" || start instanceof DayPilot.Date) {
                    start = new DayPilot.Date(start);
                    first = matchingRows.find(function(item) {
                        return start === item.start;
                    });
                }
                else {
                    first = matchingRows.first();
                }

                if (first) {
                    return new DayPilot.Row(first, calendar);
                }
                return null;
            }
            else if (typeof param === "function") {
                var index = start || 0;
                var r = calendar.rowlist.find(function(r, i) {
                    if (i < index) {
                        return false;
                    }
                    var row = calendar._createRowObject(r);
                    return param(row);
                });
                if (r) {
                    return calendar._createRowObject(r);
                }
            }
            else {
                throw new DayPilot.Exception("Invalid rows.find() argument: id or function expected");
            }
        };

        this.rows.load = function(url, success, error) {

            if (!url) {
                throw new DayPilot.Exception("rows.load(): 'url' parameter required");
            }

            var onError = function(args) {
                var largs = {};
                largs.exception = args.exception;
                largs.request = args.request;

                if (typeof error === 'function') {
                    error(largs);
                }
            };

            var onSuccess = function(args) {
                var r = args.request;
                var data;

                // it's supposed to be JSON
                try {
                    data = JSON.parse(r.responseText);
                }
                catch (e) {
                    var fargs = {};
                    fargs.exception = e;
                    onError(fargs);
                    return;
                }

                if (DayPilot.isArray(data)) {
                    var sargs = {};
                    sargs.preventDefault = function() {
                        this.preventDefault.value = true;
                    };
                    sargs.data = data;
                    if (typeof success === "function") {
                        success(sargs);
                    }

                    if (sargs.preventDefault.value) {
                        return;
                    }

                    calendar.resources = sargs.data;
                    if (calendar._initialized) {
                        calendar.update();
                    }
                }
            };

            var usePost = calendar.rowsLoadMethod && calendar.rowsLoadMethod.toUpperCase() === "POST";

            if (usePost) {
                DayPilot.ajax({
                    "method": "POST",
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
            else {
                DayPilot.ajax({
                    "method": "GET",
                    "url": url,
                    "success": onSuccess,
                    "error": onError
                });
            }
        };

        this.rows.expand = function(levels) {
            var rows = [];
            var level = levels || 1;
            for (var i = 0; i < calendar.rowlist.length; i++) {
                var row = calendar.rowlist[i];
                var withinLevel = level === -1;
                if (row.level < level) {
                    withinLevel = true;
                }
                if (withinLevel && !row.expanded && row.children && row.children.length > 0) {
                    rows.push(row.index);
                }
            }
            if (rows.length === 0) {
                return;
            }
            if (rows.length === 1) {
                calendar._toggle(rows[0]);
            }
            else {
                for (var i = 0; i < rows.length; i++) {
                    var index = rows[i];
                    var res = calendar.rowlist[index].resource;
                    res.expanded = true;
                }
                calendar._update();
            }
        };

        this.rows.expandAll = function() {
            calendar.rows.expand(-1);
        };

        this.rows.collapseAll = function() {
            calendar.rowlist.forEach(function(row) {
                row.resource.expanded = false;
            });
            calendar._update();
        };

        this.rows.headerHide = function() {
            calendar._rowHeaderHidden = true;
            calendar._updateRowHeaderWidthOuter();
            calendar._updateAutoCellWidth();

            calendar._detectDimensionChange();
        };

        this.rows.headerShow = function() {
            calendar._rowHeaderHidden = false;
            calendar._updateRowHeaderWidthOuter();
            calendar._updateAutoCellWidth();

            calendar._detectDimensionChange();
        };

        this.rows.headerToggle = function() {
            if (calendar._rowHeaderHidden) {
                calendar.rows.headerShow();
            }
            else {
                calendar.rows.headerHide();
            }
        };

        this.rows.edit = function(row, column) {
            var cols = calendar.rowHeaderColumns;
            var max = cols && cols.length - 1;
            if (typeof column !== "undefined") {
                if (column < 0 || column > max) {
                    throw new DayPilot.Exception("Invalid column index: " + column);
                }
            }
            rowtools._edit(row.$.row, column);
        };

        // row - DayPilot.Row object
        this.rows.remove = function(row) {
            if (typeof row === "number" || typeof row === "string") {
                var rf = calendar.rows.find(row);
                if (!rf) {
                    throw new DayPilot.Exception("The row to be removed was not found");
                }
                calendar.rows.remove(rf);
                return;
            }

            var data = row.$.row.resource;

            var sourceParent = restools._findParentArray(data);
            if (!sourceParent) {
                throw new DayPilot.Exception("Cannot find source node parent");
            }
            var sourceIndex = indexOf(sourceParent, data);
            sourceParent.splice(sourceIndex, 1);

            calendar.update();
        };

        this.rows.add = function(data) {
            calendar.resources.push(data);
            calendar._update();
        };

        this.rows.addChild = function(parent, data) {
            if (typeof parent === "number" || typeof parent === "string") {
                parent = calendar.rows.find(parent);
            }
            if (!parent) {
                return;
            }
            if (!(parent instanceof DayPilot.Row)) {
                var data = parent;
                parent = calendar.rows.find(data.id);
                if (!parent) {
                    return;
                }
            }
            if (!parent.data.children) {
                parent.data.children = [];
            }
            parent.data.children.push(data);
            calendar._update();
        };

        // not supported to be changed: id, children
        // freeze ok
        this.rows.update = function(row) {
            if (!(row instanceof DayPilot.Row || typeof row === "object")) {
                throw new DayPilot.Exception("DayPilot.Scheduler.rows.update() expects a DayPilot.Row object or a data object.");
            }
            if (!(row instanceof DayPilot.Row)) {
                var data = row;
                row = calendar.rows.find(data.id);
                if (!row) {
                    return;
                }
                row.data = data;
            }

            var queued = !createList(calendar.events._postponedData.rows).isEmpty();
            if (queued) {
                focus._supressHighlight = true;
                calendar.events._immediateRefresh({"dontResetFocus": true});
            }

            var wasSelected = calendar.rows.selection.isSelected(row);
            var originalRow = row;

            var index = row.index;
            var rowlist = calendar._gridInfo(row.grid).rowlist;

            var oldRow = rowlist[index];
            var res = row.data;

            var parent = row.parent() ? row.parent().$.row : null;

            var rcustomized = calendar._doBeforeResHeaderRender(res);

            var row = calendar._createRowFromResource(rcustomized, parent);
            row.hidden = oldRow.hidden;
            row.level = oldRow.level;
            row.children = oldRow.children;
            row.index = index;
            row.top = oldRow.top;
            row.height = oldRow.height;
            row.grid = oldRow.grid;
            rowlist[index] = row;

            if (wasSelected) {
                DayPilot.rfa(rowtools._selected, originalRow.$.row);
                rowtools._selected.push(row);
            }

            row._resetEvents();
            calendar._ensureRowData(row.index, row.grid);
            calendar._createCells();

            calendar._loadEventsForRow(row);
            calendar._loadRow(row);
            calendar._updateRowHeights();

            calendar._invalidateAlwaysRows();
            calendar._updateRowsNoLoad([row]);
            calendar._updateHeight();

            // calendar._redrawInvalidatedCells();

            /*
            calendar._drawRowForced(row.index, row.grid); // updateRowsNoLoad

            calendar._deleteCells();// updateRowsNoLoad
            calendar._drawCells();// updateRowsNoLoad

            calendar._deleteEventsInRow(row.index, row.grid);  // updateRowsNoLoad
            calendar._drawEventsInRow(row.index, row.grid);// updateRowsNoLoad
*/

            calendar._rowEditNow = true;
            calendar._rowEditNowTimeout = setTimeout(function() {
                calendar._rowEditNow = false;
            }, 500);
        };

        this._loadEventsForRow = function(row) {
            var events = calendar.events.list;
            var listlength = events.length;
            var ober = typeof calendar.onBeforeEventRender  === "function";

            for (var j = 0; j < listlength; j++) {

                var edata = events[j];

                if (!edata) {
                    continue;
                }

                if (edata instanceof DayPilot.Event) {
                    throw new DayPilot.Exception("DayPilot.Scheduler: DayPilot.Event object detected in events.list array. Use raw event data instead.");
                    //edata = edata.data;
                }

                if (calendar.viewType === "Days") {
                    throw new DayPilot.Exception(".rows.update() not supported for viewType = 'Days'.");
                }
                else if (calendar.viewType === "Gantt") {
                    throw new DayPilot.Exception(".rows.update() not supported for viewType = 'Gantt'.");
                }

                var belongsHere = edata.resource === "*" || row.id === "*" || edata.resource === row.id;

                if (!belongsHere) {
                    continue;
                }

                if (ober) {
                    this._doBeforeEventRender(j);
                }

                var ep = this._loadEvent(edata, row);

                if (!ep) {
                    continue;
                }

                if (ober) {
                    ep.cache = this._cache.events[j];
                }
            }
        };

        this._rowMoveDispatch = function() {
            var source = rowmoving.source;
            var target = rowmoving.target;
            var position = rowmoving.position;

            var sourceCalendar = rowmoving.sourceCalendar;

            rowtools._resetMoving();

            if (calendar._api2()) {
                var args  = {};
                args.source = calendar._createRowObject(source);
                args.source.calendar = sourceCalendar;
                args.target = calendar._createRowObject(target);
                args.position = position;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onRowMove === "function") {
                    calendar.onRowMove(args);
                    if (args.preventDefault.value) {
                        return;
                    }
                }

                switch (calendar.rowMoveHandling) {
                    case "Update":
                        rowtools._move(args);
                        break;
                    case "CallBack":
                        calendar.rowMoveCallBack(args.source, args.target, args.position);
                        break;
                    case "PostBack":
                        calendar.rowMovePostBack(args.source, args.target, args.position);
                        break;
                    case "Notify":
                        rowtools._move(args);
                        calendar.rowMoveNotify(args.source, args.target, args.position);
                        break;
                }

                if (typeof calendar.onRowMoved === "function") {
                    calendar.onRowMoved(args);
                }
            }
            else {

                var source = calendar._createRowObject(source);
                var target = calendar._createRowObject(target);
                var position = position;

                switch (calendar.rowMoveHandling) {
                    case "CallBack":
                        calendar.rowMoveCallBack(source, target, position);
                        break;
                    case "PostBack":
                        calendar.rowMovePostBack(source, target, position);
                        break;
                    case "JavaScript":
                        calendar.onRowMove(source, target, position);
                        break;
                }

            }

        };

        /**
         * @param rows Array of strings (row IDs)
         * @private
         */
        this._loadSelectedRows = function(rows) {
            var list = createList(rows);
            rowtools._selected = [];

            if (!list.isEmpty()) {
                calendar._cellPropertiesLazyLoading = false;
                calendar._expandCellProperties();
            }

            list.forEach(function(item) {
                var row = calendar._findRowByResourceId(item);
                if (row) {
                    rowtools._selected.push(row);
                }
            });
            rowtools._updateHighlighting();
        };

        this._rowtools = {};
        var rowtools = this._rowtools;

        rowtools._edit = function(row, column) {
            var input = rowtools._textarea(row, column);
        };

        rowtools._rowSelectLastSetDefault = function() {
            rowtools._rowSelectLast = {"row": calendar.rowlist[0], "index": 0};
        };

        rowtools._rowSelectSetLast = function(row) {
            var index = indexOf(calendar.rowlist, row);
            if (index === -1) {
                throw new DayPilot.Exception("DayPilot.Scheduler: Row not found when selecting a range");
            }
            rowtools._rowSelectLast = {"row": row, "index": index};
        };

        rowtools._fixRowSelectLast = function() {
            // nothing
            if (!rowtools._rowSelectLast) {
                rowtools._rowSelectLastSetDefault();
            }

            // from previous state
            var index = indexOf(calendar.rowlist, rowtools._rowSelectLast.row);

            if (index > -1) {
                return;
            }

            // the row isn't in the list - ._update() was called, try to find it
            var row = calendar._findRowByResourceId(rowtools._rowSelectLast.row.id);
            if (row) {
                index = indexOf(calendar.rowlist, row);
                rowtools._rowSelectLast = {"row": row, "index": index};
            }
            else {
                rowtools._rowSelectLastSetDefault();
            }
        };

        rowtools._createOverlay = function(row) {

            var width = calendar._getTotalRowHeaderWidth();
            var css = calendar._prefixCssClass("_rowmove_source");

            var top = row.top;
            var height = row.height;

            if (row.split.list.length > 0) {
                top = row.split.list[0].top;
                height = row.split.totalHeight();
            }

            var div = utilDiv(calendar.divHeader, 0, top, width, height);
            div.className = css;

            row.moveOverlay = div;

        };

        rowtools._deleteOverlay = function(row) {
            if (!row) {
                return;
            }
            deleteElement(row.moveOverlay);
            row.moveOverlay = null;
        };

        rowtools._textAreaRemove = function() {
            var c = rowtools._textAreaCell;
            if (!c) {
                return;
            }
            rowtools._textAreaCell = null;
            try {
                c.input.parentNode.removeChild(c.input);
            }
            catch(e) {
                doNothing();
            }
            c.input = null;
        };

        rowtools._textarea = function(row, column) {
            column = column || 0;
            if (row.isNewRow) {
                column = 0;
            }

            var r = rowtools._findTableRow(row);
            var c = r.cells[column];

            if (c.input) {
                return c.input;
            }

            rowtools._textAreaRemove();

            DayPilot.Areas.disable(c.firstChild);

            var width = c.clientWidth;
            if (row.isNewRow) {
                width = calendar._getOuterRowHeaderWidth();
            }

            // test
            // c.style.overflow = "hidden";
            var paddingLeft = 0;
            if (column === 0) {
                paddingLeft = row.level * calendar.treeIndent;
            }

            var input = document.createElement("input");
            input.style.position = "absolute";
            input.style.top = "0px";
            input.style.left = "0px";
            input.style.width = width + "px";
            input.style.height = (row.height - 1) + "px";
            input.style.border = "0px none";
            input.style.overflow = "hidden";
            input.style.boxSizing = "border-box";
            input.style.resize = "none";
            input.style.paddingLeft = (paddingLeft) + "px";
            input.style.outline = "none";

            var object = c.textDiv;
            input.style.fontFamily = DayPilot.gs(object, 'fontFamily') || DayPilot.gs(object, 'font-family');
            input.style.fontSize = DayPilot.gs(object, 'fontSize') || DayPilot.gs(object, 'font-size');

            var text = row.name;

            if (!row.isNewRow && calendar.rowHeaderColumns) {
                var headerCol = calendar.rowHeaderColumns[column] || {};
                var display = headerCol.display;
                text = calendar._getTabularValue(row.resource, display);
                if (column === 0 && !display) {
                    text = row.name;
                }
            }

            input.value = text || "";
            c.firstChild.appendChild(input);
            c.input = input;

/*            var remove = function() {
                try {
                    c.input.parentNode.removeChild(c.input);
                }
                catch(e) {
                    doNothing();
                }
                c.input = null;
            };*/
            var remove = rowtools._textAreaRemove;

            input.focus();
            input.onblur = function() {
                input.onblur = null;
                var newText = input.value;
                //var index = indexOf(calendar.rowlist, row);
                remove();
                DayPilot.Areas.enable(c.firstChild);
                calendar._rowEditDispatch(row, newText, input.canceled, column);
                /*if (!input.canceled) {
                    calendar._rowEditDispatch(row, newText);
                }*/
            };
            input.onkeydown = function(e) {
                var keynum = e.keyCode;

                if (keynum === 27) {
                    input.canceled = true;
                    remove();
                }
                if (keynum === 13) {
                    input.onblur();
                    return false;
                }
                return true;
            };

            if (input.setSelectionRange) {
                input.setSelectionRange(0, 9999); // using this instead of .select() that is not fully supported in mobile Safari
            }
            else {
                input.select();
            }

            rowtools._textAreaCell = c;

            return input;
        };

        rowtools._selected = [];
        rowtools._select = function(row, ctrl, shift, meta) {

            var selected = indexOf(rowtools._selected, row) !== -1;

            if (ctrl || meta) {
                if (selected) {
                    // rowtools.unselect(row);
                    DayPilot.rfa(rowtools._selected, row);
                    rowsel._updateInitialList();
                    rowtools._highlight(row);
                    return;
                }
            }
            else {
                selected = false;
                rowtools._clearSelection();
            }

            // selected list
            if (!selected) {
                rowtools._selected.push(row);
            }

            rowsel._updateInitialList();

            rowtools._highlight(row);

        };

        rowtools._selectRange = function(startIndex, endIndex) {
            rowtools._clearSelection();

            var min = Math.min(startIndex, endIndex);
            var max = Math.max(startIndex, endIndex);

            for (var i = min; i <= max; i++) {
                var row = calendar.rowlist[i];
                rowtools._selected.push(row);
            }

            rowsel._updateInitialList();

            for (var i = min; i <= max; i++) {
                var row = calendar.rowlist[i];
                rowtools._highlight(row);
            }

        };

        rowtools._updateHighlighting = function() {
            for (var i = 0; i < rowtools._selected.length; i++) {
                var row = rowtools._selected[i];
                rowtools._highlight(row);
            }
        };

        rowtools._highlight = function(row) {
            // cells
            var y = indexOf(calendar.rowlist, row);
            if (y === -1) {  // not found, search using id
                var target = calendar._findRowByResourceId(row.id);
                if (target) {
                    y = target.index;
                }
                else {
                    return;
                }
            }

            // delete cells from row, draw cells
            calendar._deleteCellsInRow(y);
            calendar._drawCells();

            // delete row header, draw row header
            calendar._deleteRow(y);
            calendar._drawRow(y);
        };

        rowtools._getSelectedList = function() {
            var list = [];
            if (!rowtools._selected) {
                return list;
            }
            for(var i = 0; i < rowtools._selected.length; i++) {
                var row = rowtools._selected[i];
                var index = indexOf(calendar.rowlist, row);
                var r = calendar._createRowObject(row, index);
                list.push(r.toJSON());
            }
            return list;
        };


        rowtools._rowSelectLast = null;

        rowtools._clearSelection = function() {

            var selected = rowtools._selected;

            // clear the list
            rowtools._selected = [];
            calendar.selectedRows = [];
            rowsel._cache = [];

            var maxNumberClearedIndividually = 5;

            if (selected.length <= maxNumberClearedIndividually) {
                selected.forEach(function(row) {
                    rowtools._highlight(row);
                });
            }
            else {
                calendar._deleteCells();
                calendar._drawCells();

                for (var i = 0; i < calendar.rowlist.length; i++) {
                    if (calendar.divHeader.rows[i]) {
                        calendar._drawRowForced(i);
                    }
                }
            }

        };

        rowtools._findTableRow = function(row) {
            var table = calendar.divHeader;
            for (var y = 0; y < table.rows.length; y++) {
                var r = table.rows[y];
                if (r && r.cells[0] && r.cells[0].row && r.cells[0].row.resource === row.resource) {
                    return r;
                }
            }
            return null;
        };

        rowtools._startMoving = function(row) {
            var rowmoving = DpGlobal.rowmoving;
            var rowResolved = row.split.parent ? row.split.parent : row;

            rowmoving.row = rowResolved;
            rowmoving.sourceCalendar = calendar;
            rowmoving.cursor = calendar.divResScroll.style.cursor;
            calendar.divResScroll.style.cursor = "move";

            rowtools._createOverlay(rowResolved);
        };

        rowtools._resetMoving = function() {
            calendar.divResScroll.style.cursor = rowmoving.cursor;
            deleteElement(rowmoving.div);
            rowtools._deleteOverlay(rowmoving.row);
            DpGlobal.rowmoving = rowmoving = {};
        };

        rowtools._updateMovingPosition = function(ev) {
            var coords = DayPilot.mo3(calendar.divHeader, ev);
            var ri = calendar._getRow(coords.y, "main", true);
            var row = calendar.rowlist[ri.i];
            if (!row) {
                return;
            }
            if (row.isNewRow) {
                return;
            }
            if (row.split.parent) {
                row = row.split.parent;
            }
            var sameLevelOnly = calendar.rowMoveSameLevelOnly;
            var relative = coords.y - ri.top;
            var rowheight = ri.bottom - ri.top;
            var third1 = rowheight/3;
            var third2 = third1*2;
            var mid = rowheight/2;
            var position = "before";
            var hasChildren = row.children && row.children.length > 0;
            var expanded = hasChildren && row.expanded;
            var sourceInParents = (function() {
                var i = ri.i;
                var lastlevel = row.level;
                while (i >= 0) {
                    var r = calendar.rowlist[i];
                    i--;

                    if (lastlevel <= r.level) {
                        continue;
                    }
                    if (r === rowmoving.row) {
                        return true;
                    }
                    if (r.level === 0) {
                        return false;
                    }
                    lastlevel = r.level;
                }
                return false;
            })();
            var target = row;

            var childEnabled = calendar.treeEnabled;
            if (sourceInParents || (ri.i === rowmoving.row.index && !sameLevelOnly)) {
                position = "forbidden";
            }
            else if (childEnabled) {
                if (sameLevelOnly) {
                    var srcLevel = rowmoving.row.level;
                    var tgtLevel = row.level;
                    if (tgtLevel === srcLevel - 1) {
                        position = "child";
                    }
                    else if (srcLevel !== tgtLevel) {
                        if (srcLevel === tgtLevel - 1) {
                            var par = row._makeVisibleParent;
                            var lastPos = par.children.length - 1;
                            if (row.index === par.children[lastPos]) {
                                target = par;
                                position = "after";
                            }
                            else {
                                position = "forbidden"
                            }
                        }
                        else {
                            position = "forbidden";
                        }
                    }
                    else {
                        if (relative < mid) {
                            position = "before";
                        }
                        else if (hasChildren && expanded) {
                            position = "before";
                        }
                        else {
                            position = "after";
                        }
                    }
                }
                else if (hasChildren && expanded) {
                    if (relative < mid) {
                        position = "before";
                    }
                    else {
                        position = "child";
                    }
                }
                else {
                    if (relative < third1) {
                        position = "before";
                    }
                    else if (relative < third2) {
                        position = "child";
                    }
                    else {
                        position = "after";
                    }
                }
            }
            else {
                if (hasChildren) {
                    position = "before";
                }
                else {
                    if (relative < mid) {
                        position = "before";
                    }
                    else {
                        position = "after";
                    }
                }
            }

            if (rowmoving.row.moveDisabled) {
                position = "forbidden";
            }

            rowmoving.calendar = calendar;
            rowmoving.source = rowmoving.row;
            // rowmoving.target = calendar.rowlist[ri.i];
            rowmoving.target = target;
            rowmoving.position = position;

            var changed = (function() {
                if (!rowmoving.last) {
                    return true;
                }
                if (rowmoving.last.target !== rowmoving.target) {
                    return true;
                }
                if (rowmoving.last.position !== rowmoving.position) {
                    return true;
                }
                return false;
            })();

            if (changed) {
                if (typeof calendar.onRowMoving === 'function') {
                    var args = {};
                    args.source = calendar._createRowObject(rowmoving.source);
                    args.target = calendar._createRowObject(rowmoving.target);
                    args.position = position;

                    calendar.onRowMoving(args);

                    rowmoving.position = args.position;
                }
            }
            else if (rowmoving.last) {
                rowmoving.position = rowmoving.last.position;
            }

            rowmoving.last = {};
            rowmoving.last.target = rowmoving.target;
            rowmoving.last.position = rowmoving.position;

            (function drawRowPosition() {
                if (rowmoving.div) {
                    deleteElement(rowmoving.div);
                }
                var top = ri.top;
                var pos = rowmoving.position;
                var ro = calendar.rowlist[ri.i];
                var level = ro.level;
                var left = level * calendar.treeIndent;

                switch (pos) {
                    case "before":
                        top = ri.top;
                        break;
                    case "child":
                        top = ri.top + mid;
                        break;
                    case "after":
                        top = ri.bottom;
                        break;
                    case "forbidden":
                        top = ri.top + mid;
                        break;
                }

                var width = calendar._getTotalRowHeaderWidth() - left;

                var position = createDiv();
                position.style.position = "absolute";
                position.style.left = left + "px";
                position.style.width = width + "px";
                position.style.top = top + "px";

                position.className = calendar._prefixCssClass("_rowmove_position_" + pos);

                rowmoving.div = position;
                calendar.divResScroll.appendChild(position);

            })();
        };

        rowtools._move = function(args) {

            // modify .resources
            var source = args.source.$.row.resource;
            var target = args.target.$.row.resource;
            var position = args.position;

            if (source === target) {
                return;
            }

            if (position === "forbidden") {
                return;
            }

            //var rowmoving = DpGlobal.rowmoving;

            // remove from source
            var sourceParent = args.source.calendar._restools._findParentArray(source);
            if (!sourceParent) {
                throw new DayPilot.Exception("Cannot find source node parent");
            }
            var sourceIndex = indexOf(sourceParent, source);
            sourceParent.splice(sourceIndex, 1);

            // move to target
            var targetParent = restools._findParentArray(target);
            if (!targetParent) {
                throw new DayPilot.Exception("Cannot find target node parent");
            }
            var targetIndex = indexOf(targetParent, target);

            switch (position) {
                case "before":
                    targetParent.splice(targetIndex, 0, source);
                    break;
                case "after":
                    targetParent.splice(targetIndex + 1, 0, source);
                    break;
                case "child":
                    if (!target.children) {
                        target.children = [];
                        target.expanded = true;
                    }
                    target.children.push(source);
                    break;
            }

            calendar.update();
        };

        var rm = {};
        this._rowmoving = rm;

        // activate dragging mode
        rm._start = function(ev) {

        };


        var restools = {};
        this._restools = restools;

        restools._findParentArray = function(res) {
            return restools._findInArray(calendar.resources, res);
        };

        restools._findInArray = function(array, res) {
            if (indexOf(array, res) !== -1) {
                return array;
            }
            for(var i = 0; i < array.length; i++) {
                var r = array[i];
                if (r.children && r.children.length > 0) {
                    var parent = restools._findInArray(r.children, res);
                    if (parent) {
                        return parent;
                    }
                }
            }
            return null;
        };

        this._loadResources = function() {
            // this.rowlist = createList();

            var resources = this.resources;

            var force = this._serverBased();
            if (!force) {
                if (this.viewType === "Gantt") {
                    resources = this._loadResourcesGantt();
                }
                else if (this.viewType === "Days") {
                    resources = this._loadResourcesDays();
                }
            }

            if (force && this.viewType === "Days" && (!resources || resources.length === 0)) {
                resources = this._loadResourcesDays();
            }

            // pass by reference
            var index = {};
            index.i = 0;

            if (resources != null && !DayPilot.isArray(resources)) {
                throw new DayPilot.Exception("DayPilot.Scheduler.resources expects an array object");
            }

            resources = resources || [];

            calendar._splitResources = false;

            var main = resources.filter(function(r) {
                var frozen = typeof r.frozen === "string" ? r.frozen.toLowerCase() : null;
                return frozen !== "top" && frozen !== "bottom";
            });
            calendar.rowlist = createList();
            this._loadResourceChildren(main, index, 0, null, this.treeEnabled, false, "main");

            var top = resources.filter(function(r) { return typeof r.frozen === "string" && r.frozen.toLowerCase() === "top";});
            calendar._grids.top.rowlist = createList();
            calendar._grids.top.height = 0;
            this._loadResourceChildren(top, {"i":0}, 0, null, false, false, "top");

            var bottom = resources.filter(function(r) { return typeof r.frozen === "string" && r.frozen.toLowerCase() === "bottom";});
            calendar._grids.bottom.rowlist = createList();
            calendar._grids.bottom.height = 0;
            this._loadResourceChildren(bottom, {"i":0}, 0, null, false, false, "bottom");

            // moved to _update, after row filter
            // calendar._createCells();

            var newResourceRow = calendar.rowCreateHandling !== "Disabled";
            if (newResourceRow) {
                this._createNewResourceRow();
            }
        };

        this._createNewResourceRow = function() {
            var r = {};
            r.id = "NEW";
            r.isNewRow = true;
            r.html = "";
            r.index = calendar.rowlist.length;
            //r.moveEnabled = false;
            r.loaded = true;
            r.start = this.startDate;
            r.children = [];
            r.height = calendar.eventHeight;
            r.marginBottom = 0;
            r.marginTop = 0;
            r.getHeight = function() {
                if (calendar.rowCreateHeight) {
                    return calendar.rowCreateHeight;
                }
                return calendar.eventHeight + calendar.rowMarginBottom + calendar.rowMarginTop;
                //return Math.max(calendar.rowMinHeight, calendar.eventHeight + calendar.rowMarginBottom);
            };
            r._putIntoLine = function() {};
            r._resetEvents = function() {};

            this.rowlist.push(r);
        };

        this._createCells = function(options) {

            // debugger;
            options = options || {};
            var includeHidden = options.includeHidden;

            calendar.rowlist.forEach(function(row, y) {
                create(row, y);
            });

            calendar._grids.top.rowlist.forEach(function(row, y) {
                create(row, y);
            });

            calendar._grids.bottom.rowlist.forEach(function(row, y) {
                create(row, y);
            });


            function create(row, y) {
                row.cells = [];

                if (row.hidden && !includeHidden) {
                    return;
                }

                var parent = row.split && row.split.parent;

                var columns = calendar.rowHeaderColumns || [{}];

                columns.forEach(function(coldef, x) {
                    var cell = {};
                    cell.row = coldef.split ? row : parent || row;
                    // cell.base = parent;
                    cell.y = y;
                    cell.x = x;

                    cell.rowspan = 1;

                    var hasRowSpan = !coldef.split && parent;
                    var firstInMergedRows = parent && row.split._isFirstVisible();
                    var splitColNoChildren = coldef.split && !parent;

                    var visibleChildrenCount = parent && parent.split.list.filter(function(r) { return !r.hidden; }).length;
                    var refIndex = 0;
                    if (parent) {
                        var first = parent.split.list.find(function(r) { return r.split._isFirstVisible(); });
                        var index = parent.split.list.indexOf(first);
                        if (index > 0) {
                            refIndex = index;
                        }
                    }

                    // create cell
                    if (hasRowSpan) {
                        if (firstInMergedRows) {
                            cell.rowspan = visibleChildrenCount;
                            cell.totalHeight = function() {
                                return parent.split.totalHeight();
                            }
                            // cell.html = grid._displayVal(cell.row.data, coldef.display);
                        }
                        else {
                            cell.refCell = parent.split.list[refIndex].cells[x];
                        }
                    }
                    else {
                        if (splitColNoChildren) {
                            //cell.html = "";
                        }
                        else {
                            // cell.html = grid._displayVal(row.data, coldef.display);
                        }

                    }

                    row.cells.push(cell);

                });
            }
        };

        this._loadResourcesGantt = function() {
            var list = [];

            if (this._ganttAppendToResources && this.resources) {
                for (var i = 0; i < this.resources.length; i++) {
                    list.push(this.resources[i]);
                }
            }

            if (!this.events.list) {
                return;
            }

            //this.resources = [];
            for (var i = 0; i < this.events.list.length; i++) {
                var e = this.events.list[i];
                var r = {};
                r.id = e.id;
                r.name = e.text;
                r.columns = e.columns;
                list.push(r);
            }

            return list;
        };

        this._loadResourcesDays = function() {
            var list = [];
            var start = calendar._visibleStart();
            var locale = this._resolved._locale();

            var resources = calendar.resources || [];

            var top = resources.filter(function(r) { return typeof r.frozen === "string" && r.frozen.toLowerCase() === "top";});
            var bottom = resources.filter(function(r) { return typeof r.frozen === "string" && r.frozen.toLowerCase() === "bottom";});

            list = list.concat(top).concat(bottom);

            for (var i = 0; i < this.days; i++) {
                //var d = this.startDate.addDays(i);
                var d = start.addDays(i);

                if (!calendar.showNonBusiness && !calendar.businessWeekends) {
                    if (d.dayOfWeek() == 0 || d.dayOfWeek() == 6) {
                        continue;
                    }
                }

                var r = {};
                r.name = d.toString(locale.datePattern, locale);
                r.start = d;
                list.push(r);
            }
            return list;
        };

        this._visibleStart = function() {
            if (this.itline && this.itline.length > 0) {
                return this.itline[0].start;
            }
            return new DayPilot.Date(this.startDate);
        };

        this._visibleEnd = function() {
            if (this.itline && this.itline.length > 0) {
                var end = calendar.itline[this.itline.length - 1].end;
                if (calendar.viewType !== "Days") {
                    return end;
                }
                return end.addDays(calendar.days - 1);
            }
            var start = new DayPilot.Date(calendar.startDate);
            return start.addDays(calendar.days);
        };

        this.visibleStart = function() {
            return this._visibleStart();
        };

        this.visibleEnd = function() {
            return this._visibleEnd();
        };

        this._createRowFromResource = function(res, parent) {
            var row = {};

            // defined values
            row.backColor = res.backColor;
            row.fontColor = res.fontColor;
            row.cssClass = res.cssClass;
            row.expanded = res.expanded;
            row.name = res.name;
            // row.html = res.html ? res.html : row.name;
            row.html = calendar._xssTextHtml(res.name, res.html);
            row.emptyHeight = typeof res.emptyHeight !== "undefined" ? res.emptyHeight : calendar.rowEmptyHeight;
            row.eventHeight = typeof res.eventHeight !== 'undefined' ? res.eventHeight : calendar._resolved._eventHeight();
            row.minHeight = typeof res.minHeight !== 'undefined' ? res.minHeight : calendar.rowMinHeight;
            row.marginBottom = typeof res.marginBottom !== 'undefined' ? res.marginBottom : calendar.rowMarginBottom;
            row.marginTop = typeof res.marginTop !== 'undefined' ? res.marginTop : calendar.rowMarginTop;
            row.eventStackingLineHeight = typeof res.eventStackingLineHeight !== 'undefined' ? res.eventStackingLineHeight : calendar.eventStackingLineHeight;
            row.loaded = !res.dynamicChildren;  // default is true
            row.id = res.id || res.value;  // accept both id and value
            row.toolTip = res.toolTip;
            row.children = [];
            row.columns = [];
            row.start = res.start ? new DayPilot.Date(res.start) : this._visibleStart();
            row.isParent = res.isParent;
            row.contextMenu = res.contextMenu ? DayPilot.Util.evalVariable(res.contextMenu) : this.contextMenuResource;
            row.areas = res.areas;
            row.moveDisabled = res.moveDisabled;
            row.bubbleHtml = res.bubbleHtml;
            row.cellsDisabled = res.cellsDisabled;

            // custom properties
            row.tags = res.tags;

            // gantt
            row.task = res.task;

            // kanban
            row.swimlane = res.swimlane;
            row.hideEvents = res.hideEvents;

            // calculated
            row.height = row.eventHeight;  // TODO might not be necessary
            row.level = 0;

            // reference to resource
            row.resource = res._data;

            // event ordering
            row.lines = [];
            row.blocks = [];
            row.containers = [];
            row.containerCache = {};

            row.isRow = true;

            row.split = {};
            row.split.list = [];
            row.split.totalHeight = function() {
                var height = 0;
                this.list.forEach(function(r) {
                    if (!r.hidden) {
                        height += r.height;
                    }
                });
                return height;
            };

            // functions
            row.getHeight = function() {
                // if (typeof this.forcedHeight === "number") {
                //     return this.forcedHeight;
                // }
                var height = 0;
                var maxLines = Math.max(0, row.resource && row.resource.maxLines || 100000);
                if (calendar.groupConcurrentEvents) {
                    for (var i = 0; i < this.blocks.length; i++) {
                        var block = this.blocks[i];
                        height = Math.max(height, block.getHeight());
                    }
                }
                else {
                    if (this.lines.length > 0) {
                        var lineCount = Math.min(this.lines.length, maxLines);
                        var last = lineCount - 1;
                        var line = this.lines[last];
                        var lheight = line.height || this.eventHeight;
                        var top = line.top || 0;
                        height = top + lheight;
                    }
                }
                if (height === 0) {
                    if (typeof this.emptyHeight === "number") {
                        return this.emptyHeight;
                    }
                    height = this.eventHeight;
                }
                return (height > this.minHeight) ? height : this.minHeight;
            };

            row._end = function() {
                var rowOffset = row.start.getTime() - calendar._visibleStart().getTime();
                var end = calendar.itline[calendar.itline.length - 1].end.addTime(rowOffset);
                return end;
            };

            row._resetEvents = function() {
                var r = this;
                r.events = createList();
                r.events.forRange = function(start, end) {
                    start = new DayPilot.Date(start);
                    end = end ? new DayPilot.Date(end) : r._end();
                    var result = createList();
                    for (var i = 0; i < r.events.length; i++) {
                        var ev = r.events[i];
                        var evEnd = calendar._adjustEndIn(ev.end());
                        if (overlaps(ev.start(), evEnd, start, end)) {
                            result.push(ev);
                        }
                    }
                    return result;
                };
            };

            row._calculateUtilization = function() {
                var r = this;

                var sections = r.sections = getSections();
                for (var i = 0; i < sections.length; i++) {
                    var section = sections[i];
                    section.events = createList();
                    //var test = section.start.addTime(1);
                    for (var x = 0; x < r.events.length; x++) {
                        var e = r.events[x];
                        if (overlaps(section.start, section.end, e.start(), e.rawend())) {
                            section.events.push(e);
                        }
                    }
                    section.sum = function(name) {
                        var sum = 0;
                        for (var i = 0; i < this.events.length; i++) {
                            var e = this.events[i];
                            var value = 0;
                            if (typeof name === "undefined") {
                                value = 1;
                            }
                            else if (e.tag(name)) {
                                value = e.tag(name);
                            }
                            else if (e.data[name]) {
                                value = e.data[name];
                            }

                            if (typeof value === 'number') {
                                sum += value;
                            }
                        }
                        return sum;
                    }
                }

                function getPoints() {
                    var points = [];
                    for (var i = 0; i < r.events.length; i++) {
                        var e = r.events[i];
                        if (!contains(points, e.start().toString())) {
                            points.push(e.start().toString());
                        }
                        if (!contains(points, e.rawend().toString())) {
                            points.push(e.rawend().toString());
                        }
                    }

                    points.sort();
                    return points;
                }

                function getSections() {
                    var points = getPoints();
                    var sections = [];

                    var section = { "start": r.data.start};
                    for (var i = 0; i < points.length; i++) {
                        section.end = new DayPilot.Date(points[i]);
                        sections.push(section);
                        section = { "start": new DayPilot.Date(points[i])};
                    }
                    section.end = r.data.end;
                    sections.push(section);

                    sections.forRange = function(start, end) {
                        var list = createList();
                        for (var i = 0; i < this.length; i++) {
                            var section = this[i];
                            if (overlaps(start, end, section.start, section.end)) {
                                list.push(section);
                            }
                        }
                        list.maxSum = function(name) {
                            var max = 0;
                            for (var i = 0; i < this.length; i++) {
                                var section = this[i];
                                var sum = section.sum(name);
                                if (sum > max) {
                                    max = sum;
                                }
                            }
                            return max;
                        };
                        return list;
                    };

                    return sections;
                }
            };

            row._createLine = function() {
                // create a new line
                var line = [];
                line.height = 0;
                line.add = function(ep) {
                    this.push(ep);

                    var pheight = ep.part._getHeightWithVersions();

                    if (pheight > line.height) {
                        line.height = pheight;
                    }
                };
                line._isFree = function(colStart, colWidth, except) {
                    //var free = true;
                    var end = colStart + colWidth - 1;
                    var max = this.length;

                    for (var i = 0; i < max; i++) {
                        var e = this[i];
                        if (e.data.nonBlocking) {
                            continue;
                        }
                        if (!(end < e.part.left || colStart > e.part.left + e.part.width - 1)) {
                            if (contains(except, e.data)) {
                                continue;
                            }
                            return false;
                        }

                        // check the container if specified
                        if (e.part.container) {
                            if (!(end < e.part.container.left || colStart > e.part.container.left + e.part.container.width - 1)) {
                                return false;
                            }
                        }

                        // check versions if requested
                        if (calendar.eventVersionsReserveSpace) {
                            if (!(end < e.part.versionsLeft || colStart > e.part.versionsRight - 1)) {
                                return false;
                            }
                        }
                    }

                    return true;
                };

                return line;
            };

            // pixel-based
            row._findFreeLine = function(left, width, forcedLine) {

                if (typeof forcedLine === "number") {

                    // make sure all prior lines are created
                    for (var i = 0; i <= forcedLine; i++) {
                        if (!this.lines[i]) {
                            this.lines[i] = row._createLine();
                        }
                    }

                    return forcedLine;
                }
                else if (forcedLine === "dedicated") {
                    var line = row._createLine();
                    line._isFree = function() { return false; };

                    this.lines.push(line);
                    return this.lines.length - 1;
                }

                // check space in existing lines
                for (var i = 0; i < this.lines.length; i++) {
                    var line = this.lines[i];
                    if (line._isFree(left, width)) {
                        return i;
                    }
                }

                var line = row._createLine();
                this.lines.push(line);
                return this.lines.length - 1;
            };

            row._putIntoLine = function(ep) {
                var thisRow = this;
                var data = ep.data;
                var part = ep.part;
                var container = ep.part.container;

                if (container) {
                    if (container.line === null) { // not placed yet, check "line"
                        if (typeof data.line === "number" || data.line === "dedicated") {
                            i = row._findFreeLine(container.left, container.width, data.line);
                            part.line = i;
                            this.lines[i].add(ep);
                            container.line = i;
                            return i;
                        }
                    }
                }
                else if (typeof data.line === "number" || data.line === "dedicated") {
                    i = row._findFreeLine(part.left, part.width, data.line);
                    part.line = i;
                    this.lines[i].add(ep);
                    return i;
                }

                var i = -1;
                if (container) {
                    if (container.line !== null) {
                        this.lines[container.line].add(ep);
                        return container.line;
                    }
                    i = row._findFreeLine(container.left, container.width);
                    container.line = i;
                }
                else if (calendar.eventVersionsReserveSpace) {
                    i = row._findFreeLine(part.versionsLeft, part.versionsWidth);
                }
                else {
                    i = row._findFreeLine(part.left, part.width);
                }

                part.line = i;
                this.lines[i].add(ep);
                return i;
            };

            row._putIntoBlock = function(ep) {

                var reserve = calendar.eventVersionsReserveSpace;

                for (var i = 0; i < this.blocks.length; i++) {
                    var block = this.blocks[i];
                    if (indexOf(block.events, ep) !== -1) {
                        return;
                    }
                    var left = reserve ? ep.part.versionsLeft : ep.part.left;
                    var width = reserve ? ep.part.versionsWidth : ep.part.width;
                    if (block._overlapsWith(left, width)) {
                        block.events.push(ep);
                        ep.part.block = block;
                        block.min = Math.min(block.min, left);
                        block.max = Math.max(block.max, left + width);
                        return i;
                    }
                }

                // no suitable block found, create a new one
                var block = {};
                block.expanded = false;
                block.row = this;
                block.events = createList();
                block.lines = createList();

                block._putIntoLine = function(ep) {
                    var thisCol = this;

                    for (var i = 0; i < this.lines.length; i++) {
                        var line = this.lines[i];
                        var pleft = reserve ? ep.part.versionsLeft : ep.part.left;
                        var pwidth = reserve ? ep.part.versionsWidth : ep.part.width;
                        if (line._isFree(pleft, pwidth)) {
                            line.add(ep);
                            return i;
                        }
                    }

                    var line = [];
                    line.height = 0;
                    line.add = function(ep) {
                        this.push(ep);
                        if (ep.part.height > line.height) {
                            line.height = ep.part.height;
                        }
                        if (ep.data.versions) {
                            line.height = ep.part.height + ep.data.versions.length * (calendar.eventVersionHeight + calendar.eventVersionMargin);
                        }
                    };
                    line._isFree = function(start, width) {
                        //var free = true;
                        var end = start + width - 1;
                        var max = this.length;

                        for (var i = 0; i < max; i++) {
                            var e = this[i];
                            var pleft = reserve ? e.part.versionsLeft : e.part.left;
                            var pwidth = reserve ? e.part.versionsWidth : e.part.width;

                            if (!(end < pleft || start > pleft + pwidth - 1)) {
                                return false;
                            }
                        }

                        return true;
                    };

                    line.add(ep);

                    this.lines.push(line);

                    //return this.lines.length - 1;

                };

                block._overlapsWith = function(start, width) {
                    var end = start + width - 1;

                    if (!(end < this.min || start > this.max - 1)) {
                        return true;
                    }

                    return false;
                };

                block.getHeight = function() {
                    if (!this.expanded) {
                        return calendar.eventHeight;
                    }
                    if (this.lines.length > 0) {
                        var last = this.lines.length - 1;
                        var line = this.lines[last];
                        var lheight = line.height || calendar.eventHeight;
                        var top = line.top || 0;
                        return top + lheight;
                    }
                    else {
                        return calendar.eventHeight;
                    }
                };

                block.clear = function() {
                    block.events = createList();
                    block.min = null;
                    block.max = null;
                };

                block.events.push(ep);
                ep.part.block = block;
                block.min = reserve ? ep.part.versionsLeft : ep.part.left;
                block.max = block.min + (reserve ? ep.part.versionsWidth : ep.part.width);

                this.blocks.push(block);

                //return this.blocks.length - 1;
            };

            row._hiddenUsingFilter = false;
            row._makeVisibleParent = parent;
            row._makeVisibleOnFilter = function() {
                /*
                 if (this._makeVisibleDefaultHidden) {
                 return;
                 }
                 */
                this.hidden = !this._allParentsExpanded();
                this._hiddenUsingFilter = false;
                if (this._makeVisibleParent) {
                    this._makeVisibleParent._makeVisibleOnFilter();
                }
            };

            row._allParentsExpanded = function() {
                if (!this._makeVisibleParent) {  // top
                    return true;
                }
                return this._makeVisibleParent._allParentsExpanded() && this._makeVisibleParent.expanded;
            };

            if (res.columns) {
                for (var j = 0; j < res.columns.length; j++) {
                    row.columns.push(res.columns[j]); // plain copy, it's the same structure
                }
            }

            return row;

        };

        this._filterRows = function() {

            var rowlist = calendar._rowlistMerged();
            rowlist.forEach(function(row) {
                if (row.isNewRow) {
                    return;
                }
                if (typeof calendar.onRowFilter === "function" && calendar.rows._filterParams) {
                    var parent = row._makeVisibleParent;
                    var args = {};
                    //args.visible = !hidden;
                    args.visible = true;
                    args.row = calendar._createRowObject(row);
                    args.filter = calendar.rows._filterParams;
                    args.filterParam = calendar.rows._filterParams;
                    args.control = calendar;

                    calendar.onRowFilter(args);

                    row._hiddenUsingFilter = !args.visible;
                    if (!args.visible) {
                        row.hidden = true;
                    }
                    else {
                        var alwaysShowParents = calendar.rowFilterParentsAlwaysVisible;
                        if (alwaysShowParents && parent) {
                            parent._makeVisibleOnFilter();
                        }
/*                        if (row.split.parent) {
                            row.split.parent._makeVisibleOnFilter();
                        }*/
                    }
                }
            });
        };

        this._nodesAllLeaves = function(resources) {
            return !resources.some(function(r) {
                return r.children && r.children.length;
            });
        };

        this._nodesAllParents = function(resources) {
            return !resources.some(function(r) {
                return !r.children || r.children.length === 0;
            });
        };

        this._gridInfo = function(name) {
            name = name || "main";
            return calendar._grids[name];
        };

        this._loadResourceChildren = function(resources, index, level, parent, recursively, hidden, gridName) {
            if (!resources) {
                return;
            }

            var sortingActive = false;
            if (calendar.rows._sortParam) {
                switch (calendar.rowSortingMode) {
                    case "LeavesOnly":
                        sortingActive = calendar._nodesAllLeaves(resources);
                        break;
                    case "ParentsOnly":
                        sortingActive = calendar._nodesAllParents(resources);
                        break;
                }
            }

            if (sortingActive) {
                var sortProperty = calendar.rows._sortField();
                var invert = calendar.rows._sortOrder() === "desc";
                var copy = createList(resources, true);
                copy.sort(function(first, second) {
                    var a = calendar._getTabularValue(first, sortProperty);
                    var b = calendar._getTabularValue(second, sortProperty);

                    var result = 0;
                    if (a === b) {
                        result = 0;
                    }
                    else if (typeof a === "number" && typeof b === "number") {
                        result = a - b;
                    }
                    else {
                        result = calendar._stringComparer(a, b, "asc");
                    }
                    return invert ? -result: result;
                });
                resources = copy;
            }

            var rowlist = calendar._gridInfo(gridName).rowlist;

            for (var i = 0; i < resources.length; i++) {
                if (!resources[i]) {
                    continue;
                }

                var additional = {};
                additional.level = level;
                additional.hidden = hidden;
                additional.index = index.i;

                //var res = this._createBeforeResHeaderRenderArgs(resources[i], additional);

                if (resources[i].hidden) {
                    continue;
                }

                var res = this._doBeforeResHeaderRender(resources[i], additional);
                var row = calendar._createRowFromResource(res, parent);

                if (hidden) {
                    row.hidden = true;
                }

                row.level = level;
                row.index = index.i;
                row.grid = gridName || "main";

                var noChildren = !res.children || res.children.length === 0;
                var isSplit = noChildren && res.split;
                if (isSplit) {
                    loadSplit(res, row);
                }
                else {
                    if (parent !== null) {
                        parent.children.push(index.i);
                    }
                    rowlist.push(row);
                    index.i++;
                }

                if (recursively && res.children && res.children.length) {
                    var hiddenChildren = hidden || !row.expanded;
                    this._loadResourceChildren(res.children, index, level + 1, row, true, hiddenChildren, gridName);
                }
            }

            function loadSplit(res, splitParent) {
                for (var i = 0; i < res.split.length; i++) {

                    (function() {
                        var r = res.split[i];

                        // check "parent"
                        var sres = calendar._doBeforeResHeaderRender(r, additional);
                        var srow = calendar._createRowFromResource(sres, parent);

                        srow.level = level;
                        srow.index = index.i;
                        srow.grid = gridName || "main";

                        if (hidden) {
                            srow.hidden = true;
                        }

                        srow.split = {};
                        // srow.split.parent = row;
                        srow.split.parent = splitParent;
                        srow.split.y = i;
                        srow.split._isFirstVisible = function() {
                            var first = srow.split.parent.split.list.find(function(childR) {
                                return !childR.hidden;
                            });
                            return srow === first;
                        };
                        // not necessary
                        srow._makeVisibleParent = splitParent;

                        splitParent.split.list.push(srow);

                        if (parent !== null) {
                            parent.children.push(index.i);
                        }
                        rowlist.push(srow);
                        index.i++;

                        calendar._splitResources = true;

                    })();
                }
            }


        };


        this._columnProps = ['text', 'html', 'backColor', 'cssClass', 'areas', 'horizontalAlignment', 'hidden'];

        this._doBeforeRowHeaderRender = function(row) {
            if (row.isNewRow) {
                return {
                    "row": {
                        "cssClass": calendar._prefixCssClass("_row_new"),
                        "moveDisabled": true,
                        "html": calendar._xssTextHtml(calendar.rowCreateText, calendar.rowCreateHtml)
                    }
                };
            }


            var args = {};
            args.row = this._createRowObject(row);

            copyProps(row, args.row, ['html', 'backColor', 'fontColor', 'cssClass', 'toolTip', 'contextMenu', 'moveDisabled']);
            args.row.areas = DayPilot.Util.createArrayCopy(row.areas);
            args.row.columns = DayPilot.Util.createArrayCopy(row.columns, calendar._columnProps);

            if (row.split && DayPilot.isArray(calendar.rowHeaderColumns)) {
                calendar.rowHeaderColumns.forEach(function(coldef, x) {
                    if (!row.split.parent && row.split.list.length === 0 && coldef.split) {
                        args.row.columns[x].text = "";
                    }
                    else if (!row.split.parent && coldef.split) {
                        args.row.columns[x] = null;
                    }
                    else if (row.split.parent && !coldef.split) {
                        args.row.columns[x] = null;
                    }
                });
            }

            // var rhc = resolved._rowHeaderColumnsVisible();
            var rhc = calendar.rowHeaderColumns;
            if (typeof args.row.columns === 'undefined' && rhc.length > 0) {
                r.columns = [];
                for (var i = 0; i < rhc.length; i++) {
                    r.columns.push({});
                }
            }

            var isParent = args.row.children().length > 0;
            if (isParent && calendar.rowHeaderColumnsMergeParents && calendar.rowHeaderColumns) {
                calendar.rowHeaderColumns.forEach(function(coldef, x) {
                   if (x > 0) {
                       delete args.row.columns[x];
                   }
                });
            }

            if (typeof this.onBeforeRowHeaderRender === "function") {
                this.onBeforeRowHeaderRender(args);
            }

            return args;
        };

        this._doBeforeResHeaderRender = function(res, additional) {
            var r = this._createBeforeResHeaderRenderArgs(res, additional);

            if (typeof this.onBeforeResHeaderRender === 'function') {
                var args = {};
                args.resource = r;
                this.onBeforeResHeaderRender(args);
            }
            return r;
        };

        this._createBeforeResHeaderRenderArgs = function(res, additional) {
            var r = {
                get $data() { return this._data; }
            };

            // extra properties like level, index, hidden
            for (var name in additional) {
                r[name] = additional[name];
            }

            // shallow copy
            // TODO resolve children, columns
            for (var name in res) {
                r[name] = res[name];
            }

/*
            if (typeof res.html === 'undefined') {
                r.html = res.name;
            }
*/

            r.html = calendar._xssTextHtml(res.name, res.html);

            var rowHeaderColumnsDefined = calendar.rowHeaderColumns && calendar.rowHeaderColumns.length > 0;

            if (rowHeaderColumnsDefined) {
                if (typeof r.columns === 'undefined') {
                    r.columns = [];
                    var rhc = calendar.rowHeaderColumns;
                    if (calendar._isTabularMode()) {
                        for (var i = 0; i < rhc.length; i++) {
                            var headerCol = rhc[i];
                            var text = calendar._getTabularValue(res, headerCol.display);
                            r.columns.push({"text": text});
                        }
                        if (r.columns[0] && rhc[0] && !rhc[0].display) {
                            r.columns[0].text = r.name;
                        }
                    }
                    // Tabular
                    else {
                        for (var i = 0; i < rhc.length; i++) {
                            r.columns.push({});
                        }
                    }
                }
            }

            r._data = res;

            return r;
        };


        this._initPrepareDiv = function() {
            this.nav.top.dp = this;
            this.nav.top.innerHTML = "";  // TODO remove
            addClass(this.nav.top, this._prefixCssClass("_main"));

            this.nav.top.setAttribute("role", "region");
            this.nav.top.setAttribute("aria-label", "scheduler");

            this.nav.top.style.MozUserSelect = 'none';
            this.nav.top.style.KhtmlUserSelect = 'none';
            this.nav.top.style.webkitUserSelect = 'none';

            this.nav.top.style.WebkitTapHighlightColor = "rgba(0,0,0,0)";
            this.nav.top.style.WebkitTouchCallout = "none";

            if (this.width) {
                this.nav.top.style.width = this.width;
            }
            if (this.heightSpec === "Parent100Pct") {
                this.nav.top.style.height = "100%";
            }
            //this.nav.top.style.boxSizing = "border-box";
            this.nav.top.style.lineHeight = "1.2";
            this.nav.top.style.position = "relative";

            if (!this.visible) {
                this.nav.top.style.display = "none";
            }

            this.nav.top.onmousemove = this._onTopMouseMove;
            this.nav.top.onmouseout = function() { calendar._cancelAutoexpand(); };

            DayPilot.reNonPassive(this.nav.top, "touchstart", touch._onMainTouchStart);
            DayPilot.reNonPassive(this.nav.top, "touchmove", touch._onMainTouchMove);
            DayPilot.reNonPassive(this.nav.top, "touchend", touch._onMainTouchEnd);

            if (this.hideUntilInit && this.backendUrl) {
                this.nav.top.style.visibility = 'hidden';
            }
            var rowHeaderWidth = this._getOuterRowHeaderWidth();

            var timeHeaderAbove = calendar.timeHeaderPosition === "Top";
            calendar._renderedTimeHeaderPosition = calendar.timeHeaderPosition;

            var layout = this._resolved._layout();
            if (layout === 'DivBased') {
                // left
                var left = createDiv();
                //left.style.cssFloat = "left";
                //left.style.styleFloat = "left";  // IE7
                left.style.position = "absolute";
                left.style.left = "0px";
                left.style.width = (rowHeaderWidth) + "px";

                // divider horizontal
                var dh1 = createDiv();
                // prevent the line from disappearing for zoom < 100%
                // dh1.style.height = "1px";
                dh1.style.height = "0px";
                dh1.style.boxSizing = "content-box";
                dh1.style.borderTop = "1px solid transparent";
                dh1.className = this._prefixCssClass("_divider_horizontal");
                this.nav.dh1 = dh1;

                this.nav.left = left;

                if (calendar.timeHeaderPosition === "Top") {
                    left.appendChild(this._drawCorner());
                    left.appendChild(dh1);
                    left.appendChild(this._drawResScroll());
                    if (calendar._grids.top.enabled() || true) {
                        left.appendChild(this._drawGridTopResScroll());
                    }
                    left.appendChild(this._drawGridBottomResScroll());
                }
                else if (calendar.timeHeaderPosition === "Bottom") {
                    left.appendChild(this._drawResScroll());
                    left.appendChild(dh1);
                    left.appendChild(this._drawCorner());
                }
                else {
                    left.appendChild(this._drawResScroll());
                }

                // divider
                var divider = createDiv();
                divider.style.position = "absolute";
                divider.style.left = (rowHeaderWidth) + "px";
                //divider.style.cssFloat = "left";
                //divider.style.styleFloat = "left";  // IE7
                divider.style.width = resolved._splitterWidth() + "px";
                divider.style.height = (this._getTotalHeaderHeight() + this._getScrollableHeight()) + "px";
                divider.className = this._prefixCssClass("_divider") + " " + this._prefixCssClass("_splitter");  // TODO _divider is obsolete
                divider.setAttribute("unselectable", "on");
                this.nav.divider = divider;

                // maybe not the best place
                if (this.rowHeaderScrolling) {
                    this._activateSplitter();
                }

                // right
                var right = createDiv();
                right.style.marginLeft = (rowHeaderWidth + resolved._splitterWidth()) + "px";
                right.style.marginRight = '1px';
                right.style.position = 'relative';

                this.nav.right = right;

                // divider horizontal #2
                var dh2 = createDiv();
                if (timeHeaderAbove) {
                    dh2.style.position = "absolute";
                    dh2.style.top = this._getTotalHeaderHeight() + "px";
                }
                dh2.style.width = "100%";
                // dh2.style.height = "1px";

                dh2.style.height = "0px";
                dh2.style.boxSizing = "content-box";
                dh2.style.borderBottom = "1px solid transparent";
                dh2.setAttribute("data-dh2", "true");

                dh2.className = this._prefixCssClass("_divider_horizontal");
                this.nav.dh2 = dh2;

                if (calendar.timeHeaderPosition === "Top") {
                    right.appendChild(calendar._drawTimeHeaderDiv());
                    right.appendChild(calendar._drawMainContent());
                    right.appendChild(dh2);
                    if (calendar._grids.top.enabled() || true) {
                        right.appendChild(calendar._drawGridTopMainContent());
                    }
                    right.appendChild(calendar._drawGridBottomMainContent());
                }
                else if (calendar.timeHeaderPosition === "Bottom") {
                    right.appendChild(calendar._drawMainContent());
                    right.appendChild(dh2);
                    right.appendChild(calendar._drawTimeHeaderDiv());
                }
                else {
                    right.appendChild(calendar._drawMainContent());
                }

                // clear
                var clear = createDiv();
                clear.style.clear = 'left';

                var dividerTop = createDiv();
                dividerTop.style.height = "1px";
                dividerTop.style.position = "absolute";
                dividerTop.style.left = "0px";
                dividerTop.style.right = "0px";
                dividerTop.style.display = "none";
                dividerTop.className = this._prefixCssClass("_divider_horizontal") + " " + this._prefixCssClass("_divider_horizontal_frozen_top");
                dividerTop.onmousemove = function(ev) {
                    // prevent registered.out()
                    ev.cancelBubble = true;
                };
                this.nav.dividerTop = dividerTop;

                var dividerBottom = createDiv();
                dividerBottom.style.height = "1px";
                dividerBottom.style.position = "absolute";
                dividerBottom.style.left = "0px";
                dividerBottom.style.right = "0px";
                dividerBottom.style.display = "none";
                dividerBottom.className = this._prefixCssClass("_divider_horizontal") + " " + this._prefixCssClass("_divider_horizontal_frozen_bottom");
                dividerBottom.onmousemove = function(ev) {
                    // prevent registered.out()
                    ev.cancelBubble = true;
                };
                this.nav.dividerBottom = dividerBottom;

                // add all at once
                this.nav.top.appendChild(left);
                this.nav.top.appendChild(divider);
                this.nav.top.appendChild(right);
                this.nav.top.appendChild(clear);
                this.nav.top.appendChild(dividerTop);
                this.nav.top.appendChild(dividerBottom);
            }
            else {
                var table = document.createElement("table");
                table.cellPadding = 0;
                table.cellSpacing = 0;
                table.border = 0;

                // required for proper width measuring (onresize)
                table.style.position = 'absolute';

                var row1 = table.insertRow(-1);

                var td1 = row1.insertCell(-1);
                td1.appendChild(this._drawCorner());

                var td2 = row1.insertCell(-1);
                td2.appendChild(this._drawTimeHeaderDiv());

                var row2 = table.insertRow(-1);

                var td3 = row2.insertCell(-1);
                td3.appendChild(this._drawResScroll());

                var td4 = row2.insertCell(-1);
                td4.appendChild(this._drawMainContent());

                this.nav.top.appendChild(table);
            }

            // hidden fields
            this._vsph = createDiv();
            //this.vsph.id = this.id + "_vsph";
            this._vsph.style.display = "none";
            this.nav.top.appendChild(this._vsph);

            if (this._isAspnetWebForms()) {
                var stateInput = document.createElement("input");
                stateInput.type = "hidden";
                stateInput.id = this.id + "_state";
                stateInput.name = this.id + "_state";
                this.nav.state = stateInput;
                this.nav.top.appendChild(stateInput);
            }

            var margin = 5;

            var loading = createDiv();
            loading.style.position = 'absolute';
            loading.style.left = (this._getOuterRowHeaderWidth() + resolved._splitterWidth() + 5) + "px";
            loading.style.top = (this._getTotalHeaderHeight() + margin) + "px";
            loading.style.display = 'none';
            loading.innerHTML = calendar._xssTextHtml(this.loadingLabelText, this.loadingLabelHtml);

            addClass(loading, this._prefixCssClass("_loading"));

            this.nav.loading = loading;
            this.nav.top.appendChild(loading);

            this._drawRowHeaderHideIcon();

            calendar._fixedRelatedInit();
        };

        this._onTopMouseMove = function(ev) {
            if (rowmoving.row) {
                rowtools._updateMovingPosition(ev);
            }
            else if (DayPilotScheduler._splitting) {
                var width = DayPilot.mo3(calendar.nav.top, ev).x;
                var max = calendar._getTotalRowHeaderWidth();
                var min = calendar.rowHeaderWidthMin;
                var newWidth = width - 1;
                if (calendar.rowHeaderCols) {
                    newWidth = Math.min(max, width - 1);
                }
                newWidth = Math.max(min, newWidth);
                // var newWidth = width - 1;
                calendar.rowHeaderWidth = newWidth;
                calendar._rowHeaderHidden = false;

                if (!calendar.rowHeaderCols) {
                    calendar._updateRowHeaderWidthInner();
                }
                calendar._updateRowHeaderWidthOuter();

                calendar._onScroll();
                calendar._crosshairHide();
            }
        };


        // update all positions that depend on header height
        this._updateHeaderHeight = function() {
            var height = this._getTotalHeaderHeight();

            var timeHeaderAbove = calendar.timeHeaderPosition === "Top";

            if (this.nav.corner) {
                this.nav.corner.style.height = (height) + "px";
            }

            //this.divCorner.style.height = (height) + "px";

            if (this.divTimeScroll) {
                this.divTimeScroll.style.height = height + "px";
            }

            if (this.divNorth) {
                this.divNorth.style.height = height + "px";
            }

            if (this.nav.dh1 && this.nav.dh2) {
                if (timeHeaderAbove) {
                    this.nav.dh1.style.top = height + "px";
                    this.nav.dh2.style.top = height + "px";
                }
            }

            this.nav.loading.style.top = (height + 5) + "px";
            if (timeHeaderAbove) {
                this.nav.scroll.style.top = (height + 1) + "px";
            }
        };


        this._getOuterRowHeaderWidth = function() {
            if (this._rowHeaderHidden) {
                return 0;
            }

            var result = 0;

            var fixed = this.rowHeaderScrolling;
            var inner = this._getTotalRowHeaderWidth();
            if (fixed && this.rowHeaderWidth < inner) {
                result = this.rowHeaderWidth;
            }
            else {
                result = inner;
            }

            return result;
        };

        this._activateSplitter = function() {
            var div = this.nav.divider;

            if (calendar.rowHeaderScrolling) {
                div.style.cursor = "col-resize";
                div.setAttribute("unselectable", "on");

                div.onmousedown = function(ev) {
                    var splitting = DayPilotScheduler._splitting = {};
                    splitting.cursor = calendar.nav.top.style.cursor;
                    splitting.cleanup = function() {
                        // calendar._scrollWidth = calendar.nav.scroll.clientWidth;
                        // calendar._cache.drawArea = null;
                        calendar._updateAutoCellWidth();
                        calendar.nav.top.style.cursor = splitting.cursor;
                        if (typeof calendar.onRowHeaderResized === "function") {
                            var args = {};
                            calendar.onRowHeaderResized(args);
                        }
                    };
                    calendar.nav.top.style.cursor = "col-resize";
                    return false;
                };
            }
            else {
                div.style.cursor = null;
                div.onmousedown = null;
            }
        };

        this._updateRowHeaderWidthOuter = function() {
            var dividerWidth = resolved._splitterWidth();

            var width = this._getOuterRowHeaderWidth();
            if (this.nav.corner) this.nav.corner.style.width = width + "px";
            if (this.nav.corner) this.divCorner.style.width = width + "px";
            this.divResScroll.style.width = width + "px";

            if (resolved._layout() === "DivBased") {
                this.nav.left.style.width = (width) + "px";
                this.nav.divider.style.left = (width - dividerWidth) + "px";
                this.nav.right.style.marginLeft = (width) + "px";
            }

            if (this.nav.message) {
                this.nav.message.style.left = calendar._messageLeft() + "px";
            }
            if (this.nav.loading) {
                this.nav.loading.style.left = (width + dividerWidth + 5) + "px";
            }
            if (this.nav.hideIcon) {
                var hi = this.nav.hideIcon;
                var showCss = calendar._prefixCssClass("_header_icon_show");
                var hideCss = calendar._prefixCssClass("_header_icon_hide");
                hi.style.left = (width - 1) + "px";
                if (calendar._rowHeaderHidden) {
                    removeClass(hi, hideCss);
                    addClass(hi, showCss);
                }
                else {
                    removeClass(hi, showCss);
                    addClass(hi, hideCss);
                }
            }
        };

        this._updateRowHeaderWidthInner = function() {
            this._loadRowHeaderColumns();
            var total = this._getTotalRowHeaderWidth();

            var updateCell = function(cell, width, left) {
                if (!cell || !cell.style) {
                    return;
                }
                var div = cell.firstChild;
                if (calendar._resHeaderDivBased) {
                    cell.style.width = width + "px";
                    div.style.width = width + "px";
                    if (typeof left === "number") {
                        cell.style.left = left + "px";
                    }
                }
                else {
                    div.style.width = width + "px";
                }
            };

            var updateRow = function(row) {
                var cell = row.cells[0];
                if (cell && (cell.colSpan > 1 || cell.colSpan === "max")) {
                    var cell = row.cells[0];
                    updateCell(cell, total);
                }
                else {
                    if (calendar.rowHeaderCols) {
                        var left = 0;
                        for (var j = 0; j < row.cells.length; j++) {
                            var width = calendar.rowHeaderCols[j];
                            var cell = row.cells[j];
                            updateCell(cell, width, left);
                            left += width;
                        }
                    }
                    else {
                        var width = calendar.rowHeaderWidth;
                        var cell = row.cells[0];
                        updateCell(cell, width);
                    }
                }

            };

            var table = this.divHeader;
            table.style.width = total + "px";

            var range = calendar._getAreaRowsWithMargin();

            for (var i = range.start; i < range.end; i++) {
                var row = table.rows[i];

                if (!row) {
                    continue;
                }

                updateRow(row);

            }

            if (calendar._grids.top.enabled()) {
                for (var i = 0; i < calendar._grids.top.rowlist.length; i++) {
                    var row = calendar._grids.top.divHeader.rows[i];
                    if (row) {
                        updateRow(row);
                    }
                }
            }

            if (calendar._grids.bottom.enabled()) {
                for (var i = 0; i < calendar._grids.bottom.rowlist.length; i++) {
                    var row = calendar._grids.bottom.divHeader.rows[i];
                    if (row) {
                        updateRow(row);
                    }
                }
            }

            if (calendar.nav.resScrollSpace) {
                calendar.nav.resScrollSpace.style.width = total + "px";
            }

            if (calendar._grids.bottom.enabled()) {
                var div = calendar._grids.bottom.divSpace;
                div.style.width = total + "px";
            }

            this._crosshairHide(); // update

        };

        this._updateRowHeaderWidth = function() {
            this._updateRowHeaderWidthOuter();
            this._updateRowHeaderWidthInner();
        };


        this._drawHeaderColumns = function() {
            var div = calendar.nav.corner;
            var props = resolved._rowHeaderColumnsVisible();

            var scroll = createDiv();
            scroll.style.position = "absolute";
            scroll.style.bottom = "0px";
            scroll.style.left = "0px";
            scroll.style.width = "100%";
            scroll.style.height = resolved._headerHeight() + "px";
            scroll.style.overflow = "hidden";
            calendar.nav.columnScroll = scroll;

            var row = createDiv();
            row.style.position = "absolute";
            row.style.bottom = "0px";
            row.style.left = "0px";
            row.style.width = "5000px";
            //row.style.width = "100%";
            row.style.height = resolved._headerHeight() + "px";
            row.style.overflow = "hidden";
            row.className = this._prefixCssClass("_columnheader");
            scroll.appendChild(row);

            var inner = createDiv();
            inner.style.position = "absolute";
            inner.style.top = "0px";
            inner.style.bottom = "0px";
            inner.style.left = "0px";
            inner.style.right = "0px";
            inner.className = this._prefixCssClass("_columnheader_inner");
            row.appendChild(inner);

            if (calendar._splitter) {
                calendar._splitter.dispose();
                calendar._splitter = null;
            }

            var argsArray = [];

            // preprocess
            props.forEach(function(col) {
                var args = {};
                args.column = {};
                // args.column.html = col.html || col.text || col.name || col.title || "";
                args.column.html = calendar._xssTextHtml(col.text || col.name || col.title, col.html);
                args.column.areas = null;

                // affects the icon only
                args.column.sortingEnabled = !!col.sort;
                args.column.data = col;
                args.column.cssClass = null;

                argsArray.push(args);

                if (typeof calendar.onBeforeRowHeaderColumnRender === "function") {
                    calendar.onBeforeRowHeaderColumnRender(args);
                }

            });

            var splitter = new DayPilot.Splitter(inner);
            splitter.enabled = calendar.rowHeaderColumnsResizable;
            splitter.widths = DayPilot.Util.propArray(props, "width", calendar.rowHeaderColumnDefaultWidth);
            splitter.height = resolved._headerHeight();
            splitter.css.title = this._prefixCssClass("_columnheader_cell");
            splitter.css.titleInner = this._prefixCssClass("_columnheader_cell_inner");
            splitter.css.splitter = this._prefixCssClass("_columnheader_splitter");

            var widerLast = calendar.rowHeaderScrolling;
            if (widerLast) {
                splitter.splitterWidthLast = 6;
            }

            var sortField = calendar.rows._sortField();
            var sortOrder = calendar.rows._sortOrder();
            splitter.titles = createList(argsArray).map(function(args) {
                var col = args.column.data;
                var html = args.column.html;
                var cssClass = args.column.cssClass;
                var title = {};
                title.areas = [];
                if (col.sort && args.column.sortingEnabled) {
                    var css = calendar._prefixCssClass("_sorticon");

                    if (sortField === col.sort) {
                        css += " " + calendar._prefixCssClass("_sorticon_active");
                        if (sortOrder === "asc") {
                            css += " " + calendar._prefixCssClass("_sorticon_asc");
                        }
                        else {
                            css += " " + calendar._prefixCssClass("_sorticon_desc");
                        }
                    }
                    else {
                        css += " " + calendar._prefixCssClass("_sorticon_asc");
                    }

                    title.areas = [
                        { right: 5, top: 0, bottom: 0, width: 10, cssClass: css, onClick: function(args) {
                            var spec = {};
                            spec.field = col.sort;
                            if (sortField === col.sort) {
                                spec.order = calendar.rows._sortOrder() === "asc" ? "desc" : "asc";
                            }
                            else {
                                spec.order = "asc";
                            }
                            calendar.rows.sort(spec);
                        }
                        }
                    ];
                }

                if (DayPilot.isArray(args.column.areas)) {
                    title.areas = title.areas.concat(args.column.areas);
                }

                title.cssClass = cssClass;
                title.html = html;
                return title;
            });

            // make it available to areas
            splitter.data = createList(props, true);

            splitter.started = function() {
                var isMax = splitter.totalWidth() === calendar.rowHeaderWidth;
                splitter._isMax = isMax;
            };

            splitter.updating = function(args) {
                calendar._angular2.skip = true;
                DayPilot.Util.updatePropsFromArray(resolved._rowHeaderColumnsVisible(), "width", this.widths);

                var isMax = splitter._isMax;
                if (isMax && calendar.rowHeaderScrolling) {
                    calendar.rowHeaderWidth = splitter.totalWidth();
                }
                calendar._updateRowHeaderWidth();

                if (calendar.cellWidthSpec === "Auto") {

                }
            };
            splitter.updated = function(rargs) {

                calendar._updateAutoCellWidth();

                if (calendar._api2()) {
                    if (typeof calendar.onRowHeaderColumnResized === "function") {
                        var args = {};
                        args.column = resolved._rowHeaderColumnsVisible()[rargs.index];
                        calendar.onRowHeaderColumnResized(args);
                    }
                }
                else {
                    switch (calendar.rowHeaderColumnResizedHandling) {
                        case "CallBack":
                            break;
                        case "PostBack":
                            break;
                        case "JavaScript":
                            if (typeof calendar.onRowHeaderColumnResized === "function") {
                                var args = {};
                                args.column = resolved._rowHeaderColumnsVisible()[rargs.index];
                                calendar.onRowHeaderColumnResized(args);
                            }
                            break;
                    }
                }
            };
            splitter.color = '#000000';
            splitter.opacity = 30;
            //splitter.height = 19;
            splitter.init();

            div.appendChild(scroll);
            this._splitter = splitter;
        };

        this._updateCorner = function() {

            var div = this.nav.corner;
            if (!div) {
                return;
            }
            calendar._disposeCorner();

            div.innerHTML = '';
            div.className = this._prefixCssClass('_corner');

            var inner = createDiv();
            inner.style.position = "absolute";
            inner.style.top = "0px";
            inner.style.left = "0px";
            inner.style.right = "0px";
            inner.style.bottom = "0px";
            inner.className = this._prefixCssClass('_corner_inner');
            this.divCorner = inner;
            inner.innerHTML = '&nbsp;';

            if (this.rowHeaderColumns && this.rowHeaderColumns.length > 0) {
                var mini = createDiv();
                mini.style.position = "absolute";
                mini.style.top = "0px";
                mini.style.left = "0px";
                mini.style.right = "0px";
                mini.style.bottom = (resolved._headerHeight() + 1) + "px";
                div.appendChild(mini);

                var divider = createDiv();
                divider.style.position = "absolute";
                divider.style.left = "0px";
                divider.style.right = "0px";
                divider.style.height = "1px";
                divider.style.bottom = (resolved._headerHeight()) + "px";
                divider.className = this._prefixCssClass("_divider");
                div.appendChild(divider);

                mini.appendChild(inner);

                this._drawHeaderColumns();
            }
            else {
                div.appendChild(inner);
            }

            (function _updateCornerHtml() {
                var args = {};
                args.control = calendar;
                args.html = calendar._xssTextHtml(calendar.cornerText, calendar.cornerHtml);
                args.areas = null;
                var argsElement = null;

                if (typeof calendar.onBeforeCornerRender === "function") {
                    calendar.onBeforeCornerRender(args);
                }

                if (typeof calendar.onBeforeCornerDomAdd === "function") {
                    args.element = null;

                    calendar.onBeforeCornerDomAdd(args);

                    argsElement = args.element;
                }

                if (argsElement) {
                    var target = calendar.divCorner;
                    target.domArgs = args;
                    var isReactComponent = isReactCmp(argsElement);
                    if (isReactComponent) {
                        if (!calendar._react.reactDOM) {
                            throw new DayPilot.Exception("Can't reach ReactDOM");
                        }
                        calendar._react._render(argsElement, target);
                    }
                    else {
                        target.appendChild(argsElement);
                    }
                }
                else {
                    if (calendar.divCorner) {
                        calendar.divCorner.innerHTML = args.html || '';
                    }

                }

                if (args.areas) {
                    DayPilot.Areas.attach(calendar.nav.corner, {}, {"areas": args.areas});
                }

            })();

            var inner2 = createDiv();
            inner2.style.position = 'absolute';
            inner2.style.padding = '2px';
            inner2.style.top = '0px';
            inner2.style.left = '1px';
            inner2.style.backgroundColor = "#FF6600";
            inner2.style.color = "white";
            inner2.innerHTML = "\u0044\u0045\u004D\u004F";

            if (isNullOrUndefined("K5woOes")) div.appendChild(inner2);

            if (calendar.rowHeaderScrolling && calendar.nav.columnScroll && calendar._scrollRes) {
                calendar.nav.columnScroll.scrollLeft = calendar._scrollRes.scrollLeft;
            }
        };

        this._drawRowHeaderHideIcon = function() {

            var marginTop = 3;

            var left = this._getOuterRowHeaderWidth() + resolved._splitterWidth() - 1;
            var width = 10;
            var height = 20;
            var top = this._getTotalHeaderHeight() + marginTop;

            var div = utilDiv(this.nav.top, left, top, width, height);
            div.style.cursor = "pointer";
            div.className = calendar._prefixCssClass("_header_icon");
            addClass(div, calendar._prefixCssClass("_header_icon_hide"));
            div.onclick = function() {
                calendar.rows.headerToggle();
            };
            div.ontouchstart = function(ev) {
                ev.stopPropagation();
            };
            this.nav.hideIcon = div;
        };

        this._updateRowHeaderHideIconVisibility = function() {
            var marginTop = 3;
            var icon = calendar.nav.hideIcon;
            var top = calendar._getTotalHeaderHeight() + marginTop;
            if (!icon) {
                return;
            }
            if (calendar.rowlist.length > 0  && calendar.rowHeaderHideIconEnabled) {
                icon.style.display = '';
            }
            else {
                icon.style.display = 'none';
            }
            icon.style.top = top + "px";
        };

        this._drawCorner = function() {
            var rowHeaderWidth = this._getOuterRowHeaderWidth();

            var div = createDiv();
            calendar.nav.corner = div;
            div.style.width = rowHeaderWidth + "px";
            div.style.height = (this._getTotalHeaderHeight()) + "px";
            div.style.overflow = 'hidden';
            div.style.position = 'relative';
            div.setAttribute("unselectable", "on");
            div.onmousemove = function() { calendar._out(); };
            div.oncontextmenu = function() { return false; };

            this._updateCorner();

            return div;
        };

        this._getTotalHeaderHeight = function() {
            if (calendar.timeHeaderPosition === "None") {
                return 0;
            }
            if (calendar.timeHeaders) {
                var last = dim._timeHeader(calendar.timeHeaders.length - 1);
                return last.top + last.height;
            }
            else if (this.timeHeader) {
                return calendar.timeHeader.length * resolved._headerHeight();
            }
            else {
                return 0;
            }
        };

        this._rowHeaderScrollSyncTimeout = null;

        this._resolveScrollStep = function() {
            return calendar.scrollStep || calendar.eventHeight;
        };

        this._drawResScroll = function() {
            var div = createDiv();
            div.style.width = (this._getOuterRowHeaderWidth()) + "px";
            div.style.height = this._getScrollableHeight() + "px";
            div.style.overflow = 'hidden';
            div.style.position = 'relative';
            div.className = calendar._prefixCssClass("_rowheader_scroll"); // divResScroll

            var step = calendar._resolveScrollStep();

            var mobile = calendar._resolved._mobile();

            //var noscrollbar = calendar._noScrollbarBrowser();
            // ios = false;

            // if (mobile && !ios) {
            if (mobile) {
                div.style.overflowY = "auto";
                if (calendar.rowHeaderScrolling) {
                    div.style.overflowX = "auto";
                }
            }

            div.onmousemove = function() {
                calendar._out();
            };
            DayPilot.rePassive(div, "touchstart", function() {
                DayPilotScheduler._touchingRes = true;
            });
            div.addEventListener("wheel", function(ev) {
                if (calendar._vScrollbarWidth() === 0) {
                    return;
                }
                var delta;
                if (calendar.overrideWheelScrolling || calendar.scrollStep) {
                    delta = ev.deltaY > 0 ? step : -step;
                }
                else {
                    if (ev.deltaMode === 1) {
                        // firefox
                        delta = ev.deltaY * resolved._scrollLineHeight() * 1.7;
                    }
                    else {
                        // only good for deltaMode === 0 but other modes are not likely
                        delta = ev.deltaY;
                    }
                }
                calendar.nav.scroll.scrollTop = div.scrollTop + delta;
                ev.preventDefault();
            }, {"passive": false});

            // DayPilot.browser.passiveEvents ? { "passive": false} : false

            div.oncontextmenu = function() { return false; };

            div.onscroll = function() {
                if (calendar._rowHeaderScrollSyncTimeout) {
                    clearTimeout(calendar._rowHeaderScrollSyncTimeout);
                }

                if (mobile) {
                    var f = function() {
                        var maxScrollY = calendar._getScrollableInnerHeight() - calendar.nav.scroll.offsetHeight;
                        div.scrollTop = Math.min(div.scrollTop, maxScrollY);
                        // calendar._activateRowScrollingNow();
                        calendar.nav.scroll.scrollTop = div.scrollTop;
                    };
                    if (ios) {
                        if (DayPilotScheduler._touchingRes) {
                            calendar._rowHeaderScrollSyncTimeout = setTimeout(f, 10);
                        }
                    }
                    else {
                        calendar._rowHeaderScrollSyncTimeout = setTimeout(f, 10);
                    }
                }
                else {
                    calendar._rowHeaderScrollSyncTimeout = setTimeout(function() {
                        calendar.nav.scroll.scrollTop = div.scrollTop;
                    }, 500);

                    // delay of 10ms causes jerky scrolling in firefox

                    // calendar.nav.scroll.scrollTop = div.scrollTop;
                }
            };

            calendar._activateForHorRowHeaderScrolling(div);

            div.setAttribute("role", "region");
            div.setAttribute("aria-label", "scheduler rows");

            var wrap = createDiv();
            wrap.onmousemove = function() { calendar._out(); };
            this.divHeader = wrap;

            div.appendChild(wrap);

            this.divResScroll = div;

            this._scrollRes = div;

            return div;
        };

        this._activateForHorRowHeaderScrolling = function(div) {
            div.addEventListener("scroll", function() {
                if (!calendar.rowHeaderScrolling) {
                    return;
                }
                if (calendar.nav.columnScroll) {
                    calendar.nav.columnScroll.scrollLeft = div.scrollLeft;
                }
                if (calendar._grids.top.enabled()) {
                    calendar._grids.top.divHeader.scrollLeft = div.scrollLeft;
                }
                if (this !== calendar.divResScroll) {
                    calendar.divResScroll.scrollLeft = div.scrollLeft;
                }
            });

            div.onmouseenter = function() {
                if (calendar.rowHeaderScrolling) {
                    div.style.overflowX = "auto";
                }
            };

            div.onmouseleave = function() {
                if (calendar.rowHeaderScrolling) {
                    div.style.overflowX = "hidden";
                }
            };

        };

        this._setRightColWidth = function(div) {
            if (resolved._layout() === 'TableBased') {
                var width = parseInt(this.width, 10);
                var isPercentage = isNaN(width) || (this.width.indexOf("%") !== -1);
                var isIE = /MSIE/i.test(navigator.userAgent);
                var rowHeaderWidth = this._getTotalRowHeaderWidth();

                if (isPercentage) {
                    if (this.nav.top && this.nav.top.offsetWidth > 0) {
                        div.style.width = (this.nav.top.offsetWidth - 6 - rowHeaderWidth) + "px";
                    }
                }
                else {  // fixed
                    div.style.width = (width - rowHeaderWidth) + "px";
                }
            }
        };

        this._onKeyUp = function(ev) {
            if (typeof calendar.onEventMoving !== "function") {
                return;
            }
            if (!DayPilotScheduler._movingEvent) {
                return;
            }
            var coords = calendar.coords || {};
            coords.shift = ev.shiftKey;
            coords.meta = ev.metaKey;
            coords.ctrl = ev.ctrlKey;
            coords.alt = ev.altKey;

            //calendar.coords = coords;

            calendar._doEventMoving();
        };


        this._onKeyDown = function(ev) {
            if (typeof calendar.onEventMoving !== "function") {
                return;
            }
            if (!DayPilotScheduler._movingEvent) {
                return;
            }
            var coords = calendar.coords || {};
            coords.shift = ev.shiftKey;
            coords.meta = ev.metaKey;
            coords.ctrl = ev.ctrlKey;
            coords.alt = ev.altKey;
            calendar._doEventMoving();
        };

        this._onWindowResize = function(ev) {
            if (typeof ResizeObserver === "function" && calendar.watchWidthChanges) {
                return;
            }
            if (!DayPilotScheduler._movingEvent) {
                return;
            }
            calendar._resize();
            calendar._onScroll();
        };

        this._resize = function() {

            if (calendar._disposed) {
                return;
            }

            if (calendar._resolved._layout() === 'TableBased') {
                calendar._setRightColWidth(calendar.nav.scroll);
                calendar._setRightColWidth(calendar.divTimeScroll);
            }

            calendar._updateHeight();
            calendar._updateAutoCellWidth();

            calendar._updateSelectionPosition();

            calendar._cache.drawArea = null;
        };

        this._wd = null;
        this._widthChangeDetectionInterval = null;
        this._watchObserver = null;
        this._watchWidthChanges = function() {

            var fix = function() {
                calendar._resize();
                calendar._onScroll(null, {"dontHideBubble": true});
            };

            var detect = function() {
                var top = calendar.nav.top;
                var op = top.offsetParent;
                var opHeight = op && op.offsetHeight;
                if (!calendar._wd) {
                    calendar._wd = {};
                    calendar._wd.changed = false;
                    calendar._wd.width = top.offsetWidth;
                    calendar._wd.height = top.offsetHeight;
                    calendar._wd.opHeight = opHeight;
                    return;
                }

                var widthChanged = calendar._wd.width !== top.offsetWidth;
                var heightChanged = calendar._wd.height !== top.offsetHeight;
                var maxParentChanged = calendar.heightSpec === "Max100Pct" && calendar._wd.opHeight !== opHeight;

                if (widthChanged || heightChanged || maxParentChanged) {
                    calendar._wd.changed = true;
                    calendar._wd.width = top.offsetWidth;
                    calendar._wd.height = top.offsetHeight;
                    calendar._wd.opHeight = opHeight;
                }

                if (calendar._wd.changed) {
                    calendar._wd.changed = false;
                    fix();
                }
            };

            if (!calendar.watchWidthChanges) {
                return;
            }

            // not supported in IE
            if (typeof ResizeObserver === "function") {

                if (calendar._watchObserver) {
                    return;
                }

                var observer = new ResizeObserver(detect);
                observer.observe(calendar.nav.top);
                if (calendar.nav.top.offsetParent) {
                    observer.observe(calendar.nav.top.offsetParent);
                }
                calendar._watchObserver = observer;

                return;
            }

            // legacy, used in IE
            if (calendar._widthChangeDetectionInterval) {
                return;
            }

            var check = function() {
                if (!calendar.nav || !calendar.nav.top) {  // disposed object
                    clearInterval(calendar._widthChangeDetectionInterval);
                    return;
                }
                if (!calendar._wd) {
                    calendar._wd = {};
                    calendar._wd.counter = 0;
                    calendar._wd.changed = false;
                    calendar._wd.width = calendar.nav.top.offsetWidth;
                    return;
                }
                if (calendar._wd.width !== calendar.nav.top.offsetWidth) {
                    calendar._wd.changed = true;
                    calendar._wd.counter = 0;
                    calendar._wd.width = calendar.nav.top.offsetWidth;
                }
                if (calendar._wd.changed) {
                    calendar._wd.counter += 1;
                }
                if (calendar._wd.changed && calendar._wd.counter > 0) {
                    calendar._wd.changed = false;
                    fix();
                }
            };

            this._widthChangeDetectionInterval = setInterval(check, 200);

            // record the current width immediately
            check();
        };

        this._updateSelectionPosition = function() {
            var range = calendar._rangeHold;
            calendar.clearSelection();
            calendar._rangeHold = range;
            calendar._drawRange(range, {"justDraw": true});
        };

        this._updateAutoCellWidth = function() {


            if (calendar.cellWidthSpec !== 'Auto') {
                return;
            }

            // fixing incorrect breaks
            calendar._deleteCells();

            if (!calendar._initialized) {
                return;
            }

            // calendar._invalidateAlwaysRows();

            // TODO detect a real dimension change
            calendar._calculateCellWidth();
            calendar._prepareItline();
            calendar._drawTimeHeader();
            calendar._deleteSeparators();
            calendar._deleteEvents();
            calendar._loadEvents();

            // fixing row height changes, it can happen for forced minimal event widths
            calendar._prepareRowTops();
            calendar._updateRowHeaderHeights();
            calendar._updateRowHeights();

            // events must be rendered after row tops are updated
            calendar._drawEvents();

            // cells must be redrawn at this point, using the new row heights
            calendar._drawCells();
            calendar._drawSeparators();

            calendar._updateHeight();
        };

        this._calculateCellWidth = function() {

            // only valid for automatic cell width
            if (this.cellWidthSpec !== 'Auto') {
                return;
            }
            var total = this.nav.top.clientWidth;
            var header = this._getOuterRowHeaderWidth();
            var vscrollbar = calendar._vScrollbarWidth();
            var full = total - header - vscrollbar;
            var cellCount = this._cellCount();
            if (!cellCount) {
                return;
            }
            var cell = full / this._cellCount();
            //this.cellWidth = Math.floor(cell);

            //this.cellWidth = cell;
            this.cellWidth = Math.max(cell, calendar.cellWidthMin);
            calendar._minCellWidthApplied = cell < calendar.cellWidthMin;
        };

        this._vScrollbarWidth = function() {
            if (calendar.heightSpec === "Auto") {
                return 0;
            }
            if (calendar.heightSpec === "Max" || calendar.heightSpec === "Fixed" || calendar.heightSpec === "Parent100Pct") {
                var inner = calendar._getScrollableInnerHeight();
                if (inner > calendar.height) {
                    var sw = DayPilot.sw(calendar.nav.scroll);
                    return sw || 1;  // macos returns 0 if no mouse is connected, make sure it's a positive value
                }
                else {
                    return 0;
                }

            }
            return DayPilot.sw(calendar.nav.scroll);
        };

        /*
        this._isNoScrollbarBrowser = null;
        this._noScrollbarBrowser = function() {
            if (calendar._isNoScrollbarBrowser === null) {

                var div = createDiv();
                div.style.height = "200px";
                div.style.width = "100px";
                div.style.position = "absolute";
                div.style.left = "-1000px";

                var scroll = createDiv();
                scroll.style.overflowY = "scroll";
                scroll.appendChild(div);

                var ref = this.nav.top;

                ref.appendChild(scroll);

                var width = DayPilot.sw(scroll);

                ref.removeChild(scroll);

                calendar._isNoScrollbarBrowser = (width === 0);
            }

            return calendar._isNoScrollbarBrowser;

        };
        */

        this._getScrollableWidth = function() {  // only the visible part
            /*
            if (this.nav.scroll) {
                this.debug.message("scrollableWidth/clientWidth: " + this.nav.scroll.clientWidth);
                return this.nav.scroll.clientWidth;
            }
            */

            //
            // TODO get directly from nav.scroll (but it may not be ready yet)
            var total = this.nav.top.clientWidth;
            //var total = this.nav.top.offsetWidth;
            var header = this._getOuterRowHeaderWidth();
            var manualAdjustment = 2;


            var height = this._getScrollableHeight();
            var innerHeight = this._getScrollableInnerHeight();
            var autoHeight = calendar.heightSpec === "Auto";
            var scrollBarWidth = 0;
            if (innerHeight > height  && !autoHeight) {
                scrollBarWidth = DayPilot.swa();
            }

            var full = total - header - manualAdjustment - scrollBarWidth;
            return full;
        };

        this._drawTimeHeaderDiv = function() {

            var timeHeaderAbove = calendar.timeHeaderPosition === "Top";

            var div = createDiv();
            div.style.overflow = 'hidden';
            div.style.display = 'block';
            if (timeHeaderAbove) {
                div.style.position = 'absolute';
                div.style.top = "0px";
            }
            else {
                div.style.position = "relative";
            }
            div.style.width = "100%";
            div.style.height = this._getTotalHeaderHeight() + "px";
            div.style.overflow = "hidden";
            div.onmousemove = function() { calendar._out(); if (calendar.cellBubble) { calendar.cellBubble.delayedHide(); } };
            div.className = calendar._prefixCssClass("_timeheader_scroll");

            this._setRightColWidth(div);

            this.divTimeScroll = div;

            var inner = createDiv();
            inner.style.width = (this._getGridWidth() + 5000) + "px";

            this.divNorth = inner;

            div.appendChild(inner);

            return div;
        };

        this._getScrollableHeight = function() {
            var height = 0;
            var spec = calendar.heightSpec;
            if (spec === 'Fixed' || spec === "Parent100Pct") {
                return this.height ? this.height : 0;
            }
            else {
                height = calendar._getScrollableInnerHeight();
            }

            var maxMode = spec === "Max" || spec === "Max100Pct";

            if (maxMode && height > calendar.height) {
                return calendar.height;
            }

            return height;

        };

        this._detectTimeout = null;
        this._detectLastHeight = 0;
        this._detectLastWidth = 0;
        this._detectLastRowHeaderWidth = 0;
        this._detectDimensionChange = function() {
            if (typeof calendar.onHeightChanged !== "function" && typeof calendar.onDimensionsChanged !== "function") {
                return;
            }

            // make sure it's performed after all changes and only once
            if (calendar._detectTimeout) {
                clearTimeout(calendar._detectTimeout);
            }

            var doit = function() {
                var newHeight = calendar.nav.top.offsetHeight;
                var originalHeight = calendar._detectLastHeight;
                calendar._detectLastHeight = newHeight;

                var newWidth = calendar.nav.top.offsetWidth;
                var originalWidth = calendar._detectLastWidth;
                calendar._detectLastWidth = newWidth;

                var newRowHeaderWidth = calendar._getOuterRowHeaderWidth();
                var originalRowHeaderWidth = calendar._detectLastRowHeaderWidth;
                calendar._detectLastRowHeaderWidth = newRowHeaderWidth;

                // legacy
                if (typeof calendar.onHeightChanged === "function") {
                    if (newHeight !== originalHeight) {
                        var args = {};
                        args.oldHeight = originalHeight;
                        args.newHeight = newHeight;
                        calendar.onHeightChanged(args);
                    }
                }

                if (typeof calendar.onDimensionsChanged === "function") {
                    if (newHeight !== originalHeight || newWidth !== originalWidth || newRowHeaderWidth !== originalRowHeaderWidth) {
                        var args = {};
                        args.oldHeight = originalHeight;
                        args.newHeight = newHeight;
                        args.oldWidth = originalWidth;
                        args.newWidth = newWidth;
                        args.oldRowHeaderWidth = originalRowHeaderWidth;
                        args.newRowHeaderWidth = newRowHeaderWidth;

                        calendar.onDimensionsChanged(args);
                    }
                }
            };

            calendar._detectTimeout = setTimeout(doit, 100);
        };

        this._getScrollableInnerHeight = function() {
            var height;
            if (this._innerHeightTree !== -1) {
                height = this._innerHeightTree;
                if (this._innerHeightTree > 0 && calendar.nav.scroll.style.overflowX === "auto") {
                    height += DayPilot.sh(calendar.nav.scroll);
                }
            }
            else {
                height = this.rowlist.length * this._resolved._eventHeight();
            }
            height += calendar._grids.bottom.height;
            return height;
        };

        this._out = function() {

            this._stopScroll();

            if (!calendar._outRequired) {
                return;
            }

            // this._stopScroll();
            this._crosshairHide();
            this._cellhoverout();
            this._clearShadowHover();
            this._cancelAutoexpand();

            calendar.cellBubble && calendar.cellBubble.hideOnMouseOut();
            calendar.bubble && calendar.bubble.hideOnMouseOut();
            calendar.groupBubble && calendar.groupBubble.hideOnMouseOut();
            // resource bubble intentionally not included

            calendar._outRequired = false;

        };

        this._grids = {};

        this._grids.top = {};
        this._grids.top.height = 0;
        this._grids.top.rowlist = [];
        this._grids.top.enabled = function() {
            return this.rowlist && this.rowlist.length > 0;
        };
        Object.defineProperty(calendar._grids.top, "top", {
            get: function() {
                return calendar._getTotalHeaderHeight() + 1;
            },
        });
        Object.defineProperty(calendar._grids.top, "right", {
            get: function() {
                return calendar._vScrollbarWidth();
            },
        });
        Object.defineProperty(calendar._grids.top, "heightRes", {
            get: function() {
                return this.height;
            },
        });

        this._grids.bottom = {};
        this._grids.bottom.height = 0;
        this._grids.bottom.rowlist = [];
        this._grids.bottom.enabled = function() {
            return this.rowlist && this.rowlist.length > 0;
        };

        Object.defineProperty(calendar._grids.bottom, "top", {
            get: function() {
                return calendar._getTotalHeaderHeight() + calendar._getScrollableHeight() - this.height - DayPilot.sh(calendar.nav.scroll) + 1;
            },
        });
        Object.defineProperty(calendar._grids.bottom, "right", {
            get: function() {
                return calendar._vScrollbarWidth();
            },
        });
        Object.defineProperty(calendar._grids.bottom, "heightRes", {
            get: function() {
                return this.height + DayPilot.sh(calendar.nav.scroll);
            },
        });


        this._grids.main = {};

        this._fixedRelatedInit = function() {
            var main = calendar._grids.main;
            main.divCells = calendar.divCells;
            main.divLines = calendar.divLines;
            main.divBreaks = calendar.divBreaks;
            main.divHeader = calendar.divHeader;
            main.divEvents = calendar.divEvents;
            main.divShadow = calendar.divShadow;
            main.divHover = calendar.divHover;
            main.divCrosshair = calendar.divCrosshair;
            main.div = calendar.nav.scroll;

            Object.defineProperty(calendar._grids.main, "rowlist", {
                get: function() {
                    return calendar.rowlist;
                },
            });

            Object.defineProperty(calendar._grids.main, "top", {
                get: function() {
                    return calendar._getTotalHeaderHeight() + 1;
                },
            });

            Object.defineProperty(calendar._grids.main, "height", {
                get: function() {
                    return calendar._innerHeightTree;
                },
            });


        };

        this._drawGridTopResScroll = function() {
            var grid = calendar._grids.top;

            var top = grid.top;
            var height = grid.height;

            var div = createDiv();
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.right = "0px";
            div.style.top = top + "px";
            div.style.height = height + "px";
            div.style.overflow = "hidden";
            div.style.boxSizing = "border-box";

            div.rows = [];

            grid.divHeader = div;

            return div;

        };

        this._drawGridBottomResScroll = function() {
            var grid = calendar._grids.bottom;

            var top = grid.top;
            var height = grid.height;

            var div = createDiv();
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.right = "0px";
            div.style.top = top + "px";
            div.style.height = height + "px";
            div.style.overflow = "hidden";
            div.style.boxSizing = "border-box";

            var space = createDiv();
            space.style.position = "absolute";
            space.style.height = "500px";  // more than scrollbar height
            space.style.top = grid.height + "px";
            space.style.left = "0px";
            // space.style.right = "0px";
            space.style.width = calendar._getTotalRowHeaderWidth() + "px";
            space.className = calendar._prefixCssClass("_rowheader");
            div.appendChild(space);

            div.rows = [];

            var wrap = createDiv();
            // wrap.rows = [];
            div.appendChild(wrap);

            div._content = wrap;
            // div._space = space;

            calendar._activateForHorRowHeaderScrolling(div);

            grid.divHeader = div;
            grid.divSpace = space;

            return div;

        };

        this._drawGridTopMainContent = function() {
            var grid = calendar._grids.top;

            var top = grid.top;
            var height = grid.height;
            // var right = calendar._vScrollbarWidth();
            var right = 0;

            var div = createDiv();
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.right = right + "px";
            div.style.top = top + "px";
            div.style.height = height + "px";
            div.style.overflow = "hidden";
            div.className = calendar._prefixCssClass("_grid_top");

            div.onmousedown = calendar._onMaindMouseDown;
            div.onmousemove = calendar._onMaindMouseMove;
            div.oncontextmenu = calendar._onMaindRightClick;
            div.onmouseup = calendar._onMaindMouseUp;
            div.ondblclick = this._onMaindDblClick;

            calendar.nav.fixedTop = div;
            grid.div = div;

            var refs = calendar._drawGridMainContentInner(div);

            copyProps(refs, grid);

            return div;
        };

        this._drawGridBottomMainContent = function() {
            var grid = calendar._grids.bottom;

            var top = grid.top;
            var height = grid.height;
            var right = 0;

            var div = createDiv();
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.right = right + "px";
            div.style.bottom = top + "px";
            div.style.height = height + "px";
            div.style.overflow = "hidden";
            div.className = calendar._prefixCssClass("_grid_bottom");

            // div.style.borderTop = "1px solid red";

            div.onmousedown = calendar._onMaindMouseDown;
            div.onmousemove = calendar._onMaindMouseMove;
            div.oncontextmenu = calendar._onMaindRightClick;
            div.onmouseup = calendar._onMaindMouseUp;
            div.ondblclick = this._onMaindDblClick;

            calendar.nav.fixedBottom = div;
            grid.div = div;

            var refs = calendar._drawGridMainContentInner(div);

            copyProps(refs, grid);

            return div;
        };


        this._drawGridMainContentInner = function(div) {
            var divCells = createDiv();
            divCells.style.position = "absolute";
            div.appendChild(divCells);

            var divLines = createDiv();
            divLines.style.position = "absolute";
            div.appendChild(divLines);

            var divBreaks = createDiv();
            divBreaks.style.position = "absolute";
            div.appendChild(divBreaks);

            var divCrosshair = createDiv();
            divCrosshair.style.position = "absolute";
            div.appendChild(divCrosshair);

            var divEvents = createDiv();
            divEvents.style.position = "absolute";
            div.appendChild(divEvents);

            var divBottom = createDiv();
            divBottom.style.position = "absolute";
            divBottom.style.left = "0px";
            divBottom.style.width = "100000px";  // hack
            divBottom.style.bottom = "0px";
            divBottom.style.height = "1px";
            div.appendChild(divBottom);

            var divHover = createDiv();
            divHover.style.position = 'absolute';
            div.appendChild(divHover);

            var divShadow = createDiv();
            divShadow.style.position = "absolute";
            div.appendChild(divShadow);

            return {
                "divCells": divCells,
                "divLines": divLines,
                "divBreaks": divBreaks,
                "divEvents": divEvents,
                "divShadow": divShadow,
                "divHover": divHover,
                "divCrosshair": divCrosshair
            };

        };

        this._fixedUpdatePosition = function() {

            var gridTop = calendar._grids.top;
            var gridBottom = calendar._grids.bottom;

            updateGrid(gridTop);
            updateGrid(gridBottom);

            calendar.divStretch.style.height = (calendar._innerHeightTree + gridBottom.height) + "px";

            calendar.nav.dividerTop.style.top = (gridTop.top + gridTop.height - 1) + "px";
            calendar.nav.dividerTop.style.right = gridTop.right + "px";
            calendar._showIf(calendar.nav.dividerTop, gridTop.enabled());

            calendar.nav.dividerBottom.style.top = (gridBottom.top - 1) + "px";
            calendar.nav.dividerBottom.style.right = (gridBottom.right) + "px";
            calendar._showIf(calendar.nav.dividerBottom, gridBottom.enabled());

        };

        function updateGrid(grid) {
            grid.div.style.right = grid.right + "px";
            grid.div.style.height = grid.height + "px";
            grid.div.style.top = grid.top + "px";
            calendar._showIf(grid.div, grid.enabled());

            grid.divHeader.style.height = grid.heightRes + "px";
            grid.divHeader.style.top = grid.top + "px";
            calendar._showIf(grid.divHeader, grid.enabled());

            // hack
            if (grid.divSpace) {
                grid.divSpace.style.top = grid.height + "px";
            }
        }

        this._showIf = function(el, condition) {
            el.style.display = condition ? "" : "none";
        };

        this._rowlistMerged = function() {
            var rowlist = calendar.rowlist;
            rowlist = rowlist.concat(calendar._grids.top.rowlist);
            rowlist = rowlist.concat(calendar._grids.bottom.rowlist);
            return rowlist;
        };

        this._hasRows = function() {
            return calendar.rowlist.length > 0 || calendar._grids.top.rowlist.length > 0 || calendar._grids.bottom.rowlist.length > 0;
        };

        this._initVer = function() {
            this._versionCheck();
            this._adjustApi();
        };

        this._drawMainContent = function() {

            var div = createDiv();
            div.style.overflow = "auto";
            div.style.overflowX = "auto";
            div.style.overflowY = "auto";

            div.style.height = (this._getScrollableHeight()) + "px";
            if (calendar.timeHeaderPosition === "Top") {
                div.style.top = (this._getTotalHeaderHeight() + 1) + "px";
                div.style.position = "absolute";
            }
            else {
                div.style.position = "relative";
            }
            div.style.width = "100%";
            div.className = this._prefixCssClass("_scrollable");
            div.oncontextmenu = function() { return false; };

            this._setRightColWidth(div);

            if (calendar.overrideWheelScrolling) {
                var scrollStep = calendar._resolveScrollStep();
                div.onwheel = function(ev) {
                    var delta = ev.deltaY > 0 ? scrollStep : -scrollStep;
                    calendar.nav.scroll.scrollTop = div.scrollTop + delta;
                    ev.preventDefault();
                };
                div.onmousewheel = function(ev) {
                    var delta = ev.wheelDelta < 0 ? scrollStep : -scrollStep;
                    calendar.nav.scroll.scrollTop = div.scrollTop + delta;
                    ev.preventDefault();
                    ev.returnValue = false;
                };
            }

            DayPilot.rePassive(div,"wheel", calendar._onNavScrollWheel);

            this.nav.scroll = div;

            this._maind = createDiv();
            var maind = this._maind;

            maind.style.MozUserSelect = "none";
            maind.style.KhtmlUserSelect = "none";
            maind.style.webkitUserSelect = "none";
            maind.daypilotMainD = true;
            maind.calendar = this;  // used in DayPilotScheduler._gTouchMove
            // required for infinite scrolling
            maind.style.minHeight = "1px";

            // Android browser bug
            if (android) {
                maind.style.webkitTransform = "translateZ(0px)";
            }
            maind.style.position = 'absolute';

            var gridwidth = this._getGridWidth();
            if (gridwidth > 0 && !isNaN(gridwidth)) {
                maind.style.width = (gridwidth) + "px";
            }
            maind.setAttribute("unselectable", "on");

            maind.onmousedown = this._onMaindMouseDown;
            maind.onmousemove = this._onMaindMouseMove;
            maind.onmouseup = this._onMaindMouseUp;
            maind.oncontextmenu = this._onMaindRightClick;
            maind.ondblclick = this._onMaindDblClick;

            maind.className = this._prefixCssClass("_matrix");

            this.divStretch = createDiv();
            this.divStretch.style.position = 'absolute';
            this.divStretch.style.height = '1px';
            maind.appendChild(this.divStretch);

            this.divCells = createDiv();
            this.divCells.style.position = 'absolute';
            this.divCells.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divCells);

            this.divLines = createDiv();
            this.divLines.style.position = 'absolute';
            this.divLines.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divLines);

            this.divBreaks = createDiv();
            this.divBreaks.style.position = 'absolute';
            this.divBreaks.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divBreaks);

            this.divSeparators = createDiv();
            this.divSeparators.style.position = 'absolute';
            this.divSeparators.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divSeparators);

            this.divLinksBelow = createDiv();
            this.divLinksBelow.style.position = "absolute";
            maind.appendChild(this.divLinksBelow);

            this.divCrosshair = createDiv();
            this.divCrosshair.style.position = 'absolute';
            this.divCrosshair.ondblclick = this._onMaindDblClick;
            this.divCrosshair.onmousedown = this._onCrosshairMouseDown;
            maind.appendChild(this.divCrosshair);

            this.divRange = createDiv();
            this.divRange.style.position = 'absolute';
            this.divRange.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divRange);

            this.divEvents = createDiv();
            this.divEvents.style.position = 'absolute';
            maind.appendChild(this.divEvents);

            this.divSeparatorsAbove = createDiv();
            this.divSeparatorsAbove.style.position = 'absolute';
            this.divSeparatorsAbove.oncontextmenu = this._onMaindRightClick;
            maind.appendChild(this.divSeparatorsAbove);

            this.divLinksAbove = createDiv();
            this.divLinksAbove.style.position = "absolute";
            maind.appendChild(this.divLinksAbove);

            this.divLinkShadow = createDiv();
            this.divLinkShadow.style.position = "absolute";
            maind.appendChild(this.divLinkShadow);

            this.divLinkpoints = createDiv();
            this.divLinkpoints.style.position = "absolute";
            maind.appendChild(this.divLinkpoints);

            this.divRectangle = createDiv();
            this.divRectangle.style.position = "absolute";
            maind.appendChild(this.divRectangle);

            this.divHover = createDiv();
            this.divHover.style.position = 'absolute';
            maind.appendChild(this.divHover);

            this.divShadow = createDiv();
            this.divShadow.style.position = 'absolute';
            maind.appendChild(this.divShadow);

            div.appendChild(maind);

            return div;
        };

        calendar._onNavScrollWheel = function(ev) {
            calendar._updateCoords(ev);
        };

        this._overlay = {};
        var overlay = this._overlay;

        overlay._create = function() {
            if (calendar.nav.overlay) {
                return;
            }
            var div = document.createElement('div');
            div.style.position = "absolute";
            div.style.left = "0px";
            div.style.right = "0px";
            div.style.top = "0px";
            div.style.bottom = "0px";
            div.className = calendar._prefixCssClass("_block");
            calendar.nav.top.appendChild(div);
            calendar.nav.overlay = div;
        };

        overlay._show = function() {
            overlay._create();
            calendar.nav.overlay.style.display = '';
        };

        overlay._hide = function() {
            if (calendar.nav.overlay) {
                calendar.nav.overlay.style.display = 'none';
            }
        };

        this._loadingStart = function(options) {

            options = options || {};
            var delay = options.delay || 0;
            // var text = options.text || calendar.loadingLabelText;
            var html = calendar._xssTextHtml(options.text || this.loadingLabelText, this.loadingLabelHtml);

            var block = typeof options.block !== "undefined" ? options.block : calendar.blockOnCallBack;

            if (calendar._loadingTimeout) {
                window.clearTimeout(calendar._loadingTimeout);
            }

            var show = function() {
                if (calendar.loadingLabelVisible || options.text) {
                    calendar.nav.loading.innerHTML = html;
                    calendar.nav.loading.style.display = '';
                }
                if (block) {
                    overlay._show();
                }
            };

            if (delay === 0) {
                show();
            }
            else {
                calendar._loadingTimeout = window.setTimeout(show, delay);
            }

        };

        this._loadingStop = function(requestUnblock) {
            if (this._loadingTimeout) {
                window.clearTimeout(this._loadingTimeout);
            }

            this.nav.loading.style.display = 'none';

            if (requestUnblock || calendar.blockOnCallBack) {
                overlay._hide();
            }

        };

        this.loadingStart = function(options) {
            calendar._loadingStart(options);
        };

        this.loadingStop = function() {
            calendar._loadingStop(true);
        };

        this.uiBlock = function() {
            overlay._show();
        };

        this.uiUnblock = function() {
            overlay._hide();
        };

        this._prepareVariables = function() {
            this.startDate = new DayPilot.Date(this.startDate).getDatePart();
            //this._getEventHeightFromCss();
        };

        this._getDimensionsFromCss = function(className) {
            var div = createDiv();
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.className = this._prefixCssClass(className);

            body().appendChild(div);
            var height = div.offsetHeight;
            var width = div.offsetWidth;
            body().removeChild(div);

            var result = {};
            result.height = height;
            result.width = width;
            return result;
        };

        // interval defined in seconds, minimum 30 seconds
        this._startAutoRefresh = function(forceEnabled) {
            if (forceEnabled) {
                this.autoRefreshEnabled = true;
            }

            if (!this.autoRefreshEnabled) {
                return;
            }

            if (this._autoRefreshCount >= this.autoRefreshMaxCount) {
                return;
            }

            this._pauseAutoRefresh();

            var interval = this.autoRefreshInterval;
            if (!interval || interval < 10) {
                throw new DayPilot.Exception("The minimum autoRefreshInterval is 10 seconds");
            }
            //this.autoRefresh = interval * 1000;
            this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
        };

        this._pauseAutoRefresh = function() {
            if (this.autoRefreshTimeout) {
                window.clearTimeout(this.autoRefreshTimeout);
                this.autoRefreshTimeout = null;
            }
        };

        this.autoRefreshStart = function(forceEnabled) {
            calendar._startAutoRefresh(forceEnabled);
        };

        this.autoRefreshPause = function() {
            calendar._pauseAutoRefresh();
        };

        this._noDragAndDropInProgress = function() {
            return !DayPilotScheduler._resizing && !DayPilotScheduler._moving && !DayPilotScheduler._drag && !DayPilotScheduler._range;
        };

        this._doRefresh = function() {
            // skip if an operation is active
            if (calendar._noDragAndDropInProgress()) {
                var skip = false;
                if (typeof this.onAutoRefresh === 'function') {
                    var args = {};
                    args.i = this._autoRefreshCount;
                    args.preventDefault = function() {
                        this.preventDefault.value = true;
                    };

                    calendar.onAutoRefresh(args);
                    if (args.preventDefault.value) {
                        skip = true;
                    }
                }
                if (!skip && this._serverBased()) {
                    this.commandCallBack(this.autoRefreshCommand);
                }
                this._autoRefreshCount++;
            }
            if (this._autoRefreshCount < this.autoRefreshMaxCount) {
                this.autoRefreshTimeout = window.setTimeout(function() { calendar._doRefresh(); }, this.autoRefreshInterval * 1000);
            }
        };

        this._registerGlobalHandlers = function() {
            if (!DayPilotScheduler._globalHandlers) {
                DayPilotScheduler._globalHandlers = true;
                DayPilot.re(document, 'mousemove', DayPilotScheduler._gMouseMove);
                DayPilot.re(document, 'mouseup', DayPilotScheduler._gMouseUp);
                DayPilot.re(document, 'mousedown', DayPilotScheduler._gMouseDown);
                DayPilot.re(document, 'touchend', DayPilotScheduler._gTouchEnd);

                DayPilot.reNonPassive(document, "touchmove", DayPilotScheduler._gTouchMove);
                // document.addEventListener("touchmove", DayPilotScheduler._gTouchMove, {"passive": false});

                DayPilot.re(window, 'keyup', DayPilotScheduler._gKeyUp);

                //DayPilot.re(window, 'unload', DayPilotScheduler._gUnload);
            }
            DayPilot.re(window, 'resize', this._onWindowResize);
            DayPilot.re(document, 'keydown', this._onKeyDown);
            DayPilot.re(document, 'keyup', this._onKeyUp);
        };

        this._registerOnScroll = function() {
            this.nav.scroll.root = this;  // might not be necessary
            this.nav.scroll.onscroll = this._onScroll;

            calendar._scrollPos = this.nav.scroll.scrollLeft;
            calendar._scrollTop = this.nav.scroll.scrollTop;
            if (this.divNorth) {
                calendar._scrollWidth = this.divNorth.clientWidth; // divScroll might not be available (if there are no resources)
            }

        };

        this._saveState = function() {
            if (!this.nav.state) {
                return;
            }

            //var start = new Date();
            var state = {};
            state.scrollX = this.nav.scroll.scrollLeft;
            state.scrollY = this.nav.scroll.scrollTop;

            var area = calendar._getArea(state.scrollX, state.scrollY);
            var range = calendar._getAreaRange(area);
            var res = calendar._getAreaResources(area);

            state.rangeStart = range.start;
            state.rangeEnd = range.end;
            state.resources = res;

            if (this.syncResourceTree) {
                state.tree = this._getTreeState();
            }

            this.nav.state.value = DayPilot.he(JSON.stringify(state));
        };

        // freeze ok
        this._drawSeparators = function() {
            if (!this.separators) {
                return;
            }
            for (var i = 0; i < this.separators.length; i++) {
                this._drawSeparator(i);
            }
        };

        this._batch = {};
        this._batch.step = 300;
        this._batch.delay = 10;
        this._batch.mode = "display";
        this._batch.layers = false;

        this._updateEventPositionsInRow = function(row) {

            if (calendar._cellStacking) {
                cellstacking._calculateEventPositionsRow(row);
                return;
            }

            var alwaysRecalculate = true;

            var lineTop = 0;
            for (var j = 0; j < row.lines.length; j++) {
                var line = row.lines[j];

                line.height = 0;
                line.top = lineTop;

                for (var k = 0; k < line.length; k++) {
                    var e = line[k];

                    // do something faster instead, probably move it to another function
                    if (!e.part.top || alwaysRecalculate) {
                        e.part.line = j;
                        if (!e.part.height) {
                            e.part.height = row.eventHeight;
                        }

                        var pheight = e.part._getHeightWithVersions();
                        if (pheight > line.height) {
                            line.height = pheight;
                        }

                        //e.part.top = j * (e.part.height + eventMarginTop) + eventMarginTop;
                        e.part.top = lineTop + row.marginTop;

                        var above = calendar.eventVersionPosition === "Above";

                        if (calendar.eventVersionsEnabled && !createList(e.versions).isEmpty()) {
                            var cacheOrData = e.cache || e.data;

                            var count = cacheOrData.versions.length;
                            var top = e.part.top;

                            if (!above) {
                                top += e.part.height + calendar.eventVersionMargin;
                            }

                            createList(cacheOrData.versions).forEach(function(version, i) {
                                if (!e.versions[i]) {
                                    return;
                                }

                                var offset = i * (calendar.eventVersionHeight + calendar.eventVersionMargin);
                                e.versions[i].top = top + offset;

                                if (above) {
                                    e.part.top += calendar.eventVersionHeight;
                                    e.part.top += calendar.eventVersionMargin;
                                }
                            });
                        }
                        // e.part.top += calendar.eventMarginBottom;

                        // e.part.detachedBarTop = e.part.top - eventMarginTop;
                        e.part.right = e.part.left + e.part.width;
                        // var rowlist = calendar._grids[e.part.grid].rowlist;
                        // e.part.fullTop = rowlist[e.part.dayIndex].top + e.part.top;
                        e.part.fullTop = row.top + e.part.top;
                        e.part.fullBottom = e.part.fullTop + e.part.height;
                    }
                }
                lineTop += (line.height || row.eventHeight) * row.eventStackingLineHeight/100;
            }
            //row.height = lineTop;
        };

        var cellstacking = {};

        cellstacking._loadRow = function(row) {
            row.evColumns = createList(calendar.itline).map(function(cell, i) {
                return {"events":createList()};
            });

            createList(row.events).forEach(function(e) {
                var start = e.start();
                var cell = calendar._getItlineCellFromTime(start);
                row.evColumns[cell.i].events.push(e);
            });
        };

        cellstacking._calculateEventPositions = function() {
            var autoHeight = calendar._cellStackingAutoHeight;

            var rowTop = 0;
            createList(calendar.rowlist).forEach(function(row) {
                var maxHeight = 0;
                row.evColumns.forEach(function(column, i) {
                    var cell = calendar.itline[i];
                    var top = calendar.rowMarginTop;
                    column.events.forEach(function(e) {
                        e.part.left = cell.left;
                        e.part.width = cell.width;
                        e.part.top = top;

                        if (!e.part.height) {
                            if (autoHeight) {
                                e.part.height = cellstacking._getEventAutoHeight(e) + resolved._barHeight();
                            }
                            else {
                                e.part.height = row.eventHeight;
                            }
                        }

                        top += e.part.height + calendar.eventMarginBottom;
                    });
                    column.height = top;
                    if (column.height > maxHeight) {
                        maxHeight = column.height;
                    }
                });
                row.maxColumnHeight = maxHeight;
                row.top = rowTop;

                var oldHeight = row.height;
                row.height = row.getHeight();
                if (maxHeight > calendar.rowMarginTop) {
                    row.height = maxHeight + calendar.rowMarginBottom;
                }
                if (oldHeight !== row.height) {
                    calendar._rowsDirty = true;
                }

                rowTop += row.height;
            });

            calendar._innerHeightTree = rowTop;
        };

        cellstacking._getEventAutoHeight = function(e) {
            var html = e.client.html();

            var div = createDiv();
            div.style.position = "absolute";
            div.style.top = "-2000px";
            div.style.left = "-2000px";
            div.style.width = e.part.width + "px";
            div.className = calendar._prefixCssClass(cssNames.event);

            var inner = createDiv();
            inner.className = calendar._prefixCssClass(cssNames.eventInner);
            inner.innerHTML = html;
            inner.style.position = 'static';
            inner.style.overflow = 'auto';

            div.appendChild(inner);

            var parent = calendar.divEvents;
            parent.appendChild(div);
            var height = div.offsetHeight;
            parent.removeChild(div);

            return height;
        };

        cellstacking._calculateEventPositionsRow = function(row) {
            // hack
            cellstacking._calculateEventPositions();
        };

        cellstacking._drawEventsWithoutCheckingOverflow = function() {
            createList(calendar.rowlist).forEach(function(row) {
                cellstacking._drawEventsRow(row);
            });

        };

        cellstacking._drawEvents = function() {
            cellstacking._drawEventsWithoutCheckingOverflow();
            cellstacking._checkOverflow();
            calendar._updateRowHeaderHeights();
            calendar._updateHeight();
        };

        cellstacking._checkOverflow = function() {
            if (!calendar._cellStackingAutoHeight) {
                return;
            }

            var dirty = false;
            createList(calendar.elements.events).forEach(function(div) {
                var inner = div.firstChild;
                // we are setting the full event height
                var plus = inner.offsetHeight - inner.clientHeight + div.offsetHeight - div.clientHeight;
                var realHeight = inner.scrollHeight + plus;

                var originalHeight = div.event.part.height;
                div.event.part.height = realHeight;

                if (originalHeight !== realHeight) {
                    dirty = true;
                }
                /*
                if (inner.scrollHeight > inner.clientHeight) {
                    dirty = true;
                }
                */
            });
            if (dirty) {
                calendar._deleteEvents();
                cellstacking._calculateEventPositions();
                cellstacking._drawEventsWithoutCheckingOverflow();

                calendar._deleteCells();
                calendar._drawCells();
            }
        };

        cellstacking._drawEventsRow = function(row) {
            row.evColumns.forEach(function(column, i) {
                column.events.forEach(function(e) {
                    calendar._drawEvent(e);
                });
            });
        };

        this._drawEventsTimeout = null;

        // batch rendering flushes events in 10-item batches
        this._drawEvents = function(batch) {

            if (calendar._disposed) {
                return;
            }

            if (calendar._cellStacking) {
                cellstacking._drawEvents();
                return;
            }

            //var start = new Date().getTime();

            var step = this._batch.step;  // batch size
            var layers = this._batch.layers;

            // experimental
/*            if (layers) {
                // create a new layer
                calendar.divEvents = createDiv();
                calendar.divEvents.style.position = 'absolute';  // relative
                calendar._maind.insertBefore(this.divEvents, this.divSeparatorsAbove);
            }*/

            if (this._batch.mode === 'display') {
                this.divEvents.style.display = 'none';
            }
            else if (this._batch.mode === 'visibility') {
                this.divEvents.style.visibility = 'hidden';
            }

            this.divEvents.setAttribute("role", "region");
            this.divEvents.setAttribute("aria-label", "scheduler events");

            var dynamic = this.dynamicEventRendering === 'Progressive';
            var area = this._getDrawArea();
            var top = area.pixels.top;
            var bottom = area.pixels.bottom;

            var multiMoveOrResize = calendar.allowMultiMove || calendar.allowMultiResize;

            var rowlist = calendar.rowlist.filter(function(row) {
                var rowTop = row.top - calendar.dynamicEventRenderingMargin;
                var rowBottom = rowTop + row.height + 2 * calendar.dynamicEventRenderingMargin;
                if (dynamic && !multiMoveOrResize && (bottom <= rowTop || top >= rowBottom)) {
                    return false;
                }
                return true;
            });

            if (calendar._grids.top.enabled()) {
                rowlist = rowlist.concat(calendar._grids.top.rowlist);
            }
            if (calendar._grids.bottom.enabled()) {
                rowlist = rowlist.concat(calendar._grids.bottom.rowlist);
            }

            rowlist.forEach(function(row) {

                calendar._updateEventPositionsInRow(row);
                var maxLines = Math.max(0, row.resource && row.resource.maxLines || 100000);

                for (var j = 0; j < row.lines.length; j++) {
                    var line = row.lines[j];
                    if (j >= maxLines) {
                        continue;
                    }
                    for (var k = 0; k < line.length; k++) {
                        var e = line[k];
                        var rendered = calendar._drawEvent(e);

                        if (batch && rendered) {
                            step--;
                            // flush
                            if (step <= 0) {
                                calendar.divEvents.style.visibility = '';
                                calendar.divEvents.style.display = '';
                                calendar._drawEventsTimeout = window.setTimeout(function() { calendar._drawEvents(batch); }, calendar._batch.delay);
                                //var end = new Date().getTime();
                                return;
                            }
                        }
                    }
                }
            });

            this.divEvents.style.display = '';
            if (!createList(calendar.multiselect._list).isEmpty()) {
                calendar.multiselect.redraw();
            }

            this._findEventsInViewPort();
            linktools._load();
            this._redrawInvalidatedCells();
            //this._loadingStop();
        };

        // freeze ok
        this._drawEventsInRow = function(rowIndex, gridName) {

            var grid = calendar._gridInfo(gridName);
            var row = grid.rowlist[rowIndex];

            if (calendar._cellStacking) {
                cellstacking._drawEventsRow(row);
                return;
            }

            this._maind.insertBefore(this.divEvents, this.divSeparatorsAbove);
            calendar._cache._layers.push(this.divEvents);

            this._updateEventPositionsInRow(row);

            //var lineTop = 0;
            for (var j = 0; j < row.lines.length; j++) {
                var line = row.lines[j];
                for (var k = 0; k < line.length; k++) {
                    var e = line[k];
                    // batch rendering not supported here
                    this._drawEvent(e);
                }
            }
            this.divEvents.style.display = '';

            // calendar._clearEventLayers();

            //this._findEventsInViewPort();
            //this.multiselect.redraw();
        };

        this._clearEventLayers = function() {
            // unused, not using layers anymore
            var layers = calendar._cache._layers;
            var stays = [];
            layers.forEach(function(layer) {
                if (layer.childNodes.length === 0) {
                    layer.remove();
                }
                else {
                    stays.push(layer);
                }
            });

            calendar._cache._layers = stays;

        };

        this._deleteEvents = function() {

            // focus._unfocusCell();
            if (this.elements.events) {
                var length = this.elements.events.length;

                for (var i = 0; i < length; i++) {
                    var div = this.elements.events[i];
                    this._deleteEvent(div);
                }
            }
            this.elements.events = [];
        };

        // freeze ok, check refs
        this._deleteEventsInRow = function(rowIndex, gridName) {

            gridName = gridName || "main";

            //var count = 0;
            if (this.elements.events) {
                var length = this.elements.events.length;
                var removed = [];

                for (var i = 0; i < length; i++) {
                    var div = this.elements.events[i];
                    var e = div.event;
                    //if (div.row === rowIndex) {
                    if (e.part.dayIndex === rowIndex && e.part.grid === gridName) {
                        this._deleteEvent(div);
                        removed.push(i);
                        //count += 1;
                    }
                }

                for (var i = removed.length - 1; i >= 0; i--) {
                    this.elements.events.splice(removed[i], 1);
                }
            }

        };

        this._deleteEvent = function(div) {

            /*var removeCallback = div.event && div.event.part && div.event.part.onElementRemove;

            if (removeCallback) {
                var args = div.event && div.event.part.elementCreateArgs;
                //var args = {};
                args.div = div;
                removeCallback(args);
            }*/

            var domArgs = div.domArgs;
            div.domArgs = null;

            // legacy, to be removed
            if (domArgs && typeof calendar.onDomRemoveEvent === "function") {
                calendar.onDomRemoveEvent(domArgs);
            }

            if (domArgs && typeof calendar.onBeforeEventDomRemove === "function") {
                calendar.onBeforeEventDomRemove(domArgs);
            }

            if (domArgs && typeof calendar.onBeforeEventDomAdd === "function" && calendar._react.reactDOM) {
                var target = domArgs && domArgs._targetElement;
                if (target) {
                    var isReact = isReactCmp(domArgs.element);
                    if (isReact) {
                        if (!calendar._react.reactDOM) {
                            throw new DayPilot.Exception("Can't reach ReactDOM");
                        }
                        calendar._react._unmount(target);
                    }
                }
            }

            if (div.parentNode) { div.parentNode.removeChild(div); }

            // direct event handlers
            div.onclick = null;
            div.oncontextmenu = null;
            div.onmouseover = null;
            div.onmouseout = null;
            div.onmousemove = null;
            div.onmousedown = null;
            div.ondblclick = null;

            if (div.event) {
                div.event.rendered = null;
                div.event = null;
            }

            if (div.related) {
                deleteElement(div.related);
            }

        };

        this._deleteBlock = function(div) {
            if (div.event) {
                div.event.rendered = false;
            }
            div.onclick = null;
            div.onmousedown = null;
            div.event = null;
            if (div.parentNode) {
                div.parentNode.removeChild(div);
            }
        };

        // deletes events that are out of the current view
        // keeps the last "keepPlus" number of events outside of the view
        this._deleteOldEvents = function() {
            if (this.dynamicEventRendering !== 'Progressive') {
                return;
            }

            var deleteOld = calendar.dynamicEventRenderingCacheSweeping;  // deletes old events (outside of the visible area)
            if (!deleteOld) {
                return;
            }

            var keepPlus = calendar.dynamicEventRenderingCacheSize || 0;  // how many old events should be kept visible (cached)

            this.divEvents.style.display = 'none';

            var updated = [];

            var deleted = 0;

            var length = this.elements.events.length;
            for (var i = length - 1; i >= 0; i--) {
                var div = this.elements.events[i];
                if (this._oldEvent(div.event)) {
                    if (keepPlus > 0) {
                        keepPlus--;
                        updated.unshift(div);
                    }
                    else {
                        this._deleteEvent(div);
                        deleted++;
                    }
                }
                else {
                    updated.unshift(div);
                }
            }

            this.elements.events = updated;

            this.divEvents.style.display = '';
        };

        this._deleteOldCells = function(keepPlus) {
            var updated = [];

            var deleted = 0;

            var area = this._getDrawArea();

            var length = this.elements.cells.length;
            for (var i = length - 1; i >= 0; i--) {
                var div = this.elements.cells[i];

                var visible = (area.xStart < div.coords.x && div.coords.x <= area.xEnd) && (area.yStart < div.coords.y && div.coords.y <= area.yEnd);

                if (!visible) {
                    if (keepPlus > 0) {
                        keepPlus--;
                        updated.unshift(div);
                    }
                    else {
                        this._deleteCell(div);
                        deleted++;
                    }
                }
                else {
                    updated.unshift(div);
                }
            }

        };

        this._deleteCell = function(div) {
            if (!div) {
                return;
            }
            if (!div.coords) {
                return;
            }
            var x = div.coords.x;
            var y = div.coords.y;
            var gridName = div.coords.grid;

            (function DomRemove() {
                var domArgs = div.domArgs;
                div.domArgs = null;

                if (domArgs && typeof calendar.onBeforeCellDomRemove === "function") {
                    calendar.onBeforeCellDomRemove(domArgs);
                }

                if (domArgs && typeof calendar.onBeforeCellDomAdd === "function" && calendar._react.reactDOM) {
                    var target = domArgs && domArgs._targetElement;
                    if (target) {
                        var isReact = isReactCmp(domArgs.element);
                        if (isReact) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._unmount(target);
                        }
                    }
                }
            })();


            // remove div
            DayPilot.rfa(calendar.elements.cells, div);
            deleteElement(div);

            //var index = indexOf(calendar.elements.cells, div);
            //calendar.elements.cells.splice(index, 1);
            //if (div.parentNode) { div.parentNode.removeChild(div); }

            // remove from cache
            calendar._cache.cells[gridName + "_" + x + "_" + y] = null;
        };

        this._deleteSeparators = function() {
            if (this.elements.separators) {
                for (var i = 0; i < this.elements.separators.length; i++) {
                    var div = this.elements.separators[i];
                    //DayPilot.pu(div); // not necessary
                    deleteElement(div);
                    //div.parentNode.removeChild(div);
                }
            }
            this.elements.separators = [];
        };


        this._hiddenEvents = function() {
            var dynamic = this.dynamicEventRendering === 'Progressive';

            if (!this.nav.scroll) {
                return false;
            }
            var top = this.nav.scroll.scrollTop;
            var bottom = top + this.nav.scroll.clientHeight;

            for (var i = 0; i < this.rowlist.length; i++) {

                var row = this.rowlist[i];

                var rowTop = row.top;
                var rowBottom = row.top + row.height;
                if (dynamic && (bottom <= rowTop || top >= rowBottom)) {
                    continue;
                }

                for (var j = 0; j < row.lines.length; j++) {
                    var line = row.lines[j];
                    for (var k = 0; k < line.length; k++) {
                        var e = line[k];
                        if (this._hiddenEvent(e)) {
                            return true;
                        }
                    }
                }

            }

            return false;
        };

        this._hiddenEvent = function(data) {
            if (data.rendered) {
                return false;
            }

            var dynamic = this.dynamicEventRendering === 'Progressive';
            var left = this.nav.scroll.scrollLeft;
            var right = left + this.nav.scroll.clientWidth;
            var eventLeft = data.part.left;
            var eventRight = data.part.left + data.part.width;

            if (dynamic && (right <= eventLeft || left >= eventRight)) {
                return false;
            }
            return true;
        };

        this._oldEvent = function(ev) {
            if (!ev.rendered) {  // just for the case, these events might not have Top defined
                return true;
            }

            var area = this._getDrawArea();

            var top = area.pixels.top;
            var bottom = area.pixels.bottom;
            var left = area.pixels.left - this.dynamicEventRenderingMargin;
            var right = area.pixels.right + this.dynamicEventRenderingMargin;

            var eventLeft = ev.part.left;
            var eventRight = ev.part.right;
            var eventTop = ev.part.fullTop;
            var eventBottom = ev.part.fullBottom;

            if (right <= eventLeft || left >= eventRight) {
                return true;
            }

            if (bottom <= eventTop || top >= eventBottom) {
                return true;
            }

            return false;
        };

        this._blockExpandedEvents = createList();

        this._drawBlock = function(block) {


            if (block.rendered) {
                return false;
            }

            var row = block.row;
            if (row.hidden) {
                return false;
            }

            var grid = calendar._grids[row.grid];

            var left = block.min;
            var width = block.max - block.min;
            var height = calendar.eventHeight;
            var top = block.row.top;

            if (typeof row.forcedHeight === "number") {
                height = Math.min(row.forcedHeight, calendar.eventHeight);
            }

            var div = createDiv();
            div.style.position = 'absolute';
            div.style.left = left + 'px';
            div.style.top = top + 'px';
            div.style.width = width + 'px';
            div.style.height = height + 'px';

            // temp styling
            div.className = calendar._prefixCssClass("_event_group");
            div.style.cursor = "pointer";

            var args = {};
            args.group = {};
            args.group.count = block.events.length;
            args.group.events = createList(block.events, true); // make a copy
            args.group.html = "&#x1F7A7; " + block.events.length + " events";
            args.group.bubbleHtml = null;
            if (typeof calendar.onBeforeGroupRender === "function") {
                calendar.onBeforeGroupRender(args);
            }

            var inner = createDiv();
            inner.innerHTML = args.group.html;
            div.appendChild(inner);

            div.onmousedown = function(ev) {
                ev.cancelBubble = true;
            };

            div.onclick = function(ev) {
                var block = div.event;
                block.expanded = true;

                calendar._deleteBlock(div);
                var elindex = indexOf(calendar.elements.events, div);
                if (elindex !== -1) {
                    calendar.elements.events.splice(elindex, 1);
                }

                var list = calendar._blockExpandedEvents;
                createList(block.events).forEach(function(e) {
                    list.push(e.id());
                });

                if (typeof DayPilot.Bubble !== "undefined") {
                    DayPilot.Bubble.hideActive();
                    DayPilot.Bubble.cancelShowing();
                }

                //calendar._drawEvents();
                calendar._updateRowHeights();
                calendar._updateRowsNoLoad([row]);
                calendar._updateHeight();
                calendar._drawEvents();

                ev.cancelBubble = true;

            };

            div.onmousemove = function(ev) {
                if (calendar.groupBubble) {
                    var bargs = {};
                    bargs.calendar = calendar;
                    bargs.type = "Group";
                    bargs.object = {
                        "events": createList(block.events, true)
                    };
                    bargs.staticHTML = args.group.bubbleHtml;
                    bargs.div = div;
                    bargs.toJSON = function() {
                        var result = {};
                        result.uid = calendar.uniqueID;
                        result.type = "Group";
                        result.object = bargs.object;
                        return result;
                    };

                    calendar.groupBubble.showGroup(bargs);
                }
            };

            div.onmouseout = function(ev) {
                if (calendar.groupBubble) {
                    calendar.groupBubble.hideOnMouseOut();
                }
            };

            // make it compatible with event.part
            // TODO resolve
            block.part = {};
            block.part.left = left;
            block.part.width = width;
            block.part.height = calendar.eventHeight;
            block.part.dayIndex = indexOf(grid.rowlist, block.row);
            block.part.top = 0;
            block.part.isBlock = true;
            block.part.grid = block.row.grid;
            block.client = {};
            block.client.html = function() { return args.group.html; };
            block.data = {};
            div.event = block;

            // add it to the events collection
            this.elements.events.push(div);

            // draw the div
            grid.divEvents.appendChild(div);

            block.rendered = true;

            return true;

        };

        // returns true if the event was actually rendered
        this._drawEvent = function(e, options) {

            options = options || {};
            var forced = options.forced;

            if (e.rendered) {
                return false;
            }

            if (calendar.groupConcurrentEvents) {
                var block = e.part.block;
                if (block.events.length > 1 && !block.expanded) {
                    return calendar._drawBlock(block);
                }
            }

            //var dynamic = this.dynamicEventRendering === 'Progressive' && !this.dynamicLoading;
            var dynamic = this.dynamicEventRendering === 'Progressive';

            var rowIndex = e.part.dayIndex;
            var gridName = e.part.grid || "main";
            var grid = calendar._grids[gridName];

            var divEvents = grid.divEvents;
            var rowlist = grid.rowlist;
            var row = rowlist[rowIndex];
            if (row.hidden) {
                return false;
            }

            var maxLines = Math.max(0, row.resource.maxLines || 100000);
            if (e.part.line >= maxLines) {
                return false;
            }

            var rowTop = row.top;

            var area = this._getDrawArea();
            var left = area.pixels.left - this.dynamicEventRenderingMargin;
            var right = area.pixels.right + this.dynamicEventRenderingMargin;
            var top = area.pixels.top;
            var bottom = area.pixels.bottom;

            var eventLeft = e.part.left;
            var eventRight = e.part.left + e.part.width;
            var eventTop = e.part.top + rowTop;
            var eventBottom = eventTop + e.part.height;

            var shouldBeSelected = calendar.multiselect._shouldBeSelected(e);
            var horizontalOut = right <= eventLeft || left >= eventRight;
            var verticalOut = gridName === "main" && (bottom <= eventTop || top >= eventBottom);
            if (!forced && !shouldBeSelected && dynamic && (horizontalOut || verticalOut)) { // dynamic rendering, event outside of the current view
                return false;
            }

            var isMilestone = e.data.type === "Milestone";

            var width = e.part.width;
            var height = e.part.height;

            var cache = e.cache || e.data;

            // make sure it's not negative
            width = atLeast(0, width);
            height = atLeast(0, height);

            // var barDetached = this._durationBarDetached;

            var div = createDiv();
            div.related = [];

            (function drawVersions(parent) {
                if (!calendar.eventVersionsEnabled) {
                    return;
                }

                // data.data.versions => source data
                // data.versions => calculated data

                createList(cache.versions).forEach(function(version, i) {
                    if (!version) {
                        return;
                    }

                    //var offset = (e.data.versions.length - i) * (calendar.eventVersionHeight + calendar.eventVersionMargin);
                    var vpart = e.versions[i];

                    if (!vpart) {
                        return;
                    }

                    var div = createDiv();
                    div.style.position = "absolute";
                    div.style.overflow = "hidden";
                    div.style.left = vpart.left + 'px';
                    //div.style.top = (rowTop + e.part.top - offset) + 'px';
                    div.style.top = (rowTop + vpart.top) + 'px';
                    div.style.width = vpart.width + 'px';
                    div.style.height = calendar.eventVersionHeight + 'px';
                    div.className = calendar._prefixCssClass(cssNames.event) + " " + calendar._prefixCssClass("_event_previous") + " " + calendar._prefixCssClass("_event_version");

                    div.onmousedown = function(ev) {
                        ev.preventDefault();
                        ev.stopPropagation();
                    }

                    if (version.toolTip) {
                        div.title = version.toolTip;
                    }

                    if (version.cssClass) {
                        addClass(div, version.cssClass);
                    }
                    /*
                     supported properties:
                     * text
                     * html
                     * backColor
                     * fontColor
                     * borderColor
                     * backImage
                     * backRepeat
                     * complete
                     * barColor
                     * barBackColor
                     * barImageUrl
                     * barHidden
                     * htmlRight
                     * htmlLeft
                     * cssClass
                     * toolTip

                     add
                     * areas

                     */

                    var inner = createDiv();
                    inner.setAttribute("unselectable", "on");
                    inner.className = calendar._prefixCssClass(cssNames.eventInner);
                    // inner.innerHTML = version.html || version.text || "";
                    inner.innerHTML = calendar._xssTextHtml(version.text, version.html);

                    if (version.backColor) {
                        inner.style.background = version.backColor;
/*
                        if (DayPilot.browser.ie9 || DayPilot.browser.ielt9) {
                            inner.style.filter = '';
                        }
*/
                    }
                    if (version.fontColor) {
                        inner.style.color = version.fontColor;
                    }
                    if (version.borderColor) {
                        inner.style.borderColor = version.borderColor;
                    }
                    if (version.backImage) {
                        inner.style.backgroundImage = "url(" + version.backImage + ")";
                        if (version.backRepeat) {
                            inner.style.backgroundRepeat = version.backRepeat;
                        }
                    }


                    div.appendChild(inner);

                    if (vpart.continueLeft && !isMilestone) {
                        addClass(div, calendar._prefixCssClass("_event_continueleft"));
                    }
                    if (vpart.continueRight && !isMilestone) {
                        addClass(div, calendar._prefixCssClass("_event_continueright"));
                    }

                    var barVisible = calendar.durationBarVisible && !version.barHidden;
                    var width = vpart.width;

                    if (barVisible && width > 0) {
                        var barLeft = 100 * vpart.barLeft / (width); // %
                        var barWidth = Math.ceil(100 * vpart.barWidth / (width)); // %

                        if (calendar.durationBarMode === "PercentComplete") {
                            barLeft = 0;
                            barWidth = version.complete || 0;
                        }

                        var bar = createDiv();
                        bar.setAttribute("unselectable", "on");
                        bar.className = calendar._prefixCssClass(cssNames.eventBar);
                        bar.style.position = "absolute";

                        if (version.barBackColor) {
                            bar.style.backgroundColor = version.barBackColor;
                        }

                        var barInner = createDiv();
                        barInner.setAttribute("unselectable", "on");
                        barInner.className = calendar._prefixCssClass(cssNames.eventBarInner);
                        barInner.style.left = barLeft + "%";
                        if (0 < barWidth && barWidth <= 1) {
                            barInner.style.width = "1px";
                        }
                        else {
                            barInner.style.width = barWidth + "%";
                        }

                        if (version.barColor) {
                            barInner.style.backgroundColor = version.barColor;
                        }

                        if (version.barImageUrl) {
                            barInner.style.backgroundImage = "url(" + version.barImageUrl + ")";
                        }

                        bar.appendChild(barInner);
                        div.appendChild(bar);
                    }

                    if (version.htmlLeft) {

                        var margin = calendar.eventHtmlLeftMargin;
                        var divLeft = createDiv();
                        divLeft.style.position = 'absolute';
                        divLeft.style.right = -(vpart.left - margin) + 'px';
                        divLeft.style.top = (rowTop + vpart.top) + 'px';
                        divLeft.style.height = calendar.eventVersionHeight + 'px';
                        divLeft.style.boxSizing = "border-box";
                        divLeft.innerHTML = version.htmlLeft;
                        divLeft.className = calendar._prefixCssClass("_event_left");
                        divLeft.type = "divLeft";
                        divLeft.versionPart = vpart;

                        parent.related.push(divLeft);

                        // draw the div
                        divEvents.appendChild(divLeft);
                    }

                    if (version.htmlRight) {
                        var margin = calendar.eventHtmlRightMargin;
                        var divRight = createDiv();
                        divRight.style.position = 'absolute';
                        divRight.style.left = (vpart.left + vpart.width + margin) + 'px';
                        divRight.style.top = (rowTop + vpart.top) + 'px';
                        divRight.style.height = calendar.eventVersionHeight + 'px';
                        divRight.style.boxSizing = "border-box";
                        divRight.innerHTML = version.htmlRight;
                        divRight.className = calendar._prefixCssClass("_event_right");
                        divRight.type = "divRight";
                        divRight.versionPart = vpart;

                        parent.related.push(divRight);

                        // draw the div
                        divEvents.appendChild(divRight);
                    }

                    div.versionPart = vpart;
                    div.type = "version";

                    // angular-safe copy (change detection)
                    var areas = DayPilot.Areas.resolvePosition(version.areas, calendar, vpart.left, vpart.width);

                    DayPilot.Areas.attach(div, version, {"areas": areas});

                    parent.related.push(div);

                    // draw the div
                    divEvents.appendChild(div);

                });

            })(div);

            if (cache.htmlLeft) {

                var margin = calendar.eventHtmlLeftMargin;
                var divLeft = createDiv();
                divLeft.style.position = 'absolute';
                divLeft.style.right = -(e.part.left - margin) + 'px';
                divLeft.style.top = (rowTop + e.part.top) + 'px';
                divLeft.style.height = calendar.eventHeight + 'px';
                divLeft.style.boxSizing = "border-box";
                divLeft.innerHTML = cache.htmlLeft;
                divLeft.className = calendar._prefixCssClass("_event_left");
                divLeft.type = "divLeft";

                div.related.push(divLeft);

                // draw the div
                divEvents.appendChild(divLeft);
            }

            if (cache.htmlRight) {
                var margin = calendar.eventHtmlRightMargin;
                var divRight = createDiv();
                divRight.style.position = 'absolute';
                divRight.style.left = (e.part.left + e.part.width + margin) + 'px';
                divRight.style.top = (rowTop + e.part.top) + 'px';
                divRight.style.height = calendar.eventHeight + 'px';
                divRight.style.boxSizing = "border-box";
                divRight.innerHTML = cache.htmlRight;
                divRight.className = calendar._prefixCssClass("_event_right");
                divRight.type = "divRight";

                div.related.push(divRight);

                // draw the div
                divEvents.appendChild(divRight);
            }

            var top = rowTop + e.part.top;

            if (calendar.treeAnimation) {
                var rowHeight = typeof row.forcedHeight === "number" ? row.forcedHeight: row.height;
                if (e.part.top + e.part.height > rowHeight) {
                    height = Math.max(0, rowHeight - e.part.top);
                }
            }

            //div.data = data;
            div.style.position = 'absolute';
            div.style.left = (e.part.left + calendar.eventMarginLeft)  + 'px';
            div.style.top = (rowTop + e.part.top) + 'px';
            div.style.width = (width - calendar.eventMarginLeft - calendar.eventMarginRight) + 'px';
            div.style.height = height + 'px';
            if (!calendar.eventTextWrappingEnabled) {
                div.style.whiteSpace = 'nowrap';
            }
            div.style.overflow = 'hidden';
            div.className = this._prefixCssClass(cssNames.event);
            if (isMilestone) {
                addClass(div, calendar._prefixCssClass("_task_milestone"));
            }
            if (e.data.type === "Group") {
                addClass(div, calendar._prefixCssClass("_task_parent"));  // remove
                addClass(div, calendar._prefixCssClass("_task_group"));
            }
            if (cache.cssClass) {
                addClass(div, cache.cssClass);
            }
            var lineClasses = true;
            if (lineClasses && typeof e.part.line === "number") {
                addClass(div, this._prefixCssClass(cssNames.eventLine + e.part.line));
            }
            div.setAttribute("unselectable", "on");

            if (this.showToolTip && !this.bubble) {
                div.title = e.client.toolTip() || "";
            }

            div.onmousemove = this._onEventMouseMove;
            div.onmouseout = this._onEventMouseOut;
            div.onmousedown = this._onEventMouseDown;
            div.onmouseup = this._onEventMouseUp;

            DayPilot.reNonPassive(div, "touchstart", touch._onEventTouchStart);
            DayPilot.rePassive(div, "touchmove", touch._onEventTouchMove);
            DayPilot.reNonPassive(div, "touchend", touch._onEventTouchEnd);

            if (e.client.clickEnabled()) {
                div.onclick = this._onEventClick;
            }

            if (e.client.doubleClickEnabled()) {
                div.ondblclick = this._eventDoubleClickDispatch;
            }

            // div.oncontextmenu = this._eventRightClickDispatch;
            div.oncontextmenu = function(ev) {
                if (!calendar.allowDefaultContextMenu) {
                    ev.preventDefault();
                }
            };

            if (typeof cache.ariaLabel !== "undefined") {
                div.setAttribute("aria-label", cache.ariaLabel);
            }
            else {
                div.setAttribute("aria-label", cache.text);
            }

            div.setAttribute("tabindex", "-1");

            var inside = [];
            var durationBarHeight = 0;

            var inner = createDiv();
            inner.setAttribute("unselectable", "on");
            inner.className = calendar._prefixCssClass(cssNames.eventInner);

            if (cache.backColor) {
                inner.style.background = cache.backColor;
            }
            if (cache.fontColor === "contrasting" && cache.backColor) {
                inner.style.color = DayPilot.ColorUtil.contrasting(cache.backColor);
            }
            else {
                inner.style.color = cache.fontColor;
            }
            if (cache.borderColor === "darker" && cache.backColor) {
                inner.style.borderColor = DayPilot.ColorUtil.darker(cache.backColor, 2);
            }
            else {
                inner.style.borderColor = cache.borderColor;
            }

            if (cache.backImage) {
                inner.style.backgroundImage = "url(" + cache.backImage + ")";
                if (cache.backRepeat) {
                    inner.style.backgroundRepeat = cache.backRepeat;
                }
            }

            div.appendChild(inner);

            var startsHere = e.start().getTime() === e.part.start.getTime();
            var endsHere = e.rawend().getTime() === e.part.end.getTime();

            if (!startsHere && !isMilestone) {
                addClass(div, this._prefixCssClass("_event_continueleft"));
            }
            if (!endsHere && !isMilestone) {
                addClass(div, this._prefixCssClass("_event_continueright"));
            }

            if (e.client.barVisible() && width > 0 && !isMilestone) {
                var barLeft = 100 * e.part.barLeft / (width); // %
                var barWidth = Math.ceil(100 * e.part.barWidth / (width)); // %

                if (this.durationBarMode === "PercentComplete") {
                    barLeft = 0;
                    barWidth = cache.complete || 0;
                }

                // make space for the bar
                if (calendar.durationBarHeight) {
                    inner.style.paddingTop = calendar.durationBarHeight + "px";
                }


                var bar = createDiv();
                bar.setAttribute("unselectable", "on");
                bar.className = this._prefixCssClass(cssNames.eventBar);
                bar.style.position = "absolute";

                if (calendar.durationBarHeight) {
                    bar.style.height = calendar.durationBarHeight + "px";
                }

                if (cache.barBackColor) {
                    bar.style.backgroundColor = cache.barBackColor;
                }

                var barInner = createDiv();
                barInner.setAttribute("unselectable", "on");
                barInner.className = this._prefixCssClass(cssNames.eventBarInner);
                barInner.style.left = barLeft + "%";
                if (calendar.durationBarHeight) {
                    barInner.style.height = calendar.durationBarHeight + "px";
                }
                //barInner.setAttribute("barWidth", data.part.barWidth);  // debug
                if (0 < barWidth && barWidth <= 1) {
                    barInner.style.width = "1px";
                }
                else {
                    barInner.style.width = barWidth + "%";
                }

                if (cache.barColor) {
                    barInner.style.backgroundColor = cache.barColor;
                }

                if (cache.barImageUrl) {
                    barInner.style.backgroundImage = "url(" + cache.barImageUrl + ")";
                }

                bar.appendChild(barInner);
                div.appendChild(bar);
            }
            div.row = rowIndex;

            if (cache.areas) {
                var areas = DayPilot.Areas.resolvePosition(cache.areas, calendar, e.part.left, e.part.width);
                areas = areas.filter(function(area) { return DayPilot.Areas.isVisible(area); });
                areas.forEach(function(area) {
                    var a = DayPilot.Areas.createArea(div, e, area);
                    div.appendChild(a);
                });
/*
                for (var i = 0; i < cache.areas.length; i++) {
                    var area = cache.areas[i];
                    if (!DayPilot.Areas.isVisible(area)) {
                        continue;
                    }
                    if (area.start) {
                        area.left = calendar.getPixels(new DayPilot.Date(area.start)).left - e.part.left;
                    }
                    if (area.end) {
                        area.right = e.part.left + e.part.width - calendar.getPixels(new DayPilot.Date(area.end)).left;
                    }

                    var a = DayPilot.Areas.createArea(div, e, area);
                    div.appendChild(a);
                }
*/
            }

            div.event = e;

            if (shouldBeSelected) {
                calendar.multiselect.add(div.event, true);
                calendar.multiselect._update(div);
            }

            (function domAdd() {

                if (typeof calendar.onBeforeEventDomAdd !== "function" && typeof calendar.onBeforeEventDomRemove !== "function") {
                    if (!isMilestone) {
                        inner.innerHTML = e.client.innerHTML();
                    }
                    return;
                }

                var args = {};
                args.control = calendar;
                args.e = e;
                args.element = null;

                div.domArgs = args;

                // legacy, to be removed
                if (typeof calendar.onDomAddEvent === "function") {
                    calendar.onDomAddEvent(args);
                }

                if (typeof calendar.onBeforeEventDomAdd === "function") {
                    calendar.onBeforeEventDomAdd(args);
                }

                if (args.element) {
                    var target = inner;
                    if (target) {
                        args._targetElement = target;
                        // target.innerHTML = "";

                        var isReactComponent = isReactCmp(args.element);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }
                else if (!isMilestone) {
                    inner.innerHTML = e.client.innerHTML();
                }
            })();

            // add it to the events collection
            this.elements.events.push(div);

            // draw the div
            divEvents.appendChild(div);

            e.rendered = true;

            if (calendar._api2()) {
                if (typeof calendar.onAfterEventRender === 'function') {
                    var args = {};
                    args.e = div.event;
                    args.div = div;

                    calendar.onAfterEventRender(args);
                }
            }
            else {
                if (calendar.afterEventRender) {
                    calendar.afterEventRender(div.event, div);
                }
            }

            return true;
        };

        this._xssTextHtml = function(text, html) {

            if (calendar._resolved._xssProtectionEnabled()) {
                return DayPilot.Util.escapeTextHtml(text, html);
            }

            if (!isNullOrUndefined(html)) {
                return html;
            }
            if (isNullOrUndefined(text)) {
                return "";
            }
            return text;
        };

        this._api2 = function() {
            return calendar.api === 2;
        };

        // freeze ok
        this._updateEventTops = function() {
            for (var i = 0; i < this.elements.events.length; i++) {
                var div = this.elements.events[i];
                var event = div.event;
                var rowIndex = event.part.dayIndex;
                var grid = calendar._gridInfo(event.part.grid);
                var row = grid.rowlist[rowIndex];
                var rowTop = row.top;
                var top = rowTop + event.part.top;
                var rowHeight = typeof row.forcedHeight === "number" ? row.forcedHeight: row.height;

                var height = event.part.height;
                var heightDirty = false;
                if (event.part.top + event.part.height > rowHeight) {
                    height = Math.max(0, rowHeight - event.part.top);
                    heightDirty = true;
                }

                div.style.top = top + 'px';
                div.style.height = height + "px";

                // versions, including left and right div
                createList(div.related).filter(function(item) {
                    return !!item.versionPart;
                }).forEach(function(rel) {
                    var vpart = rel.versionPart;
                    rel.style.top = (rowTop + vpart.top) + 'px';
                });

                // left and right div
                createList(div.related).filter(function(item) {
                    return !item.versionPart && (item.type === "divLeft" || item.type === "divRight");
                }).forEach(function(rel) {
                    rel.style.top = top + 'px';
                });

                /*
                if (DayPilot.isArray(div.related)) {
                    for (var j = 0; j < div.related.length; j++) {
                        var rel = div.related[j];
                    }
                }
                */
                /*
                if (div.bar) {
                    div.bar.style.top = (rowTop + event.part.top + 10) + 'px'; // HACK
                }*/
            }
        };

        this._findEventDiv = function(e) {
            if (!e) {
                return null;
            }
            for (var i = 0; i < calendar.elements.events.length; i++) {
                var div = calendar.elements.events[i];
                if (calendar._isSameEvent(div.event, e)) {
                    return div;
                }
/*
                if (div.event === e || div.event.data === e.data) {
                    return div;
                }
*/
            }
            return null;
        };

        this._findEventDivEnsureRendered = function(e) {
            var ev = calendar.events._findEventInRows(e.data);
            if (!ev) {
                return null;
            }
            var row = calendar.rowlist[ev.part.dayIndex];
            calendar._updateEventPositionsInRow(row);
            calendar._drawEvent(ev, {"forced": true});  // make sure it's rendered
            return calendar._findEventDiv(ev);
        };

        this._onEventMouseOut = function(ev) {
            var div = this;

            DayPilot.Areas.hideAreas(div, ev);

            if (div.active) {
                return;
            }

            removeClass(div, calendar._prefixCssClass("_event_hover"));

            calendar._doEventMouseOut(div);

            if (!linking.source) {
                linktools._hideLinkpointsWithDelay();
            }

            if (calendar.bubble && calendar.eventHoverHandling === 'Bubble') {
                calendar.bubble.hideOnMouseOut();
            }

        };

        this._doEventMouseOver = function(div) {
            var args = {};
            args.div = div;
            args.e = div.event;

            if (typeof this.onEventMouseOver === "function") {
                this.onEventMouseOver(args);
            }
            if (typeof this.onEventMouseEnter === "function") {
                this.onEventMouseEnter(args);
            }
        };

        this._doEventMouseOut = function(div) {
            var args = {};
            args.div = div;
            args.e = div.event;

            if (typeof this.onEventMouseOut === "function") {
                this.onEventMouseOut(args);
            }
            if (typeof this.onEventMouseLeave === "function") {
                this.onEventMouseLeave(args);
            }
        };

        this._doRowMouseOver = function(div) {
            var row = div.row;
            var args = {};
            args.div = div;
            args.row = calendar._createRowObject(row);

            if (typeof this.onRowMouseOver === "function") {
                this.onRowMouseOver(args);
            }
/*
            if (typeof this.onRowMouseEnter === "function") {
                this.onRowMouseEnter(args);
            }
*/
        };

        this._doRowMouseOut = function(div) {
            var row = div.row;
            var args = {};
            args.div = div;
            args.row = calendar._createRowObject(row);

            if (typeof this.onRowMouseOut === "function") {
                this.onRowMouseOut(args);
            }
/*
            if (typeof this.onRowMouseLeave === "function") {
                this.onRowMouseLeave(args);
            }
*/

        };


        this._onEventMouseMove = function(ev) {
            if (calendar.cellBubble) { calendar.cellBubble.delayedHide(); }

            var div = this;
            while (div && !div.event) { // make sure it's the top event div
                div = div.parentNode;
            }
            var e = div.event;

            calendar._eventUpdateCursor(div, ev);

            var deleteDisabled = div.event.cache ? div.event.cache.deleteDisabled : div.event.data.deleteDisabled;
            // var linkDisabled = div.event.cache ? div.event.cache.linkDisabled : div.event.data.linkDisabled;

            if (!div.active) {
                var areas = [];

                if (calendar.eventDeleteHandling !== "Disabled" && !deleteDisabled) {
                    var top = calendar.durationBarVisible ? resolved._barHeight() : 0;
                    areas.push({"action":"JavaScript","v":"Hover","w":17,"h":17,"top": top + 2,"right":2, "css": calendar._prefixCssClass(cssNames.eventDelete),"js":function(e) { calendar._eventDeleteDispatch(e); } });
                }

                var list = div.event.cache ? div.event.cache.areas : div.event.data.areas;
                if (list && list.length > 0) {
                    list = DayPilot.Areas.resolvePosition(list, calendar, e.part.left, e.part.width);
                    areas = areas.concat(list);
                }
                DayPilot.Areas.showAreas(div, div.event, null, areas);
                addClass(div, calendar._prefixCssClass("_event_hover"));

                calendar._doEventMouseOver(div);

            }

            if (calendar.linkCreateHandling !== "Disabled" && !linking.source) {
                linktools._clearHideTimeout();
                linktools._hideLinkpoints();
                if (calendar._noDragAndDropInProgress()) {
                    linktools._showLinkpoint(div);
                }
            }

            calendar._updateCoords(ev);
            calendar.coords.insideEvent = div.event;

/*
            if (ev.srcElement) {
                ev.srcElement.insideEvent = true;
            }
            else {
                ev.insideEvent = true;
            }
*/

            // bubbling must be allowed, required for moving and resizing
            //ev.cancelBubble = true;

        };


        this._moving = {};
        // var moving = this._moving;

        this._onEventMouseUp = function(ev) {
            var moving = calendar._moving;

            var button = mouseButton(ev);
            if (button.right) {
                calendar._eventRightClickDispatch.call(this, ev);
                return;
            }

            if (!calendar.ionicEventClickFix) {
                return;
            }

            var origMouse = moving._originalMouse;
            if (!origMouse) {  // right click
                return;
            }
            var curMouse = DayPilot.mc(ev);
            if (origMouse.x === curMouse.x && origMouse.y === curMouse.y) {
                calendar._onEventClick.call(this, ev);
                ev.preventDefault();
                ev.stopPropagation();
            }
        };

        this._onEventMouseDown = function(ev) {

            calendar._out();

            if (typeof DayPilot.Bubble !== 'undefined') {
                DayPilot.Bubble.hideActive();
                DayPilot.Bubble.cancelShowing();
            }

            calendar._updateCoords(ev);

            var button = mouseButton(ev);

            ev.preventDefault();
            ev.stopPropagation();

            if (button.left) {
                var shift = ev.shiftKey;
                if (resolved._rectangleSelectMode() !== "Disabled" && shift) {
                    rectangle.start();
                    return false;
                }

                if (this.style.cursor === 'w-resize' || this.style.cursor === 'e-resize') {
                    DayPilotScheduler._preventEventClick = true;

                    // set
                    DayPilotScheduler._resizing = this;
                    DayPilotScheduler._resizingEvent = this.event;
                    DayPilotScheduler._originalMouse = DayPilot.mc(ev);

                    // cursor
                    body().style.cursor = this.style.cursor;
                    linktools._hideLinkpoints();
                }
                else if ((this.style.cursor === 'move') || (calendar.moveBy === 'Full' && this.event.client.moveEnabled())) {
                    // DayPilotScheduler._preventEventClick = true;
                    calendar._startMoving(this, ev);
                }
            }

            // = menuClean()
            if (DayPilot.Menu && DayPilot.Menu.active) {
                DayPilot.Menu.active.hide();
                DayPilot.Menu.active = null;
            }


            // ev.stopPropagation();

        };

        this._startMoving = function(div, ev) {
            var moving = calendar._moving;

            calendar._updateCoords(ev);

            moving._movingStarted = true;
            moving._moving = div;
            moving._movingEvent = div.event; // need to store it separately because the event box may get cleaned on sweeping
            moving._originalMouse = DayPilot.mc(ev);
            moving._moveOffsetX = DayPilot.mo3(div, ev).x;  // unused?
            moving._moveDragStart = calendar.getDate(calendar.coords.x, true);  // unused?
            linktools._hideLinkpoints();
        };

        this._touch = {};
        var touch = calendar._touch;

        if (typeof DpGlobal.touch === "undefined") {
            DpGlobal.touch = {};
        }
        DpGlobal.touch.active = false;
        DpGlobal.touch.start = false;
        touch._timeouts = [];

        // internal API
        touch.relativeCoords = function(ev) {
            return touch._relativeCoords(ev);
        };

        touch.startResizing = function(div, border) {
            touch._startResizing(div, border);
        }

        touch.startMoving = function(div, coords) {
            touch._startMoving(div, coords);
        };

        touch._onEventTouchStart = function(ev) {

            // iOS
            if (DpGlobal.touch.active || DpGlobal.touch.start) {
                return;
            }

            if (DayPilot.Menu) {
                DayPilot.Menu.touchPosition(ev);
            }

            // prevent onMainTouchStart
            ev.stopPropagation();

            touch._clearTimeouts();

            DpGlobal.touch.start = true;
            DpGlobal.touch.active = false;

            var div = this;

            calendar.coords = touch._relativeCoords(ev);

            var holdfor = calendar.tapAndHoldTimeout;
            touch._timeouts.push(window.setTimeout(function() {

                DpGlobal.touch.active = true;
                DpGlobal.touch.start = false;

                // required
                ev.preventDefault();

                var e = div.event;

                switch (calendar.eventTapAndHoldHandling) {
                    case "Move":
                        if (e.client.moveEnabled()) {
                            var coords = touchMousePos(ev);
                            touch._startMoving(div, coords);
                        }
                        break;
                    case "ContextMenu":

                        if (DayPilot.Menu) {
                            DayPilot.Menu.touchPosition(ev);
                        }

                        var menu = e.client.contextMenu();

                        if (menu) {
                            menu.show(e);
                        }
                        else {
                            if (calendar.contextMenu) {
                                calendar.contextMenu.show(e);
                            }
                        }

                        break;
                }


            }, holdfor));


        };

        touch._onEventTouchMove = function(ev) {
            touch._clearTimeouts();
            DpGlobal.touch.start = false;
        };

        touch._onEventTouchEnd = function(ev) {
            if (DayPilot.Util.isMouseEvent(ev)) {
                return;
            }

            touch._clearTimeouts();

            // quick tap
            if (DpGlobal.touch.start) {
                DpGlobal.touch.start = false;
                ev.preventDefault();
                ev.stopPropagation();

                var div = this;
                window.setTimeout(function() {
                    calendar._eventClickSingle(div, ev);
                });
            }

            window.setTimeout(function() {
                DpGlobal.touch.start = false;
                DpGlobal.touch.active = false;
            }, 500);

        };

        touch._onMainTouchStart = function(ev) {

            // prevent after-alert firing on iOS
            if (DpGlobal.touch.active || DpGlobal.touch.start) {
                return;
            }

            // pinch
            if (ev.touches.length > 1) {
                return;
            }

            if (calendar.timeRangeSelectedHandling === 'Disabled') {
                return;
            }

            touch._clearTimeouts();

            DpGlobal.touch.start = true;
            DpGlobal.touch.active = false;

            var holdfor = calendar.tapAndHoldTimeout;
            touch._timeouts.push(window.setTimeout(function() {
                DpGlobal.touch.active = true;
                DpGlobal.touch.start = false;

                ev.preventDefault();

                calendar.coords = touch._relativeCoords(ev);
                var withinRange = calendar._isWithinRange(calendar.coords);
                if (withinRange) {
                    calendar._onMaindRightMouseUp(ev);
                }
                else {
                    touch._range = calendar._rangeFromCoords();
                }

            }, holdfor));

            var tapAllowed = true;
            if (tapAllowed) {
                calendar.coords = touch._relativeCoords(ev);
            }
        };

        touch._onMainTouchMove = function(ev) {
            touch._clearTimeouts();

            DpGlobal.touch.start = false;

            if (DayPilotScheduler._resizing) {
                ev.preventDefault();
                touch._updateResizing();
                return;
            }

            if (DpGlobal.touch.active) {
                ev.preventDefault();

                calendar.coords = touch._relativeCoords(ev);

                if (DayPilotScheduler._moving) {
                    touch._updateMoving();
                    return;
                }


                if (touch._range) {
                    var range = touch._range;
                    range.end = {
                        x: Math.floor(calendar.coords.x / calendar.cellWidth),
                        "time": calendar.getDate(calendar.coords.x, true)
                    };

                    calendar._drawRange(range);
                }
            }

        };

        touch.debug = function(msg) {};

        touch._onMainTouchEnd = function(ev) {
            touch._clearTimeouts();

            var tapAllowed = true;

            if (DpGlobal.touch.active) {
                if (DayPilotScheduler._moving) {

                    ev.preventDefault();

                    var e = DayPilotScheduler._movingEvent;

                    if (calendar !== DayPilotScheduler._movingShadow.calendar) {
                        return;
                    }

                    var newStart = DayPilotScheduler._movingShadow.start;
                    var newEnd = DayPilotScheduler._movingShadow.end;
                    var newResource = (calendar.viewType !== 'Days') ? DayPilotScheduler._movingShadow.row.id : null;
                    var external = DayPilotScheduler._drag && e.part.external;

                    var overlapping = DayPilotScheduler._movingShadow.overlapping;
                    var forbidden = !DayPilotScheduler._movingShadow.allowed;

                    removeClass(DayPilotScheduler._moving, calendar._prefixCssClass(calendar._css.eventMovingSource));

                    // clear the moving state
                    deleteElement(DayPilotScheduler._movingShadow);
                    calendar._clearShadowHover();
                    DayPilotScheduler._movingShadow.calendar = null;
                    body().style.cursor = '';
                    DayPilotScheduler._moving = null;
                    DayPilotScheduler._movingEvent = null;
                    DayPilotScheduler._movingShadow = null;

                    calendar._multimove.clear();
                    if (overlapping || forbidden || calendar._multimove.forbidden  || calendar._multimove.invalid) {
                        return;
                    }

                    calendar._eventMoveDispatch(e, newStart, newEnd, newResource, external);

                }

                if (touch._range) {
                    var range = touch._range;
                    touch._range = null;

                    var shadow = calendar.elements.range2;
                    if (shadow && shadow.overlapping) {
                        calendar.clearSelection();
                    }
                    else {
                        calendar._rangeHold = range;
                        calendar._timeRangeSelectedDispatchFromRange(range);
                    }
                }
            }
            else if (DpGlobal.touch.start && tapAllowed) {  // simple tap
                if (calendar.coords.x < calendar.getScrollX()) {
                    return; // invisible
                }

                var range = calendar._rangeFromCoords();
                calendar._drawRange(range);

                var shadow = calendar.elements.range2;
                if (shadow && shadow.overlapping) {
                    calendar.clearSelection();
                }
                else {
                    calendar._rangeHold = range;
                    calendar._timeRangeSelectedDispatchFromRange(range);
                }
            }

            window.setTimeout(function() {
                DpGlobal.touch.start = false;
                DpGlobal.touch.active = false;
            }, 500);

        };

        touch._clearTimeouts = function() {
            for (var i = 0; i < touch._timeouts.length; i++) {
                clearTimeout(touch._timeouts[i]);
            }
            touch._timeouts = [];
        };

        touch._relativeCoords = function(ev) {
            var ref = calendar._maind;

            var t = ev.touches ? ev.touches[0] : ev;

            var x = t.pageX;
            var y = t.pageY;

            var coords = offset(x, y, ref);
            coords.grid = "main";

            if (calendar._grids.top.enabled()) {
                var top = calendar._grids.top;
                var coordsTop = offset(x, y, top.divCells);
                if (coordsTop.y > 0 && coordsTop.y <= top.height) {
                    coords = coordsTop;
                    coords.grid = "top";
                }
            }

            if (calendar._grids.bottom.enabled()) {
                var bottom = calendar._grids.bottom;
                var coordsBottom = offset(x, y, bottom.divCells);
                if (coordsBottom.y > 0 && coordsBottom.y <= top.height) {
                    coords = coordsBottom;
                    coords.grid = "bottom";
                }
            }

            function offset(x, y, div) {
                var abs = DayPilot.abs(div);
                var coords = {x: x - abs.x, y: y - abs.y, toString: function() { return "x: " + this.x + ", y:" + this.y; } };
                return coords;
            }

            return coords;
        };

        // coords - page coords
        touch._startMoving = function(div, coords) {

            DayPilotScheduler._moving = div;
            DayPilotScheduler._movingEvent = div.event;
            DayPilotScheduler._originalMouse = coords;

            var absE = DayPilot.abs(div);
            DayPilotScheduler._moveOffsetX = coords.x - absE.x;

            //var absR = DayPilot.abs(calendar.maind);
            //var x = coords.x - absR.x;
            DayPilotScheduler._moveDragStart = calendar.getDate(calendar.coords.x, true);

            DayPilotScheduler._movingShadow = calendar._createShadow(div);

            // update dimensions
            calendar._moveShadow();

        };

        touch._startResizing = function(div, border) {
            //var coords = {x: ev.touches[0].pageX, y: ev.touches[0].pageY};

            DayPilotScheduler._resizing = div;
            DayPilotScheduler._resizingEvent = div.event;
            DayPilotScheduler._resizing.dpBorder = border;

            if (!DayPilotScheduler._resizingShadow) {
                DayPilotScheduler._resizingShadow = calendar._createShadow(div);
            }

            // update dimensions
            calendar._resizeShadow();
        };


        // coords - relative to maind
        touch._updateResizing = function() {
            if (!DayPilotScheduler._resizingShadow) {
                var mv = DayPilotScheduler._resizing;
                DayPilotScheduler._resizingShadow = calendar._createShadow(mv);
            }

            calendar._resizeShadow();

            var coords = { x: calendar.coords.x, y: calendar.coords.y, "grid": calendar.coords.grid };
            calendar._doAutoScroll(coords);

        };

        // coords - relative to maind
        touch._updateMoving = function() {
            if (DayPilotScheduler._movingShadow && DayPilotScheduler._movingShadow.calendar !== calendar) {
                calendar._clearShadowHover();
            }
            if (!DayPilotScheduler._movingShadow) {
                var mv = DayPilotScheduler._moving;
                DayPilotScheduler._movingShadow = calendar._createShadow(mv);
            }

            var target = DayPilotScheduler._movingShadow.calendar;

            target._moveShadow();

            var coords = { x: calendar.coords.x, y: calendar.coords.y, "grid": calendar.coords.grid };
            calendar._doAutoScroll(coords);

        };

        touch._onRowTouchStart = function(ev) {

            var rowFromList = this.row;
            var row = calendar._createRowObject(rowFromList);

            // prevent after-alert firing on iOS
            if (DpGlobal.touch.active || DpGlobal.touch.start) {
                return;
            }

            // pinch
            if (ev.touches.length > 1) {
                return;
            }

/*
            if (calendar.timeRangeSelectedHandling === 'Disabled') {
                return;
            }

*/
            touch._clearTimeouts();

            DpGlobal.touch.start = true;
            DpGlobal.touch.active = false;

            var holdfor = calendar.tapAndHoldTimeout;
            touch._timeouts.push(window.setTimeout(function() {
                DpGlobal.touch.active = true;
                DpGlobal.touch.start = false;

                ev.preventDefault();

                if (calendar.contextMenuResource) {
                    calendar.contextMenuResource.show(row);
                }

            }, holdfor));

            var tapAllowed = true;
            if (tapAllowed) {
                calendar.coords = touch._relativeCoords(ev);
            }

        };

        touch._onRowTouchEnd = function(ev) {
            // prevent context menu cancellation on iPad
            if (DpGlobal.touch.active) {
                DpGlobal.touch.start = false;
                ev.preventDefault();
                ev.stopPropagation();
            }

            window.setTimeout(function() {
                DpGlobal.touch.start = false;
                DpGlobal.touch.active = false;
            }, 500);
        };

        this._eventUpdateCursor = function(div, ev) {

            // const
            var resizeMargin = this.eventResizeMargin;
            var moveMargin = this.eventMoveMargin;

            var object = div;

            if (typeof (DayPilotScheduler) === 'undefined') {
                return;
            }

            // position
            var offset = DayPilot.mo3(div, ev);
            if (!offset) {
                return;
            }

            calendar.eventOffset = offset;

            if (DayPilotScheduler._resizing) {
                return;
            }

            if (DayPilotScheduler._moving) {
                return;
            }

            var isFirstPart = object.event.part.start.toString() === object.event.start().toString();
            var isLastPart = object.event.part.end.toString() === object.event.rawend().toString();

            // top
            if (calendar.moveBy === 'Top' && offset.y <= moveMargin && object.event.client.moveEnabled() && calendar.eventMoveHandling !== 'Disabled') {  // TODO disabled check not necessary
                div.style.cursor = 'move';
            }
            // left resizing
            else if ((calendar.moveBy === 'Top' || calendar.moveBy === 'Full') && offset.x <= resizeMargin && object.event.client.resizeEnabled() && calendar.eventResizeHandling !== 'Disabled') {  // TODO disabled check not necessary
                if (isFirstPart) {
                    div.style.cursor = "w-resize";
                    div.dpBorder = 'left';
                }
                else {
                    div.style.cursor = 'not-allowed';
                }
            }
            // left moving
            else if (calendar.moveBy === 'Left' && offset.x <= moveMargin && object.event.client.moveEnabled() && calendar.eventMoveHandling !== 'Disabled') {  // TODO disabled check not necessary
                div.style.cursor = "move";
            }
            // right resizing
            else if (div.offsetWidth - offset.x <= resizeMargin && object.event.client.resizeEnabled() && calendar.eventResizeHandling !== 'Disabled') {  // TODO disabled check not necessary
                if (isLastPart) {
                    div.style.cursor = "e-resize";
                    div.dpBorder = 'right';
                }
                else {
                    div.style.cursor = 'not-allowed';
                }
            }
            else if (!DayPilotScheduler._resizing && !DayPilotScheduler._moving) {
                if (object.event.client.clickEnabled() && calendar.eventClickHandling !== 'Disabled') {  // TODO disabled check not necessary
                    div.style.cursor = 'pointer';
                }
                else {
                    div.style.cursor = 'default';
                }
            }


            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.bubble && calendar.eventHoverHandling === 'Bubble') {
                if (div.style.cursor === 'default' || div.style.cursor === 'pointer') {
                    // preventing Chrome bug
                    var notMoved = this._lastOffset && offset.x === this._lastOffset.x && offset.y === this._lastOffset.y;

                    // turned off because it doesn't work on macos
                    var notMoved = false;

                    if (!notMoved) {
                        this._lastOffset = offset;
                        calendar.bubble.showEvent(div.event);
                    }
                }
                else {
                    /*
                    // disabled, now it is hidden on click
                    DayPilot.Bubble.hideActive();
                    */
                }
            }
        };

        this._cellCount = function() {
            if (this.viewType !== 'Days') {
                return this.itline.length;
            }
            else {
                return Math.floor(24 * 60 / this.cellDuration);
            }
        };

        this._getSelection = function(range) {

            var range = range || DayPilotScheduler._range || calendar._rangeHold;

            if (!range) {
                return null;
            }

            var grid = calendar._gridInfo(range.start.grid);
            var row = grid.rowlist[range.start.y];

            if (!row) {
                return null;
            }

            var r = range._customized ? range._customized : range;

            var natural = r.end.time > r.start.time;

            var resource = row.id;
            var startX = natural ? r.start.x : r.end.x;
            var endX = (natural ? r.end.x : r.start.x);

            var rowOffset = row.start.getTime() - this._visibleStart().getTime();

            var snapToGrid = calendar.snapToGrid && calendar.snapToGridTimeRangeSelecting;
            if (range.forceSnap) {
                snapToGrid = true;
            }

            var start, end;
            if (snapToGrid) {
                start = this.itline[startX].start.addTime(rowOffset);
                end = this.itline[endX].end.addTime(rowOffset);
            }
            else {
                if (natural) {
                    start = r.start.time;
                    end = r.end.time;
                }
                else {
                    start = r.end.time;
                    end = r.start.time;
                }
            }

            var sel = new DayPilot.Selection(start, end, resource, calendar);
            sel.allowed = !range.div || !range.div.overlapping;

            return sel;
        };

        this._createEdit = function(object) {
            var parentTd = object.parentNode;

            var minWidth = calendar.eventEditMinWidth;

            var text = (object.event.text() || "").trim();

            var edit = document.createElement('textarea');
            edit.style.position = 'absolute';
            edit.style.width = ((object.offsetWidth < minWidth) ? minWidth : (object.offsetWidth - 2)) + 'px';
            edit.style.height = (object.offsetHeight - 2) + 'px'; //offsetHeight
            edit.style.fontFamily = DayPilot.gs(object, 'fontFamily') || DayPilot.gs(object, 'font-family');
            edit.style.fontSize = DayPilot.gs(object, 'fontSize') || DayPilot.gs(object, 'font-size');
            edit.style.left = object.offsetLeft + 'px';
            edit.style.top = object.offsetTop + 'px';
            edit.style.border = '1px solid black';
            edit.style.padding = '1px';
            edit.style.marginTop = '0px';
            edit.style.backgroundColor = 'white';
            edit.value = text;

            edit.event = object.event;
            parentTd.appendChild(edit);
            return edit;
        };

        this._findNextInVieport = function(div) {
            var divs = viewport._events();
            divs.sort(function(a, b) {
                var e1 = a.event;
                var e2 = b.event;
                if (e1.part.dayIndex !== e2.part.dayIndex) {
                    return e1.part.dayIndex - e2.part.dayIndex;
                }
                if (e1.start() !== e2.start()) {
                    return e1.start().getTime() - e2.start().getTime();
                }
                return e2.end().getTime() - e1.end().getTime();
            });
            var index = divs.indexOf(div);

            if (index === -1) {
                return null;
            }
            if (index + 1 < divs.length) {
                return divs[index + 1];
            }
            return divs[0];
        };

        this._divEdit = function(object) {
            if (!object) {
                return;
            }

            var nowEditing = DayPilotScheduler._editing;
            if (nowEditing) {
                DayPilotScheduler._editing.blur();
                //return;
            }

            if (!object.event) {
                return;
            }

            var oev = object.event;

            focus._unfocusCell();

            var edit = this._createEdit(object);
            DayPilotScheduler._editing = edit;

            DayPilot.rePassive(edit, DayPilot.touch.start, function(ev) {
                ev.stopPropagation();
            });

            edit.onblur = function() {
                //var id = object.event.value();
                //var tag = object.event.tag();

                edit.onblur = null;

                if (DayPilotScheduler._editing === edit) {
                    DayPilotScheduler._editing = null;
                }

                if (edit.parentNode) {
                    edit.parentNode.removeChild(edit);
                }

                if (!object.event) {
                    return;
                }

                var oldText = object.event.text();
                var newText = edit.value;

                // onEventEdit is always fired
                /*
                if (oldText === newText && !edit.canceling) {
                    return;
                }
                */

                //object.style.display = 'none';
                calendar._eventEditDispatch(object.event, newText, edit.canceling);
            };

            edit.onmousedown = function(e) {
                e.stopPropagation && e.stopPropagation();
            };

/*            edit.onkeypress = function(e) {
                var keynum = e.keyCode;

                if (keynum === 13) {
                    this.onblur();
                    return false;
                }

                return true;
            };*/

            edit.cancel = function() {
                if (DayPilotScheduler._editing) {
                    DayPilotScheduler._editing.canceling = true;
                    DayPilotScheduler._editing.blur();
                }
            };

            edit.onkeydown = function(e) {

                if (typeof calendar.onEventEditKeyDown === "function") {
                    var args = {};
                    args.e = object.event;
                    args.element = edit;
                    args.preventDefault = function() {
                        args.preventDefault.value = true;
                    };
                    args.submit = function() {
                        //e.stopPropagation();  // let it be managed by the event handler
                        edit.onblur();
                    };
                    args.cancel = function() {
                        DayPilotScheduler._editing.cancel();
                    } ;
                    args.originalEvent = e;

                    calendar.onEventEditKeyDown(args);

                    if (args.preventDefault.value) {
                        return;
                    }

                }

                var editing = DayPilotScheduler._editing;

                var keynum = e.keyCode;
                if (keynum === 13) {
                    e.stopPropagation();
                    this.onblur();
                }
                if (keynum === 27) {
                    editing.cancel();
                }
                else if (keynum === 9 && calendar.eventEditTabNext) {  // tab
                    var obj = calendar._findEventDiv(oev);
                    var next = calendar._findNextInVieport(obj);
                    if (editing) {
                        editing.cancel();
                    }
                    if (next) {
                        setTimeout(function() { calendar._divEdit(next); }, 0);
                    }
                    return false;
                }

            };

            if (typeof calendar.onAfterEventEditRender === "function") {
                var args = {};
                args.element = edit;
                args.e = object.event;

                calendar.onAfterEventEditRender(args);
            }

            edit.select();
            edit.focus();
        };

        this._autoBubble = {}
        this._autoBubble.resource = (function(){
            return typeof (DayPilot.Bubble) !== 'undefined' ? new DayPilot.Bubble() : {"showResource": function() {}, "hideOnMouseOut": function() {}};
        })();
        this._autoBubble.cell = (function(){
            return typeof (DayPilot.Bubble) !== 'undefined' ? new DayPilot.Bubble() : {"showResource": function() {}, "hideOnMouseOut": function() {}};
        })();

        this._onResMouseMove = function(ev) {
            var td = this;
            var row = td.row;

            calendar._stopScroll();

            calendar._resMouseMoveActive = true;
            clearTimeout(calendar._resMouseMoveActiveTimeout);
            calendar._resMouseMoveActiveTimeout = setTimeout(function() {
                calendar._resMouseMoveActive = false;
            }, 500);

            if (typeof (DayPilot.Bubble) !== 'undefined') {
                if (calendar.cellBubble) {
                    // hideOnMouseOut() is universal, it prevented resource bubble from appearing
                    //calendar.cellBubble.hideOnMouseOut();
                }
                var r = calendar._createRowObject(row);
                r.div = td;

                if (calendar.resourceBubble) {
                    calendar.resourceBubble.showResource(r);
                }
                else if (row.bubbleHtml) {
                    calendar._autoBubble.resource.showResource(r);
                }
            }



            /*var div = td.firstChild;
            if (!div.active) {
                calendar._doRowMouseOver(div, row);
            }*/

            /*
            var div = td.firstChild; // rowheader
            if (!div.active) {
                var row = calendar.rowlist[td.index];
                var r = calendar._createRowObject(row);
                r.areas = row.areas;
                DayPilot.Areas.showAreas(div, r);
            }
            */
        };

        this._onRowMouseEnter = function(ev) {
            // calendar._crosshairHide();
            var div = this;
            if (div.active) {
                return;
            }
            div.active = true;
            calendar._doRowMouseOver(div);
        };

        this._onRowMouseLeave = function(ev) {
            var div = this;
            delete div.active;
            calendar._doRowMouseOut(div);
        };

        this._onResMouseOut = function(ev) {
            var td = this;
            if (typeof (DayPilot.Bubble) !== 'undefined' && calendar.resourceBubble) {
                calendar.resourceBubble.hideOnMouseOut();
            }
            else {
                calendar._autoBubble.resource.hideOnMouseOut();
            }

            var div = td.firstChild;

            DayPilot.Areas.hideAreas(div, ev);
            div.data = null;

            // calendar._doRowMouseOut(div, td.row);
        };

        this._onResMouseUp = function(ev) {
            if (rowmoving.row) {
                // testing a hack
                rowtools.cancelClick = true;
                setTimeout(function() {
                    rowtools.cancelClick = false;
                }, 100);
            }

            if (calendar._rowEditNow) {
                calendar._rowEditNow = false;
                clearTimeout(calendar._rowEditNowTimeout);
                calendar._onResClick.call(this, ev);
            }
        };

        this._drawTimeHeader = function() {

            if (calendar.timeHeaderPosition === "None") {
                return;
            }

            if (!this.timeHeader) {
                return; // mvc shortInit
            }

            this._cache.timeHeader = {};

            //var oldheader = calendar.nav.header;
            if (calendar.elements.timeHeader.length > 0) {
                calendar._disposeTimeHeader();
                calendar.elements.timeHeader = [];
            }

            var header = createDiv();
            header.style.position = "relative";
            this.nav.timeHeader = header;

            for (var y = 0; y < this.timeHeader.length; y++) {
                var row = this.timeHeader[y];
                for (var x = 0; x < row.length; x++) {
                    this._drawTimeHeaderCell2(x, y);
                }
            }

            var north = this.divNorth;

            // already rendered, updating
            if (north.childNodes.length === 1) {
                north.replaceChild(header, north.childNodes[0]);
            }
            // not rendered before
            else {
                if (DayPilot.browser.ie) {
                    if (north && north.firstChild) {
                        var nodes = [];
                        for (var i = 0; i < north.firstChild.childNodes.length; i++) {
                            nodes.push(north.firstChild.childNodes[i]);
                        }
                        deleteElement(nodes);
                    }
                    //DayPilot.puc(north);
                    // north.innerHTML = '';
                    //north.appendChild(header);
                }

                // just to make sure
                north.innerHTML = '';
                north.appendChild(header);
            }

            var gridwidth = this._getGridWidth();
            north.style.width = (gridwidth + 5000) + "px";

            if (gridwidth > 0) {
                this.divStretch.style.width = (gridwidth) + "px";
            }

            calendar._nowHighlightCell();

        };

        this._disposeCorner = function() {
            if (!calendar.divCorner) {
                return;
            }
            var domArgs = calendar.divCorner && calendar.divCorner.domArgs;
            calendar.divCorner.domArgs = null;

            if (!domArgs) {
                return;
            }

            if (typeof calendar.onBeforeCornerDomRemove === "function") {
                calendar.onBeforeCornerDomRemove(domArgs);
            }

            if (typeof calendar.onBeforeCornerDomAdd === "function" && calendar._react.reactDOM) {
                var target = calendar.divCorner;
                if (target) {
                    var isReact = isReactCmp(domArgs.element);
                    if (isReact) {
                        if (!calendar._react.reactDOM) {
                            throw new DayPilot.Exception("Can't reach ReactDOM");
                        }
                        calendar._react._unmount(target);
                    }
                }
            }
        };

        this._getGroupName = function(h, cellGroupBy) {
            var html = null;
            var locale = this._resolved._locale();

            var cellGroupBy = cellGroupBy || this.cellGroupBy;

            var from = h.start;
            var to = h.end;

            switch (cellGroupBy) {
                case 'Minute':
                    html = from.toString("m");
                    break;
                case 'Hour':
                    html = (calendar._resolved._timeFormat() === 'Clock12Hours') ? from.toString("h tt", locale) : from.toString("H", locale);
                    break;
                case 'Day':
                    html = from.toString(locale.datePattern);
                    break;
                case 'Week':
                    html = resolved._weekStarts() === 1 ? from.weekNumberISO() : from.weekNumber(); // TODO format
                    break;
                case 'Month':
                    html = from.toString("MMMM yyyy", locale);
                    break;
                case 'Quarter':
                    html = "Q" + Math.floor(from.getMonth() / 3 + 1);
                    break;
                case 'Year':
                    html = from.toString("yyyy");
                    break;
                case 'None':
                    html = '';
                    break;
                case 'Cell':
                    // always guess, usually it's the bottom row
                    var duration = (h.end.ticks - h.start.ticks) / 60000;
                    html = this._getCellName(from, duration);
/*
                    if (this.scale === 'Manual' || this.scale === 'CellDuration') {  // hard-to-guess cell sizes
                        var duration = (h.end.ticks - h.start.ticks) / 60000;
                        html = this._getCellName(from, duration);
                    }
                    else {
                        html = this._getGroupName(h, this.scale);
                    }*/
                    break;
                default:
                    throw new DayPilot.Exception("Invalid groupBy value: " + cellGroupBy);
            }

            return html;
        };

        this._getCellName = function(start, duration) {
            var locale = this._resolved._locale();
            var duration = duration || this.cellDuration;
            if (duration < 1) // smaller than minute, use seconds
            {
                return start.toString("ss");
            }
            else if (duration < 60) // smaller than hour, use minutes
            {
                return start.toString("mm");
            }
            else if (duration < 1440) // smaller than day, use hours
            {
                return calendar._resolved._timeFormat() === 'Clock12Hours' ? start.toString("h tt", locale) : start.toString("H", locale);
            }
            else if (duration < 10080) // use days
            {
                return start.toString("d");
            }
            else if (duration === 10080) {
                return resolved._weekStarts() === 1 ? start.weekNumberISO() : start.weekNumber();
            }
            else
            {
                return start.toString("MMMM yyyy", locale);
            }
        };

        this._addScaleSize = function(from) {
            var scale = this.scale;
            switch (scale) {
                case "Cell":
                    throw new DayPilot.Exception("Invalid scale: Cell");
                case "Manual":
                    throw new DayPilot.Exception("Internal error (addScaleSize in Manual mode)");
/*
                case "Second":
                    return from.addSeconds(1);
*/
                case "CellDuration":
                    return from.addMinutes(this.cellDuration);
                default:
                    return this._addGroupSize(from, scale, true);
            }
        };

        this._addGroupSize = function(from, cellGroupBy, isScale) {
            var to;

            var endDate;
            if (isScale) {
                var daysHorizontally = this.viewType !== 'Days' ? this.days : 1;
                 endDate = this.startDate.addDays(daysHorizontally);
                if (calendar.scale  === "Manual") {
                    endDate = calendar._visibleEnd();
                }
            }
            else {
                endDate = calendar._visibleEnd();
                if (calendar.viewType  === "Days") {
                    endDate = calendar.startDate.addDays(1);
                }
            }

            var cellGroupBy = cellGroupBy || this.cellGroupBy;
            var cellDuration = 60; // dummy value to make sure it's aligned properly

            switch (cellGroupBy) {
                case 'Minute':
                    if (from.getMinutes() + from.getSeconds() + from.getMilliseconds() > 0) {
                        from = from.getDatePart().addHours(from.getHours()).addMinutes(from.getMinutes());
                    }
                    to = from.addMinutes(1);
                    break;
                case 'Hour':
                    if (from.getHours() + from.getMinutes() + from.getSeconds() + from.getMilliseconds() > 0) {
                        from = from.getDatePart().addHours(from.getHours());
                    }
                    to = from.addHours(1);
                    break;
                case 'Day':
                    to = from.getDatePart().addDays(1);
                    break;
                case 'Week':
                    to = from.getDatePart().addDays(1);
                    while (to.dayOfWeek() !== resolved._weekStarts()) {
                        to = to.addDays(1);
                    }
                    break;
                case 'Month':
                    from = from.getDatePart();
                    to = from.addMonths(1);
                    to = to.firstDayOfMonth();
                    //to = from.firstDayOfMonth().addDays(from.daysInMonth());

                    //var minDiff =
                    var isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    while (!isInt) {
                        to = to.addHours(1);
                        isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    }
                    break;
                case "Quarter":
                    from = from.getDatePart();
                    to = from.addMonths(1);
                    to = to.firstDayOfMonth();

                    //to = to.addMonths(to.getMonth() % 3);
                    while (to.getMonth() % 3) {
                        to = to.addMonths(1);
                    }


                    //var minDiff =
                    var isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    while (!isInt) {
                        to = to.addHours(1);
                        isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    }

                    break;
                case 'Year':
                    from = from.getDatePart();
                    to = from.addYears(1);
                    to = to.firstDayOfYear();

                    var isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    while (!isInt) {
                        to = to.addHours(1);
                        isInt = (DayPilot.DateUtil.diff(to, from) / (1000.0 * 60)) % cellDuration === 0;
                    }
                    break;
                case 'None':
                    to = endDate;
                    break;
                case 'Cell':
                    var cell = this._getItlineCellFromTime(from);
                    if (cell.current)
                    {
                        to = cell.current.end;
                    }
                    else
                    {
                        if (cell.past) {
                            to = cell.previous.end;
                        }
                        else {
                            to = cell.next.start;
                        }
                    }
                    break;
                default:
                    if (isScale){
                        throw new DayPilot.Exception("Invalid scale value: " + cellGroupBy);
                    }
                    else {
                        throw new DayPilot.Exception("Invalid groupBy value: " + cellGroupBy);
                    }
            }
            if (to.getTime() > endDate.getTime()) {
                to = endDate;
            }

            return to;
        };

        this._css = {};
        this._css.timeheadercol = "_timeheadercol";
        this._css.timeheadercolInner = "_timeheadercol_inner";
        this._css.resourcedivider = "_resourcedivider";
        this._css.eventFloat = "_event_float";
        this._css.eventFloatInner = "_event_float_inner";
        this._css.event = "_event";
        this._css.eventInner = "_event_inner";
        this._css.eventBar = "_event_bar";
        this._css.eventBarInner = "_event_bar_inner";
        this._css.eventDelete = "_event_delete";
        this._css.eventLine = "_event_line";
        this._css.eventMovingSource = "_event_moving_source";
        var cssNames = this._css;

        this._drawTimeHeaderCell2 = function(x, y) {

            var header = this.nav.timeHeader;

            var p = this.timeHeader[y][x];
            var isLast = x === this.timeHeader[y].length - 1;

            var isGroup = y < this.timeHeader.length - 1;
            var left = p.left;
            var width = p.width;

            var headerDim = dim._timeHeader(y);
            var top = headerDim.top;
            var height = headerDim.height;

            var cell = createDiv();
            cell.style.position = "absolute";
            cell.style.top = top + "px";
            cell.style.left = left + "px";
            cell.style.width = width + "px";
            cell.style.height = height + "px";
            if (p.toolTip) {
                cell.title = p.toolTip;
            }

            cell.setAttribute("aria-hidden", "true");

            if (p.cssClass) {
                addClass(cell, p.cssClass);
            }

            cell.setAttribute("unselectable", "on");
            cell.style.KhtmlUserSelect = 'none';
            cell.style.MozUserSelect = 'none';
            cell.style.webkitUserSelect = 'none';

            cell.oncontextmenu = function() { return false; };
            cell.cell = {};
            cell.cell.start = p.start;
            cell.cell.end = p.end;
            cell.cell.level = y;
            cell.cell.th = p;
            cell.onclick = this._onTimeHeaderClick;
            cell.oncontextmenu = this._onTimeHeaderRightClick;

            DayPilot.rePassive(cell, DayPilot.touch.start, function(ev) {
                ev.stopPropagation();
            });

            cell.style.overflow = 'hidden';

            if (!calendar.timeHeaderTextWrappingEnabled) {
                cell.style.whiteSpace = "nowrap";
            }

            var inner = createDiv();
            inner.setAttribute("unselectable", "on");
            inner.innerHTML = calendar._xssTextHtml(p.text, p.innerHTML);
/*
            if (p.innerHTML) {
                inner.innerHTML = p.innerHTML;
            }
*/

            if (p.backColor) {
                inner.style.background = p.backColor;
            }

            if (p.fontColor) {
                inner.style.color = p.fontColor;
            }

            var cl = this._prefixCssClass(cssNames.timeheadercol);
            var cli = this._prefixCssClass(cssNames.timeheadercolInner);
            if (isGroup) {
                cl = this._prefixCssClass("_timeheadergroup");
                cli = this._prefixCssClass("_timeheadergroup_inner");
            }
            addClass(cell, cl);
            addClass(inner, cli);

            addClass(cell, calendar._prefixCssClass("_timeheader_cell"));
            addClass(inner, calendar._prefixCssClass("_timeheader_cell_inner"));

            if (isLast) {
                addClass(cell, calendar._prefixCssClass("_timeheader_cell_last"));
            }

            // prepare left and width from start, end
/*            createList(p.areas).forEach(function(area) {
                if (area.start) {
                    area.left = calendar.getPixels(new DayPilot.Date(area.start)).left - left;
                    if (area.end) {
                        area.width = calendar.getPixels(new DayPilot.Date(area.end)).left - area.left - left;
                    }
                }
            });*/

            (function domAdd() {

                if (typeof calendar.onBeforeTimeHeaderDomAdd !== "function" && typeof calendar.onBeforeTimeHeaderDomRemove !== "function") {
                    return;
                }

                var args = {};
                args.control = calendar;
                args.header = {};
                args.header.start = p.start;
                args.header.end = p.end;
                args.header.level = y;
                args.element = null;

                cell.domArgs = args;

                if (typeof calendar.onBeforeTimeHeaderDomAdd === "function") {

                    calendar.onBeforeTimeHeaderDomAdd(args);

                    var argsElement = args.element;
                    if (argsElement) {
                        inner.innerHTML = "";

                        var target = createDiv();
                        inner.appendChild(target);
                        args._targetElement = target;

                        var isReactComponent = isReactCmp(argsElement);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(argsElement, target);
                        }
                        else {
                            target.appendChild(argsElement);
                        }
                    }
                }

            })();

            cell.appendChild(inner);

            var areas = DayPilot.Areas.resolvePosition(p.areas, calendar, left, width);
            DayPilot.Areas.attach(cell, p, {"areas": areas});

            this._cache.timeHeader[x + "_" + y] = cell;
            this.elements.timeHeader.push(cell);

            header.appendChild(cell);
        };


        this._nowFindTimeHeaderCell = function() {
            var timeHeader = calendar.timeHeader;
            var y = timeHeader.length - 1;
            if (y < 0) {
                return null;
            }
            var row = timeHeader[y];
            var now = DayPilot.Date.now();
            for (var x = 0; x < row.length; x++) {
                var cell = row[x];
                if (cell.start <= now && now <= cell.end) {
                    return calendar._cache.timeHeader[x + "_" + y];
                }
            }
            return null;
        };

        this._nowCell = null;
        this._nowHighlightCell = function() {
            var className = calendar._prefixCssClass("_timeheader_cell_now");
            var cell = calendar._nowCell;
            var next = calendar._nowFindTimeHeaderCell();
            if (cell === next) {
                return;
            }
            removeClass(cell, className);
            addClass(next, className);
            calendar._nowCell = next;
        };

        this._nowTimeout = null;
        this._nowNext = function() {
            clearTimeout(calendar._nowTimeout);
            calendar._nowTimeout = setTimeout(function() {
                calendar._nowHighlightCell();
                calendar._nowNext();
            }, 5000);
        };

        this._nowDeactivate = function() {
            clearTimeout(calendar._nowTimeout);
        };

        this._nowStart = function() {
            clearTimeout(calendar._nowTimeout);
            if (!calendar.showCurrentTimeHeader) {
                return;
            }
            calendar._nowHighlightCell();
            calendar._nowNext();
        };

        // freeze ok
        this._updateRowHeights = function() {

            if (calendar._cellStacking) {
                cellstacking._calculateEventPositions();
                return;
            }

            var rowlist = calendar._rowlistMerged();
            rowlist.forEach(function(row) {
                var updated = row.getHeight() + row.marginBottom + row.marginTop;
                if (row.height !== updated) {
                    calendar._rowsDirty = true;
                }
                row.height = updated;
            });


            if (calendar._rowsDirty) {
                calendar._cache.drawArea = null;
            }

        };

        // freeze ok
        this._updateRowHeaderHeights = function() {

            var rowlist = calendar._rowlistMerged();

            rowlist.forEach(function(row) {
                // var row = this.rowlist[i];
                if (row.hidden) {
                    return;
                }

                var grid = calendar._gridInfo(row.grid);
                var header = grid.divHeader;
                if (!header) {
                    return;
                }

                var index = row.index;

                if (!header.rows[index]) {
                    return;
                }

                for (var c = 0; c < header.rows[index].cells.length; c++) {
                    var headerCell = header.rows[index].cells[c];
                    var cell = grid.rowlist[index].cells[c];

                    if (calendar._resHeaderDivBased && headerCell) {
                        headerCell.style.top = row.top + "px";
                    }

                    var newHeight = row.height;
                    if (cell.rowspan > 1) {
                        newHeight = cell.totalHeight();
                    }

                    if (headerCell && headerCell.firstChild && parseInt(headerCell.firstChild.style.height, 10) !== newHeight) {
                        headerCell.firstChild.style.height = newHeight + "px";
                    }
                }
            });

            if (calendar._resHeaderDivBased) {
                if (calendar.nav.resScrollSpace) {
                    calendar.nav.resScrollSpace.style.top = calendar._innerHeightTree + "px";
                }
            }

        };

        // TODO freeze
        this._drawSeparator = function(index) {
            var s = this.separators[index];


            // fix
            s.location = s.location || s.Location;
            s.color = s.color || s.Color;
            s.layer = s.layer || s.Layer;
            s.width = s.width || s.Width;
            s.opacity = s.opacity || s.Opacity;

            var time = new DayPilot.Date(s.location);
            var color = s.color;
            var width = s.width ? s.width : 1;
            var above = s.layer ? s.layer === 'AboveEvents' : false;
            var opacity = s.opacity ? s.opacity : 100;

            // check the start and end dates of the visible area
            if (time.getTime() < calendar._visibleStart().getTime()) {
                return;
            }
            if (time.getTime() >= calendar._visibleEnd().getTime()) {
                return;
            }

            var pixels = this.getPixels(time);

            // check if it's in the hidden area, don't show in that case
            if (pixels.cut) {
                return;
            }

            if (pixels.left < 0) {
                return;
            }
            if (pixels.left > calendar._getGridWidth()) {
                return;
            }

            var line = createDiv();
            line.style.width = width + 'px';
            line.style.height = calendar._innerHeightTree + 'px';
            line.style.position = 'absolute';
            line.style.left = (pixels.left - 1) + 'px';
            line.style.top = '0px';
            line.style.backgroundColor = color;
            line.style.opacity = opacity / 100;
            line.style.filter = "alpha(opacity=" + opacity + ")";

            line.className = calendar._prefixCssClass("_separator");
            if (s.cssClass) {
                line.className += " " + s.cssClass;
            }

            if (above) {
                this.divSeparatorsAbove.appendChild(line);
            }
            else {
                this.divSeparators.appendChild(line);
            }

            this.elements.separators.push(line);
        };

        this._onCrosshairMouseDown = function(ev) {
            return; // temp
        };

        this._onMaindDblClick = function(ev) {
            if (calendar.timeRangeDoubleClickHandling === 'Disabled') {
                return false;
            }

            if (DayPilotScheduler._timeRangeTimeout) {
                clearTimeout(DayPilotScheduler._timeRangeTimeout);
                DayPilotScheduler._timeRangeTimeout = null;
            }

            var range = {};

            // make sure that coordinates are set
/*
            if (!calendar.coords) {
                var ref = calendar._maind;
                calendar.coords = DayPilot.mo3(ref, ev);
            }
*/
            calendar._updateCoords(ev);

            ev.stopPropagation && ev.stopPropagation();
            ev.cancelBubble = true;

            // only process left and right button outside of selection
            if (calendar._isWithinRange(calendar.coords)) {
                var sel = calendar._getSelection(calendar._rangeHold);
                calendar._timeRangeDoubleClickDispatch(sel.start, sel.end, sel.resource);
            }
            else {
                DayPilotScheduler._range = calendar._rangeFromCoords();
                if (DayPilotScheduler._range) {
                    DayPilotScheduler._rangeCalendar = calendar;
                    var sel = calendar._getSelection(DayPilotScheduler._range);
                    calendar._timeRangeDoubleClickDispatch(sel.start, sel.end, sel.resource);
                    calendar._rangeHold = DayPilotScheduler._range;
                }
            }

            // rangeHold remains unchanged - double-clicking an existing selection doesn't cancel it
            /*
            DayPilotScheduler._rangeHold = DayPilotScheduler._range;

            */

            // range must be cleared (stops active drag and drop mode)
            DayPilotScheduler._range = null;

        };

        // handles:
        // - TimeRangeSelected
        this._onMaindMouseDown = function(ev) {

            if (DpGlobal.touch.start || DpGlobal.touch.active) {
                return;
            }

            if (DayPilotScheduler._timeRangeTimeout && false) {
                clearTimeout(DayPilotScheduler._timeRangeTimeout);
                DayPilotScheduler._timeRangeTimeout = null;
            }

            calendar._crosshairHideFull();
            calendar._stopScroll();

            // make sure that coordinates are set
            calendar._updateCoords(ev);

            if (DayPilotScheduler._rectangleSelect) {
                return false;
            }

            var button = mouseButton(ev);

            // cancel all additional mouse down events, the first mouse up will be used when resolving the selection
            if (calendar._dragInProgress()) {
                return false;
            }

            if (button.middle || (button.right && calendar._isWithinRange(calendar.coords))) {
                return false;
            }

            var inRange = calendar._isWithinRange(calendar.coords);
            if (inRange) {
                return false;
            }

            var buttonAsString = button.left ? "left" : (button.right ? "right" : (button.middle ? "middle" : "unknown"));

            calendar._rangeButton = buttonAsString;

            var ctrl = ev.ctrlKey;
            var meta = ev.metaKey;
            var shift = ev.shiftKey;
            var ctrlOrMeta = ctrl || meta;

            var args = {};
            args.action = "None";
            // if (calendar.multiSelectRectangle !== "Disabled" && shift) {
            if (resolved._rectangleSelectMode() !== "Disabled" && shift) {
                args.action = "RectangleSelect";
            }
            else if (calendar.timeRangeSelectedHandling !== 'Disabled') {
                args.action = "TimeRangeSelect";
            }
            args.shift = shift;
            args.ctrl = shift;
            args.meta = meta;
            args.originalEvent = ev;
            args.button = buttonAsString;
            args.preventDefault = function() {
                args.action = "None";
            };

            if (typeof calendar.onGridMouseDown === "function") {
                calendar.onGridMouseDown(args);
            }

            if (args.action === "None") {
                if (typeof DayPilot.Menu !== "undefined") {
                    DayPilot.Menu.hide({"calendar": calendar});
                }
                ev.preventDefault();
                ev.stopPropagation();
                return false;
            }

            if (args.action === "RectangleSelect") {
                var rect = {};
                rect.start = calendar.coords;
                rect.calendar = calendar;

                DayPilotScheduler._rectangleSelect = rect;
                return false;
            }

            if (calendar.allowMultiRange && !ctrlOrMeta) {
                mr.clear();
            }

            // var i = calendar._getRow(calendar.coords.y, calendar.coords.grid).i;
            var row = calendar._getRow(calendar.coords.y, calendar.coords.grid).element;
            // var row = calendar.rowlist[i];
            if (row.isNewRow) {
                return false;
            }

            DayPilotScheduler._range = calendar._rangeFromCoords();
            if (DayPilotScheduler._range) {
                DayPilotScheduler._range.ctrl = ctrlOrMeta;
                DayPilotScheduler._rangeCalendar = calendar;
            }

            return false; // prevent FF3 bug (?), dragging is otherwise activated and DayPilot.mo2 gives incorrect results
        };

        // creates a single cell range selection at the current position (calendar.coords)
        this._rangeFromCoords = function() {

            var range = {};

            var cx = calendar._getItlineCellFromPixels(calendar.coords.x).x;
            var time = calendar.getDate(calendar.coords.x, true);

            range.start = {
                y: calendar._getRow(calendar.coords.y, calendar.coords.grid).i,
                x: cx,
                "grid": calendar.coords.grid,
                "time": time
            };

            range.end = {
                x: cx,
                "time": time
            };

            if (calendar._isRowDisabled(calendar._getRow(calendar.coords.y, calendar.coords.grid).i, calendar.coords.grid)) {
                return null;
            }

            range.calendar = calendar;
            calendar._drawRange(range);

            return range;
        };

        this._doEventResizing = function() {
            calendar._updateResizingShadow();

            var shadow = DayPilotScheduler._resizingShadow;
            var ev = DayPilotScheduler._resizing;

            (function() {

                var last = calendar._lastEventResizing;

                var original = {
                    "start": shadow.start,
                    "end": calendar._adjustEndOut(shadow.end)
                };
                shadow.original = original;


                var resizing = DayPilotScheduler._resizing.dpBorder === "left" ? "start" : "end";

                // don't fire the event if there is no change in input values
                var so = shadow.original;

                // if (so && last && last.start === so.start && last.end === calendar._adjustEndOut(so.end)) {
                // so.end already adjusted
                if (so && last && last.start === so.start && last.end === so.end) {
                    return;
                }

                mre.clear();
                mre._calculate();

                if (last) {
                    removeClass(shadow, last.cssClass);
                    shadow.firstChild.innerHTML = "";
                }

                var rowIndex = ev.event.part.dayIndex;
                var row = calendar.rowlist[rowIndex];

                var args = {};

                args.start = original.start;
                args.end = original.end;
                args.duration = new DayPilot.Duration(args.start, args.end);
                args.row = calendar._createRowObject(row);
                args.e = ev.event;
                args.allowed = true;
                args.resizing = resizing;
                args.what = resizing;
                args.anchor = args.what === "end" ? original.start : original.end;
                args.left = {};
                args.left.html = args.start.toString(calendar.eventResizingStartEndFormat, resolved._locale());
                args.left.enabled = calendar.eventResizingStartEndEnabled;
                args.left.space = 5;
                args.left.width = null;
                args.left.height = calendar.eventHeight;
                args.right = {};
                args.right.html = args.end.toString(calendar.eventResizingStartEndFormat, resolved._locale());
                args.right.enabled = calendar.eventResizingStartEndEnabled;
                args.right.space = 5;
                args.right.width = null;
                args.right.height = calendar.eventHeight;
                args.cssClass = null;
                args.html = null;
                args.overlapping = args.row.events.forRange(args.start, args.end).filter(function(e) { return !calendar._isSameEvent(e, args.e); }).length > 0;
                args.shift = calendar.coords.shift;
                args.ctrl = calendar.coords.ctrl;
                args.meta = calendar.coords.meta;
                args.alt = calendar.coords.alt;

                // args.multiresize = createList(mre.list);
                args.multiresize = mre._listCopy();

                var info = {};
                info.event = ev.event;
                info.start = args.start;
                info.end = args.end;
                args.multiresize.splice(0, 0, info);

                // calendar._lastEventResizing = { "start": args.start, "end": args.end };
                calendar._lastEventResizing = original;

                if (typeof calendar.onEventResizing === 'function') {
                    calendar.onEventResizing(args);
                }

                mre.list = createList(args.multiresize, true);
                mre.list.splice(0, 1);

                mre._draw();

                shadow.allowed = args.allowed;

                addClass(shadow, args.cssClass);

                if (args.html) {
                    shadow.firstChild.innerHTML = args.html;
                }

                // allow adjusting the start and end
                var start = args.start;
                var end = calendar._adjustEndIn(args.end);

                shadow.finalStart = start;
                shadow.finalEnd = end;

                // adjust start for viewType="Days"
                if (calendar.viewType === "Days") {
                    var rowOffset = row.start.getTime() - calendar._visibleStart().getTime();

                    start = start.addTime(-rowOffset);
                    end = end.addTime(-rowOffset);
                }


                var duration = DayPilot.DateUtil.diff(start, end);
                duration = atLeast(duration, 1);

                var useBox = resolved._useBox(duration);
                var snapToGrid = calendar.snapToGrid && calendar.snapToGridEventResizing;

                var left = snapToGrid ? calendar.getPixels(start).boxLeft : calendar.getPixels(start).left;
                var right = snapToGrid ? calendar.getPixels(end).boxRight : calendar.getPixels(end).left;
/*
                var left = useBox ? calendar.getPixels(start).boxLeft : calendar.getPixels(start).left;
                var right = useBox ? calendar.getPixels(end).boxRight : calendar.getPixels(end).left;
*/
                shadow.style.left = left + "px";
                shadow.style.width = (right - left) + "px";

                shadow.left = left;
                shadow.width = right - left;

                calendar._disabledShadow(DayPilotScheduler._resizingShadow, args);
                calendar._showShadowHover(DayPilotScheduler._resizingShadow, args);
            })();

        };

        this._onMaindMouseUp = function(ev) {

            if (DayPilotScheduler._rectangleSelect) {
                ev.cancelBubble = true;
                ev.preventDefault();

                DayPilotScheduler._gMouseUp(ev);

                return false;  // trying to prevent onmaindclick
            }
            calendar._moving = {};  // clear

            if (calendar._rangeHold) {
                // handles clicking an existing time range

                var button = mouseButton(ev);

                if (button.left) {
                    var range = calendar._rangeHold;

                    if (calendar._isWithinRange(calendar.coords)) {

                        var createTimeRangeClickDispatcher = function(range) {
                            return function() {
                                DayPilotScheduler._timeRangeTimeout = null;

                                var sel = calendar._getSelection(range);
                                if (!sel) {
                                    return;
                                }

                                var args = {};
                                args.start = sel.start;
                                args.end = sel.end;
                                args.resource = sel.resource;
                                args.preventDefault = function() {
                                    args.preventDefault.value = true;
                                };
                                if (typeof calendar.onTimeRangeClick === "function") {
                                    calendar.onTimeRangeClick(args);
                                }

                                if (!args.preventDefault.value) {
                                    if (typeof calendar.onTimeRangeClicked === "function") {
                                        calendar.onTimeRangeClicked(args);
                                    }
                                }
                            };
                        };

                        if (calendar.timeRangeClickHandling != "Disabled") {
                            if (calendar.timeRangeDoubleClickHandling === "Disabled") {
                                createTimeRangeClickDispatcher(range)();
                            }
                            else {
                                clearTimeout(DayPilotScheduler._timeRangeTimeout);
                                DayPilotScheduler._timeRangeTimeout = setTimeout(createTimeRangeClickDispatcher(range), calendar.doubleClickTimeout);
                            }
                        }
                    }

                }

            }

            var button = mouseButton(ev);
            if (button.right) {
                calendar._onMaindRightMouseUp(ev);
            }

        };


        this._onMaindRightMouseUp = function(ev) {
            if (calendar.timeRangeSelectedHandling === 'Disabled') {
                return;
            }

            if (calendar.timeRangeRightClickHandling === "Disabled") {
                return;
            }

            var range = DayPilotScheduler._range || calendar._rangeHold;
            if (!range) {
                // this can happen when trying to drag an event using right mouse button
                return;
            }

            var args = range.args;

            var row = calendar._getRow(calendar.coords.y, calendar.coords.grid);
            if (calendar._isRowDisabled(row.i)) {
                DayPilotScheduler._range = null;
                return;
            }


            //  ***************************************
            var selection = null;
            if (calendar._isWithinRange(calendar.coords)) {
                selection = calendar._getSelection(calendar._rangeHold);
            }
            else {
                selection = calendar._getSelection();
            }

            if (!selection) {
                DayPilotScheduler._range = null;
                return;
            }

            if (args && !args.ignoreDisabledCells && calendar._overDisabledCells(selection.start, selection.end, selection.resource)) {
                DayPilotScheduler._range = null;
                calendar.clearSelection();
                return;
            }

            selection.end = calendar._adjustEndOut(selection.end);

            var args = {};
            args.start = selection.start;
            args.end = selection.end;
            args.resource = selection.resource;

            args.ctrl = ev.ctrlKey;
            args.shift = ev.shiftKey;
            args.meta = ev.metaKey;

            args.preventDefault = function() {
                this.preventDefault.value = true;
            };

            if (typeof calendar.onTimeRangeRightClick === "function") {
                calendar.onTimeRangeRightClick(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            if (calendar.timeRangeRightClickHandling === "ContextMenu" && calendar.contextMenuSelection) {
                calendar.contextMenuSelection.show(selection);
            }

            if (typeof calendar.onTimeRangeRightClicked === "function") {
                calendar.onTimeRangeRightClicked(args);
            }


            //  ***************************************
        };

        this._dragInProgress = function() {
            var inProgress = DayPilotScheduler._resizing || DayPilotScheduler._moving || DayPilotScheduler._range || DayPilotScheduler._drag;
            if (inProgress) {
                return true;
            }

            // required for areas
            if (calendar._moving._movingStarted) {
                return true;
            }

            return false;
        };

        this.dragInProgress = function() {
            return calendar._dragInProgress();
        }

        this._updateCoords = function(ev) {
            // do not override the object if the coords are the same
            // it's used to store insideEvent (required in Firefox)
            // var grid = "main";
            var coords = DayPilot.mo3(calendar._maind, ev);
            coords = coords || {};
            coords.grid = "main";

            if (calendar._grids.top.enabled()) {
                var top = calendar._grids.top;
                var coordsTop = DayPilot.mo3(top.divCells, ev);
                if (coordsTop && coordsTop.y > 0 && coordsTop.y <= top.height) {
                    coords = coordsTop;
                    coords.grid = "top";
                }
            }

            if (calendar._grids.bottom.enabled()) {
                var bottom = calendar._grids.bottom;
                var coordsBottom = DayPilot.mo3(bottom.divCells, ev);
                if (coordsBottom && coordsBottom.y > 0 && coordsBottom.y <= bottom.height) {
                    coords = coordsBottom;
                    coords.grid = "bottom";
                }
            }

            coords.stamp = coords.grid + "_" + coords.x + "_" + coords.y;

            // coords object needs to stay the same unless values have changed
            if (!calendar.coords || calendar.coords.stamp !== coords.stamp) {
                calendar.coords = coords;
            }

        };

        this.getCoords = function() {

            if (!calendar.coords) {
                return null;
            }

            var result = {};
            result.x = calendar.coords.x;
            result.y = calendar.coords.y;
            result.grid = calendar.coords.grid;

            var row = calendar._getRow(result.y, result.grid).element;
            // var row = calendar._createRowObject(calendar.rowlist[i]);

            result.row = row;
            result.time = calendar.getDate(result.x, true);
            result.cell = calendar.cells.findByPixels(result.x, result.y, result.grid)[0];
            result.event = calendar.coords.insideEvent ? calendar.coords.insideEvent: null;
            result.eventOffset = null;

            if (result.event) {
                result.eventOffset = copyProps(calendar.eventOffset, {}, ["x", "y"]);
            }

            return result;
        };

        this._outRequired = true;

        // handles:
        // - EventMove (including external)
        // - EventResize
        // - TimeRangeSelected
        //
        // saves calendar.coords
        this._onMaindMouseMove = function(ev) {

            if (DpGlobal.touch.active) {
                return;
            }

            // DayPilotScheduler._activeCalendar = calendar; // required for moving
            var mousePos = DayPilot.mc(ev);

            // calendar.coords = DayPilot.mo3(calendar._maind, ev);
            calendar._updateCoords(ev);

            ev.insideMainD = true;
            calendar._outRequired = true;
            if (window.event && window.event.srcElement) {
                window.event.srcElement.inside = true;
            }

            if (calendar._moving._movingStarted) {
                var requiredDistance = 2;
                var distance = DayPilot.distance(calendar._moving._originalMouse, mousePos);

                if (distance > requiredDistance) {
                    copyProps(calendar._moving, DayPilotScheduler);
                    body().style.cursor = 'move';
                    calendar._moving = {};
                }
            }

            if (DayPilotScheduler._resizing && DayPilotScheduler._resizingEvent.calendar === calendar) {
                if (!DayPilotScheduler._resizing.event) {
                    DayPilotScheduler._resizing.event = DayPilotScheduler._resizingEvent;
                }
                calendar._mouseMoveUpdateResizing();
            }
            else if (DayPilotScheduler._movingEvent) {

                var srccal = DayPilotScheduler._movingEvent.calendar;
                var differentSource = srccal !== calendar;
                // fixing fast drag and drop between two scheduler
                if (differentSource && srccal) {
                    DayPilotScheduler._movingEvent.calendar._out();
                }

                DayPilotScheduler._movingEvent.part.external = differentSource;

                calendar._mouseMoveUpdateMoving();

            }
            else if (DayPilotScheduler._range && DayPilotScheduler._range.calendar === calendar) {
                DayPilotScheduler._range.moved = true;
                calendar._mouseMoveUpdateRange();
            }
            else if (linking.source) {
                var src = linking.source;
                linktools._drawShadow(src.coords, calendar.coords);
            }
            else if (DayPilotScheduler._rectangleSelect) {
                DayPilotScheduler._rectangleSelect.moved = true;

                // debounce
                clearTimeout(rectangle._drawTimeout);
                rectangle._drawTimeout = setTimeout(function() {
                    rectangle.draw();
                }, 0);
            }

            // always update, even during drag and drop
            if (calendar.crosshairType !== 'Disabled') {  // crosshair
                calendar._updateCrosshairPosition();
            }

            calendar._cellhover();

            var insideEvent = calendar.coords.insideEvent;

            // cell bubble
            if (calendar.cellBubble && calendar.coords && calendar.rowlist && calendar.rowlist.length > 0 && !insideEvent) {

                var x = calendar._getItlineCellFromPixels(calendar.coords.x).x;
                var y = calendar._getRow(calendar.coords.y).i;

                if (0 <= y && y < calendar.rowlist.length && 0 <= x && x < calendar.itline.length) {
                    var cell = {};
                    cell.calendar = calendar;
                    cell.start = calendar.itline[x].start;
                    cell.end = calendar.itline[x].end;
                    cell.resource = calendar.rowlist[y].id;
                    cell.toJSON = function() {
                        var json = {};
                        json.start = this.start;
                        json.end = this.end;
                        json.resource = this.resource;
                        return json;
                    };

                    calendar.cellBubble.showCell(cell);
                }
            }

            if (DayPilotScheduler._drag) {

                calendar._crosshairHideFull();
                if (DayPilotScheduler._gShadow) {
                    body().removeChild(DayPilotScheduler._gShadow);
                }
                DayPilotScheduler._gShadow = null;

                if (!DayPilotScheduler._movingShadow && calendar.coords && calendar.rowlist.length > 0) {
                    if (!DayPilotScheduler._movingEvent) { // can be null if the location is forbidden (first two rows in IE)

                        // disabled, this is the original object which can't be used for calculations
                        DayPilotScheduler._moving = DayPilotScheduler._drag._schedulerSourceEvent || {};

                        var eFromSrc = DayPilotScheduler._drag._schedulerSourceEvent ? DayPilotScheduler._drag._schedulerSourceEvent.event: null;
                        var event = eFromSrc || DayPilotScheduler._drag.event;

                        if (!event) {
                            //var now = new DayPilot.Date().getDatePart();

                            var ev = calendar._createEvFromDrag();

                            event = new DayPilot.Event(ev);

                            event.calendar = calendar;
                            // testing external
                            event.calendar = null;

                            // it's in seconds, convert to ticks
                            event.part.duration = DayPilotScheduler._drag.duration * 1000;

                            // mark as external
                            event.part.external = true;
                        }
                        else if (calendar !== event.calendar) { // source is another calendar
                            var srccal = event.calendar;
                            var originalEvent = event;
                            var newData = copyProps(event.data);
                            event = new DayPilot.Event(newData);
                            event.calendar = srccal;

                            event.part.duration = srccal._getEventDurationWithoutNonBusiness(originalEvent);
                            //event.calendar = calendar;

                            // mark as external
                            event.part.external = true;
                        }
                        else {
                            event.part.external = false;
                        }


                        if (!DayPilotScheduler._moving.event) {
                            DayPilotScheduler._moving.event = event; // required for accessing the source event during external drag and drop
                        }

                        DayPilotScheduler._movingEvent = event;

                        // experimental, allows eventMoveSkipNonBusiness with external drag and drop
                        // DayPilotScheduler._moveDragStart = event.data.start;

                    }
                    DayPilotScheduler._movingShadow = calendar._createShadow(DayPilotScheduler._movingEvent);
                }

                ev.cancelBubble = true;
            }

            var coords = { x: calendar.coords.x, y: calendar.coords.y, "grid": calendar.coords.grid };
            calendar._doAutoScroll(coords);

            // don't cancel the event bubbling here, it will hurt position detection used in DayPilot ContextMenu and DayPilot Bubble
            //ev.cancelBubble = true;
        };


        this._createEvFromDrag = function() {
            var now = calendar.itline[0].start;

            var ev;

            var data = DayPilotScheduler._drag._dragData;
            if (data) {
                ev = copyProps(data, {});
                ev.start = now;
                ev.end = now.addSeconds(DayPilotScheduler._drag.duration);
            }
            else {
                // backwards compatibility

                ev  = {
                    'id': DayPilotScheduler._drag.id,
                    'start': now,
                    'end': now.addSeconds(DayPilotScheduler._drag.duration),
                    'text': DayPilotScheduler._drag.text
                };

                var options = DayPilotScheduler._drag._dragOptions;

                if (options) {
                    var skip = ['duration', 'element', 'remove', 'id', 'text'];
                    for (var name in options) {
                        if (contains(skip, name)) {
                            continue;
                        }
                        ev[name] = options[name];
                    }
                }
            }

            return ev;
        };

        function invertedPct(value, max) {
            return 1 - value/max;
        }

        this._doAutoScroll = function(coords) {
            var gridName = coords.grid;

            var dragInProgress = DayPilotScheduler._moving || DayPilotScheduler._resizing || DayPilotScheduler._range || DayPilotScheduler._rectangleSelect;
            var autoscrollAlways = calendar.autoScroll === "Always";
            var autoscrollDrag = calendar.autoScroll === "Drag" && dragInProgress;

            var autoscrollEnabled = autoscrollAlways || autoscrollDrag;
            // var autoscrollHorizontalDisabled = calendar.cellWidthSpec === "Auto";
            var autoscrollHorizontalDisabled = false;
            var autoscrollVerticalDisabled = DayPilotScheduler._resizing || DayPilotScheduler._range || gridName !== "main";

            // autoscroll
            if (autoscrollEnabled) {

                var scrollDiv = calendar.nav.scroll;
                // var coords = { x: calendar.coords.x, y: calendar.coords.y };
                coords.x -= scrollDiv.scrollLeft;
                coords.x += infitools._shiftX;
                coords.y -= scrollDiv.scrollTop;

                var width = scrollDiv.clientWidth;
                var height = scrollDiv.clientHeight;

                var border = 30;

                var left = coords.x < border ? coords.x : 0;
                var right = width - coords.x < border ? width - coords.x : 0;

                // var top = coords.y < border ? coords.y : 0;
                var topOffset = calendar._grids.top.height;
                var yAdjusted = coords.y - topOffset;
                var top = yAdjusted < border && yAdjusted > 0 ? yAdjusted : 0;

                var heightAdjusted = height - calendar._grids.bottom.height - calendar._grids.top.height;
                var bottom = heightAdjusted - yAdjusted < border ? height - coords.y : 0;

                var x = 0;
                var y = 0;

                var speed = 50;

                if (left) {
                    x = -speed*invertedPct(left, border);
                }
                if (right) {
                    x = speed*invertedPct(right, border);
                }

                if (top) {
                    y = -speed*invertedPct(top, border)/2;
                }
                if (bottom) {
                    y = speed*invertedPct(top, border)/2;
                }

                if (autoscrollVerticalDisabled) {
                    y = 0;
                }

                if (autoscrollHorizontalDisabled) {
                    x = 0;
                }

                if (x || y) {
                    calendar._asTimeout = setTimeout(function() {
                        calendar._startScroll(x, y);
                        // calendar._doAutoScroll(calendar.coords);
                    }, 200);
                }
                else {
                    clearTimeout(calendar._asTimeout);
                    calendar._stopScroll();
                }

/*                if (x || y) {
                    calendar._startScroll(x, y);
                }
                else {
                    calendar._stopScroll();
                }*/
            }

        };

        this._mouseMoveUpdateRange = function() {
            var range = DayPilotScheduler._range;

            var x = calendar._getItlineCellFromPixels(calendar.coords.x).x;
            var time = calendar.getDate(calendar.coords.x, true);
            range.end = {
                x: x,
                "time": time
            };

            calendar._drawRange(range);
        };


        // external because of autoscroll
        this._mouseMoveUpdateResizing = function() {
            if (!DayPilotScheduler._resizingShadow) {
                DayPilotScheduler._resizingShadow = calendar._createShadow(DayPilotScheduler._resizing);
            }
            calendar._resizeShadow();
        };

        this._mouseMoveUpdateMoving = function() {
            if (DayPilotScheduler._movingShadow && DayPilotScheduler._movingShadow.calendar !== calendar && DayPilotScheduler._movingShadow.calendar) {
                DayPilotScheduler._movingShadow.calendar._out();
                DayPilotScheduler._movingShadow.calendar = null;
                deleteElement(DayPilotScheduler._movingShadow);
                DayPilotScheduler._movingShadow = null;
            }
            if (!DayPilotScheduler._movingShadow) {
                addClass(DayPilotScheduler._moving, calendar._prefixCssClass(cssNames.eventMovingSource));

                var mv = DayPilotScheduler._movingEvent;
                DayPilotScheduler._movingShadow = calendar._createShadow(mv);
            }

            calendar._expandParent();
            calendar._moveShadow();
        };

        this._rectangle = {};
        var rectangle = this._rectangle;

        rectangle.start = function() {
            var rect = {};
            rect.start = calendar.coords;
            rect.calendar = calendar;

            DayPilotScheduler._rectangleSelect = rect;
        };

        rectangle.draw = function() {
            var rect = DayPilotScheduler._rectangleSelect;

            if (!rect) {
                return;
            }

            var start = DayPilotScheduler._rectangleSelect.start;
            var end = calendar.coords;

            rectangle.clear();

            var original = {
                "x": rect.x,
                "y": rect.y,
                "width": rect.width,
                "height": rect.height
            };

            var left, top, width, height;

            var startX, startY, endX, endY;
            (function rectifyStartEnd() {
                startX = Math.min(start.x, end.x);
                endX = Math.max(start.x, end.x);
                if (resolved._rectangleSelectMode() === "Free") {
                    startY = Math.min(start.y, end.y);
                    endY = Math.max(start.y, end.y);
                }
                else if (resolved._rectangleSelectMode() === "Row") {
                    startY = start.y;  // the original row, end.y not used here
                    endY = start.y;
                }
            })();

            if (resolved._rectangleSelectMode() === "Free") {
                left = startX;
                top = startY;
                width = endX - startX;
                height = endY - startY;
            }
            else if (resolved._rectangleSelectMode() === "Row") {
                var y = calendar._getRow(startY).i;
                var row = calendar.rowlist[y];

                top = row.top;
                height = row.height;

                var snapToGrid = calendar.snapToGrid && calendar.snapToGridRectangleSelecting;
                if (snapToGrid) {
                    var startCell = calendar._getItlineCellFromPixels(startX).cell;
                    left = startCell.left;

                    var endCell = calendar._getItlineCellFromPixels(endX).cell;
                    width = endCell.left + endCell.width - left;
                }
                else {
                    left = startX;
                    width = endX - startX;
                }

            }
            else {
                throw new DayPilot.Exception("Invalid DayPilot.Scheduler.rectangleSelectMode value: " + calendar.rectangleSelectMode);
            }

            var div = utilDiv(calendar.divRectangle, left, top, width, height);
            div.style.boxSizing = "border-box";
            div.className = calendar._prefixCssClass("_selectionrectangle");

            rect.x = left;
            rect.y = top;
            rect.width = width;
            rect.height = height;

            if (rect.x !== original.x || rect.y !== original.y || rect.width !== original.width || rect.height !== original.height) {  // change detected
                if (typeof calendar.onRectangleEventSelecting === "function" || typeof calendar.onRectangleSelecting === "function") {
                    var yStart = calendar._getRow(rect.y).i;
                    var yEnd = calendar._getRow(rect.y + rect.height).i;
                    var area = {"start": { "y": yStart}, "end" : { "y": yEnd}};
                    var resources = calendar._getAreaResources(area);

                    var args = {};
                    args.events = viewport._eventsInRectangle(rect.x, rect.y, rect.width, rect.height).map(function(item) {return item.event; });
                    args.start = calendar.getDate(rect.x, true);
                    args.end = calendar.getDate(rect.x + rect.width, true);
                    args.resources = resources;
                    args.visible = true;

                    if (typeof calendar.onRectangleEventSelecting === "function") {
                        calendar.onRectangleEventSelecting(args);
                    }

                    if (typeof calendar.onRectangleSelecting === "function") {
                        calendar.onRectangleSelecting(args);
                    }

                    if (!args.visible) {
                        div.style.display = "none";
                    }
                }
            }

        };

        rectangle.clear = function() {
            // clear
            calendar.divRectangle.innerHTML = '';
            calendar.elements.rectangle = [];
        };

        this._getCurrentCell = function() {
            if (!calendar.coords) {
                return null;
            }

            if (!calendar._hasRows()) {
                return null;
            }

            if (!calendar.itline || calendar.itline.length === 0) {
                return null;
            }

            var x = calendar._getItlineCellFromPixels(calendar.coords.x).x;
            var row = calendar._getRow(calendar.coords.y, calendar.coords.grid).element;
            if (!row) {
                return null;
            }
            var y = row.index;

            var cells = calendar.cells.findXy(x, y, calendar.coords.grid);
            return cells[0];
        };

        this._cellhover = function() {

            var cell = this._getCurrentCell();

            if (this.hover.cell) {
                if (this.hover.cell.x === cell.x && this.hover.cell.y === cell.y && this.hover.cell.grid === cell.grid) {
                    return;
                }
                this._cellhoverout();
            }

            this.hover.cell = cell;

            var args = {};
            args.cell = cell;

            if (typeof this.onCellMouseOver === 'function') {
                this.onCellMouseOver(args);
            }

            if (typeof this.onCellMouseEnter === 'function') {
                this.onCellMouseEnter(args);
            }

        };

        this._cellhoverout = function() {
            if (!this.hover.cell) {
                return;
            }

            var args = {};
            args.cell = this.hover.cell;

            if (typeof this.onCellMouseOut === 'function') {
                this.onCellMouseOut(args);
            }
            if (typeof this.onCellMouseLeave === 'function') {
                this.onCellMouseLeave(args);
            }
            this.hover.cell = null;
        };

        this.hover = {};

        this._updateCrosshairPosition = function() {
            var coords = calendar._getCrosshairCoords();
            if (!coords) {
                return;
            }
            var ch = calendar.hover.crosshair;
            if (ch) {
                if (ch.x === coords.x && ch.y === coords.y && ch.grid === coords.grid && ch.thX === coords.thX) {
                    return;
                }
            }
            calendar.hover.crosshair = coords;
            this._crosshair();
        };

        this._getCrosshairCoords = function() {
            if (!calendar.coords) {
                return null;
            }

            if (!calendar._hasRows()) {
                return null;
            }

            if (!calendar.itline || calendar.itline.length === 0) {
                return null;
            }

            var row = calendar._getRow(calendar.coords.y, calendar.coords.grid).element;
            if (!row) {
                return null;
            }
            var y = row.index;

            var x = null;
            var itc = calendar._getItlineCellFromPixels(calendar.coords.x);
            if (itc) {
                x = itc.x;
            }

            var crosshairTopY = calendar._crosshairTopY();

            var thcX = null;
            var thc = calendar._getTimeHeaderCellForY(crosshairTopY, calendar.coords.x);
            if (thc) {
                thcX = thc.x;
            }

            return {
                "x": x,
                "thX": thcX,
                "y": y,
                "grid": calendar.coords.grid
            };

        };

        this._crosshairHideFull = function() {
            this._grids.top.divCrosshair.innerHTML = '';
            this._grids.main.divCrosshair.innerHTML = '';
            this._grids.bottom.divCrosshair.innerHTML = '';
            this._crosshairVertical = null;
            this._crosshairHorizontal = null;
        };

        this._crosshairHide = function() {
            this._crosshairHideFull();

            calendar.hover.crosshair = null;

            if (this._crosshairTop && this._crosshairTop.parentNode) {
                this._crosshairTop.parentNode.removeChild(this._crosshairTop);
                this._crosshairTop = null;
            }

            if (this._crosshairLeft) {
                for (var i = 0; i < this._crosshairLeft.length; i++) {
                    var ch = this._crosshairLeft[i];
                    if (ch.parentNode) {
                        ch.parentNode.removeChild(ch);
                    }
                }
                this._crosshairLeft = null;
            }

            this._crosshairLastX = -1;
            this._crosshairLastY = -1;
            this._crosshairLastGrid = null;
        };

        this._crosshairTopY = function() {
            var crosshairTopY = this.timeHeader ? this.timeHeader.length - 1 : 1;
            if (typeof calendar.crosshairTimeHeaderLevel === "number") {
                if (calendar.crosshairTimeHeaderLevel < crosshairTopY && calendar.crosshairTimeHeaderLevel >= 0) {
                    crosshairTopY = calendar.crosshairTimeHeaderLevel;
                }
            }
            return crosshairTopY;
        };

        // TODO freeze divCrosshair
        this._crosshair = function() {

            if (!calendar.coords) {
                return;
            }

            if (!calendar._hasRows()) {
                return;
            }

            var row = calendar._getRow(calendar.coords.y, calendar.coords.grid).element;
            if (!row) {
                return;
            }
            var x = calendar._getItlineCellFromPixels(calendar.coords.x).x;
            var y = row.index;
            var gridName = row.grid;
            var grid = calendar._gridInfo(gridName);

            var gridNames = ["top", "main", "bottom"];
            // var grids = gridNames.map(function(name) { return calendar._grids[name];});
            // var otherGrids = grids.filter(function(g) {return g !== "gridName";}).map(function(name) { return calendar._grids[name];});

            var type = this.crosshairType;

            if (!this._crosshairVertical) {
                this._crosshairVertical = {};
            }
            function drawVertical(gridName, itc) {
                var grid = calendar._grids[gridName];
                var height = grid.height;
                var left = itc.left;
                var line = calendar._crosshairVertical[gridName];
                if (!line) {
                    var line = createDiv();
                    // line.style.height = calendar._innerHeightTree + 'px';
                    line.style.height = height + 'px';
                    line.style.position = 'absolute';
                    line.style.top = '0px';
                    line.className = calendar._prefixCssClass("_crosshair_vertical");
                    calendar._crosshairVertical[gridName] = line;
                    grid.divCrosshair.appendChild(line);
                }
                line.style.left = left + 'px';
                line.style.width = itc.width + 'px';
            }

            if (type === 'Full') {
                // vertical
                var itc = this.itline[x];

                gridNames.forEach(function(g) {
                   drawVertical(g, itc);
                });

                // horizontal
                var top = row.top;
                var height = row.height;
                var width = calendar._getGridWidth();

                var line = calendar._crosshairHorizontal;
                if (line && line.parentNode && calendar._crosshairLastGrid !== gridName) {
                    line.parentNode.removeChild(line);
                    line = null;
                }
                if (!line) {
                    var line = createDiv();
                    line.style.width = width + 'px';
                    line.style.height = height + 'px';
                    line.style.position = 'absolute';
                    line.style.top = top + 'px';
                    line.style.left = '0px';
                    line.className = calendar._prefixCssClass("_crosshair_horizontal");
                    calendar._crosshairHorizontal = line;
                    grid.divCrosshair.appendChild(line);
                }

                line.style.top = top + 'px';
                line.style.height = height + 'px';

            }

            var crosshairTopY = calendar._crosshairTopY();

            var thc = calendar._getTimeHeaderCellForY(crosshairTopY, calendar.coords.x);

            if (thc && calendar._crosshairLastX !== thc.x) {
                if (calendar._crosshairTop && this._crosshairTop.parentNode) {
                    calendar._crosshairTop.parentNode.removeChild(calendar._crosshairTop);
                    calendar._crosshairTop = null;
                }

                var height = dim._timeHeader(crosshairTopY).height;

                // top
                var line = createDiv();
                line.style.width = thc.cell.width + "px";
                line.style.height = height + "px";
                line.style.left = '0px';
                line.style.top = '0px';
                line.style.position = 'absolute';
                line.className = calendar._prefixCssClass("_crosshair_top");

                calendar._crosshairTop = line;
                var north = this.divNorth;
                var lastHeader = crosshairTopY;
                if (calendar.nav.timeHeader) {
                    calendar._cache.timeHeader[thc.x + "_" + lastHeader].appendChild(line);
                }
                else {
                    if (north && north.firstChild.rows[lastHeader].cells[x]) {
                        north.firstChild.rows[lastHeader].cells[x].firstChild.appendChild(line);
                    }
                }
            }

            if (calendar._crosshairLastY !== y || calendar._crosshairLastGrid !== gridName) {
                if (calendar._crosshairLeft) {
                    for (var i = 0; i < calendar._crosshairLeft.length; i++) {
                        var ch = calendar._crosshairLeft[i];
                        if (ch.parentNode) {
                            ch.parentNode.removeChild(ch);
                        }
                    }
                    calendar._crosshairLeft = null;
                }

                // left
                var columns = this.rowHeaderCols ? this.rowHeaderCols.length : 1;

                calendar._crosshairLeft = [];
                // if (grid.divHeader.rows[y]) {
                //     for (var i = 0; i < grid.divHeader.rows[y].cells.length; i++) {
                if (grid.rowlist[y]) {
                    for (var i = 0; i < grid.rowlist[y].cells.length; i++) {

                        var cell = grid.rowlist[y].cells[i];
                        var ref = cell.refCell;
                        var height = row.height;
                        var targetY = y;
                        if (ref) {
                            height = ref.row.split.totalHeight();
                            targetY = ref.y;
                        }
                        else if (cell.rowspan > 1) {
                            height = cell.totalHeight();
                        }

                        var divExists = grid.divHeader.rows[targetY] && grid.divHeader.rows[targetY].cells[i];
                        if (!divExists) {
                            continue;
                        }

                        var width = calendar._getOuterRowHeaderWidth();

                        var line = createDiv();
                        line.style.width = width + "px";
                        line.style.height = height + "px";
                        line.style.left = '0px';
                        line.style.top = '0px';
                        line.style.position = 'absolute';
                        line.className = calendar._prefixCssClass("_crosshair_left");

                        calendar._crosshairLeft.push(line);
                        grid.divHeader.rows[targetY].cells[i].firstChild.appendChild(line);
                    }
                }
            }

            if (thc) {
                calendar._crosshairLastX = thc.x;
            }
            calendar._crosshairLastY = y;
            calendar._crosshairLastGrid = gridName;
        };

        this._getTimeHeaderCellForY = function(y, pixels) {
            var row = calendar.timeHeader[y];
            if (!row) {
                return null;
            }
            for (var i = 0; i < row.length; i++) {
                var cell = row[i];
                if (pixels >= cell.left && pixels < cell.left + cell.width) {
                    var result = {};
                    result.cell = cell;
                    result.x = i;
                    return result;
                }
            }
            return null;
        };

        this._getTimeHeaderCell = function(pixels) {
            return calendar._getTimeHeaderCellForY(calendar.timeHeader.length - 1, pixels);
        };

        this._onMaindRightClick = function(ev) {
            // moved to onMaindRightMouseUp()

            ev.cancelBubble = true;

            if (!calendar.allowDefaultContextMenu) {
                return false;
            }
        };

        this._isWithinRange = function(coords) {
            var range = calendar._rangeHold;

            if (!range || !range.start || !range.end) {
                return false;
            }

            range = range._customized ? range._customized : range;

            var gridName = range.start.grid;
            var row = this._getRowByIndex(range.start.y, range.start.grid);

            var gridTop = 0;
            if (gridName ==="main") {
                gridTop = calendar._grids.top.height;
            }

            var leftToRight = range.start.time.getTime() < range.end.time.getTime();

            var start = leftToRight ? range.start.time: range.end.time;
            var end = leftToRight ? range.end.time : range.start.time;
            var rangeLeft = calendar.getPixels(start).left;
            var rangeRight = calendar.getPixels(end).left;
            // var rangeLeft = (leftToRight ? range.start.x : range.end.x) * this.cellWidth;
            // var rangeRight = (leftToRight ? range.end.x : range.start.x) * this.cellWidth + this.cellWidth;
            var rangeTop = row.top + gridTop;
            var rangeBottom = row.bottom + gridTop;

            var withinHorizontally = coords.x >= rangeLeft && coords.x <= rangeRight;
            var withinVertically = coords.y >= rangeTop && coords.y <= rangeBottom;
            var withinGrid = coords.grid === range.start.grid;

            if (withinHorizontally && withinVertically && withinGrid) {
                return true;
            }

            return false;
        };

        this._drawRange = function(range, options) {

            var range = range || DayPilotScheduler._range;

            if (!range) {
                return;
            }

            if (range.calendar !== calendar) {
                return;
            }

            if (DayPilotScheduler._editing) {
                DayPilotScheduler._editing.blur();
            }

            options = options || {};
            var justDraw = options.justDraw;
            var forceSnap = range.forceSnap;

            var snapToGrid = calendar.snapToGrid && calendar.snapToGridTimeRangeSelecting;
            if (forceSnap) {
                snapToGrid = true;
            }

            var grid = calendar._gridInfo(range.start.grid);
            var rowlist = grid.rowlist;

            (function () {

                var natural = range.end.time >= range.start.time;
                var startX = natural ? range.start.x : range.end.x;
                var endX = (natural ? range.end.x : range.start.x);
                var y = range.start.y;
                var row = rowlist[y];

                if (!row) {
                    return;
                }

                if (row.hidden) {
                    return;
                }

                var start = calendar.itline[startX];
                var end = calendar.itline[endX];

                var last = calendar._lastRange;
                var startDateTime = start.start.addTime(row.data.offset);
                var endDateTime = end.end.addTime(row.data.offset);

                if (!snapToGrid) {
                    if (natural) {
                        startDateTime = range.start.time;
                        endDateTime = range.end.time;
                    }
                    else {
                        startDateTime = range.end.time;
                        endDateTime = range.start.time;
                    }
                }

                // don't fire the event if there is no change
                if (!justDraw && last && last.start.getTime() === startDateTime.getTime() && last.rawend.getTime() === endDateTime.getTime() && last.resource === rowlist[y].id) {
                    return;
                }

                var original = {
                    "start": startDateTime,
                    "end": calendar._adjustEndOut(endDateTime),
                    "rawend": endDateTime,
                    "resource": rowlist[y].id
                };

                var args = {};
                args.anchor = natural ? original.start : original.end;
                args.start = original.start;
                args.end = original.end;
                args.duration = new DayPilot.Duration(startDateTime, endDateTime);
                args.resource = rowlist[y].id;
                args.row = calendar._createRowObject(row);
                args.allowed = true;
                args.control = calendar;
                args.ignoreDisabledCells = false;
                args.left = {};
                args.left.html = args.start.toString(calendar.timeRangeSelectingStartEndFormat, resolved._locale());
                args.left.enabled = calendar.timeRangeSelectingStartEndEnabled;
                args.left.space = 5;
                args.left.width = null;
                args.left.height = calendar.eventHeight;
                args.right = {};
                args.right.html = args.end.toString(calendar.timeRangeSelectingStartEndFormat, resolved._locale());
                args.right.enabled = calendar.timeRangeSelectingStartEndEnabled;
                args.right.space = 5;
                args.right.width = null;
                args.right.height = calendar.eventHeight;
                args.overlapping = args.row.events.forRange(startDateTime, endDateTime).length > 0;
                args.html = null;
                args.cssClass = null;
                args.button = calendar._rangeButton;

                // doesn't work for adjustments
                // calendar._lastRange = args;

                calendar._lastRange = original;

                if (typeof calendar.onTimeRangeSelecting === 'function' && !justDraw) {
                    calendar.onTimeRangeSelecting(args);

                    // make args.resource readonly
                    args.resource = original.resource;
                }

                args.end = calendar._adjustEndIn(args.end);

                // save for ontimerangeselected
                range.args = args;

                var copy = calendar._copyRange(range);
                calendar._updateRange(copy, args.start, args.end);

                var cell = draw(copy, args);

                if (args.html) {
                    cell.firstChild.innerHTML = args.html;
                }

                if (args.cssClass) {
                    addClass(cell, args.cssClass);
                }

                calendar._disabledShadow(cell, args);

                range._customized = copy;
                range.disabled = !args.allowed;

                calendar._showShadowHover(cell, args);

            })();


            function draw(range, args) {
                var natural = range.end.time > range.start.time;
                var left, right;
                var startTime, endTime;

                var y = range.start.y;

                var timesAvailable = range.start.time && range.end.time;

                if (snapToGrid || !timesAvailable) {
                    var startX = natural ? range.start.x : range.end.x;
                    var endX = (natural ? range.end.x : range.start.x);

                    var start = calendar.itline[startX];
                    var end = calendar.itline[endX];

                    // startTime = start.start;
                    // endTime = end.end;

                    left = start.left;
                    right = end.left + end.width;
                }
                else {
                    if (natural) {
                        startTime = range.start.time;
                        endTime = range.end.time;
                    }
                    else {
                        startTime = range.end.time;
                        endTime = range.start.time;
                    }

                    left = calendar.getPixels(startTime).left;
                    right = calendar.getPixels(endTime).left;

                }

                var width = right - left;

                var cell = calendar.elements.range2;

                if (!cell) {
                    cell = createDiv();
                    cell.style.position = 'absolute';
                    cell.setAttribute("unselectable", "on");


                    var inner = createDiv();
                    inner.className = calendar._prefixCssClass("_shadow_inner");
                    cell.appendChild(inner);

                    // calendar.divRange.appendChild(cell);
                    grid.divShadow.appendChild(cell);
                }

                if (cell.grid !== range.start.grid) {
                    cell.parentNode.removeChild(cell);
                    grid.divShadow.appendChild(cell);
                }

                // reset required
                cell.className = calendar._prefixCssClass("_shadow");
                cell.firstChild.innerHTML = "";

                cell.style.left = (left) + "px";
                cell.style.top = rowlist[y].top + "px";
                cell.style.width = width + "px";
                cell.style.height = (rowlist[y].height - 1) + "px";

                cell.calendar = calendar;
                cell.grid = range.start.grid;

                calendar.elements.range2 = cell;

                (function checkOverlap() {
                    cell.overlapping = false;

                    var row = rowlist[y];
                    calendar._overlappingShadow(cell, row, left, width, null);

                    // required for days view
                    var start = natural ? range.start.time : range.end.time;
                    var end = natural ? range.end.time : range.start.time;

                    if (!args.ignoreDisabledCells) {
                        calendar._checkDisabledCells(cell, start, end, row.id);
                    }

                })();

                return cell;
            }


        };

        this._copyRange = function(range) {
            return {
                "start": {
                    "x": range.start.x,
                    "y": range.start.y,
                    "time": range.start.time,
                    "grid": range.start.grid
                },
                "end": {
                    "x": range.end.x,
                    "time": range.end.time
                },
                "disabled": range.disabled,
                "calendar": range.calendar,
                "args": range.args,
                "forceSnap": range.forceSnap
            }
        };

        // backwards compatibility
        this.range = {};
        this.range.all = function() {
            // DayPilot.Scheduler.range.all(): Please use DayPilot.Scheduler.multirange.get() instead.
            return calendar.multirange.get();
        };

        this.multirange = {};
        this.multirange.get = function() {
            return mr.get(true);
        };

        this.multirange.add = function(sel) {
            if (!sel) {
                throw new DayPilot.Exception("Range not specified");
            }
            if (!sel.start || !sel.end || !sel.resource) {
                throw new DayPilot.Exception("Invalid range specified");
            }

            if (createList(mr.list).isEmpty()) {
                var defsel = calendar._getSelection();
                if (defsel) {
                    var range = calendar._createRangeFromSelection(defsel.start, defsel.end, defsel.resource);
                    calendar._multirange.add(range);
                }
            }

            var range = calendar._createRangeFromSelection(sel.start, sel.end, sel.resource);
            calendar._drawRange(range);
            calendar._multirange.add(range);
            // calendar._multirange.drawLater();
        };

/*
        this.multirange.draw = function() {
            mr.list.forEach(function(range) {
                calendar.elements.range2 = null;
                calendar._drawRange(range);
            });
        };*/

        this.multirange.clear = function() {
            mr.clear();
            calendar.clearSelection();
            calendar._lastRange = null;
        };

        this._multirange = {};
        var mr = this._multirange;

        this._multirange.list = [];

        this._multirange.drawLaterTimeout = null;
        this._multirange.drawLater = function() {
            clearTimeout(calendar._multirange.drawLaterTimeout);
            calendar._multirange.drawLaterTimeout = setTimeout(function() {
                mr.list.forEach(function(range) {
                    calendar.elements.range2 = null;
                    calendar._drawRange(range);
                });
            }, 0);
        };

        this._multirange.clear = function() {
            deleteElement(createList(mr.list).map(function(item) { return item.div; }));
            mr.list = [];
        };

        this._multirange.add = function(range) {
            range.div = calendar.elements.range2;
            calendar.elements.range2 = null;
            calendar._clearShadowHover(); // ?
            mr.list.push(range);
        };

        this._multirange.get = function(includeDefault) {
            var list = createList(mr.list).map(function(item) { return calendar._getSelection(item);});
            if (includeDefault && list.isEmpty()) {
                var sel = calendar._getSelection();
                if (sel) {
                    list.push(sel);
                }
            }
            return list;
        };

        this._multirange.dispatch = function() {
            if (!calendar.allowMultiRange) {
                return;
            }
            if (DayPilotScheduler._range) { // in progress
                return;
            }

            var last = createList(mr.list).last();
            calendar._timeRangeSelectedDispatchFromRange(last);
        };

        this._onMaindClick = function(ev) {

            if (calendar.timeRangeSelectedHandling === 'Disabled') {
                return false;
            }

            // fired on Android/Chrome on DOM change under finger
            if (DpGlobal.touch.active || DpGlobal.touch.start) {
                return;
            }

            var button = mouseButton(ev);

            if (DayPilotScheduler._range) { // time range selecting already active
                return;
            }

            if (DayPilotScheduler._rectangleSelect) {
                return;
            }

            if (calendar._rangeHold && calendar._isWithinRange(calendar.coords) && (button.right || button.middle)) {
                return;
            }

            if (calendar._isRowDisabled(calendar._getRow(calendar.coords.y).i)) {
                return;
            }

            var range = {};

            var cx = calendar._getItlineCellFromPixels(calendar.coords.x).x;

            range.start = {
                y: calendar._getRow(calendar.coords.y).i,
                x: cx,
                // "time": calendar.getDate(calendar.coords.x, true)
                "grid": calendar.coords.grid
            };

            range.end = {
                x: cx,
                // "time": calendar.getDate(calendar.coords.x, true)
            };

            range.calendar = calendar;

            // must be called before dispatch
            calendar._rangeHold = range;

            // disabled, it's called from timeRangeSelectedDispatch
            //calendar._drawRange(range);

            calendar._timeRangeSelectedDispatchFromRange(range);

        };

        this._timeouts = {};
        this._timeouts._drawEvents = null;
        this._timeouts.drawCells = null;
        this._timeouts.drawRows = null;
        this._timeouts.click = null;
        this._timeouts.resClick = [];
        this._timeouts.updateFloats = null;
        // this._timeouts.rsync = null;

        this._onScroll = function(ev, options) {

            if (calendar._disposed) {
                return;
            }

            options = options || {};

            if (typeof DayPilot.Bubble !== "undefined" && !options.dontHideBubble) {
                DayPilot.Bubble.hideActive();
            }

            calendar._clearCachedValues();

            var divScroll = calendar.nav.scroll;

            calendar._scrollPos = divScroll.scrollLeft;
            calendar._scrollTop = divScroll.scrollTop;
            calendar._scrollWidth = divScroll.clientWidth;

            if (calendar.divTimeScroll) {
                calendar.divTimeScroll.scrollLeft = calendar._scrollPos;
            }
            if (calendar._grids.top.enabled()) {
                calendar._grids.top.div.scrollLeft = calendar._scrollPos;
            }
            if (calendar._grids.bottom.enabled()) {
                calendar._grids.bottom.div.scrollLeft = calendar._scrollPos;
            }

            if (ios && DayPilotScheduler._touchingRes) {
                doNothing();
            }
            else {
                calendar.divResScroll.scrollTop = calendar._scrollTop;
            }

            if (infitools._isEnabled() && calendar._initialized && calendar.cellWidthSpec != "Auto" && !calendar._scrollToAfterInit) {

                if (infitools._active) {
                    doNothing();
                }
                else {

                    if (calendar.nav.scroll.scrollLeft < calendar.infiniteScrollingMargin) {

                        infitools._active = true;
                        calendar.nav.scroll.style.overflowX = "hidden";

                        setTimeout(function() {
                            infitools._shiftStart(-calendar.infiniteScrollingStepDays);
                        }, 100);
                        return;
                    }
                    else if (calendar.nav.scroll.scrollWidth - (calendar.nav.scroll.scrollLeft + calendar.nav.scroll.clientWidth) < calendar.infiniteScrollingMargin) {
                        infitools._active = true;
                        calendar.nav.scroll.style.overflowX = "hidden";

                        setTimeout(function() {
                            infitools._shiftStart(calendar.infiniteScrollingStepDays);
                        }, 100);
                        return;
                    }
                }

            }

            if (calendar.navigatorBackSync) {
                (function backSync() {
                    var navi = DayPilot.Util.evalVariable(calendar.navigatorBackSync);
                    var start = calendar.getViewPort().start;
                    navi.select(start, { "dontNotify": true, "dontFocus": true});
                })();
            }

            // draw rows before cells (by default both delays are 0) - affects lines
            if (calendar.progressiveRowRendering) {
                if (calendar._timeouts.drawRows) {
                    clearTimeout(calendar._timeouts.drawRows);
                    calendar._timeouts.drawRows = null;
                }
                if (calendar.scrollDelayRows > 0) {
                    calendar._timeouts.drawRows = setTimeout(function() { calendar._drawResHeadersProgressive(); }, calendar.scrollDelayRows);
                }
                else {
                    calendar._drawResHeadersProgressive();
                }

            }

            if (calendar._timeouts.drawCells) {
                clearTimeout(calendar._timeouts.drawCells);
                calendar._timeouts.drawCells = null;
            }
            if (calendar.scrollDelayCells > 0) {
                calendar._timeouts.drawCells = setTimeout(calendar._delayedDrawCells(), calendar.scrollDelayCells);
            }
            else {
                var f = calendar._delayedDrawCells();
                f();
            }

            if (calendar.dynamicLoading) {
                calendar._saveState();
                calendar._onScrollDynamic();
                return;
            }

            //calendar._loadingStart();

            if (calendar._timeouts._drawEvents) {
                clearTimeout(calendar._timeouts._drawEvents);
                calendar._timeouts._drawEvents = null;
            }
            if (calendar.scrollDelayEvents > 0) {
                calendar._timeouts._drawEvents = setTimeout(calendar._delayedDrawEvents(), calendar.scrollDelayEvents);
            }
            else {
                calendar._drawEvents();
            }

            if (calendar._timeouts.updateFloats) {
                clearTimeout(calendar._timeouts.updateFloats);
                calendar._timeouts.updateFloats = null;
            }
            if (calendar.scrollDelayFloats > 0) {
                calendar._timeouts.updateFloats = setTimeout(function() { calendar._updateFloats(); }, calendar.scrollDelayFloats);
            }
            else {
                calendar._updateFloats();
            }

            calendar.onScrollCalled = true;
        };

        this._delayedDrawCells = function() {
            return function() {
                if (!calendar) {
                    return;
                }

                calendar._saveState();
                calendar._drawCells();
            };
        };


        this._delayedDrawEvents = function() {
            var batch = true; // turns on batch rendering

            return function() {
                if (!calendar) {
                    return;
                }

                if (calendar._hiddenEvents()) {
                    //calendar._loadingStart();

                    window.setTimeout(function() {
                        calendar._deleteOldEvents();
                        window.setTimeout(function() { calendar._drawEvents(batch); }, 50);
                    }, 50);
                }
                else {
                    calendar._findEventsInViewPort();
                }
            };
        };

        this._clearCachedValues = function() {
            calendar._cache.eventHeight = null;
            calendar._cache.drawArea = null;
        };

        this.show = function() {
            calendar.visible = true;
            calendar._previousVisible = true;
            calendar.nav.top.style.display = '';
            calendar._show();
            calendar._resize();
            calendar._redrawInvalidatedCells();
            calendar._onScroll();
        };

        this.hide = function() {
            calendar.visible = false;
            calendar._previousVisible = false;
            calendar.nav.top.style.display = 'none';
        };

        this._onScrollDynamic = function() {

            var divScroll = calendar.nav.scroll;

            calendar._scrollPos = divScroll.scrollLeft;
            calendar._scrollTop = divScroll.scrollTop;
            calendar._scrollWidth = divScroll.clientWidth;

            calendar.divTimeScroll.scrollLeft = calendar._scrollPos;
            calendar.divResScroll.scrollTop = calendar._scrollTop;

            if (calendar.refreshTimeout) {
                window.clearTimeout(calendar.refreshTimeout);
            }

            var delay = calendar.scrollDelayDynamic;

            calendar.refreshTimeout = window.setTimeout(calendar._delayedRefreshDynamic(divScroll.scrollLeft, divScroll.scrollTop), delay);
            calendar._updateFloats();
        };

        this._findEventInList = function(data) {
            if (!calendar.events.list) {
                return null;
            }

            for (var j = 0; j < this.events.list.length; j++) {
                var ex = this.events.list[j];
                if (calendar._isSameEvent(ex, data)) {
                    var result = {};
                    result.ex = ex;
                    result.index = j;
                    result.modified = !calendar._equalObjectFlat(data, ex);
                    return result;
                }
            }
            return null;
        };

        this._equalObjectFlat = function(first, second) {
            for (var name in first) {
                if (typeof first[name] === 'object'  && !(first[name] instanceof DayPilot.Date)) {
                    continue;
                }
                if (first[name] !== second[name]) {
                    return false;
                }
            }

            for (var name in second) {
                if (typeof second[name] === 'object') {
                    continue;
                }
                if (first[name] !== second[name]) {
                    return false;
                }
            }

            return true;
        };

        this._loadEventsDynamic = function(supplied, finished, args) {

            var clear = args && args.clearEvents;
            var toBeDeleted = args && args.remove;
            var dontForceCellRendering = args && args.dontForceCellRendering;
            var updatedRows = [];

            if (!calendar.events.list) {
                calendar.events.list = [];
            }

            if (clear) {
                calendar._loadEvents(supplied);
                // calendar._updateRowHeights();
            }
            else {
                var deletelist = [];

                // first, delete events
                createList(toBeDeleted).forEach(function(id) {
                    var data = createList(calendar.events.list).find(function(data) {
                        return data.id === id;
                    });
                    if (data) {
                        deletelist.push(data);
                    }
                });

                deletelist.forEach(function(data) {
                    var rows = calendar.events._removeFromRows(data);
                    updatedRows = updatedRows.concat(rows);
                    DayPilot.rfa(calendar.events.list, data);
                });

                var foundlist = [];
                // compare only against the original list
                for (var i = 0; i < supplied.length; i++) {
                    var e = supplied[i];
                    foundlist[i] = calendar._findEventInList(e);
                }

                // perform the action
                for (var i = 0; i < supplied.length; i++) {
                    var e = supplied[i];

                    var found = foundlist[i];
                    var update = found && found.modified;
                    var add = !found;

                    if (update) {
                        // update it directly in list
                        this.events.list[found.index] = e;

                        // remove it from rows
                        var rows = calendar.events._removeFromRows(found.ex);
                        updatedRows = updatedRows.concat(rows);
                    }
                    else if (add) {
                        this.events.list.push(e);
                    }

                    if (update || add) {
                        updatedRows = updatedRows.concat(calendar.events._addToRows(e));
                    }
                }
                calendar._loadRows(updatedRows);
                calendar._updateRowHeights();
            }

            calendar._prepareRowTops();
            calendar._updateHeight();

            // only for partial update
            var useRowBasedUpdate = !clear;

            if (clear || dontForceCellRendering) {
                calendar._deleteEvents();

                // 2020-12-08 need to force cell reload for beforeCellRenderCaching = false as well (F-5284)
                var rowsDirty = calendar._rowsDirty || !calendar.beforeCellRenderCaching;

                // disabled, it prevented cellSweeping from working
                // 2019-04-19 enabled again, it's required for full reload - force if row heights changed
                if (rowsDirty) {
                    calendar._deleteCells();
                }

                calendar._updateRowHeaderHeights();

                // 2018-10-24 don't draw cells here, it's now driven by scrollDelayCells
                // calendar._drawCells();

                // need to draw any cells that were invalidated in onScroll
                // calendar._drawCells();

                if (rowsDirty) {
                    calendar._drawCells();
                }
                else {
                    calendar._redrawInvalidatedCells();
                }

                calendar._drawEvents();
                finished && finished();
            }
            else {

                // row-based update: doesn't draw events that were swept
                calendar._updateRowsNoLoad(updatedRows, false, function() {
                    finished && finished();

                    calendar._deleteOldEvents();
                    // draw remaining events - loaded but not rendered (close to viewport)
                    calendar._drawEvents();
                });

                calendar._redrawInvalidatedCells();

            }
        };

        this._delayedRefreshDynamic = function(scrollX, scrollY) {
            if (!calendar._serverBased()) {
                return function() {
                    if (typeof calendar.onScroll === 'function') {

                        var update = function(args) {
                            //var updatedRows = calendar._loadEvents(events, true);
                            var finished = function() {
                                if (calendar._api2()) {
                                    if (typeof calendar.onAfterRender === 'function') {
                                        var args = {};
                                        args.isCallBack = false;
                                        args.isScroll = true;
                                        args.data = null;

                                        calendar.onAfterRender(args);
                                    }
                                }
                            };

                            calendar._loadEventsDynamic(args.events, finished, args);
                        };


                        var args = {};
                        args.viewport = calendar.getViewPort();
                        args.async = true;
                        args.events = [];
                        args.remove = [];
                        args.clearEvents = true;
                        args.dontForceCellRendering = false;
                        args.loaded = function() {
                            if (this.async) {
                                update(args);
                            }
                        };

                        calendar.onScroll(args);

                        if (!args.async) {
                            update(args);
                        }

                    }
                };
            }
            else {
                return function() {
                    calendar.scrollX = scrollX;
                    calendar.scrollY = scrollY;
                    calendar._callBack2('Scroll');
                };
            }
        };

        // freeze top ok
        this._drawCellsFull = function() {
            var area = this._getDrawArea();

            var cellLeft = area.xStart;
            var cellWidth = area.xEnd - area.xStart;
            var cellTop = area.yStart;
            var cellHeight = area.yEnd - area.yStart;

            // initialize for client-side processing
            if (!this.cellProperties) {
                this.cellProperties = {};
            }

            var topGrid = calendar._grids.top;
            var bottomGrid = calendar._grids.bottom;

            for (var i = 0; i <= cellWidth; i++) {
                var x = cellLeft + i;
                for (var j = 0; j < cellHeight; j++) {
                    var y = cellTop + j;
                    if (!this.rowlist[y].hidden) {
                        this._drawCell(x, y);
                    }
                }
                this._drawLineVertical(x);

                if (topGrid.enabled()) {
                    for (var y = 0; y < topGrid.rowlist.length; y++) {
                        this._drawCell(x, y, "top");
                    }
                    this._drawLineVertical(x, "top");
                }

                if (bottomGrid.enabled()) {
                    for (var y = 0; y < bottomGrid.rowlist.length; y++) {
                        this._drawCell(x, y, "bottom");
                    }
                    this._drawLineVertical(x, "bottom");
                }

            }

            // full height
            var rarea = this._getAreaRowsWithMargin();
            for (var y = rarea.start; y < rarea.end; y++) {
                if (!this.rowlist[y].hidden) {
                    this._drawLineHorizontal(y);
                }
            }

            if (topGrid.enabled()) {
                for (var y = 0; y < topGrid.rowlist.length; y++) {
                    if (!topGrid.rowlist[y].hidden) {
                        this._drawLineHorizontal(y, "top");
                    }
                }
            }
            if (bottomGrid.enabled()) {
                for (var y = 0; y < bottomGrid.rowlist.length; y++) {
                    if (!bottomGrid.rowlist[y].hidden) {
                        this._drawLineHorizontal(y, "bottom");
                    }
                }
            }

        };

        // freeze ok
        this._drawCells = function() {
            if (calendar._disposed) {
                return;
            }

            var rowlist = calendar._rowlistMerged();
            if (rowlist && rowlist.length > 0) {
                var sweep = this.cellSweeping;
                if (sweep) {
                    var keepOld = this.cellSweepingCacheSize;
                    this._deleteOldCells(keepOld);
                }

                focus._unfocusCell();
                this._drawCellsFull();
                this._drawTimeBreaks();
                focus._focusCell({"dontFocus": true});
            }

            this._rowsDirty = false;
        };

        // freeze ok
        this._drawTimeBreaks = function() {
            var area = this._getDrawArea();
            var topGrid = calendar._grids.top;
            var bottomGrid = calendar._grids.bottom;

            for (var x = area.xStart; x < area.xEnd; x++) {
                var breaks = (x < this.itline.length - 1) ? this.itline[x + 1].breakBefore : false;
                if (breaks) {
                    this._drawTimeBreak(x);

                    if (topGrid.enabled()) {
                        this._drawTimeBreak(x, "top");
                    }

                    if (bottomGrid.enabled()) {
                        this._drawTimeBreak(x, "bottom");
                    }

                }
            }
        };

        // TODO freeze
        this._drawTimeBreak = function(x, gridName) {

            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var divBreaks = grid.divBreaks;
            var isMain = gridName === "main";
            var height = isMain ? calendar._innerHeightTree : grid.height ;

            var index = gridName + "_x_" + x;
            if (this._cache.breaks[index]) {
                return;
            }

            var args = {};
            if (typeof calendar.onBeforeGridLineRender === "function") {
                var itcBefore = calendar.itline[x];
                var itcAfter = calendar.itline[x + 1];

                args.start = itcBefore && itcBefore.end;
                args.end = itcAfter && itcAfter.start;
                args.hidden = false;
                args.cssClass = null;
                args.type = "VerticalBreak";
                args.grid = gridName;
                args.color = null;

                calendar.onBeforeGridLineRender(args);

                if (args.hidden) {
                    return;
                }
            }

            var left = calendar.itline[x + 1].left - 1;
            // var height = calendar._innerHeightTree;

            var line = createDiv();
            line.style.left = left + "px";
            line.style.top = "0px";
            line.style.width = "1px";
            line.style.height = height + "px";
            line.style.fontSize = '1px';
            line.style.lineHeight = '1px';
            line.style.overflow = 'hidden';
            line.style.position = 'absolute';
            line.setAttribute("unselectable", "on");
            line.className = this._prefixCssClass("_matrix_vertical_break");

            if (args.cssClass) {
                line.className += " " + args.cssClass;
            }
            if (args.color) {
                line.style.backgroundColor = args.color;
            }

            divBreaks.appendChild(line);
            this.elements.breaks.push(line);

            this._cache.breaks[index] = line;

        };

        this._getDrawArea = function() {

            if (calendar._cache.drawArea) {
                return calendar._cache.drawArea;
            }

            if (!this.nav.scroll) {
                return null;
            }

            var scrollTop = calendar._scrollTop;

            var area = {};

            var marginX = this.dynamicEventRenderingMarginX != null ? this.dynamicEventRenderingMarginX : this.dynamicEventRenderingMargin;
            var marginY = this.dynamicEventRenderingMarginY != null ? this.dynamicEventRenderingMarginY : this.dynamicEventRenderingMargin;
            var left = calendar._scrollPos - marginX - infitools._shiftX;
            var right = left + calendar._scrollWidth + 2*marginX;

            var start = 0;
            var end = 0;

            if (calendar.itline && calendar.itline.length > 0) {
                start = calendar._getItlineCellFromPixels(left).x;
                end = calendar._getItlineCellFromPixels(right, true).x;
                var totalWidth = this._cellCount();
                end = Math.min(end, totalWidth); // make sure it's within the boundaries
                start = atLeast(start, 0); // check the left side
            }

            var top = scrollTop - marginY;
            var bottom = scrollTop + this.nav.scroll.offsetHeight + 2*marginY;

            var cellTop = this._getRow(top).i;
            var cellBottom = this._getRow(bottom).i;
            if (cellBottom < this.rowlist.length) {
                cellBottom++;
            }

            area.xStart = start;
            area.xEnd = end;
            area.yStart = cellTop;
            area.yEnd = cellBottom;

            var ref = calendar.nav.scroll;

            if (ref.clientWidth === 0) {
                ref = calendar.divTimeScroll;
            }

            area.pixels = {};
            area.pixels.left = ref.scrollLeft - infitools._shiftX;
            area.pixels.right = ref.scrollLeft - infitools._shiftX + ref.clientWidth;
            area.pixels.top = ref.scrollTop;
            area.pixels.bottom = ref.scrollTop + ref.clientHeight;
            area.pixels.width = ref.scrollWidth;

            area.sw = DayPilot.sw(calendar.nav.scroll);

            calendar._cache.drawArea = area;

            return area;
        };

        this._getGridWidth = function() {
            var result = 0;

            var last = this.itline[this.itline.length - 1];
            if (!last) {
                result = 0;
            }
            else {
                result = last.left + last.width;
            }

            if (result < 0 || isNaN(result)) {
                result = 0;
            }
            return result;
        };

        this._drawLineHorizontal = function(y, gridName) {
            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;
            var divLines = grid.divLines;
            var isMain = gridName === "main";

            var index = gridName + "_y_" + y;

            if (this._cache._linesHorizontal[index]) {
                return;
            }

            var row = rowlist[y];

            var args = {};
            if (typeof calendar.onBeforeGridLineRender === "function") {
                args.row = calendar._createRowObject(row);
                args.hidden = false;
                args.cssClass = null;
                args.type = "HorizontalLine";
                args.color = null;

                calendar.onBeforeGridLineRender(args);

                if (args.hidden) {
                    return;
                }
            }

            var height = typeof row.forcedHeight === "number" ? row.forcedHeight : row.height;
            var top = row.top + height - 1;
            var width = this._getGridWidth();

            var line = createDiv();
            var lineStyle = line.style;
            lineStyle.left = "0px";
            lineStyle.top = top + "px";
            lineStyle.width = width + "px";
            lineStyle.height = "1px";
            lineStyle.fontSize = '1px';
            lineStyle.lineHeight = '1px';
            lineStyle.overflow = 'hidden';
            lineStyle.position = 'absolute';
            line.setAttribute("unselectable", "on");
            line.className = this._prefixCssClass("_matrix_horizontal_line");

            if (args.cssClass) {
                line.className += " " + args.cssClass;
            }
            if (args.color) {
                lineStyle.backgroundColor = args.color;
            }

            divLines.appendChild(line);
            //this.elements.linesHorizontal.push(line);

            this._cache._linesHorizontal[index] = line;

        };

        this._drawLineVertical = function(x, gridName) {

            var itc = this.itline[x];
            if (!itc) {
                return;
            }

            gridName = gridName || "main";
            var grid = calendar._grids[gridName];
            var divLines = grid.divLines;
            var isMain = gridName === "main";
            var height = isMain ? calendar._innerHeightTree : grid.height ;

            var index = gridName + "_x_" + x;
            if (this._cache._linesVertical[index]) {
                return;
            }

            var args = {};
            if (typeof calendar.onBeforeGridLineRender === "function") {
                args.start = itc.start;
                args.end = itc.end;
                args.hidden = false;
                args.cssClass = null;
                args.type = "VerticalLine";
                args.color = null;

                calendar.onBeforeGridLineRender(args);

                if (args.hidden) {
                    return;
                }
            }

            var left = itc.left + itc.width - 1;

            var line = createDiv();
            var lineStyle = line.style;
            lineStyle.left = left + "px";
            lineStyle.top = "0px";
            lineStyle.width = "1px";
            lineStyle.height = height + "px";
            lineStyle.fontSize = '1px';
            lineStyle.lineHeight = '1px';
            lineStyle.overflow = 'hidden';
            lineStyle.position = 'absolute';
            line.setAttribute("unselectable", "on");
            line.className = this._prefixCssClass("_matrix_vertical_line");

            if (args.cssClass) {
                line.className += " " + args.cssClass;
            }
            if (args.color) {
                lineStyle.backgroundColor = args.color;
            }

            divLines.appendChild(line);
            this.elements.linesVertical.push(line);

            this._cache._linesVertical[index] = line;
        };

        this._toggle = function(index, options) {

            if (calendar._angular2._resourcesFromAttr) {
                calendar._angular2.skip = true;
            }

            var row = this.rowlist[index];
            var expanded = !row.expanded;

            row.expanded = expanded;
            if (row.resource) {
                row.resource.expanded = expanded;
            }

            options = options || {};

            calendar._createCells({"includeHidden": true});

            if (calendar.treeAnimation && !options.notAnimated) {
                var rows = this._updateChildren(index, row.expanded, true);
                calendar._rowAnimate(rows, expanded ? "show" : "hide", function onComplete() {
                    performUpdate();
                });
            }
            else {
                performUpdate();
            }

            function performUpdate() {
                // external access: row, expanded, index
                var rows = calendar._updateChildren(index, row.expanded, false);
                if (!expanded) {
                    for (var i = 0; i < rows.length; i++) {
                        var ri = rows[i];
                        calendar._deleteEventsInRow(ri);
                    }
                }

                calendar._updateAfterRowChange();

                // new, fix after shrinking
                calendar._updateHeight();
                // calendar._updateAutoCellWidth();

                calendar._saveState();

                var r = calendar._createRowObject(row, index);
                if (expanded) {
                    calendar._resourceExpandDispatch(r);
                }
                else {
                    calendar._resourceCollapseDispatch(r);
                }

            }

        };

        this._updateAfterRowChange = function() {
            calendar._prepareRowTops();
            calendar._deleteRowHeaders();
            calendar._drawResHeader();
            calendar._updateHeight();
            calendar._clearCachedValues();
            calendar._updateEventTops();
            linktools._load();
            calendar._deleteCells(); // don't confuse the cache
            calendar._drawCells();
            calendar._drawResHeadersProgressive(); // used to be called inside drawCells

            // 2020-01-15 turned off, shadow disappears after row toggle
            // calendar._deleteRange();

            calendar._drawEvents(); // only renders events that were brought into viewport
            calendar._clearCachedValues();
        };

        this._loadNode = function(i) {
            var params = {};
            params.index = i;

            if (typeof this.onLoadNode === 'function') {
                var args = {};
                var resource = this.rowlist[i].resource;
                args.resource = resource;
                args.async = false;
                args.loaded = function() {
                    if (this.async) {
                        resource.dynamicChildren = false;
                        resource.expanded = true;
                        calendar.update();
                    }
                };

                this.onLoadNode(args);

                if (!args.async) {
                    resource.dynamicChildren = false;
                    resource.expanded = true;
                    this.update();
                }
            }
            else {
                this._callBack2('LoadNode', params);
            }

        };

        this._updateChildren = function(i, topExpanded, prepareOnly) {
            var row = this.rowlist[i];
            var changed = [];
            //var node = this.tree[i];

            if (row.children === null || row.children.length === 0) {
                return changed;
            }

            for (var k = 0; k < row.children.length; k++) {
                var index = row.children[k];
                var child = this.rowlist[index];

                var visible = topExpanded && row.expanded && !child._hiddenUsingFilter;

                if (topExpanded && child.hidden) {
                    child.forcedHeight = 0;
                }

                // always show for animation
                if (!prepareOnly || topExpanded) {
                    child.hidden = !visible; // show/hide but don't change Expanded state
                }

                if (!prepareOnly) {
                    delete child.forcedHeight;
                }

                if (topExpanded === visible) {
                    changed.push(index);
                }
/*
                if (topExpanded === !child.hidden) {
                    changed.push(index);
                }
*/
                var uchildren = this._updateChildren(index, topExpanded && !child.hidden);
                if (uchildren.length > 0) {
                    changed = changed.concat(uchildren);
                }
            }

            return changed;
        };

        this._startScroll = function(stepX, stepY) {
            //var step = 10;
            this._stopScroll();
            this._scrollabit(stepX, stepY);
        };

        this._scrollabitX = function(step) {
            if (!step) {
                return false;
            }
            var navScroll = this.nav.scroll;
            var total = navScroll.scrollWidth;
            var start = navScroll.scrollLeft;
            var width = navScroll.clientWidth;
            var right = start + width;

            if (step < 0 && start <= 0) {
                return false;
            }

            if (step > 0 && right >= total) {
                return false;
            }

            navScroll.scrollLeft += step;
            calendar.coords.x += step;

            calendar._scrollabitUpdateShadow();

            // this is not necessary, it's linked using nav.scroll.onscroll
            //this.divTimeScroll.scrollLeft = this.nav.scroll.scrollLeft;

            return true;
        };

        this._scrollabitY = function(step) {
            if (!step) {
                return false;
            }
            var navScroll = this.nav.scroll;
            var total = navScroll.scrollHeight;
            var start = navScroll.scrollTop;
            var height = navScroll.clientHeight;
            var bottom = start + height;

            if (step < 0 && start <= 0) {
                return false;
            }

            if (step > 0 && bottom >= total) {
                return false;
            }

            navScroll.scrollTop += step;
            calendar.coords.y += step;

            calendar._scrollabitUpdateShadow();

            // this is not necessary, it's linked using nav.scroll.onscroll
            //this.divTimeScroll.scrollTop = this.nav.scroll.scrollTop;

            return true;
        };


        this._scrollabitUpdateShadow = function() {
            if (DayPilotScheduler._resizing && DayPilotScheduler._resizing.event.calendar === calendar) {
                calendar._mouseMoveUpdateResizing();
            }
            else if (DayPilotScheduler._moving  && (DayPilotScheduler._movingEvent.calendar === calendar || (DayPilotScheduler._movingEvent.calendar && DayPilotScheduler._movingEvent.calendar.dragOutAllowed))) {
                if (!DayPilotScheduler._moving.event) {
                    DayPilotScheduler._moving.event = DayPilotScheduler._movingEvent;
                }
                calendar._mouseMoveUpdateMoving();
            }
            else if (DayPilotScheduler._range && DayPilotScheduler._range.calendar === calendar) {
                calendar._mouseMoveUpdateRange();
            }
        };

        this._scrollabit = function(stepX, stepY) {

            if (!calendar._resMouseMoveActive) {
                var moved = this._scrollabitX(stepX) || this._scrollabitY(stepY);
                if (!moved) {
                    return;
                }
            }

            var delayed = function(stepX, stepY) {
                return function() {
                    calendar._scrollabit(stepX, stepY);
                };
            };

            this._autoScrollTimeout = window.setTimeout(delayed(stepX, stepY), 100);

        };

/*
        this._scrollabit = function(stepX, stepY) {

            var move = function() {
                var moved = this._scrollabitX(stepX) || this._scrollabitY(stepY);
                if (!moved) {
                    return;
                }

                var delayed = function(stepX, stepY) {
                    return function() {
                        calendar._scrollabit(stepX, stepY);
                    };
                };

                this._autoScrollTimeout = window.setTimeout(delayed(stepX, stepY), 100);
            };


            move();
/!*
            calendar._autoScrollStartTimeout = setTimeout(function() {
                move();
            }, 200);
*!/


        };
*/

        this._stopScroll = function() {
            // clearTimeout(calendar._autoScrollStartTimeout);
            if (calendar._autoScrollTimeout) {
                window.clearTimeout(calendar._autoScrollTimeout);
                calendar._autoScrollTimeout = null;
            }
        };

        // freeze top
        this._prepareRowTops = function() {

            if (calendar._grids.top.enabled()) {
                calendar._grids.top.height = calendar._prepareRowTopsRowlist(calendar._grids.top.rowlist, 0);
            }

            if (calendar._grids.bottom.enabled()) {
                calendar._grids.bottom.height = calendar._prepareRowTopsRowlist(calendar._grids.bottom.rowlist, 0);
            }

            calendar._innerHeightTree = calendar._prepareRowTopsRowlist(calendar.rowlist, calendar._grids.top.height);

        };

        this._prepareRowTopsRowlist = function(rowlist, top) {
            var displayY = 0;
            var absTop = top || 0;
            var top = top || 0;
            for (var i = 0; i < rowlist.length; i++) {
                var row = rowlist[i];
                if (!row.hidden) {
                    row.top = top;
                    row.displayY = displayY;

                    if (typeof row.forcedHeight === "number") {
                        top += row.forcedHeight;
                    }
                    else {
                        top += row.height;
                    }

                    displayY += 1;
                }
                row.absTop = absTop;
                absTop += row.height;
            }
            return top;
        };

        this._deleteCells = function() {

            var addAndReact = typeof calendar.onBeforeRowHeaderDomAdd === "function" && calendar._react.reactDOM;

            if (DayPilot.browser.ie || addAndReact) {
                calendar._deleteCellsByOne();
            }

            calendar.elements.cells = [];
            //this.elements.linesHorizontal = [];
            calendar.elements.breaks = [];
            calendar._cache.cells = [];
            calendar._cache.breaks = [];

            calendar.divBreaks.innerHTML = '';
            calendar._grids.top.divBreaks.innerHTML = '';
            calendar._grids.bottom.divBreaks.innerHTML = '';

            calendar.divCells.innerHTML = '';
            calendar._grids.top.divCells.innerHTML = '';
            calendar._grids.bottom.divCells.innerHTML = '';

            calendar._deleteLines();
        };

        this._deleteLines = function() {
            calendar.divLines.innerHTML = '';
            calendar._grids.top.divLines.innerHTML = '';
            calendar._grids.bottom.divLines.innerHTML = '';

            calendar._cache._linesVertical = {};
            calendar._cache._linesHorizontal = {};
            calendar.elements.linesVertical = [];
        };

        this._deleteCellsByOne = function(y) {
            var list = createList();
            for (var name in calendar._cache.cells) {
                list.push(calendar._cache.cells[name]);
            }
            list.forEach(function(item) {
                calendar._deleteCell(item);
            });
        };

        // freeze ok
        this._deleteCellsInRow = function(y, gridName) {
            gridName = gridName || "main";
            var list = createList();
            for (var name in calendar._cache.cells) {
                list.push(calendar._cache.cells[name]);
            }
            list.filter(function(item) {
                return item && item.coords && item.coords.y === y && item.coords.grid === gridName;
            }).forEach(function(item) {
                calendar._deleteCell(item);
            });
        };

        this._cellsRendered = 0;

        this._cellPropsBlank = createList(['html', 'cssClass', 'backColor', 'backImage', 'backRepeat', 'areas', 'disabled']);  // "business" removed
        this._cellProps = calendar._cellPropsBlank.add('business');

        // freeze ok
        this._drawCell = function(x, y, gridName) {

            if (!this._initialized) {
                return;
            }

            var itc = calendar._getItline(x);
            if (!itc) {
                return;
            }

            gridName = gridName || "main";
            var grid = this._grids[gridName];
            var rowlist = grid.rowlist;
            var divCells = grid.divCells;
            var isMain = gridName === "main";

            var index = gridName + "_" + x + '_' + y;
            if (this._cache.cells[index]) {
                return;
            }

            var p = this._getCellProperties(x, y, gridName);

            calendar._doBeforeCellRender(x, y, gridName);

            // don't draw cells with no/default properties
            if (!this.drawBlankCells) {
                var isDefault = false;
                if (isMain && this._isRowParent(y)) {
                    isDefault = false;
                }
                else if (!this._hasProps(p, calendar._cellPropsBlank)) {
                    isDefault = true;
                }
                if (isDefault) {
                    return;
                }
            }

            var cell = createDiv();
            cell.style.left = (itc.left) + "px";
            cell.style.top = rowlist[y].top + "px";
            cell.style.width = (itc.width) + "px";
            cell.style.height = (rowlist[y].height) + "px";
            cell.style.position = 'absolute';
            if (p && p.backColor) {
                cell.style.backgroundColor = p.backColor;
            }
            cell.setAttribute("unselectable", "on");
            cell.className = this._prefixCssClass('_cell');

            cell.coords = {};
            cell.coords.x = x;
            cell.coords.y = y;
            cell.coords.grid = gridName;

            if (isMain && calendar._isRowParent(y)) {
                addClass(cell, this._prefixCssClass("_cellparent"));
            }

            if (rowsel._cache[y]) {
                addClass(cell, this._prefixCssClass("_cell_selected"));
            }

            var c = calendar.cells.findXy(x, y, gridName)[0];
            if (p) {
                if (p.cssClass) {
                    addClass(cell, p.cssClass);
                }
                if (!isNullOrUndefined(p.html)) {
                    cell.innerHTML = p.html;
                }
                if (p.backImage) {
                    cell.style.backgroundImage = "url(\"" + p.backImage + "\")";
                }
                if (p.backRepeat) {
                    cell.style.backgroundRepeat = p.backRepeat;
                }
                if (p.business && calendar.cellsMarkBusiness) {
                    addClass(cell, calendar._prefixCssClass("_cell_business"));
                }
                if (p.disabled) {
                    addClass(cell, calendar._prefixCssClass("_cell_disabled"));
                }

                var areas = DayPilot.Areas.resolvePosition(p.areas, calendar, itc.left, itc.width);
                DayPilot.Areas.attach(cell, c, {"areas": areas});
            }

            (function domAdd() {

                if (typeof calendar.onBeforeCellDomAdd !== "function" && typeof calendar.onBeforeCellDomRemove !== "function") {
                    return;
                }

                var args = {};
                args.control = calendar;
                args.cell = c;
                args.element = null;

                cell.domArgs = args;

                if (typeof calendar.onBeforeCellDomAdd === "function") {
                    calendar.onBeforeCellDomAdd(args);
                }

                if (args.element) {
                    var target = cell;
                    if (target) {
                        args._targetElement = target;

                        var isReactComponent = isReactCmp(args.element);
                        if (isReactComponent) {
                            if (!calendar._react.reactDOM) {
                                throw new DayPilot.Exception("Can't reach ReactDOM");
                            }
                            calendar._react._render(args.element, target);
                        }
                        else {
                            target.appendChild(args.element);
                        }
                    }
                }
            })();


/*            var focused = focus._getCell();
            if (focused) {
                if (focused.x === x && focused.y === y) {
                    addClass(cell, calendar._prefixCssClass("_cell_focus"));
                }
            }*/

            // disabled because it is firing the onTimeRangeSelected twice
            //cell.onclick = this._onMaindClick;

            // disabled temporarily, might not be necessary
            //cell.onmouseup = this._onMaindMouseUp;

            divCells.appendChild(cell);
            this.elements.cells.push(cell);

            this._cache.cells[index] = cell;

            if (typeof calendar.onAfterCellRender === 'function') {
                var args = {};
                args.cell = copyProps(c, {}, ["x", "y", "displayY", "start", "end", "resource", "grid"]);
                args.div = cell;

                calendar.onAfterCellRender(args);
            }

        };

        this._bcrCache = {};

        this._redrawInvalidatedCells = function() {

            calendar._invalidateAlwaysRows();

            var rows = calendar._rowsWithInvalidCells();

            rows.forEach(function(item) {
                calendar._deleteCellsInRow(item.y, item.grid);
            });

            calendar._drawCells();

        };


        this._invalidateAlwaysRows = function() {

            forGrid("main");
            forGrid("top");
            forGrid("bottom");

            function forGrid(grid) {
                var rowlist = calendar._grids[grid].rowlist;
                rowlist.forEach(function(row, y) {
                    if (row.isNewRow) {
                        return;
                    }
                    if (!row.resource.cellsAutoUpdated) {
                        return;
                    }
                    calendar.itline.forEach(function(ci, x) {
                        var i = grid + "_" + x + "_" + y;
                        delete calendar._bcrCache[i];
                    });
                });
            }
        };

        this._rowsWithInvalidCells = function() {
            // find all rows in viewport and check for invalid cells

            var result = createList();  // array of rows indices

            var area = this._getDrawArea();

            var cellLeft = area.xStart;
            var cellWidth = area.xEnd - area.xStart;
            var cellTop = area.yStart;
            var cellHeight = area.yEnd - area.yStart;

            forRowlist("main", cellTop, cellHeight);
            forRowlist("top", 0, calendar._grids.top.rowlist.length);
            forRowlist("bottom", 0, calendar._grids.bottom.rowlist.length);

            function forRowlist(grid, top, height) {
                for (var j = 0; j < height; j++) {
                    var y = top + j;
                    var row = calendar._grids[grid].rowlist[y];
                    for (var i = 0; i <= cellWidth; i++) {
                        var x = cellLeft + i;
                        if (!row.hidden) {
                            //this._drawCell(x, y);
                            if (!calendar._bcrCache[grid + "_" + x + "_" + y]) {
                                result.push({
                                    "grid": grid,
                                    "y": y
                                });
                                break;
                            }
                        }
                    }
                }
            }

            return result;
        };

        // freeze ok
        this._doBeforeCellRender = function(x, y, gridName) {
            if (typeof this.onBeforeCellRender === 'function') {
                gridName = gridName || "main";
                var index = gridName + "_" + x + "_" + y;
                if (calendar.beforeCellRenderCaching && calendar._bcrCache[index]) {
                    return;
                }
                calendar._bcrCache[index] = true;

                var itc = calendar._getItline(x);
                if (!itc) {
                    return;
                }

                var cell = calendar.cells.findXy(x, y, gridName)[0];

                var args = {};
                args.cell = cell;
                args.control = calendar;
                args.getPixels = function(date) {
                    var date = new DayPilot.Date(date);
                    var totalpix = calendar.getPixels(date).left;
                    return totalpix - itc.left;
                };

                this.onBeforeCellRender(args);

                // backwards compatibility
                // args.cell.properties is the cellProperties[x_y] object, use it
                // args.cell holds methods
                copyProps(args.cell, args.cell.properties, calendar._cellProps);

                if (args.cell.properties.disabled) {
                    calendar._bcrCache._dirtyDisabled = true;
                }

                return args;
            }

        };

        this._hasProps = function(object, props) {
            if (props) {
                for (var i = 0; i < props.length; i++) {
                    if (!isNullOrUndefined(object[props[i]])) {
                        return true;
                    }
                }
            }
            else {
                for (var name in object) {
                    if (!isNullOrUndefined(object[name])) {
                        return true;
                    }
                }
            }
            return false;
        };

        this.clearSelection = function() {
            this._deleteRange();
            mr.clear();
        };

        this.cleanSelection = this.clearSelection;

/*
        this._selectTimeRangeFromArray = function(array, dontFireEvent) {
            if (!array) {
                throw new DayPilot.Exception("array not specified");
            }
            if (!DayPilot.isArray(array)) {
                throw new DayPilot.Exception("Argument not an array");
            }

            calendar._multirange.clear();
            array.forEach(function(sel) {
                var range = calendar._createRangeFromSelection(sel);
                calendar._multirange.add(range);
                calendar._drawRange(range);
            });

            var last = createList(mr.list).last();

            if (!dontFireEvent) {
                setTimeout(function() {
                    calendar._timeRangeSelectedDispatchFromRange(last);
                }, 0);
            }
        };

*/
        this._createRangeFromSelection = function(start, end, resource) {

            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);

            var row = calendar._findRowByResourceId(resource);

            var itcStart = calendar._getItlineCellFromTime(start);
            var cellStart = itcStart.current || itcStart.next;
            if (!cellStart) {
                throw new DayPilot.Exception("Time range selection 'start' out of timeline");
            }

            var itcEnd = calendar._getItlineCellFromTime(new DayPilot.Date(end).addMilliseconds(-1));
            var cellEnd = itcEnd.current || itcEnd.previous;
            if (!cellEnd) {
                throw new DayPilot.Exception("Time range selection 'end' out of timeline");
            }

            var range = {};

            range.start = {
                y: row.index,
                x: indexOf(calendar.itline, cellStart),
                "time": start,
                "grid": row.grid
            };

            range.end = {
                x: indexOf(calendar.itline, cellEnd),
                "time": end
            };

            range.calendar = this;

            return range;
        };

        this.selectTimeRange = function(start, end, resource, dontFireEvent) {

/*            if (DayPilot.isArray(start)) {
                var array = start;
                var dontFireEvent = end;
                calendar._selectTimeRangeFromArray(array, dontFireEvent);
                return;
            }*/

            var range = calendar._createRangeFromSelection(start, end, resource);

            calendar._drawRange(range);

            if (!dontFireEvent) {
                setTimeout(function() {
                    calendar._timeRangeSelectedDispatchFromRange(range);
                }, 0);
            }

        };

        this._clearMovingShadow = function() {
            var src = DayPilotScheduler._movingShadow && DayPilotScheduler._movingShadow.source;

            if (src) {
                removeClass(src, calendar._prefixCssClass(calendar._css.eventMovingSource));
            }

            deleteElement(DayPilotScheduler._movingShadow);
            DayPilotScheduler._movingShadow = null;
            calendar._clearShadowHover();
            calendar._multimove.clear();

            if (DpGlobal.movingLink) {
                DpGlobal.movingLink.clear();
                DpGlobal.movingLink = null;
            }
        };

        this._deleteRange = function() {
            // IE doesn't like the div empty
            // this.divRange.innerHTML = '<div style="position:absolute; left:0px; top:0px; width:0px; height:0px;"></div>';

            if (calendar.divShadow) {
                calendar.divShadow.innerHTML = "";
            }

            if (calendar._grids.top.divShadow) {
                calendar._grids.top.divShadow.innerHTML = "";
            }

            if (calendar._grids.bottom.divShadow) {
                calendar._grids.bottom.divShadow.innerHTML = "";
            }

            calendar.elements.range = [];
            calendar.elements.range2 = null;

            calendar._clearShadowHover();

            calendar._rangeHold = null;

            calendar._lastRange = null;
        };


        var focus = {};

        focus._position = null;  // {x, y}
        focus._supressHighlight = false;

        focus._getFocusFromPosition = function(position) {
            if (!position) {
                return null;
            }

            var f = {};
            if (position.type === "event") {
                f.e = position.event;
            }
            else if (position.type === "cell") {
                var ci = focus._cellInfo(position.x, position.y);

                f.cell = {};
                f.cell.start = ci.thc.start;
                f.cell.end  = ci.thc.end;
                f.cell.resource = ci.row.id;
            }

            return f;
        }

        focus._focusCell = function(options) {
            // focus._unfocusCell();

            if (DayPilotScheduler._editing) {
                return;
            }
            if (focus._supressHighlight) {
                return;
            }

            options = options || {};
            var dontFocus = options.dontFocus;

            var position = focus._position;
            if (!position) {
                return;
            }

            var x = position.x;
            var y = position.y;

            if (position.type === "cell") {
                var ci = focus._cellInfo(x, y);
                var row = ci.row;
                var div = focus._cellDiv(x, y);
                if (div) {
                    addClass(div, calendar._prefixCssClass("_cell_focus"));
                }
                if (position.line === "top" && row.marginTop) {
                    addClass(div, calendar._prefixCssClass("_cell_focus_top"));
                }
                if (position.line === "bottom" && row.marginBottom) {
                    addClass(div, calendar._prefixCssClass("_cell_focus_bottom"));
                }
            }
            else {
                var div = calendar._findEventDiv(position.event);
                if (div) {
                    addClass(div, calendar._prefixCssClass("_event_focus"));
                }
            }

            if (!dontFocus) {
                var area = calendar._getAreaCurrent();

                if (area.start.x >= x) {
                    var start = calendar.itline[x].start;
                    calendar.scrollTo(start);
                }
                else if (area.end.x <= x) {
                    var end = calendar.itline[x].end;
                    calendar.scrollTo(end, false, "right");
                }

                // top
                if (area.start.y >= y) {
                    calendar.nav.scroll.scrollTop = calendar.rowlist[y].top - calendar._grids.top.height;
                }
                // bottom
                else if (area.end.y <= y) {
                    var row = calendar.rowlist[y];
                    var bottom = row.top + row.height;
                    calendar.nav.scroll.scrollTop = bottom - calendar.nav.scroll.clientHeight + calendar._grids.bottom.height;
                }
            }

        };

        focus._unfocusCell = function() {

            var position = focus._position;
            if (!position) {
                return;
            }
            if (position.type === "cell") {
                var div = focus._cellDiv(focus._position.x, focus._position.y);
                if (div) {
                    removeClass(div, calendar._prefixCssClass("_cell_focus"));
                    removeClass(div, calendar._prefixCssClass("_cell_focus_top"));
                    removeClass(div, calendar._prefixCssClass("_cell_focus_bottom"));
                }
            }
            else {
                var div = calendar._findEventDiv(position.event);
                if (div) {
                    removeClass(div, calendar._prefixCssClass("_event_focus"));
                }
            }
            // focus._position = null;
        };

        focus._cellInfo = function(x, y) {
            var result = {};

            var row = calendar.rowlist[y];
            var thc = calendar.itline[x];

            // all events
            var events = [];

            // by line
            var lines = row.lines.map(function(line) {
                var result = line.filter(function(e) {
                    return overlaps(e.part.start, e.part.end, thc.start, thc.end);
                });
                events = events.concat(result);
                return result;
            });

            result.lines = lines;
            result.thc = thc;
            result.row = row;
            result.events = events;

            return result;
        };

        focus._updateDefaultForCurrentPosition = function() {
            var position = focus._position;
            if (!position) {
                return;
            }
            focus._unfocusCell();
            focus._position = focus._findDefault(position.x, position.y, position.pixels, position.line);
            focus._focusCell({"dontFocus": true});
        };

        focus._findDefault = function(x, y, pixels, line) {
            var position = {};

            pixels = pixels || calendar.itline[x].left;
            line = isNullOrUndefined(line) ? "top" : line;

            var ci = focus._cellInfo(x, y);
            var lines = ci.lines;
            var row = ci.row;
            var events = ci.events;
            var marginMode = row.marginTop || row.marginBottom;

            var isThereFreeSpace = false;
            var hasEvents = events.length > 0;

            var resolvedLine = line;
            var event = null;
            var targetEvent = null;

            if (!hasEvents) {
                isThereFreeSpace = true;
                if (marginMode) {
                    resolvedLine = focus._resetLineForMarginMode(line, row);
                }
                else {
                    resolvedLine = 0;
                }
            }
            else if (row.marginTop && line === "top") {
                isThereFreeSpace = true;
                resolvedLine = "top";
            }
            else if (row.marginBottom && line === "bottom") {
                isThereFreeSpace = true;
                resolvedLine = "bottom";
            }
            else {
                if (line === "top") {
                    if (row.marginBottom) {

                        var lineWithEventAtPixels = ci.lines.find(function(line) {
                            return line.find(function(e) {
                                return e.part.left <= pixels && pixels <= e.part.right;
                            });
                        });
                        if (lineWithEventAtPixels) {
                            resolvedLine = ci.lines.indexOf(lineWithEventAtPixels);
                        }
                        else {
                            var lineWithEventAtCell = ci.lines.find(function(line) {
                                return line.find(function(e) {
                                    return overlaps(e.part.left, e.part.right, ci.thc.left, ci.thc.left + ci.thc.right);
                                });
                            });
                            if (lineWithEventAtCell) {
                                resolvedLine = ci.lines.indexOf(lineWithEventAtCell);
                                targetEvent = lineWithEventAtCell[0];
                            }
                            else {
                                resolvedLine = "bottom";
                            }
                        }
                    }
                    else if (row.marginTop) {
                        resolvedLine = "top";
                    }
                    else {
                        resolvedLine = 0;
                    }
                }
                else if (line === "bottom") {
                    if (marginMode) {
                        var lineWithEventAtPixels = ci.lines.slice().reverse().find(function(line) {
                            return line.find(function(e) {
                                return e.part.left <= pixels && pixels <= e.part.right;
                            });
                        });
                        resolvedLine = ci.lines.indexOf(lineWithEventAtPixels);
                        if (resolvedLine === -1) {
                            resolvedLine = focus._resetLineForMarginMode(line, row);
                        }
                    }
                    else {
                        resolvedLine = lines.length - 1;
                    }
                }
                else {
                    resolvedLine = line;
                }
                var activeLine = lines[resolvedLine];
                if (!targetEvent) {
                    targetEvent = activeLine && activeLine.find(function(e) {
                        return e.part.left <= pixels && pixels <= e.part.right;
                    });
                }

                if (!targetEvent) {
                    isThereFreeSpace = true;
                    // margin mode only
                    resolvedLine = focus._resetLineForMarginMode(resolvedLine, row);
                }
                event = targetEvent;
            }

            position.x = x;
            position.y = y;
            if (isThereFreeSpace) {
                position.type = "cell";
                position.pixels = pixels;
                position.line = resolvedLine;
                return position;
            }
            else {
                position.type = "event";
                position.event = event;
                position.pixels = event.part.left;
                position.x = calendar._getItlineCellFromPixels(event.part.left).x;
                position.line = resolvedLine;
            }

            return position;
        };

        focus._findNext = function(direction) {

            var position = {};

            var current = focus._position;

            var row = calendar.rowlist[current.y];
            var line = row.lines[current.line];
            var ci = focus._cellInfo(current.x, current.y);

            var marginMode = row.marginTop || row.marginBottom;

            if (direction === "right") {
                if (current.type === "event") {

                    var end = current.event.part.end;
                    // var right = current.event.part.right;
                    var right = current.event.part.right;
                    var thc = calendar._getItlineCellFromTime(end);
                    var thcx = thc.i;
                    var thcright = thc.current.left + thc.current.width; // check
                    var nei = line.indexOf(current.event) + 1;
                    var next = line[nei];

                    var cellLine = ci.lines[current.line];
                    var nextInCell = cellLine[cellLine.indexOf(current.event) + 1];

                    if (next && next.part.left === right) {
                        position.x = thcx + 1;
                        position.y = current.y;
                        position.type = "event";
                        position.line = current.line;
                        position.pixels = next.part.left;
                        position.event = next;
                        return position;
                    }
                    else if (nextInCell && marginMode) {
                        position.x = thcx;
                        position.y = current.y;
                        position.type = "event";
                        position.line = current.line;
                        position.pixels = nextInCell.part.left;
                        position.event = nextInCell;
                        return position;
                    }
                    else {
                        if (thcright === right) {
                            // check if the next cell exists
/*                            if (thcx >= calendar.itline.length - 1) {
                                return current;
                            }*/
                            var nextX = focus._visibleCellRight(thcx);
                            if (nextX === thcx) {
                                return current;
                            }

                            position.x = thcx + 1;
                            position.y = current.y;
                            position.type = "cell";
                            position.pixels = calendar.itline[position.x].left;
                            position.line = current.line;
                            if (row.marginTop) {
                                position.line = "top";
                            }
                            else if (row.marginBottom) {
                                position.line = "bottom";
                            }
                            return position;
                        }
                        else {
                            position.x = thcx;
                            position.y = current.y;
                            position.type = "cell";
                            position.line = current.line;
                            position.pixels = current.event.part.right;  // maybe + 1

                            if (marginMode) {
                                position.line = focus._resetLineForMarginMode(current.line, row);
                            }

                            return position;
                        }
                    }
                }
                // cell
                else {
                    // find first event that starts after pixel pos
                    var ci = focus._cellInfo(current.x, current.y);
                    var line = ci.lines[current.line];
                    var next = line && line.find(function(ev) {
                        return ev.part.left > current.pixels;
                    });
                    if (next) {
                        position.x = current.x;
                        position.y = current.y;
                        position.type = "event";
                        position.event = next;
                        position.pixels = next.part.left;
                        position.line = current.line;
                        return position;
                    }
                    // move to the next cell, check if there is an event
                    else {
                        var nextX = focus._visibleCellRight(current.x);
                        if (nextX === current.x) {
                            return current;
                        }

                        return focus._findDefault(current.x + 1, current.y, null, current.line);
                    }
                }
            }
            else if (direction === "left") {
                var x = current.x;
                if (current.type === "event") {
                    x = calendar._getItlineCellFromPixels(current.event.part.left).x;
                    var thc = calendar.itline[x];
                    if (current.event.part.left === thc.left) {
                        position = focus._findDefault(x - 1, current.y, thc.right, current.line);
                    }
                    else {
                        // check if there is an event
                        // position = focus._findDefault(x - 1, current.y, thc.left, current.line);
                        var nei = line.indexOf(current.event) - 1;
                        var next = line[nei];

                        if (next && next.part.right === current.event.part.left) {
                            thc = calendar._getItlineCellFromPixels(next.part.right, true);
                            position.x = thc.x;
                            position.y = current.y;
                            position.type = "event";
                            position.line = current.line;
                            position.pixels = next.part.right;
                            position.event = next;
                            return position;
                        }
                        else {
                            // next found but not immediately
                            // position = focus._findDefault(x - 1, current.y, thc.right, current.line);
                            thc = calendar._getItlineCellFromPixels(current.event.part.left);
                            position.x = thc.x;
                            position.y = current.y;
                            position.type = "cell";
                            position.line = current.line;
                            position.pixels = current.event.part.left;

                            if (marginMode) {
                                position.line = focus._resetLineForMarginMode(current.line, row);
                            }

                            return position;

                            // return focus._findDefault(thc.x, current.y, current.event.part.left, current.line);
                        }
                    }
                }
                else {
                    // cell

                    var ci = focus._cellInfo(current.x, current.y);
                    var line = ci.lines[current.line];
                    var next = line && line.slice().reverse().find(function(ev) {
                        return ev.part.right < current.pixels;
                    });

                    if (next) {
                        position.x = current.x;
                        position.y = current.y;
                        position.type = "event";
                        position.event = next;
                        position.pixels = next.part.right;
                        position.line = current.line;
                        return position;
                    }

                    var nextX = focus._visibleCellLeft(current.x);
                    if (nextX === current.x) {
                        return current;
                    }

                    var thc = calendar.itline[x - 1];
                    var thcright = thc.left + thc.width;
                    position = focus._findDefault(x - 1, current.y, thcright, current.line);
                }

                return position;
            }
            else if (direction === "down") {
                var ci = focus._cellInfo(current.x, current.y);
                var lineWithEventAtPixels = ci.lines.find(function(line) {
                    return line.find(function(e) {
                        return e.part.left <= current.pixels && current.pixels <= e.part.right;
                    });
                });

                if (current.line === "top" && row.marginTop) {
                    if (lineWithEventAtPixels) {
                        var i = ci.lines.indexOf(lineWithEventAtPixels);
                        position = focus._findDefault(current.x, current.y, current.pixels, i);
                        position.pixels = current.pixels;
                        position.x = current.x;
                        return position;
                    }
                    else {
                        var lineWithEventAtCell = ci.lines.find(function(line) {
                            return line.find(function(e) {
                                return overlaps(e.part.left, e.part.right, ci.thc.left, ci.thc.left + ci.thc.right);
                            });
                        });
                        if (lineWithEventAtCell) {
                            var e = lineWithEventAtCell[0];
                            position = focus._findDefault(current.x, current.y, e.part.left, ci.lines.indexOf(lineWithEventAtCell));
                            position.pixels = current.pixels;
                            position.x = current.x;
                            return position;
                        }
                        else {
                            var nextRow = focus._visibleRowDown(current.y);
                            if (nextRow === current.y) {
                                return current;
                            }
                            position = focus._findDefault(current.x, current.y + 1, current.pixels, "top");
                            position.pixels = current.pixels;
                            position.x = current.x;
                            return position;
                        }
                    }
                }
                else if (current.line === "bottom" && row.marginBottom) {
                    var nextRow = focus._visibleRowDown(current.y);
                    if (nextRow === current.y) {
                        return current;
                    }

                    position = focus._findDefault(current.x, current.y + 1, current.pixels, "top");
                    position.pixels = current.pixels;
                    position.x = current.x;
                    return position;
                }
                else if (current.line < row.lines.length - 1) {
                    var y = current.y;
                    var nextLine = current.line + 1;

                    if (row.marginTop && current.line === "top") {
                        nextLine = 0;
                    }

                    var lineWithEventAtPixels = ci.lines.slice(nextLine).find(function(line) {
                        return line.find(function(e) {
                            return e.part.left <= current.pixels && current.pixels <= e.part.right;
                        });
                    });

                    if (lineWithEventAtPixels) {
                        nextLine = ci.lines.indexOf(lineWithEventAtPixels);
                    }
                    else if (row.marginBottom) {
                        nextLine = "bottom";
                    }
                    else if (row.marginTop) {
                        var lineWithEventAtCell = ci.lines.slice(current.line + 1).find(function(line) {
                            return line.find(function(e) {
                                return overlaps(e.part.left, e.part.right, ci.thc.left, ci.thc.left + ci.thc.right);
                            });
                        });
                        if (lineWithEventAtCell) {
                            var e = lineWithEventAtCell[0];
                            position = focus._findDefault(current.x, current.y, e.part.left, ci.lines.indexOf(lineWithEventAtCell));
                            return position;
                        }
                        else {
                            nextLine = "top";
                            y += 1;
                        }
                    }
                    else if (current.event) {
                        nextLine = row.lines.length - 1;
                    }
                    else {
                        nextLine = 0;
                        y += 1;
                    }

                    position = focus._findDefault(current.x, y, current.pixels, nextLine);
                    position.pixels = current.pixels;
                    position.x = current.x;
                    return position;

                    // position = focus._findDefault(current.x, current.y, current.pixels, current.line + 1);
                }
                else if (current.line === row.lines.length - 1 && row.marginBottom) {
                    position = focus._findDefault(current.x, current.y, current.pixels, "bottom");
                    position.pixels = current.pixels;
                    position.x = current.x;
                    return position;
                }
                else {
                    var nextRow = focus._visibleRowDown(current.y);
                    if (nextRow === current.y) {
                        return current;
                    }

                    position = focus._findDefault(current.x, current.y + 1, current.pixels, "top");
                    position.pixels = current.pixels;
                    position.x = current.x;
                    return position;
                }

                throw new DayPilot.Exception("unhandled key");
            }
            else if (direction === "up") {
                var ci = focus._cellInfo(current.x, current.y);
                var lineWithEventAtPixels = ci.lines.slice().reverse().find(function(line) {
                    return line.find(function(e) {
                        return e.part.left <= current.pixels && current.pixels <= e.part.right;
                    });
                });

                if (current.line === "bottom" && row.marginBottom && lineWithEventAtPixels) {
                    var i = ci.lines.indexOf(lineWithEventAtPixels);
                    position = focus._findDefault(current.x, current.y, current.pixels, i);
                }
                else if (current.line === 0 && row.marginTop) {
                    position = focus._findDefault(current.x, current.y, current.pixels, "top");
                }
                else if (current.line > 0) {
                    var nextLine = "bottom";
                    var y = current.y;

                    var lineWithEventAtPixels = ci.lines.slice(0, current.line).reverse().find(function(line) {
                        return line.find(function(e) {
                            return e.part.left <= current.pixels && current.pixels <= e.part.right;
                        });
                    });

                    if (lineWithEventAtPixels) {
                        nextLine = ci.lines.indexOf(lineWithEventAtPixels);
                    }
                    else if (row.marginTop) {
                        nextLine = "top";
                    }
                    else if (row.marginBottom) {
                        y -= 1;
                    }
                    else {
                        nextLine = 0;
                    }
                    // else {
                    //     nextLine = "top";
                    // }

                    var nextRow = focus._visibleRowUp(y);
                    if (nextRow === y) {
                        return current;
                    }

                    position = focus._findDefault(current.x, y, current.pixels, nextLine);
                }
                else {
                    var nextRow = focus._visibleRowUp(current.y);
                    if (nextRow === current.y) {
                        return current;
                    }

                    position = focus._findDefault(current.x, current.y - 1, current.pixels, "bottom");
                }

                position.x = current.x;
                position.pixels = current.pixels;
                return position;
            }

            return null;
        };

        focus._resetLineForMarginMode = function(line, row) {
            // var row = calendar.rowlist[position.y];
            // var marginMode = row.marginTop || row.marginBottom;

            var hasTarget = (line === "top" && row.marginTop) || (line === "bottom" && row.marginBottom);
            if (typeof line === "number" || !hasTarget) {
                if (row.marginTop) {
                    return "top";
                }
                else if (row.marginBottom) {
                    return "bottom";
                }
            }
            return line;

            /*
                        if (marginMode) {
                            if (typeof position.line === "number") {

                            }
                        }
            */
        };

        focus._cellDiv = function(x, y, gridName) {
            gridName = gridName || "main";
            var index = gridName + "_" + x + "_" + y;
            var div = calendar._cache.cells[index];
            return div;
        };

        focus._getCell = function() {
            return focus._position;
        };

        focus._target = function() {
            var keyboardTarget = calendar.keyboardTarget;
            switch (keyboardTarget) {
                case "component":
                    return calendar.nav.top;
                case "document":
                    return document;
            }
            throw new DayPilot.Exception("Invalid keyboardTarget value: " + keyboardTarget);
        };

        focus._range = null;


        focus._onTargetKeyUp = function(ev) {
            // shift
            if (ev.keyCode === 16) {
                var range = focus._range;
                focus._range = null;

                if (!range || !range.end) {
                    return;
                }

                var natural = range.start.x < range.end.x;
                var startX = natural ? range.start.x: range.end.x;
                var endX = natural ? range.end.x : range.start.x;

                focus._timeRangeSelect(startX, range.start.y, endX, {"forceSnap": true});
            }
        };

        focus._onTargetKeyDown = function(ev) {
            var left = 37;
            var up = 38;
            var right = 39;
            var down = 40;
            var enter = 13;

            var directions = {};
            directions["_" + left] = "left";
            directions["_" + right] = "right";
            directions["_" + up] = "up";
            directions["_" + down] = "down";

            var navi = [left, up, right, down];
            var isNavi = navi.indexOf(ev.keyCode) !== -1;
            var handled = [left, up, right, down, enter];
            var isHandled = handled.indexOf(ev.keyCode) !== -1;

            var editing = DayPilotScheduler._editing;
            if (editing) {
                return;
            }

            if (typeof calendar.onKeyDown === "function") {
                var args = {};
                args.originalEvent = ev;
                args.preventDefault = function() {
                    args.preventDefault.value = true;
                };

                calendar.onKeyDown(args);

                if (args.preventDefault.value) {
                    return;
                }
            }

            if (isNavi) {
                ev.preventDefault();
                if (!focus._position) {
                    focus._initialFocus();
                    return;
                }
            }

            if (!isHandled) {
                return;
            }

            var shift = ev.shiftKey;

            if (focus._position) {
                var isParent = calendar._isRowParent(focus._position.y);
                var selectionAllowed = !(isParent && calendar.treePreventParentUsage);

                if (shift && !focus._position.event && !focus._range && selectionAllowed) {
                    focus._range = {
                        "calendar": calendar,
                        "forceSnap": true,
                        "start" :{
                            x: focus._position.x,
                            y: focus._position.y,
                            time: calendar.itline[focus._position.x].start
                        }
                    };
                }
            }

            var canMoveVertically =  !focus._range;
            if (!canMoveVertically && (ev.keyCode === up || ev.keyCode === down)) {
                return;
            }

            var next = focus._findNext(directions["_" + ev.keyCode]);

            var args = {};
            args.previous = calendar.keyboard.getFocus();
            args.focus = focus._getFocusFromPosition(next);
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };
            if (isNavi && typeof calendar.onKeyboardFocusChange === "function") {
                calendar.onKeyboardFocusChange(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            if (isNavi) {
                focus._unfocusCell();
                focus._position = next;
                focus._focusCell();
            }
            else {
                switch (ev.keyCode) {
                    case enter:
                        ev.preventDefault();
                        if (focus._position && focus._position.event) {
                            var div = calendar._findEventDiv(focus._position.event);
                            focus._eventClick(div, ev);
                        }
                        else if (selectionAllowed) {
                            focus._timeRangeSelect(focus._position.x, focus._position.y);
                        }
                        break;
                }
            }

            if (isNavi && typeof calendar.onKeyboardFocusChanged === "function") {
                calendar.onKeyboardFocusChanged(args);
                if (args.preventDefault.value) {
                    return;
                }
            }

            if (ev.keyCode === left || ev.keyCode === right) {
                if (focus._range) {
                    focus._range.end = {
                        x: focus._position.x,
                        y: focus._position.y,
                        time: calendar.itline[focus._position.x].start
                    };
                    calendar._drawRange(focus._range);
                }
            }
            if (focus._range) {
                // add onTimeRangeSelecting
            }

        };

        focus._unregisterEvents = function() {
            var target = focus._target();
            target.removeEventListener("keyup", focus._onTargetKeyUp);
            target.removeEventListener("keydown", focus._onTargetKeyDown);
        };

        focus._registerEvents = function() {
            var target = focus._target();

            if (target !== document) {
                calendar.nav.top.setAttribute("tabindex", "-1");
            }

            if (calendar._serverBased()) {
                return;
            }

            target.addEventListener("keyup", focus._onTargetKeyUp);
            target.addEventListener("keydown", focus._onTargetKeyDown);
        };

        focus._eventClick = function(div, ev) {
            calendar._eventClickSingle(div, ev);
        };

        // copied from onMaindClick
        focus._timeRangeSelect = function(x, y, x2) {
            options = options || {};

            var range = {};
            range.forceSnap = true;
            range.start = {
                y: y,
                x: x,
                time: calendar.itline[x].start
            };

            range.end = {
                x: typeof x2 === "undefined" ? x : x2
            };

            range.end.time = calendar.itline[range.end.x].start;

            range.calendar = calendar;

            // must be called before dispatch
            calendar._rangeHold = range;

            calendar._timeRangeSelectedDispatchFromRange(range);
        };

        focus._initialFocus = function() {
            var area = calendar._getAreaCurrent();
            focus._unfocusCell();
            focus._position = focus._findDefault(area.start.x, area.start.y);
            focus._focusCell();
        };

        focus._initGrid = function() {
            var allowed = calendar.useEventBoxes === "Always";
            allowed = allowed && !calendar._serverBased();

            if (!allowed) {
                return;
            }

            focus._registerEvents();

            if (focus._target() !== document) {
                calendar.nav.top.focus();
            }
        };

        focus._visibleRowUp = function(y) {
            if (y <= 0) {
                return y;
            }
            var i = y;
            while (i > 0) {
                i -= 1;
                if (!calendar.rowlist[i].hidden) {
                    return i;
                }
            }
            return y;
        };

        focus._visibleRowDown = function(y) {
            var max = calendar.rowlist.length - 1;
            if (y >= max) {
                return y;
            }
            var i = y;
            while (i < max) {
                i += 1;
                if (!calendar.rowlist[i].hidden) {
                    return i;
                }
            }
            return y;
        };

        focus._visibleCellRight = function(x) {
            var max = calendar.itline.length - 1;
            if (x >= max) {
                return x;
            }
            return x + 1;
        }

        focus._visibleCellLeft = function(x) {
            if (x <= 0) {
                return x;
            }
            return x + 1;
        }

        focus._removeFocus = function() {
            focus._position = null;
        };

        this._focus = focus;


        this.keyboard = {};
/*
        this.keyboard.focusCellXy = function(x, y) {
            focus._unfocusCell();
            focus._position = focus._findDefault(area.start.x, area.start.y);
            focus._focusCell();
        };
*/

        this.keyboard.focusCell = function(date, resource) {

            // what if it's not found or the row is frozen? exception / silent failure
            var cell = calendar._cellFindByStartRes(date, resource);
            if (!cell) {
                throw new DayPilot.Exception("Can't find the specified cell");
            }
            if (cell.grid !== "main") {
                throw new DayPilot.Exception("Can't focus a cell in a frozen row");
            }

            // calendar.keyboard.focusCellXy(cell.x, cell.y);
            focus._unfocusCell();
            focus._position = focus._findDefault(cell.x, cell.y);
            focus._focusCell();

        };

        this.keyboard.focusEvent = function(id) {
            if (id instanceof DayPilot.Event) {
                id = id.id();
            }

            var ev = calendar.events.find(id);
            if (!ev) {
                throw new DayPilot.Exception("Event not found");
            }

            ev = calendar.events._findEventInRows(ev.data);

            var row = calendar.rowlist[ev.part.dayIndex];

            var position = {};
            position.type = "event";
            position.event = ev;
            position.pixels = ev.part.left;
            position.x = calendar._getItlineCellFromPixels(ev.part.left).x;
            position.y = ev.part.dayIndex;
            position.line = ev.part.line;

            focus._unfocusCell();
            focus._position = position;
            focus._focusCell();

        };

        this.keyboard.resetFocus = function() {
            focus._initialFocus();
        };

        this.keyboard.getFocus = function() {
            return focus._getFocusFromPosition(focus._position);
        };

        this.keyboard.move = function(direction, options) {

            options = options || {};
            var dontFireEvent = options.dontFireEvent;

            focus._unfocusCell();

            var next = focus._findNext(direction);

            var args = {};
            args.previous = calendar.keyboard.getFocus();
            args.focus = focus._getFocusFromPosition(next);
            args.preventDefault = function() {
                args.preventDefault.value = true;
            };
            if (typeof calendar.onKeyboardFocusChange === "function" && !dontFireEvent) {
                calendar.onKeyboardFocusChange(args);

                if (args.preventDefault.value) {
                    focus._focusCell();
                    return;
                }
            }

            focus._position = next;

            focus._focusCell();

            if (typeof calendar.onKeyboardFocusChanged === "function" && !dontFireEvent) {
                calendar.onKeyboardFocusChanged(args);
            }
        };

        this._resolved = {};
        var resolved = this._resolved;

        resolved._clearCache = function() {
            delete calendar._cache.eventHeight;
            delete calendar._cache.headerHeight;
        };

        resolved._xssProtectionEnabled = function() {
            return calendar.xssProtection !== "Disabled";
        };

        resolved._locale = function() {
            return DayPilot.Locale.find(calendar.locale);
        };

        resolved._timeFormat = function() {
            if (calendar.timeFormat !== 'Auto') {
                    return calendar.timeFormat;
            }
            return resolved._locale().timeFormat;
        };

        resolved._weekStarts = function() {
            if (calendar.weekStarts === 'Auto') {
                var locale = resolved._locale();
                if (locale) {
                    return locale.weekStarts;
                }
                else {
                    return 0; // Sunday
                }
            }
            else {
                return calendar.weekStarts || 0;
            }
        };

        resolved._mobile = function() {
            var ua = navigator.userAgent.toLowerCase();
            return ua.indexOf("mobile") !== -1 || ua.indexOf("android") != -1;
        };

        resolved._layout = function() {
            var isIE6 = /MSIE 6/i.test(navigator.userAgent);
            if (calendar.layout === 'Auto') {
                if (isIE6) {
                    return 'TableBased';
                }
                else {
                    return 'DivBased';
                }
            }
            return calendar.layout;
        };

        resolved._notifyType = function() {
            var type;
            if (calendar.notifyCommit === 'Immediate') {
                type = "Notify";
            }
            else if (calendar.notifyCommit === 'Queue') {
                type = "Queue";
            }
            else {
                throw new DayPilot.Exception("Invalid notifyCommit value: " + calendar.notifyCommit);
            }

            return type;
        };

        resolved._isResourcesView = function() {
            return calendar.viewType !== 'Days';
        };


        resolved._useBox = function(durationTicks) {
            if (calendar.useEventBoxes === 'Always') {
                return true;
            }
            if (calendar.useEventBoxes === 'Never') {
                return false;
            }
            return durationTicks < calendar._getCellDuration() * 60 * 1000;
        };

        resolved._barHeight = function() {
            var defVal = 4;
            return typeof calendar.durationBarHeight === "number" ? calendar.durationBarHeight : defVal;
        };

        resolved._eventHeight = function() {
            if (calendar._cache.eventHeight) {
                return calendar._cache.eventHeight;
            }
            var height = calendar._getDimensionsFromCss("_event_height").height;
            if (!height) {
                height = calendar.eventHeight;
            }
            calendar._cache.eventHeight = height;
            return height;
        };

        resolved._headerHeight = function() {
            if (calendar._cache.headerHeight) {
                return calendar._cache.headerHeight;
            }
            var height = calendar._getDimensionsFromCss("_header_height").height;
            if (!height) {
                height = calendar.headerHeight;
            }
            calendar._cache.headerHeight = height;
            return height;
        };

        resolved._scrollLineHeight = function() {
            if (calendar._cache.scrollLineHeight) {
                return calendar._cache.scrollLineHeight;
            }

            var div = createDiv();
            div.style.fontSize = "initial";
            div.style.display = "none";
            body().appendChild(div);
            var result = parseInt(window.getComputedStyle(div).fontSize) || 16;
            body().removeChild(div);
            calendar._cache.scrollLineHeight = result;
            return result;
        };

        resolved._splitterWidth = function() {
            if (calendar.rowHeaderScrolling) {
                return calendar.rowHeaderSplitterWidth;
            }
            return 1;
        };

        resolved._rectangleSelectMode = function() {
            // "Disabled", "Row", "Free", transforms legacy values

            // legacy, default value is undefined
            if (typeof calendar.multiSelectRectangle === "string") {
                return calendar.multiSelectRectangle;
            }
            if (calendar.rectangleSelectHandling === "Disabled") {
                return "Disabled";
            }
            return calendar.rectangleSelectMode;
        };

        resolved._rectangleSelectHandling = function() {
            if (typeof calendar.multiSelectRectangle === "string") {
                if (calendar.multiSelectRectangle === "Free" || calendar.multiSelectRectangle === "Row") {
                    return "EventSelect";
                }
                return "Disabled";
            }
            return calendar.rectangleSelectHandling;
        };

        resolved._rowHeaderColumnsVisible = function() {
            return createList(calendar.rowHeaderColumns).filter(function(col) {
                return !col.hidden;
            });
        };

        this._dim = {};

        var dim = this._dim;

        dim._timeHeader = function(level) {
            var h = {};
            h.top = 0;
            h.height = 0;

            var defaultHeight = resolved._headerHeight();

            for (var i = 0; i <= level; i++) {
                var th = calendar.timeHeaders[i];
                h.top += h.height;
                h.height =  th.height || defaultHeight;
            }

            return h;
        };

        // freeze ok
        this._getCellProperties = function(x, y, gridName) {
            gridName = gridName || "main";
            var index = gridName + "_" + x + '_' + y;
            var grid = calendar._grids[gridName];
            var rowlist = grid.rowlist;

            // supplied from the server side, includes hidden rows - adjust y here
            if (calendar.cellConfig) {
                index = x + '_' + y;
                var fixedY = 0;
                for (var i = 0; i < calendar.resources.length; i++) {
                    if (!calendar.resources[i].hidden) {
                        if (fixedY === y) {
                            y = i;
                            break;
                        }
                        fixedY += 1;
                    }
                }
            }

            if (!this.cellProperties) {
                this.cellProperties = {};
            }

            if (this.cellProperties[index]) {
                return this.cellProperties[index];
            }

            if (this._cellPropertiesLazyLoading) {
                this.cellProperties[index] = calendar._getExpandedCell(x, y);
            }

            if (!this.cellProperties[index]) {
                var row = rowlist[y];
                var resource = row.id;
                var rowOffset = row.start.getTime() - calendar._visibleStart().getTime();
                var itc = calendar._getItline(x);
                var start = itc.start.addTime(rowOffset);
                var end = itc.end.addTime(rowOffset);

                var ibj = {};
                ibj.start = start;
                ibj.end = end;
                ibj.resource = resource;

                var cell = {};
                cell.business = calendar.isBusiness(ibj);

                if (row.cellsDisabled) {
                    calendar._bcrCache._dirtyDisabled = true;
                    cell.disabled = true;
                }

                this.cellProperties[index] = cell;
            }

            return this.cellProperties[index];
        };

        this._copyCellProperties = function(source, x, y) {
            var index = x + '_' + y;
            this.cellProperties[index] = {};
            copyProps(source, this.cellProperties[index], calendar._cellProps);

            //copyProps(source, this.cellProperties[index]);
            return this.cellProperties[index];
        };

        this._getExpandedCell = function(x, y) {
            if (!this.cellConfig) {
                return null;
            }

            var config = this.cellConfig;

            var cell = this.cellProperties[x + "_" + y];

            if (!cell && config.vertical) {
                cell = this.cellProperties[x + "_0"];
            }

            if (!cell && config.horizontal) {
                cell = this.cellProperties["0_" + y];
            }

            if (!cell && config["default"]) {
                cell = config["default"];
            }

            var copy = {};
            copyProps(cell, copy, calendar._cellProps);

            return copy;
        };

        this._expandCellProperties = function() {

            if (this._cellPropertiesLazyLoading) {
                return;
            }

            if (this._cellPropertiesExpanded) {
                return;
            }

            this._cellPropertiesExpanded = true;

            if (!this.cellConfig) {
                return;
            }

            var config = this.cellConfig;

            if (config.vertical) {
                for (var x = 0; x < config.x; x++) {
                    var def = this.cellProperties[x + "_0"];
                    if (!def) {
                        continue;
                    }
                    for (var y = 1; y < config.y; y++) {
                        this._copyCellProperties(def, x, y);
                    }
                }
            }

            if (config.horizontal) {
                for (var y = 0; y < config.y; y++) {
                    var def = this.cellProperties["0_" + y];
                    if (!def) {
                        continue;
                    }
                    for (var x = 1; x < config.x; x++) {
                        this._copyCellProperties(def, x, y);
                        //this.cellProperties[x + "_" + y] = def;
                    }
                }
            }

            if (config["default"]) {
                var def = config["default"];
                for (var y = 0; y < config.y; y++) {
                    for (var x = 0; x < config.x; x++) {
                        if (!this.cellProperties[x + "_" + y]) {
                            this._copyCellProperties(def, x, y);
                        }
                    }
                }
            }
        };

        this.isBusiness = function(cell, forceBusinessDay) {
            var start = cell.start;
            var end = cell.end;

            var cellDuration = (end.getTime() - start.getTime()) / (1000 * 60);  // minutes

            if (cellDuration <= 1440) {  // for one day per cell and lower only
                // if (calendar.viewType !== "Days" && !calendar.businessWeekends) {
                if (!calendar.businessWeekends && !forceBusinessDay) {
                    if (cell.start.dayOfWeek() === 0 || cell.start.dayOfWeek() === 6) {
                        return false;
                    }
                }
            }
            if (cellDuration < 720) {
                var startHour = start.getHours();
                startHour += start.getMinutes() / 60.0;
                startHour += start.getSeconds() / 3600.0;
                startHour += start.getMilliseconds() / 3600000.0;

                var begins = this.businessBeginsHour;
                var ends = this.businessEndsHour;
                if (ends === 0) {
                    ends = 24;
                }

                if (begins === ends) {
                    return false;
                }

                if (begins < ends) {
                    if (startHour < begins) {
                        return false;
                    }

                    if (ends >= 24) {
                        return true;
                    }
                    if (startHour >= ends) {
                        return false;
                    }
                }
                else {
                    if (startHour < ends) {
                        return true;
                    }
                    if (startHour >= begins) {
                        return true;
                    }
                    return false;
                }

            }

            return true;
        };

        this._versionCheck = function() {

            // check licensing restrictions

            switch (calendar._productCode) {
                case "aspnet":
                    if (!this._isAspnetWebForms()) {
                        throw new DayPilot.Exception("ASP.NET WebForms environment required. https://doc.daypilot.org/common/asp-net-webforms-required/");
                    }
                    break;
                case "netmvc":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-asp-net-mvc/");
                    }
                    break;
                case "javaxx":
                    if (!this.backendUrl) {
                        throw new DayPilot.Exception("DayPilot.Scheduler.backendUrl required. https://doc.daypilot.org/common/backendurl-required-java/");
                    }
                    break;
            }
        };

        this._show = function() {
            if (this.nav.top.style.visibility === 'hidden') {
                this.nav.top.style.visibility = 'visible';
            }
        };

        this._visible = function() {
            var el = calendar.nav.top;
            if (!el) {
                return false;
            }
            return el.offsetWidth > 0 && el.offsetHeight > 0;
        };

        this._waitForVisibility = function() {
            var visible = calendar._visible;

            if (visible()) {
                calendar._watchWidthChanges();
                return;
            }

            if (!calendar._visibilityInterval) {
                //calendar.debug.message("Not visible during init, starting visibilityInterval");
                calendar._visibilityInterval = setInterval(function() {
                    if (visible()) {
                        //calendar.debug.message("Made visible, calling .show()");
                        clearInterval(calendar._visibilityInterval);
                        calendar.show();
                        calendar._autoRowHeaderWidth();

                        calendar._watchWidthChanges();
                    }
                }, 100);
            }
        };

        // sets the total height
        this._setHeight = function(pixels) {
            if (this.heightSpec !== "Parent100Pct") {
                this.heightSpec = "Fixed";
            }
            this.height = pixels - (this._getTotalHeaderHeight() + 2);
            this._updateHeight();
        };

        this.setHeight = this._setHeight;

        this._findRowByResourceId = function(id) {
            return calendar._rowcacheFor(id).first();
        };

        this._loadTop = function() {
            if (this.id && this.id.tagName) {
                this.nav.top = this.id;
            }
            else if (typeof this.id === "string") {
                this.nav.top = document.getElementById(this.id);
                if (!this.nav.top) {
                    throw new DayPilot.Exception("DayPilot.Scheduler: The placeholder element not found: '" + id + "'.");
                }
            }
            else {
                throw new DayPilot.Exception("DayPilot.Scheduler() constructor requires the target element or its ID as a parameter");
            }
        };

        this._shortInit = function() {

            // Java
            this.rowHeaderColumnsMode = "Legacy";

            this._prepareVariables();
            this._loadResources();
            this._createCells();
            this._updateRowHeaderHideIconVisibility();  // must be called after _loadResources()
            this._resize();
            this._registerGlobalHandlers();
            this._registerDispose();
            DayPilotScheduler._register(this);
            this._fireAfterRenderDetached(this.afterRenderData, false);
            this._registerOnScroll();
            this._startAutoRefresh();
            this._callBack2("Init");
        };

        this.init = function() {
            if (this._initialized) {
                throw new DayPilot.Exception("This instance is already initialized. Use update() to change properties.")
            }
            this._loadTop();

            if (this.nav.top.dp) {
                if (this.nav.top.dp === calendar) {
                    return calendar;
                }
                if (this._isAspnetWebForms()) { // updatepanel
                    return calendar;
                }
                throw new DayPilot.Exception("The target placeholder was already initialized by another DayPilot component instance.");
            }
            this._initVer();
            this._initUpdateBased();
            this._waitForVisibility();
            this._initKeyboard();
            return this;
        };

        this._initKeyboard = function() {
            if (calendar.keyboardEnabled) {
                focus._initGrid();
            }
        };

        this._initSelectedEvents = function() {
            calendar.multiselect._loadList(calendar.selectedEvents);
        };


        this._initUpdateBased = function() {

            this._initPrepareDiv();

            var loadFromServer = this._isShortInit();

            if (loadFromServer) {
                this._shortInit();
                this._initialized = true;
                this._clearCachedValues();
                return;
            }

            this._registerGlobalHandlers();
            this._registerDispose();
            DayPilotScheduler._register(this);
            this._registerOnScroll();

            this._initSelectedEvents();

            if (calendar.zoomLevels && calendar.zoomLevels[calendar.zoom.active]) {
                calendar.zoom.setActive(calendar.zoom.active);
            }

            if (!calendar._initialized && infitools._isEnabled()) {
                if (!calendar._scrollToAfterInit) {
                    calendar._scrollToAfterInit = {"date": calendar.startDate};
                }
            }

            this._update();

            var angular = calendar._angular.scope || calendar._angular2.enabled;

            if (calendar.scrollToDate) {
                calendar.scrollTo(calendar.scrollToDate);
            }
            else if (calendar.scrollX || calendar.scrollY) {
                calendar.setScroll(calendar.scrollX, calendar.scrollY);
            }
            else if (!angular) {
                calendar._onScroll();
            }

            if (calendar.scrollToResourceId) {
                calendar.scrollToResource(calendar.scrollToResourceId);
                calendar.scrollToResourceId = null;
            }

            var setScrollY = function() {
                if (calendar.scrollY) {
                    calendar.setScroll(calendar.scrollX, calendar.scrollY);
                }
            };

            window.setTimeout(setScrollY, 200);

            if (this.messageHTML) {
                window.setTimeout(function() { calendar.message(calendar.messageHTML); }, 0);
            }

            this._startAutoRefresh();

            this._clearCachedValues();
            this._fireAfterRenderDetached(this.afterRenderData, false);
            //this.debug.message("Init complete.");

            if (calendar.initEventEnabled) {
                setTimeout(function() {
                    calendar._callBack2("Init");
                });
            }

            this._postInit();

            this._initialized = true;
            this._canBeDisposed = true;

            var p = calendar._scrollToAfterInit;
            if (p) {
                calendar.scrollTo(p.date, p.animated, p.position);
            }
/*
            else if (!infitools._isEnabled()) {
                calendar._onScroll();
            }
*/
            else {
                calendar._onScroll();
            }

            // allow infinite scrolling shifts
            calendar._scrollToAfterInit = null;
        };

        this._adjustApi = function() {
            if (calendar._serverBased()) {
                delete calendar.infinite;
            }
        };

        this._specialHandling = null;
        this._loadOptions = function(options) {
            if (!options) {
                return;
            }

            var specialHandling = {
                "resources": {
                    "preInit": function() {
                        var resources = this.data;
                        // calendar._angular2._resourcesFromConfig = !!resources;
                        if (!resources) {
                            return;
                        }
                        calendar.resources = resources;
                    }
                },
                "events": {
                    "preInit": function() {
                        var events = this.data;
                        // calendar._angular2._eventsFromConfig = !!events;
                        if (!events) {
                            return;
                        }
                        if (DayPilot.isArray(events.list)) {
                            calendar.events.list = events.list;
                        }
                        else {
                            calendar.events.list = events;
                        }
                    },
                    "postInit": function() {

                    }
                },
                "links": {
                    "preInit": function() {
                        var links = this.data;
                        if (!links) {
                            return;
                        }
                        if (DayPilot.isArray(links.list)) {
                            calendar.links.list = links.list;
                        }
                        else {
                            calendar.links.list = links;
                        }
                    },
                    "postInit": function() {

                    }
                },
                "scrollTo": {
                    "preInit": function() {

                    },
                    "postInit": function() {
                        if (this.data) {
                            calendar._scrollTo(this.data, options.scrollToAnimated, options.scrollToPosition);
                        }
                    }
                },
                "scrollX": {
                    "postInit": function() {
                        if (this.data) {
                            calendar._setScrollX(this.data);
                        }
                    }
                },
                "scrollY": {
                    "postInit": function() {
                        if (this.data) {
                            calendar._setScrollY(this.data);
                        }
                    }
                },
                "zoom": {
                    "preInit": function() {
                        var index = this.data;

                        if (typeof index === "string") {
                            var id = index;
                            index = calendar.zoom._findById(id);
                        }

                        var levelChanged = index !== calendar.zoom.active;

                        var date = calendar.zoom._getPosition();
                        var args = calendar.zoom._applyLevelProps(index, date);

                        if (levelChanged) {
                            this.date = date;
                        }
                        else {
                            this.date = null;
                        }
                    },
                    "postInit": function() {
                        if (this.date) {
                            calendar._scrollTo(this.date, false, calendar.zoomPosition);
                        }
                    }
                },
            };
            calendar._specialHandling = specialHandling;

            if (calendar._angular2.scrollToRequested) {
                specialHandling.scrollTo.data = calendar._angular2.scrollToRequested;
                calendar._angular2.scrollToRequested = null;
            }
            if (calendar._angular2.scrollXRequested) {
                specialHandling.scrollX.data = calendar._angular2.scrollXRequested;
                calendar._angular2.scrollXRequested = null;
            }
            if (calendar._angular2.scrollYRequested) {
                specialHandling.scrollY.data = calendar._angular2.scrollYRequested;
                calendar._angular2.scrollYRequested = null;
            }

            for (var name in options) {
                if (!specialHandling[name]) {
                    calendar[name] = options[name];
                }
            }

            // call preInit after initialization of plain items
            for (var name in options) {
                if (specialHandling[name]) {
                    var item = specialHandling[name];
                    item.data = options[name];
                    if (item.preInit) {
                        item.preInit();
                    }
                }
            }

        };

        this._postInit = function() {
            var specialHandling = calendar._specialHandling;
            for (var name in specialHandling) {
                var item = specialHandling[name];
                if (item.postInit) {
                    item.postInit();
                }
            }
            calendar._specialHandling = {};
        };

        this.diag = function() {
            var result = {};

            result.dataEvents = calendar.events.list && calendar.events.list.length;
            result.dataRows = calendar.rowlist && calendar.rowlist.length;
            result.dataTimeline = calendar.itline && calendar.itline.length;
            result.dataCells = result.dataTimeline * result.dataRows;

            result.renderedEvents = calendar.elements.events.length;
            // result.renderedEventsAvgSize = result.renderedEventsDom / result.renderedEvents;
            result.renderedCells = calendar.elements.cells.length;
            result.renderedRows = calendar.divResScroll.firstChild.childNodes.length - 1;

            result.domEvents = calendar.divEvents.getElementsByTagName("*").length;
            result.domCells = calendar.divCells.getElementsByTagName("*").length;
            result.domRows = calendar.divResScroll.getElementsByTagName("*").length;

            return result;
        };


        this.temp = {};

        // backwards compatibility, keep until 2019-03-30
        this.temp.allowDuplicateEventIds = false;

        // communication between components
        this.internal = {};
        // ASP.NET
        this.internal.initialized = function() {
            return calendar._initialized;
        };

        // Areas
        this.internal.dragInProgress = this._dragInProgress;
        this.internal.startMoving = this._startMoving;
        // DayPilot.Action
        this.internal.invokeEvent = this._invokeEvent;
        // DayPilot.Menu
        this.internal.eventMenuClick = this._eventMenuClick;
        this.internal.timeRangeMenuClick = this._timeRangeMenuClick;
        this.internal.resourceHeaderMenuClick = this._rowMenuClick;
        this.internal.linkMenuClick = this._linkMenuClick;
        // DayPilot.Bubble
        this.internal.bubbleCallBack = this._bubbleCallBack;
        this.internal.findEventDiv = this._findEventDiv;
        this.internal.rowStartMoving = this._rowtools._startMoving;
        // DayPilot.Gantt
        this.internal.getNodeChildren = this._getNodeChildren;
        this.internal.callback = function() {
            calendar._callBack2.apply(calendar, arguments);
        };
        this.internal.createRowObject = this._createRowObject;
        this.internal.restools = this._restools;
        this.internal.gantt = null;
        // DayPilot.Event
        this.internal.adjustEndIn = calendar._adjustEndIn;
        this.internal.adjustEndNormalize = calendar._adjustEndNormalize;
        this.internal.xssTextHtml = calendar._xssTextHtml;

        this.internal.touch = calendar._touch;

        // DayPilot.Kanban
        this.internal.cssNames = calendar._css;
        this.internal.enableCellStacking = function(autoHeight) {
            calendar._cellStacking = true;
            calendar._cellStackingAutoHeight = autoHeight;
        };
        this.internal.deleteDragSource = function() {
            calendar._deleteDragSource();
        };

        // Angular2
        this.internal.skipUpdate = calendar._angular2.skipUpdate;
        this.internal.skipped = calendar._angular2.skipped;
        this.internal.loadOptions = calendar._loadOptions;
        this.internal.postInit = calendar._postInit;
        this.internal.enableAngular2 = function() { calendar._angular2.enabled = true; };
        this.internal.eventsFromAttr = function() { calendar._angular2._eventsFromAttr = true; };
        this.internal.resourcesFromAttr = function() { calendar._angular2._resourcesFromAttr = true; };
        this.internal.evImmediateRefresh = function() { calendar.events._immediateRefresh(); };

        // React
        this.internal.enableReact = function (react, reactDOM) {
            calendar._react.react = react;
            calendar._react.reactDOM = reactDOM;
        };
        this.internal.reactRefs = function() {
            return copyProps(calendar._react, {}, ["react", "reactDOM"]);
        };

        this.Init = this.init;

        this._loadOptions(options);

    };

    debug = new DayPilot.Scheduler().v === "${v\u007d";

    DayPilot.Row = function(row, calendar) {
        if (!row) {
            throw new DayPilot.Exception("No row object supplied when creating DayPilot.Row");
        }
        if (!calendar) {
            throw new DayPilot.Exception("No parent control supplied when creating DayPilot.Row");
        }

        this._original = {};
        var original = this._original;

        original.id = row.id;
        original.name = row.name;
        original.data = row.resource;
        original.tags = row.tags;

        var r = this;
        r.isRow = true;
        r.menuType = 'resource';
        r.start = row.start;
        r.name = row.name;
        r.value = row.id;
        r.id = row.id;
        r.tags = row.tags;
        r.bubbleHtml = row.bubbleHtml;
        r.index = row.index;
        r.displayY = row.displayY;
        r.level = row.level;
        r.calendar = calendar;
        r.data = row.resource;
        r.grid = row.grid;
        r._row = row;
        r.$ = {};
        r.$.row = row;
        r.toJSON = function(key) {
            var json = {};
            json.start = this.start;
            json.name = this.name;
            json.value = this.value;
            json.id = this.id;
            json.index = this.index;

            return json;
        };

        r.parent = function() {
            if (!r._row._makeVisibleParent) {
                return null;
            }
            return calendar._createRowObject(r._row._makeVisibleParent);
        };

        r.children = function() {
            var list = createList(r.$.row.children).map(function(i) {
                return calendar._createRowObject(calendar.rowlist[i]);
            });

            list.add = function(child) {
                var r1 = r.$.row.resource;
                if (!r1.children) {
                    r1.children = [];
                }
                r1.children.push(child);
            };

            return list;
        };

        r.splitParent = function() {
            if (r._row.split.parent) {
                return calendar._createRowObject(r._row.split.parent);
            }
            return null;
        };

        r.splitChildren = function() {
            var list = r._row.split.list || [];
            return list.map(function(c) {
                return calendar._createRowObject(c);
            });
        };

        r.loaded = function() {
            return r._row.loaded;
        };

        Object.defineProperty(r, "hidden", {
            get: function() {
                return r._row.hidden;
            },
        });

        Object.defineProperty(r, "hiddenUsingFilter", {
            get: function() {
                return r._row._hiddenUsingFilter;
                },
            set: function(val) {
                r._row._hiddenUsingFilter = val;
                if (!val) {
                    r._row.hidden = !r._row._allParentsExpanded();
                }
            }
        });

        r.cells = {};
        r.cells.all = function() {
            var list = [];
            var maxX = calendar.itline.length;
            var y = r.index;
            for(var x = 0; x < maxX; x++) {
                var cell = calendar.cells.findXy(x, y, r.grid);
                list.push(cell[0]);
            }
            return calendar._cellArray(list);
        };

        r.cells.forRange = function(start, end) {
            var row = r;
            var rowOffset = row.start.getTime() - calendar._visibleStart().getTime();

            start = new DayPilot.Date(start);
            end = new DayPilot.Date(end);

            var rowStart = calendar._visibleStart().addTime(rowOffset);
            var rowEnd = calendar._visibleEnd().addTime(rowOffset);

            if (start < rowStart) {
                start = rowStart;
            }

            if (end > rowEnd) {
                end = rowEnd;
            }

            var startCell = calendar.cells.find(start, r)[0];
            var endCell = calendar.cells.find(end.addTime(-1), r)[0];

            if (!startCell) {
                return null;
            }

            if (!endCell) {
                return null;
            }

            if (startCell.y !== endCell.y) {
                return null;
            }

            var y = startCell.y;

            //var cell = calendar.cells._cell(x, y);
            var list = [];

            for (var x = startCell.x; x <= endCell.x; x++) {
                list.push(calendar.cells._cell(x, y, startCell.grid));
            }
            return calendar._cellArray(list);

        };

        r.cells.totalDuration = function() {
            return new DayPilot.Duration(r.cells.all().map(function(cell) { return cell.end.getTime() - cell.start.getTime();}).reduce(function(acc, val) { return acc + val; }, 0));
        };

        r.events = {};
        r.events.all = function() {
            var list = createList();
            for (var i = 0; i < r._row.events.length; i++) {
                list.push(r._row.events[i]);
            }
            return list;
        };

        r.events.isEmpty = function() {
            return r._row.events.length === 0;
        };

        r.events.forRange = function(start, end) {
            return r._row.events.forRange(start, end);
        };

        r.events.totalDuration = function() {
            var ticks = 0;
            r.events.all().forEach(function(item) {
                ticks += item.part.end.getTime() - item.part.start.getTime();
            });
            return new DayPilot.Duration(ticks);
        };

        r.groups = {};
        r.groups.collapseAll = function() {
            for (var i = 0; i < r._row.blocks.length; i++) {
                var block = r._row.blocks[i];
                var group = new EventGroup(block);
                group._collapseDontRedrawRow();
            }

            calendar._updateRowHeights();
            calendar._updateRowsNoLoad([r._row]);
            calendar._updateHeight();

        };
        r.groups.expandAll = function() {
            for (var i = 0; i < r._row.blocks.length; i++) {
                var block = r._row.blocks[i];
                var group = new EventGroup(block);
                group._expandDontRedrawRow();
            }

            calendar._updateRowHeights();
            calendar._updateRowsNoLoad([r._row]);
            calendar._updateHeight();
            // make sure that events that were outside of the viewport are rendered as well
            calendar._drawEvents();
        };
        r.groups.expanded = function() {
            var list = [];
            for (var i = 0; i < r._row.blocks.length; i++) {
                var block = r._row.blocks[i];
                if (block.expanded && block.lines.length > calendar.groupConcurrentEventsLimit) {
                    list.push(new EventGroup(block));
                }
            }
            return createList(list);
        };
        r.groups.collapsed = function() {
            var list = [];
            for (var i = 0; i < r._row.blocks.length; i++) {
                var block = r._row.blocks[i];
                if (!block.expanded) {
                    list.push(new EventGroup(block));
                }
            }
            return createList(list);
        };
        r.groups.all = function() {
            var list = [];
            for (var i = 0; i < r._row.blocks.length; i++) {
                var block = r._row.blocks[i];
                list.push(new EventGroup(block));
            }
            return createList(list);
        };

        r.events.collapseGroups = r.groups.collapseAll;
        r.events.expandGroups = r.groups.expandAll;

        r.column = function(i) {
            return new RowHeaderColumn(r, i);
        };

        r.toggle = function() {
            calendar._toggle(r.index);
        };

        r.collapse = function() {
            if (r.$.row.expanded) {
                r.toggle();
            }
        };

        r.expand = function() {
            if (!r.$.row.expanded) {
                r.toggle();
            }
        };

        r.remove = function() {
            calendar.rows.remove(r);
        };

        r.edit = function() {
            calendar.rows.edit(r);
        };

        r.addClass = function(cssClass) {
            var row = r;
            var table = calendar.divHeader;

            var row = table.rows[row.index];
            if (row) {
                var cells = createList(row.cells).map(function(cell) { return cell.cellDiv; });
                addClass(cells, cssClass);
            }

            r.$.row.cssClass = DayPilot.Util.addClassToString(r.$.row.cssClass, cssClass);
            r.data.cssClass = cssClass;
        };

        r.removeClass = function(cssClass) {
            var row = r;
            var table = calendar.divHeader;

            var row = table.rows[row.index];
            if (row) {
                var cells = createList(row.cells).map(function(cell) { return cell.cellDiv; });
                removeClass(cells, cssClass);
            }

            r.$.row.cssClass = DayPilot.Util.removeClassFromString(r.$.row.cssClass, cssClass);
            r.data.cssClass = DayPilot.Util.removeClassFromString(r.data.cssClass, cssClass);
        };

        var EventGroup = function(block) {

            var findDiv = function(block) {
                for (var i = 0; i < calendar.elements.events.length; i++) {
                    var div = calendar.elements.events[i];
                    if (div.event === block) {
                        return div;
                    }
                }
                return null;
            };

            this._expandDontRedrawRow = function() {
                block.expanded = true;

                var list = calendar._blockExpandedEvents;
                createList(block.events).forEach(function(e) {
                    list.push(e.id());
                });

                var div = findDiv(block);
                if (div) {
                    calendar._deleteBlock(div);
                    var elindex = indexOf(calendar.elements.events, div);
                    if (elindex !== -1) {
                        calendar.elements.events.splice(elindex, 1);
                    }
                }
            };

            this.expand = function() {
                this._expandDontRedrawRow();

                calendar._updateRowHeights();
                calendar._updateRowsNoLoad([block.row]);
                calendar._updateHeight();
                calendar._drawEvents();
            };

            this._collapseDontRedrawRow = function() {
                if (block.lines.length > calendar.groupConcurrentEventsLimit) {
                    block.expanded = false;

                    var collapsed = createList(block.events).map(function(e) { return e.id()});
                    calendar._blockExpandedEvents = calendar._blockExpandedEvents.filter(function(item) {
                        return !contains(collapsed, item);
                    });
                }
            };

            this.collapse = function() {
                this._collapseDontRedrawRow();

                calendar._updateRowHeights();
                calendar._updateRowsNoLoad([block.row]);
                calendar._updateHeight();
            };

        };

        var RowHeaderColumn = function(row, i) {
            this.html = function(html) {
                var table = row.calendar.divHeader;

                var row = table.rows[row.index];
                if (!row) {
                    throw new DayPilot.Exception("Row not rendered");
                }

                var cell = row.cells[i];
                var text = cell.textDiv;

                if (typeof html === "undefined") {
                    return text.innerHTML;
                }
                else {
                    text.innerHTML = html;
                }
            };
        };
    };

    // internal moving
    DayPilotScheduler._moving = null;
    DayPilotScheduler._movingEvent = null;

    // internal resizing
    DayPilotScheduler._originalMouse = null;
    DayPilotScheduler._resizing = null;
    DayPilotScheduler._resizingEvent = null;
    DayPilotScheduler._preventEventClick = false;

    DayPilotScheduler._globalHandlers = false;
    DayPilotScheduler._timeRangeTimeout = null;

    // selecting
    DayPilotScheduler._selectedCells = null;

    DayPilotScheduler._dragStart = function(element, duration, id, text) {

        DayPilot.us(element);

        var drag = DayPilotScheduler._drag = {};
        drag.element = element;
        drag.duration = duration;
        drag.text = text;
        drag.id = id;
        //drag.shadowType = type ? type : 'Fill';  // default value
        drag.data = { "id":id, "text": text, "duration":duration, "externalHtml": text};

        return false;
    };

    DayPilot.Scheduler.def = {};

    DayPilot.Scheduler.startDragging = function(options) {
        var options = options || {};

        var element = options.element;
        var removeElement = options.keepElement ? null : element;

        DayPilot.us(element);

        var drag = DayPilotScheduler._drag = {};
        drag.element = removeElement;
        drag.id = options.id;
        drag.duration = options.duration || 60;
        drag.text = options.text || "";
        drag.data = options;
        drag._dragOptions = options;
        drag._dragData = options.data;

        return false;
    };

    /*
     * options: {
     *      element: dom element,
     *      duration: duration in minutes,
     *      text: event text,
     *      id: id,
     *      onDragStart: function(args)
     *          args.data - options object
     *          args.preventDefault() - cancels the action
     * }
     */
    DayPilot.Scheduler.makeDraggable = function(options) {
        options = options || {};
        var element = options.element;
        var removeElement = options.keepElement ? null : (options.remove || element);
        var data = options.data || {};

        var id = typeof options.id !== "undefined" ? options.id : data.id;
        var text = typeof options.text === "string" ? options.text : data.text || "";
        var duration = options.duration || data.duration;

        if (duration instanceof DayPilot.Duration) {
            duration = duration.totalSeconds();
        }
        if (!duration) {
            if (data.start && data.end) {
                duration = new DayPilot.Duration(data.start, data.end).totalSeconds();
            }
            else {
                duration = 60;
            }
        }

        if (!element) {
            throw new DayPilot.Exception("makeDraggable(options): options.element must be specified");
        }

        DayPilot.us(element);  // make it unselectable
        DayPilot.re(element, "mousedown", function(ev) {
            if (!mouseButton(ev).left) {
                return;
            }

            startDragging();

            var element = (ev.target || ev.srcElement);
            if (element.tagName) {
                var tagname = element.tagName.toLowerCase();
                if(tagname === "textarea" || tagname === "select" || tagname === "input") {
                    return false;
                }
            }
            ev.preventDefault();
            return false;
        });

        DayPilot.reNonPassive(element, "touchstart", function(ev) {
            var holdfor = 0;
            window.setTimeout(function() {
                startDragging();
                DayPilotScheduler._gTouchMove(ev);
                ev.preventDefault();
            }, holdfor);

            ev.preventDefault();
        });

        function startDragging() {
            // TODO create drag.event = new DayPilot.Event() here
            // TODO merge with DayPilot.Scheduler.startDragging()

            var drag = DayPilotScheduler._drag = {};
            drag.element = removeElement;
            drag.id = id;
            drag.duration = duration;
            drag.text = text;
            //drag.shadowType = 'Fill';  // default value
            drag.data = options;
            drag._dragOptions = options;
            drag._dragData = options.data;
        }
    };

    DayPilot.Scheduler.stopDragging = function() {

        if (DayPilotScheduler._drag) {
            if (DayPilotScheduler._drag._schedulerSourceEvent) {
                var e = DayPilotScheduler._drag._schedulerSourceEvent;
                var srcCal = e.event.calendar;
                if (srcCal) {
                    removeClass(e, srcCal._prefixCssClass(calendar._css.eventMovingSource));
                }
            }
        }
            // external
        DayPilotScheduler._dragStop();

        // resizing
        if (DayPilotScheduler._resizing) {
            deleteElement(DayPilotScheduler._resizingShadow);
            DayPilotScheduler._resizing = null;
            DayPilotScheduler._resizingEvent = null;
            DayPilotScheduler._resizingShadow = null;
        }

        // moving
        if (DayPilotScheduler._moving) {
            var calendar = DayPilotScheduler._movingEvent.calendar;
            if (calendar) {
                calendar._clearMovingShadow();
                calendar._lastEventMoving = null;
                removeClass(DayPilotScheduler._moving, calendar._prefixCssClass(calendar._css.eventMovingSource));
            }

            deleteElement(DayPilotScheduler._movingShadow);
            DayPilotScheduler._moving = null;
            DayPilotScheduler._movingEvent = null;
            DayPilotScheduler._movingShadow = null;
        }


        if (DayPilotScheduler._range) {
            var calendar = DayPilotScheduler._range.calendar;
            calendar.clearSelection();
            DayPilotScheduler._range = null;
        }

        body().style.cursor = '';

        createList(DayPilotScheduler._registered).forEach(function(calendar) {
            calendar._stopScroll();
            calendar._clearShadowHover();
            calendar._rowtools._resetMoving();
            calendar._multimove.clear();
        });
    };


    DayPilot.Scheduler.registerDropTarget = function(options) {
        options = options || {};
        var element = options.element;

        var onDragOver = options.onDragOver;
        var isDragOver = typeof onDragOver === "function";
        var onDrop = options.onDrop;
        var isDrop = typeof onDrop === "function";
        var onDragLeave = options.onDragLeave;
        var isDragLeave = typeof onDragLeave === "function";

        if (!element) {
            throw new DayPilot.Exception("registerDropTarget(options): options.element must be specified");
        }

        element.addEventListener("mousemove", function(ev) {
            if (!DayPilotScheduler._drag) {
                return;
            }
            var event = DayPilotScheduler._drag.event;
            if (!event) {
                return;
            }
            if (!isDragOver) {
                return;
            }
            var args = {};
            args.e = event;
            onDragOver(args);
        });

        element.addEventListener("mouseleave", function(ev) {
            if (!DayPilotScheduler._drag) {
                return;
            }
            var event = DayPilotScheduler._drag.event;
            if (!event) {
                return;
            }
            if (!isDragLeave) {
                return;
            }
            var args = {};
            args.e = event;
            onDragLeave(args);
        });

        element.addEventListener("mouseup", function(ev) {
            if (!DayPilotScheduler._drag) {
                return;
            }
            var event = DayPilotScheduler._drag.event;
            if (!event) {
                return;
            }
            if (!isDrop) {
                return;
            }

            var args = {};
            args.e = event;
            onDrop(args);

        });


    };

    DayPilotScheduler._dragStop = function() {
        if (DayPilotScheduler._gShadow) {
            body().removeChild(DayPilotScheduler._gShadow);
            DayPilotScheduler._gShadow = null;
        }
        DayPilotScheduler._drag = null;
    };

    DayPilotScheduler._externalDrop = function() {
        var drag = DayPilotScheduler._drag;
        if (!drag) {
            return;
        }
        var options = drag && drag._dragOptions;
        var onDrop = options && options.onDrop;
        if (typeof onDrop === "function") {
            var args = {};
            args.options = options;
            onDrop(args);
        }
    };

    DayPilotScheduler._register = function(calendar) {
        if (!DayPilotScheduler._registered) {
            DayPilotScheduler._registered = createList();
            DayPilotScheduler._registered.out = function() {
                var list = DayPilotScheduler._registered;
                list.forEach(function(c) {
                     c._out();
                });
            };
        }
        for (var i = 0; i < DayPilotScheduler._registered.length; i++) {
            if (DayPilotScheduler._registered[i] === calendar) {
                return;
            }
        }
        DayPilotScheduler._registered.push(calendar);

    };

    DayPilotScheduler._unregister = function(calendar) {
        var a = DayPilotScheduler._registered;
        if (a) {
            var i = indexOf(a, calendar);
            if (i !== -1) {
                a.splice(i, 1);
            }
            if (a.length === 0) {
                a = null;
            }
        }

        if (!a) {
            DayPilot.ue(document, 'mousemove', DayPilotScheduler._gMouseMove);
            DayPilot.ue(document, 'mouseup', DayPilotScheduler._gMouseUp);
            DayPilot.ue(document, 'mousedown', DayPilotScheduler._gMouseDown);
            DayPilot.ue(document, 'touchmove', DayPilotScheduler._gTouchMove);
            DayPilot.ue(document, 'touchend', DayPilotScheduler._gTouchEnd);

            DayPilot.ue(window, 'keyup', DayPilotScheduler._gKeyUp);
            //DayPilot.ue(window, 'unload', DayPilotScheduler._gUnload);
            DayPilotScheduler._globalHandlers = false;
        }
    };

    function calendarFromTouchEvent(ev) {
        var clientX = ev.touches[0].clientX;
        var clientY = ev.touches[0].clientY;
        var el = document.elementFromPoint(clientX, clientY);
        while (el && el.parentNode) {
            el = el.parentNode;
            if (el.daypilotMainD) {
                return el.calendar;
            }
        }
        return false;
    }

    function touchMousePos(ev) {
        var x = ev.touches[0].pageX;
        var y = ev.touches[0].pageY;

        var mousePos = {};
        mousePos.x = x;
        mousePos.y = y;
        return mousePos;
    }

    function status(msg, clear) {
        var status = document.getElementById("status");
        if (!status) {
            return;
        }
        if (clear) {
            status.innerHTML = "";
        }

        status.innerHTML += " " + msg;
    }

    DayPilotScheduler._gTouchMove = function(ev) {

        // hide menu, it would point to a wrong position
/*        if (typeof DayPilot.Menu !== "undefined") {
            DayPilot.Menu.hide({"calendar": calendar});
        }*/


        if (DayPilotScheduler._resizing) {
            var calendar = DayPilotScheduler._resizing.event.calendar;
            calendar.coords = calendar._touch._relativeCoords(ev);
            calendar._touch._updateResizing();
            // ev.preventDefault();
        }

        if (DayPilotScheduler._moving && !DayPilotScheduler._drag) {
            // ev.preventDefault();

            var calendar = DayPilotScheduler._movingEvent.calendar;
            calendar.coords = calendar._touch._relativeCoords(ev);

            calendar._touch._updateMoving();

            (function dragOut() {
                if (!calendar.dragOutAllowed) {
                    return;
                }

                var targetCal = calendarFromTouchEvent(ev);

                if (!targetCal || targetCal !== calendar) {

                    var e = DayPilotScheduler._movingEvent;

                    DayPilotScheduler._drag = {};
                    var drag = DayPilotScheduler._drag;

                    drag.id = e.id();
                    drag.text = e.text();

                    drag._schedulerSourceEvent = DayPilotScheduler._moving;
                    drag.element = null;
                    drag.duration = (e.rawend().getTime() - e.start().getTime()) / 1000;
                    drag.text = e.text();
                    drag.id = e.id();

                    drag.event = copyProps(e, new DayPilot.Event());

                    calendar._clearShadowHover();

                    deleteElement(DayPilotScheduler._movingShadow);

                    DayPilotScheduler._movingShadow.calendar = null;
                    DayPilotScheduler._movingShadow = null;

                    // reset
                    DayPilotScheduler._moveDragStart = null;

                    DayPilotScheduler._registered.out();

                }
            })();
        }

        if (DayPilotScheduler._drag) {
            // ev.preventDefault();

            var mousePos = touchMousePos(ev);

            var calendar = calendarFromTouchEvent(ev);

                if (calendar) {

                    // hide the global shadow
                    if (DayPilotScheduler._gShadow) {
                        body().removeChild(DayPilotScheduler._gShadow);
                    }
                    DayPilotScheduler._gShadow = null;

                    calendar.coords = calendar._touch._relativeCoords(ev);

                    if (!DayPilotScheduler._movingShadow && calendar.rowlist.length > 0) {
                        if (!DayPilotScheduler._moving) { // can be null if the location is forbidden (first two rows in IE)
                            DayPilotScheduler._moving = {};

                            var event = DayPilotScheduler._drag.event;
                            if (!event) {
                                /*var now = calendar.itline[0].start;
                                var ev;

                                var data = DayPilotScheduler._drag._dragData;
                                if (data) {
                                    ev = copyProps(data, {});
                                    ev.start = now;
                                    ev.end = now.addSeconds(DayPilotScheduler._drag.duration);
                                }
                                else {
                                    // backwards compatibility

                                    ev  = {
                                        'id': DayPilotScheduler._drag.id,
                                        'start': now,
                                        'end': now.addSeconds(DayPilotScheduler._drag.duration),
                                        'text': DayPilotScheduler._drag.text
                                    };

                                    var options = DayPilotScheduler._drag._dragOptions;

                                    if (options) {
                                        var skip = ['duration', 'element', 'remove', 'id', 'text'];
                                        for (var name in options) {
                                            if (DayPilot.contains(skip, name)) {
                                                continue;
                                            }
                                            ev[name] = options[name];
                                        }
                                    }
                                }*/

                                var ev = calendar._createEvFromDrag();

                                event = new DayPilot.Event(ev);
                                event.calendar = calendar;

                                // it's in seconds, convert to ticks
                                event.part.duration = DayPilotScheduler._drag.duration * 1000;
                            }

                            event.part.external = true;

                            var src = DayPilotScheduler._drag._schedulerSourceEvent;
                            if (src && src.event && src.event.calendar === calendar) {
                                event.part.external = false;
                            }

                            DayPilotScheduler._movingEvent = event;
                        }
                        DayPilotScheduler._movingShadow = calendar._createShadow(DayPilotScheduler._movingEvent);
                    }

                    if (DayPilotScheduler._moving) {
                        calendar._touch._updateMoving();
                    }

                }
                else {

                    // hide the local shadow
                    deleteElement(DayPilotScheduler._movingShadow);
                    var movingSaveForLater = DayPilotScheduler._moving;
                    DayPilotScheduler._moving = null;
                    DayPilotScheduler._movingEvent = null;
                    DayPilotScheduler._movingShadow = null;

                    if (!DayPilotScheduler._gShadow) {
                        DayPilotScheduler._gShadow = DayPilotScheduler._createGShadow(DayPilotScheduler._drag._dragOptions);
                        DayPilotScheduler._gShadow.source = movingSaveForLater;
                    }

                    var shadow = DayPilotScheduler._gShadow;
                    shadow.style.left = mousePos.x + 'px';
                    shadow.style.top = mousePos.y + 'px';

                    DayPilotScheduler._registered.out();

                }

        }
    };

    DayPilotScheduler._gTouchEnd = function(ev) {
        DayPilotScheduler._touchingRes = false;
        DayPilotScheduler._gMouseUp(ev);
    };

    DayPilotScheduler._gMouseMove = function(ev) {

        if (typeof (DayPilotScheduler) === 'undefined') {
            return;
        }

        // AngularJS 1.x is firing onmousemove for touch events
        // Chrome on Android is firing onmousemove for touch events
        if (DpGlobal.touch.active || DpGlobal.touch.start) {
            return;
        }

        // quick and dirty inside detection
        // hack, but faster then recursing through the parents
        if (ev.insideMainD) {  // FF
            return;
        }
        else if (ev.srcElement) {  // IE
            if (ev.srcElement.inside) {
                return;
            }
        }

        var mousePos = DayPilot.mc(ev);

        if (DayPilotScheduler._drag) {

            if (!DayPilotScheduler._drag._startFired) {
                var options = DayPilotScheduler._drag._dragOptions || {};
                var onDragStart = options.onDragStart;

                var canceled = false;

                if (typeof onDragStart === "function") {
                    var args = {};
                    args.options = options;

                    args.preventDefault = function() {
                        args.preventDefault.value = true;
                    };
                    onDragStart(args);

                    canceled = args.preventDefault.value;
                }

                DayPilotScheduler._drag._startFired = true;

                if (canceled) {
                    DayPilotScheduler._externalDrop();
                    DayPilotScheduler._drag = null;
                    return;
                }
            }

            body().style.cursor = 'move';
            if (!DayPilotScheduler._gShadow) {
                DayPilotScheduler._gShadow = DayPilotScheduler._createGShadow(DayPilotScheduler._drag._dragOptions);
            }

            var shadow = DayPilotScheduler._gShadow;
            shadow.style.left = mousePos.x + 'px';
            shadow.style.top = mousePos.y + 'px';

            // it's being moved outside, delete the inside shadow
            DayPilotScheduler._moving = null;
            DayPilotScheduler._movingEvent = null;
            if (DayPilotScheduler._movingShadow) {
                var cal = DayPilotScheduler._movingShadow.calendar;
                cal && cal._clearShadowHover();
                DayPilotScheduler._movingShadow.calendar = null;
                deleteElement(DayPilotScheduler._movingShadow);
                DayPilotScheduler._movingShadow = null;
            }

        }
        else if (DayPilotScheduler._moving && DayPilotScheduler._movingEvent && DayPilotScheduler._movingEvent.calendar.dragOutAllowed && !DayPilotScheduler._drag) {
            var cal = DayPilotScheduler._movingEvent.calendar; // source
            var ev = DayPilotScheduler._movingEvent;

            body().style.cursor = 'move';
            if (!DayPilotScheduler._gShadow) {
                DayPilotScheduler._gShadow = DayPilotScheduler._createGShadow(ev.data);
                DayPilotScheduler._gShadow.source = DayPilotScheduler._moving;
            }

            var shadow = DayPilotScheduler._gShadow;
            shadow.style.left = mousePos.x + 'px';
            shadow.style.top = mousePos.y + 'px';

            // it's being moved outside, delete the inside shadow
            DayPilotScheduler._drag = {};
            var drag = DayPilotScheduler._drag;
            drag._schedulerSourceEvent = DayPilotScheduler._moving;
            drag.element = null;
            drag.duration = (ev.rawend().getTime() - ev.start().getTime()) / 1000;
            drag.text = ev.text();
            drag.id = ev.value();
            //drag.shadowType = cal.shadow;

            drag.event = copyProps(ev, new DayPilot.Event());

            cal._clearShadowHover();

            deleteElement(DayPilotScheduler._movingShadow);

            DayPilotScheduler._movingShadow.calendar = null;
            DayPilotScheduler._movingShadow = null;

        }

        if (DayPilotScheduler._splitting && ev.buttons === 0) {
            var splitting = DayPilotScheduler._splitting;
            splitting.cleanup();
            DayPilotScheduler._splitting = null;
        }

        DayPilotScheduler._registered.out();
    };

    DayPilotScheduler._gUnload = function(ev) {

        if (!DayPilotScheduler._registered) {
            return;
        }
        for (var i = 0; i < DayPilotScheduler._registered.length; i++) {
            var c = DayPilotScheduler._registered[i];
            DayPilotScheduler._unregister(c);
        }
    };

    DayPilotScheduler._gMouseDown = function(ev) {
        if (DayPilotScheduler._editing) {
            DayPilotScheduler._editing.blur();
        }
    };

    DayPilotScheduler._gKeyUp = function(ev) {
        var key = ev.keyCode;
        if (key === 17) {
            if (DayPilotScheduler._rangeCalendar) {
                var calendar = DayPilotScheduler._rangeCalendar;
                calendar._multirange.dispatch();
            }
        }
    };

    DayPilotScheduler._gMouseUp = function(ev) {

        createList(DayPilotScheduler._registered).forEach(function(calendar) {
            calendar._stopScroll();
            calendar._moving = {};
            calendar._rangeButton = null;
        });

        if (DayPilotScheduler._resizing) {

            var cleanup = function() {
                var e = DayPilotScheduler._resizingEvent;
                var calendar = e.calendar;

                body().style.cursor = '';
                DayPilotScheduler._resizing = null;
                DayPilotScheduler._resizingEvent = null;

                deleteElement(DayPilotScheduler._resizingShadow);
                DayPilotScheduler._resizingShadow = null;

                if (calendar) {
                    calendar._lastEventResizing = null;
                }

            };

            setTimeout(function() {  // it needs to survive onEventClick
                DayPilotScheduler._preventEventClick = false;
            });

            if (!DayPilotScheduler._resizingShadow) {
                cleanup();
                return;
            }

            var e = DayPilotScheduler._resizingEvent;
            var calendar = e.calendar;

            var newStart = DayPilotScheduler._resizingShadow.finalStart;
            var newEnd = DayPilotScheduler._resizingShadow.finalEnd;

            var overlapping = DayPilotScheduler._resizingShadow.overlapping;
            var forbidden = !DayPilotScheduler._resizingShadow.allowed;

            var invalid = calendar._multiresize.isInvalid();

            calendar._clearShadowHover();
            calendar._multiresize.clear();

            var what = DayPilotScheduler._resizing.dpBorder === "left" ? "start" : "end";

            cleanup();

            if (overlapping || forbidden || invalid || calendar._multiresize.forbidden) {
                return;
            }

            // action here
            calendar._eventResizeDispatch(e, newStart, newEnd, what);
        }
        else if (DayPilotScheduler._movingEvent) {

            var cleanup = function() {

                DpGlobal.movingAreaData = null;

                var calendar = DayPilotScheduler._movingShadow && DayPilotScheduler._movingShadow.calendar;

                if (DayPilotScheduler._movingShadow) {
                    deleteElement(DayPilotScheduler._movingShadow);
                    DayPilotScheduler._movingShadow.calendar = null;
                }

                body().style.cursor = '';
                DayPilotScheduler._moving = null;
                DayPilotScheduler._movingEvent = null;
                DayPilotScheduler._externalDrop();
                DayPilotScheduler._drag = null;

                // calendar._checkSuspendedOnScroll();

                if (calendar) {
                    calendar._lastEventMoving = null;
                }

            };

            setTimeout(function() {  // it needs to survive onEventClick
                DayPilotScheduler._preventEventClick = false;
            });

            if (!DayPilotScheduler._movingShadow) {
                cleanup();
                return;
            }

            var src = DayPilotScheduler._drag && DayPilotScheduler._drag._schedulerSourceEvent;
            var e = src ? src.event : DayPilotScheduler._movingEvent;

            //var calendar = e.calendar;  // doesn't work for drag&drop between two schedulers, this is the source
            var calendar = DayPilotScheduler._movingShadow.calendar;

            if (!calendar) {
                cleanup();
                return;
            }

            if (e.calendar && e.calendar !== calendar) {
                var srccal = e.calendar;
                var originalEvent = e;
                var newData = copyProps(e.data);
                // e = new DayPilot.Event(newData, calendar);
                e = new DayPilot.Event(newData, srccal);

                e.part = {
                    "external": true,
                    "duration": srccal._getEventDurationWithoutNonBusiness(originalEvent)
                };
            }


            DayPilotScheduler._movingShadow.source = DayPilotScheduler._moving;

            // remove later, when clearing the moving shadow
            // removeClass(DayPilotScheduler._moving, calendar._prefixCssClass(calendar._css.eventMovingSource));

            (function clearSourceCss() {
                if (DayPilotScheduler._drag) {
                    if (DayPilotScheduler._drag._schedulerSourceEvent) {
                        var e = DayPilotScheduler._drag._schedulerSourceEvent;
                        if (e && e.event) {
                            var srcCal = e.event.calendar;
                            removeClass(e, srcCal._prefixCssClass(calendar._css.eventMovingSource));
                        }
                    }
                }
            })();

            if (!DayPilotScheduler._movingShadow.row) {
                cleanup();
                return;
            }

            clearTimeout(calendar._autoexpand.timeout);

            var newStart = DayPilotScheduler._movingShadow.start;
            var newEnd = DayPilotScheduler._movingShadow.end;
            var newResource = (calendar.viewType !== 'Days') ? DayPilotScheduler._movingShadow.row.id : null;

            var external = e.part.external;
            var line = DayPilotScheduler._movingShadow.line;

            var overlapping = DayPilotScheduler._movingShadow.overlapping;
            var forbidden = !DayPilotScheduler._movingShadow.allowed;


            if (DayPilotScheduler._drag) {
                if (!calendar._todo) {
                    calendar._todo = {};
                }
                calendar._todo._del = DayPilotScheduler._drag.element;
                DayPilotScheduler._externalDrop();
                DayPilotScheduler._drag = null;
                //cleanup();
            }

            DayPilotScheduler._movingShadow.calendar = null;
            body().style.cursor = '';
            DayPilotScheduler._moving = null;
            DayPilotScheduler._movingEvent = null;

            if (overlapping || forbidden || calendar._multimove.forbidden  || calendar._multimove.invalid) {
                // clear the moving state
                calendar._clearMovingShadow();
                return;
            }

            calendar._eventMoveDispatch(e, newStart, newEnd, newResource, external, ev, line);
            //calendar._multimove.clear();

            DpGlobal.movingAreaData = null;
        }
        else if (DayPilotScheduler._range) {

            var button = mouseButton(ev);

            var range = DayPilotScheduler._range;
            var calendar = range.calendar;

            var cleanup = function() {
            };

            calendar._lastRange = null;

            var ctrl = ev.ctrlKey || ev.metaKey;
            if (calendar.allowMultiRange) {
                if (!calendar.elements.range2.overlapping) {
                    calendar._multirange.add(range);
                }
                else {
                    deleteElement(calendar.elements.range2);
                    calendar.elements.range2 = null;
                    calendar._clearShadowHover();
                }
                DayPilotScheduler._range = null;
                if (!ctrl) {
                    // left click only
                    if (button.left) {
                        calendar._multirange.dispatch();
                    }
                }
                cleanup();
                return;
            }

            if (DayPilotScheduler._timeRangeTimeout) {
                clearTimeout(DayPilotScheduler._timeRangeTimeout);
                DayPilotScheduler._timeRangeTimeout = null;

                // disabled because it fired timeRangeDoubleClick twice
                //calendar._onMaindDblClick(ev);

                cleanup();
                return;
            }

            calendar._rangeHold = range;

            // must be cleared before dispatching
            DayPilotScheduler._range = null;

            var createTimeRangeDispatcher = function(range) {
                return function() {

                    DayPilotScheduler._timeRangeTimeout = null;

                    var shadow = calendar.elements.range2;
                    if (shadow && shadow.overlapping) {
                        calendar.clearSelection();
                        return;
                    }

                    calendar._timeRangeSelectedDispatchFromRange(range);
                    //calendar._timeRangeSelectedDispatch(sel.start, sel.end, sel.resource);

                    // this is legacy, it overwrites _rangeHold with an invalid value (ignores onTimeRangeSelecting adjustments)
                    /*if (calendar.timeRangeSelectedHandling !== "Hold" && calendar.timeRangeSelectedHandling !== "HoldForever") {
                        doNothing();
                        //calendar.deleteRange();
                    }
                    else {
                        calendar._rangeHold = range;
                    }*/
                };
            };

            var rc = calendar._copyRange(range); // might not be necessary

            cleanup();

            if (!button.left) { // only left-click
                DayPilotScheduler._timeRangeTimeout = null;
                return;
            }

            if (range.moved || calendar.timeRangeDoubleClickHandling === 'Disabled') {
                createTimeRangeDispatcher(rc)();

                ev.cancelBubble = true;
                return false;  // trying to prevent onmaindclick
            }
            else {
                DayPilotScheduler._timeRangeTimeout = setTimeout(createTimeRangeDispatcher(rc), calendar.doubleClickTimeout);  // 300 ms
            }

        }
        else if (rowmoving.row) {
            var calendar = rowmoving.calendar;
            if (calendar) {
                calendar._rowMoveDispatch();
            }
        }
        else if (linking.source) {
            var calendar = linking.calendar;
            calendar._linktools._clearShadow();
            calendar._linktools._hideLinkpoints();

            linking.source = null;
            linking.calendar = null;
        }
        else if (DayPilotScheduler._splitting) {
            var splitting = DayPilotScheduler._splitting;
            splitting.cleanup();
            DayPilotScheduler._splitting = null;
        }
        else if (DayPilotScheduler._rectangleSelect) {
            var rect = DayPilotScheduler._rectangleSelect;
            var calendar = rect.calendar;

            if (!rect.moved) {
                DayPilotScheduler._rectangleSelect = null;
                if (!calendar._isWithinRange(calendar.coords)) {
                    calendar._onMaindClick(ev);
                }
                return;
            }

            var x = rect.x;
            var y = rect.y;
            var width = rect.width;
            var height = rect.height;

            var append = false;
            var events = calendar._viewport._eventsInRectangle(x, y, width, height).map(function(item) {return item.event;});

            var rectangleSelectCleanup = function() {
                setTimeout(function() {  // needs to survive until onmaindclick is called
                    calendar._rectangle.clear();
                    DayPilotScheduler._rectangleSelect = null;
                }, 0);

                calendar._clearShadowHover();
            };

            if (typeof calendar.onRectangleEventSelect === "function" || typeof calendar.onRectangleSelect === "function") {

                var yStart = calendar._getRow(y).i;
                var yEnd = calendar._getRow(y + height).i;
                var area = {"start": { "y": yStart}, "end" : { "y": yEnd}};
                var resources = calendar._getAreaResources(area);

                var args = {};
                args.events = events;
                args.append = false;
                args.start = calendar.getDate(x, true);
                args.end = calendar.getDate(x + width, true);
                args.resources = resources;
                args.preventDefault = function() {
                    this.preventDefault.value = true;
                };

                if (typeof calendar.onRectangleEventSelect === "function") {
                    calendar.onRectangleEventSelect(args);
                }

                if (typeof calendar.onRectangleSelect === "function") {
                    calendar.onRectangleSelect(args);
                }

                if (args.preventDefault.value) {
                    calendar._rectangle.clear();
                    DayPilotScheduler._rectangleSelect = null;

                    rectangleSelectCleanup();
                    return;
                }

                append = args.append;
            }

            // default action, add rectangeSelectHandling
            if (calendar._resolved._rectangleSelectHandling() === "EventSelect") {
                if (!append) {
                    calendar.multiselect.clear(true);
                }

                events.forEach(function(e) {
                    calendar.multiselect.add(e, true);
                });

                calendar.multiselect.redraw();
            }

            rectangleSelectCleanup();

            if (typeof calendar.onRectangleEventSelected === "function" || typeof calendar.onRectangleSelected === "function") {
                var args = {};
                args.events = events;

                if (typeof calendar.onRectangleEventSelected === "function") {
                    calendar.onRectangleEventSelected(args);
                }

                if (typeof calendar.onRectangleSelected === "function") {
                    calendar.onRectangleSelected(args);
                }

            }

            // calendar._clearShadowHover();

        }
        // clean up external drag helpers
        if (DayPilotScheduler._drag) {
            if (DayPilotScheduler._drag.event && DayPilotScheduler._drag.event.part) {
                delete DayPilotScheduler._drag.event.part.external;
            }
            DayPilotScheduler._externalDrop();
            DayPilotScheduler._drag = null;

            body().style.cursor = '';
        }

        if (DayPilotScheduler._gShadow) {
            if (DayPilotScheduler._gShadow.source) {
                var src = DayPilotScheduler._gShadow.source;
                if (!src.event) {
                    doNothing();
                }
                else {
                    var calendar = DayPilotScheduler._gShadow.source.event.calendar;
                    removeClass(DayPilotScheduler._gShadow.source, calendar._prefixCssClass(calendar._css.eventMovingSource));
                }
            }

            body().removeChild(DayPilotScheduler._gShadow);
            DayPilotScheduler._gShadow = null;
        }

        DayPilotScheduler._moveOffsetX = null; // clean for next external drag
        DayPilotScheduler._moveDragStart = null;

    };

    // global shadow, external drag&drop
    DayPilotScheduler._createGShadow = function(options) {
        options = options || {};

        var shadow = document.createElement('div');
        shadow.setAttribute('unselectable', 'on');
        shadow.style.position = 'absolute';
        shadow.style.width = '100px';
        shadow.style.height = '20px';
        shadow.style.zIndex = 101;
        shadow.style.pointerEvents = "none";

        shadow.style.backgroundColor = "#aaaaaa";
        shadow.style.opacity = 0.5;
        shadow.style.overflow = "hidden";

        shadow.className = options.externalCssClass;
        if (options.externalHtml) {
            shadow.innerHTML = options.externalHtml;
        }

        body().appendChild(shadow);

        return shadow;
    };

    var rowmoving = {};
    DpGlobal.rowmoving = rowmoving;

    var linking = {};
    DpGlobal.linking = linking;

    //  jQuery plugin
    if (typeof jQuery !== 'undefined') {
        (function($) {
            $.fn.daypilotScheduler = function(options) {
                var first = null;
                var j = this.each(function() {
                    if (this.daypilot) { // already initialized
                        return;
                    }

                    var daypilot = new DayPilot.Scheduler(this.id || this, options);
                    daypilot.init();

                    this.daypilot = daypilot;

                    if (!first) {
                        first = daypilot;
                    }
                });
                if (this.length === 1) {
                    return first;
                }
                else {
                    return j;
                }
            };
        })(jQuery);
    }

    // AngularJS plugin
    (function registerAngularModule() {
        var app = DayPilot.am();

        if (!app) {
            return;
        }

        app.directive("daypilotScheduler", ['$parse', function($parse) {
            return {
                "restrict": "E",
                "template": "<div id='{{id}}'></div>",
                "compile": function compile(element, attrs) {
                    element[0].removeAttribute("id");
                    element[0].innerHTML = this["template"].replace("{{id\u007d\u007d", attrs["id"]);

                    return function link(scope, element, attrs) {
                        // var calendar = new DayPilot.Scheduler(element[0]);
                        var calendar = new DayPilot.Scheduler(element[0].firstChild);
                        calendar._angular.scope = scope;
                        // calendar.init();

                        var oattr = attrs["id"];
                        if (oattr) {
                            scope[oattr] = calendar;
                        }

                        // save DayPilot.Scheduler object in the specified variable
                        var pas = attrs["publishAs"];
                        if (pas) {
                            var getter = $parse(pas);
                            var setter = getter.assign;
                            setter(scope, calendar);
                        }

                        // bind event handlers from attributes starting with "on"
                        for (var name in attrs) {
                            if (name.indexOf("on") === 0) {  // event handler
                                var apply = DayPilot.Util.shouldApply(name);

                                if (apply) {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            DayPilot.Util.safeApply(scope, function() {
                                                f(scope, {"args": args});
                                            });
                                            /*
                                            scope["$apply"](function() {
                                                f(scope, {"args": args});
                                            });
                                            */
                                        };
                                    })(name);
                                }
                                else {
                                    (function(name) {
                                        calendar[name] = function(args) {
                                            var f = $parse(attrs[name]);
                                            f(scope, {"args": args});
                                        };
                                    })(name);
                                }

                            }
                        }

                        var watch = scope["$watch"];
                        var config = attrs["config"] || attrs["daypilotConfig"];
                        var events = attrs["events"] || attrs["daypilotEvents"];

                        if (!config) {
                            calendar.init();
                        }

                        watch.call(scope, config, function (value, oldVal) {
                            calendar._loadOptions(value);
                            if (calendar._initialized) {
                                calendar.update();
                                calendar._postInit();
                            }
                            else {
                                calendar.init();
                            }
                        }, true);

                        events && watch.call(scope, events, function(value) {
                            //calendar.debug.message("daypilot-events value change detected, updating.");
                            //var calendar = element.data("calendar");
                            calendar.events.list = value;
                            calendar._update({"eventsOnly": true});
                        }, true);

                        scope.$on("$destroy", function() {
                            calendar.dispose();
                        });

                    };
                }
            };
        }]);
    })();

    if (typeof Sys !== 'undefined' && Sys.Application && Sys.Application.notifyScriptLoaded) {
        Sys.Application.notifyScriptLoaded();
    }

})(DayPilot);
/* Copyright © 2005 - 2023 Annpoint, s.r.o.
   Use of this software is subject to license terms.
   https://www.daypilot.org/
*/

if (typeof DayPilot === 'undefined') {
	var DayPilot = {};
}

if (typeof DayPilot.Global === 'undefined') {
    DayPilot.Global = {};
}

(function(DayPilot) {
    

    if (typeof DayPilot.Year !== 'undefined') {
        return;
    }

    DayPilot.Year = function(id, options) {
        this.v = '2023.2.5592';
        var This = this;

        this.startDate = new DayPilot.Date();
        this.cssOnly = true;
        this.cssClassPrefix = null;
        this.columns = 4;
        this.cellWidth = 20;
        this.showWeekNumbers = false;

        this._navigators = [];

        this._prepare = function() {
            this.root.dp = this;
            this._start = new DayPilot.Date(this.startDate.toString("yyyy-01-01", "en-us"));
        };

        this._prefixCssClass = function(part) {
            if (this.cssClassPrefix) {
                return this.cssClassPrefix + part;
            }
            else {
                return "";
            }
        };

        this._weekNumberWidth = function() {
            if (this.showWeekNumbers) {
                return this.cellWidth;
            }
            return 0;
        };

        this._draw = function() {
            this._navigators = [];

            var columns = this.columns;
            var rows = 12 / columns;

            this.root.className = this._prefixCssClass('_main');
            this.root.style.width = columns * (this.cellWidth * 7 + this._weekNumberWidth()) + 'px';

            for (var y = 0; y < rows; y++) {
                for (var x = 0; x < columns; x++) {
                    var m = y * columns + x;
                    var id = id + "_nav_" + m;

                    var div = document.createElement("div");
                    div.id = id;
                    div.style.float = 'left';

                    this.root.appendChild(div);

                    var navigator = new DayPilot.Navigator(id);
                    navigator.startDate = this._start.addMonths(m);
                    navigator.cssOnly = this.cssOnly;
                    navigator.cssClassPrefix = this.cssClassPrefix;
                    navigator.cellWidth = this.cellWidth;
                    navigator.showWeekNumbers = this.showWeekNumbers;
                    navigator.internal.showLinks = {};
                    navigator.selectMode = 'none';
                    navigator.timeRangeSelectedHandling = "JavaScript";
                    navigator.onTimeRangeSelected = this._onTimeRangeSelected;
                    navigator.init();
                    navigator.root.className = '';  // clear the top style

                    this._navigators.push(navigator);
                }
                var line = document.createElement("div");
                line.style.clear = 'left';
                this.root.appendChild(line);
            }
        };

        this._onTimeRangeSelected = function(args) {
            alert("clicked: " + args.day);
        };

        this.init = function() {
            this.root = document.getElementById(id);

            if (this.root.dp) { // already initialized
                return;
            }

            this._prepare();
            this._draw();

            return this;
        };


    };


})(DayPilot);
